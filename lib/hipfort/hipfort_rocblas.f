!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
! ==============================================================================
! hipfort: FORTRAN Interfaces for GPU kernels
! ==============================================================================
! Copyright (c) 2021 Advanced Micro Devices, Inc. All rights reserved.
! [MITx11 License]
! 
! Permission is hereby granted, free of charge, to any person obtaining a copy
! of this software and associated documentation files (the "Software"), to deal
! in the Software without restriction, including without limitation the rights
! to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
! copies of the Software, and to permit persons to whom the Software is
! furnished to do so, subject to the following conditions:
! 
! The above copyright notice and this permission notice shall be included in
! all copies or substantial portions of the Software.
! 
! THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
! IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
! FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.  IN NO EVENT SHALL THE
! AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
! LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
! OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
! THE SOFTWARE.
!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
          
           
module hipfort_rocblas
  use hipfort_rocblas_enums
  use hipfort_rocblas_auxiliary
  implicit none

 
  !> 
  !>   ===========================================================================
  !>      level 1 BLAS
  !>   ===========================================================================
  !>  
  interface rocblas_sscal
    function rocblas_sscal_orig(handle,incx) bind(c, name="rocblas_sscal")
      use iso_c_binding
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocblas_sscal_orig
      type(c_ptr),value :: handle
      integer(c_int),value :: incx
    end function


  end interface
  
  interface rocblas_dscal
    function rocblas_dscal_orig(handle,incx) bind(c, name="rocblas_dscal")
      use iso_c_binding
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocblas_dscal_orig
      type(c_ptr),value :: handle
      integer(c_int),value :: incx
    end function


  end interface
  
  interface rocblas_cscal
    function rocblas_cscal_orig(handle,n,alpha,x,incx) bind(c, name="rocblas_cscal")
      use iso_c_binding
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocblas_cscal_orig
      type(c_ptr),value :: handle
      integer(c_int),value :: n
      complex(c_float_complex) :: alpha
      type(c_ptr),value :: x
      integer(c_int),value :: incx
    end function

#ifdef USE_FPOINTER_INTERFACES
    module procedure rocblas_cscal_rank_0,rocblas_cscal_rank_1
#endif

  end interface
  
  interface rocblas_zscal
    function rocblas_zscal_orig(handle,n,alpha,x,incx) bind(c, name="rocblas_zscal")
      use iso_c_binding
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocblas_zscal_orig
      type(c_ptr),value :: handle
      integer(c_int),value :: n
      complex(c_double_complex) :: alpha
      type(c_ptr),value :: x
      integer(c_int),value :: incx
    end function

#ifdef USE_FPOINTER_INTERFACES
    module procedure rocblas_zscal_rank_0,rocblas_zscal_rank_1
#endif

  end interface
  
  interface rocblas_csscal
    function rocblas_csscal_orig(handle,n,alpha,x,incx) bind(c, name="rocblas_csscal")
      use iso_c_binding
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocblas_csscal_orig
      type(c_ptr),value :: handle
      integer(c_int),value :: n
      real(c_float) :: alpha
      type(c_ptr),value :: x
      integer(c_int),value :: incx
    end function

#ifdef USE_FPOINTER_INTERFACES
    module procedure rocblas_csscal_rank_0,rocblas_csscal_rank_1
#endif

  end interface
  !> ! \brief BLAS Level 1 API
  !> 
  !>     \details
  !>     scal  scales each element of vector x with scalar alpha.
  !> 
  !>         x := alpha  x
  !> 
  !>     @param[in]
  !>     handle    [rocblas_handle]
  !>               handle to the rocblas library context queue.
  !>     @param[in]
  !>     n         [rocblas_int]
  !>               the number of elements in x.
  !>     @param[in]
  !>     alpha     device pointer or host pointer for the scalar alpha.
  !>     @param[inout]
  !>     x         device pointer storing vector x.
  !>     @param[in]
  !>     incx      [rocblas_int]
  !>               specifies the increment for the elements of x.
  !> 
  !> 
  !>     
  interface rocblas_zdscal
    function rocblas_zdscal_orig(handle,n,alpha,x,incx) bind(c, name="rocblas_zdscal")
      use iso_c_binding
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocblas_zdscal_orig
      type(c_ptr),value :: handle
      integer(c_int),value :: n
      real(c_double) :: alpha
      type(c_ptr),value :: x
      integer(c_int),value :: incx
    end function

#ifdef USE_FPOINTER_INTERFACES
    module procedure rocblas_zdscal_rank_0,rocblas_zdscal_rank_1
#endif

  end interface
  
  interface rocblas_sscal_batched
    function rocblas_sscal_batched_orig(handle,n,alpha,x,incx,batch_count) bind(c, name="rocblas_sscal_batched")
      use iso_c_binding
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocblas_sscal_batched_orig
      type(c_ptr),value :: handle
      integer(c_int),value :: n
      real(c_float) :: alpha
      type(c_ptr) :: x
      integer(c_int),value :: incx
      integer(c_int),value :: batch_count
    end function

#ifdef USE_FPOINTER_INTERFACES
    module procedure rocblas_sscal_batched_full_rank,rocblas_sscal_batched_rank_0,rocblas_sscal_batched_rank_1
#endif

  end interface
  
  interface rocblas_dscal_batched
    function rocblas_dscal_batched_orig(handle,n,alpha,x,incx,batch_count) bind(c, name="rocblas_dscal_batched")
      use iso_c_binding
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocblas_dscal_batched_orig
      type(c_ptr),value :: handle
      integer(c_int),value :: n
      real(c_double) :: alpha
      type(c_ptr) :: x
      integer(c_int),value :: incx
      integer(c_int),value :: batch_count
    end function

#ifdef USE_FPOINTER_INTERFACES
    module procedure rocblas_dscal_batched_full_rank,rocblas_dscal_batched_rank_0,rocblas_dscal_batched_rank_1
#endif

  end interface
  
  interface rocblas_cscal_batched
    function rocblas_cscal_batched_orig(handle,n,alpha,x,incx,batch_count) bind(c, name="rocblas_cscal_batched")
      use iso_c_binding
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocblas_cscal_batched_orig
      type(c_ptr),value :: handle
      integer(c_int),value :: n
      complex(c_float_complex) :: alpha
      type(c_ptr) :: x
      integer(c_int),value :: incx
      integer(c_int),value :: batch_count
    end function

#ifdef USE_FPOINTER_INTERFACES
    module procedure rocblas_cscal_batched_full_rank,rocblas_cscal_batched_rank_0,rocblas_cscal_batched_rank_1
#endif

  end interface
  
  interface rocblas_zscal_batched
    function rocblas_zscal_batched_orig(handle,n,alpha,x,incx,batch_count) bind(c, name="rocblas_zscal_batched")
      use iso_c_binding
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocblas_zscal_batched_orig
      type(c_ptr),value :: handle
      integer(c_int),value :: n
      complex(c_double_complex) :: alpha
      type(c_ptr) :: x
      integer(c_int),value :: incx
      integer(c_int),value :: batch_count
    end function

#ifdef USE_FPOINTER_INTERFACES
    module procedure rocblas_zscal_batched_full_rank,rocblas_zscal_batched_rank_0,rocblas_zscal_batched_rank_1
#endif

  end interface
  
  interface rocblas_csscal_batched
    function rocblas_csscal_batched_orig(handle,n,alpha,x,incx,batch_count) bind(c, name="rocblas_csscal_batched")
      use iso_c_binding
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocblas_csscal_batched_orig
      type(c_ptr),value :: handle
      integer(c_int),value :: n
      real(c_float) :: alpha
      type(c_ptr) :: x
      integer(c_int),value :: incx
      integer(c_int),value :: batch_count
    end function

#ifdef USE_FPOINTER_INTERFACES
    module procedure rocblas_csscal_batched_full_rank,rocblas_csscal_batched_rank_0,rocblas_csscal_batched_rank_1
#endif

  end interface
  !> ! \brief BLAS Level 1 API
  !>      \details
  !>     scal_batched  scales each element of vector x_i with scalar alpha, for i = 1, ... , batch_count.
  !> 
  !>          x_i := alpha  x_i
  !> 
  !>      where (x_i) is the i-th instance of the batch.
  !>     @param[in]
  !>     handle      [rocblas_handle]
  !>                 handle to the rocblas library context queue.
  !>     @param[in]
  !>     n           [rocblas_int]
  !>                 the number of elements in each x_i.
  !>     @param[in]
  !>     alpha       host pointer or device pointer for the scalar alpha.
  !>     @param[inout]
  !>     x           device array of device pointers storing each vector x_i.
  !>     @param[in]
  !>     incx        [rocblas_int]
  !>                 specifies the increment for the elements of each x_i.
  !>     @param[in]
  !>     batch_count [rocblas_int]
  !>                 specifies the number of batches in x.
  !>      
  interface rocblas_zdscal_batched
    function rocblas_zdscal_batched_orig(handle,n,alpha,x,incx,batch_count) bind(c, name="rocblas_zdscal_batched")
      use iso_c_binding
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocblas_zdscal_batched_orig
      type(c_ptr),value :: handle
      integer(c_int),value :: n
      real(c_double) :: alpha
      type(c_ptr) :: x
      integer(c_int),value :: incx
      integer(c_int),value :: batch_count
    end function

#ifdef USE_FPOINTER_INTERFACES
    module procedure rocblas_zdscal_batched_full_rank,rocblas_zdscal_batched_rank_0,rocblas_zdscal_batched_rank_1
#endif

  end interface
  
  interface rocblas_sscal_strided_batched
    function rocblas_sscal_strided_batched_orig(handle,n,alpha,x,incx,stride_x,batch_count) bind(c, name="rocblas_sscal_strided_batched")
      use iso_c_binding
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocblas_sscal_strided_batched_orig
      type(c_ptr),value :: handle
      integer(c_int),value :: n
      real(c_float) :: alpha
      type(c_ptr),value :: x
      integer(c_int),value :: incx
      integer(c_int64_t),value :: stride_x
      integer(c_int),value :: batch_count
    end function

#ifdef USE_FPOINTER_INTERFACES
    module procedure rocblas_sscal_strided_batched_rank_0,rocblas_sscal_strided_batched_rank_1
#endif

  end interface
  
  interface rocblas_dscal_strided_batched
    function rocblas_dscal_strided_batched_orig(handle,n,alpha,x,incx,stride_x,batch_count) bind(c, name="rocblas_dscal_strided_batched")
      use iso_c_binding
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocblas_dscal_strided_batched_orig
      type(c_ptr),value :: handle
      integer(c_int),value :: n
      real(c_double) :: alpha
      type(c_ptr),value :: x
      integer(c_int),value :: incx
      integer(c_int64_t),value :: stride_x
      integer(c_int),value :: batch_count
    end function

#ifdef USE_FPOINTER_INTERFACES
    module procedure rocblas_dscal_strided_batched_rank_0,rocblas_dscal_strided_batched_rank_1
#endif

  end interface
  
  interface rocblas_cscal_strided_batched
    function rocblas_cscal_strided_batched_orig(handle,n,alpha,x,incx,stride_x,batch_count) bind(c, name="rocblas_cscal_strided_batched")
      use iso_c_binding
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocblas_cscal_strided_batched_orig
      type(c_ptr),value :: handle
      integer(c_int),value :: n
      complex(c_float_complex) :: alpha
      type(c_ptr),value :: x
      integer(c_int),value :: incx
      integer(c_int64_t),value :: stride_x
      integer(c_int),value :: batch_count
    end function

#ifdef USE_FPOINTER_INTERFACES
    module procedure rocblas_cscal_strided_batched_rank_0,rocblas_cscal_strided_batched_rank_1
#endif

  end interface
  
  interface rocblas_zscal_strided_batched
    function rocblas_zscal_strided_batched_orig(handle,n,alpha,x,incx,stride_x,batch_count) bind(c, name="rocblas_zscal_strided_batched")
      use iso_c_binding
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocblas_zscal_strided_batched_orig
      type(c_ptr),value :: handle
      integer(c_int),value :: n
      complex(c_double_complex) :: alpha
      type(c_ptr),value :: x
      integer(c_int),value :: incx
      integer(c_int64_t),value :: stride_x
      integer(c_int),value :: batch_count
    end function

#ifdef USE_FPOINTER_INTERFACES
    module procedure rocblas_zscal_strided_batched_rank_0,rocblas_zscal_strided_batched_rank_1
#endif

  end interface
  
  interface rocblas_csscal_strided_batched
    function rocblas_csscal_strided_batched_orig(handle,n,alpha,x,incx,stride_x,batch_count) bind(c, name="rocblas_csscal_strided_batched")
      use iso_c_binding
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocblas_csscal_strided_batched_orig
      type(c_ptr),value :: handle
      integer(c_int),value :: n
      real(c_float) :: alpha
      type(c_ptr),value :: x
      integer(c_int),value :: incx
      integer(c_int64_t),value :: stride_x
      integer(c_int),value :: batch_count
    end function

#ifdef USE_FPOINTER_INTERFACES
    module procedure rocblas_csscal_strided_batched_rank_0,rocblas_csscal_strided_batched_rank_1
#endif

  end interface
  !> ! \brief BLAS Level 1 API
  !>      \details
  !>     scal_strided_batched  scales each element of vector x_i with scalar alpha, for i = 1, ... , batch_count.
  !> 
  !>          x_i := alpha  x_i ,
  !> 
  !>      where (x_i) is the i-th instance of the batch.
  !>      @param[in]
  !>     handle      [rocblas_handle]
  !>                 handle to the rocblas library context queue.
  !>     @param[in]
  !>     n           [rocblas_int]
  !>                 the number of elements in each x_i.
  !>     @param[in]
  !>     alpha       host pointer or device pointer for the scalar alpha.
  !>     @param[inout]
  !>     x           device pointer to the first vector (x_1) in the batch.
  !>     @param[in]
  !>     incx        [rocblas_int]
  !>                 specifies the increment for the elements of x.
  !>     @param[in]
  !>     stride_x    [rocblas_stride]
  !>                 stride from the start of one vector (x_i) and the next one (x_i+1).
  !>                 There are no restrictions placed on stride_x, however the user should
  !>                 take care to ensure that stride_x is of appropriate size, for a typical
  !>                 case this means stride_x >= n  incx.
  !>     @param[in]
  !>     batch_count [rocblas_int]
  !>                 specifies the number of batches in x.
  !>      
  interface rocblas_zdscal_strided_batched
    function rocblas_zdscal_strided_batched_orig(handle,n,alpha,x,incx,stride_x,batch_count) bind(c, name="rocblas_zdscal_strided_batched")
      use iso_c_binding
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocblas_zdscal_strided_batched_orig
      type(c_ptr),value :: handle
      integer(c_int),value :: n
      real(c_double) :: alpha
      type(c_ptr),value :: x
      integer(c_int),value :: incx
      integer(c_int64_t),value :: stride_x
      integer(c_int),value :: batch_count
    end function

#ifdef USE_FPOINTER_INTERFACES
    module procedure rocblas_zdscal_strided_batched_rank_0,rocblas_zdscal_strided_batched_rank_1
#endif

  end interface
  
  interface rocblas_scopy
    function rocblas_scopy_orig(handle,n,x,incx,y,incy) bind(c, name="rocblas_scopy")
      use iso_c_binding
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocblas_scopy_orig
      type(c_ptr),value :: handle
      integer(c_int),value :: n
      type(c_ptr),value :: x
      integer(c_int),value :: incx
      type(c_ptr),value :: y
      integer(c_int),value :: incy
    end function

#ifdef USE_FPOINTER_INTERFACES
    module procedure rocblas_scopy_rank_0,rocblas_scopy_rank_1
#endif

  end interface
  
  interface rocblas_dcopy
    function rocblas_dcopy_orig(handle,n,x,incx,y,incy) bind(c, name="rocblas_dcopy")
      use iso_c_binding
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocblas_dcopy_orig
      type(c_ptr),value :: handle
      integer(c_int),value :: n
      type(c_ptr),value :: x
      integer(c_int),value :: incx
      type(c_ptr),value :: y
      integer(c_int),value :: incy
    end function

#ifdef USE_FPOINTER_INTERFACES
    module procedure rocblas_dcopy_rank_0,rocblas_dcopy_rank_1
#endif

  end interface
  
  interface rocblas_ccopy
    function rocblas_ccopy_orig(handle,n,x,incx,y,incy) bind(c, name="rocblas_ccopy")
      use iso_c_binding
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocblas_ccopy_orig
      type(c_ptr),value :: handle
      integer(c_int),value :: n
      type(c_ptr),value :: x
      integer(c_int),value :: incx
      type(c_ptr),value :: y
      integer(c_int),value :: incy
    end function

#ifdef USE_FPOINTER_INTERFACES
    module procedure rocblas_ccopy_rank_0,rocblas_ccopy_rank_1
#endif

  end interface
  !> ! \brief BLAS Level 1 API
  !> 
  !>     \details
  !>     copy  copies each element x[i] into y[i], for  i = 1 , ... , n
  !> 
  !>         y := x,
  !> 
  !>     @param[in]
  !>     handle    [rocblas_handle]
  !>               handle to the rocblas library context queue.
  !>     @param[in]
  !>     n         [rocblas_int]
  !>               the number of elements in x to be copied to y.
  !>     @param[in]
  !>     x         device pointer storing vector x.
  !>     @param[in]
  !>     incx      [rocblas_int]
  !>               specifies the increment for the elements of x.
  !>     @param[out]
  !>     y         device pointer storing vector y.
  !>     @param[in]
  !>     incy      [rocblas_int]
  !>               specifies the increment for the elements of y.
  !> 
  !>     
  interface rocblas_zcopy
    function rocblas_zcopy_orig(handle,n,x,incx,y,incy) bind(c, name="rocblas_zcopy")
      use iso_c_binding
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocblas_zcopy_orig
      type(c_ptr),value :: handle
      integer(c_int),value :: n
      type(c_ptr),value :: x
      integer(c_int),value :: incx
      type(c_ptr),value :: y
      integer(c_int),value :: incy
    end function

#ifdef USE_FPOINTER_INTERFACES
    module procedure rocblas_zcopy_rank_0,rocblas_zcopy_rank_1
#endif

  end interface
  
  interface rocblas_scopy_batched
    function rocblas_scopy_batched_orig(handle,n,x,incx,y,incy,batch_count) bind(c, name="rocblas_scopy_batched")
      use iso_c_binding
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocblas_scopy_batched_orig
      type(c_ptr),value :: handle
      integer(c_int),value :: n
      type(c_ptr) :: x
      integer(c_int),value :: incx
      type(c_ptr) :: y
      integer(c_int),value :: incy
      integer(c_int),value :: batch_count
    end function

#ifdef USE_FPOINTER_INTERFACES
    module procedure rocblas_scopy_batched_full_rank,rocblas_scopy_batched_rank_0,rocblas_scopy_batched_rank_1
#endif

  end interface
  
  interface rocblas_dcopy_batched
    function rocblas_dcopy_batched_orig(handle,n,x,incx,y,incy,batch_count) bind(c, name="rocblas_dcopy_batched")
      use iso_c_binding
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocblas_dcopy_batched_orig
      type(c_ptr),value :: handle
      integer(c_int),value :: n
      type(c_ptr) :: x
      integer(c_int),value :: incx
      type(c_ptr) :: y
      integer(c_int),value :: incy
      integer(c_int),value :: batch_count
    end function

#ifdef USE_FPOINTER_INTERFACES
    module procedure rocblas_dcopy_batched_full_rank,rocblas_dcopy_batched_rank_0,rocblas_dcopy_batched_rank_1
#endif

  end interface
  
  interface rocblas_ccopy_batched
    function rocblas_ccopy_batched_orig(handle,n,x,incx,y,incy,batch_count) bind(c, name="rocblas_ccopy_batched")
      use iso_c_binding
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocblas_ccopy_batched_orig
      type(c_ptr),value :: handle
      integer(c_int),value :: n
      type(c_ptr) :: x
      integer(c_int),value :: incx
      type(c_ptr) :: y
      integer(c_int),value :: incy
      integer(c_int),value :: batch_count
    end function

#ifdef USE_FPOINTER_INTERFACES
    module procedure rocblas_ccopy_batched_full_rank,rocblas_ccopy_batched_rank_0,rocblas_ccopy_batched_rank_1
#endif

  end interface
  !> ! \brief BLAS Level 1 API
  !> 
  !>     \details
  !>     copy_batched copies each element x_i[j] into y_i[j], for  j = 1 , ... , n; i = 1 , ... , batch_count
  !> 
  !>         y_i := x_i,
  !> 
  !>     where (x_i, y_i) is the i-th instance of the batch.
  !>     x_i and y_i are vectors.
  !> 
  !>     @param[in]
  !>     handle    [rocblas_handle]
  !>               handle to the rocblas library context queue.
  !>     @param[in]
  !>     n         [rocblas_int]
  !>               the number of elements in each x_i to be copied to y_i.
  !>     @param[in]
  !>     x         device array of device pointers storing each vector x_i.
  !>     @param[in]
  !>     incx      [rocblas_int]
  !>               specifies the increment for the elements of each vector x_i.
  !>     @param[out]
  !>     y         device array of device pointers storing each vector y_i.
  !>     @param[in]
  !>     incy      [rocblas_int]
  !>               specifies the increment for the elements of each vector y_i.
  !>     @param[in]
  !>     batch_count [rocblas_int]
  !>                 number of instances in the batch
  !> 
  !>     
  interface rocblas_zcopy_batched
    function rocblas_zcopy_batched_orig(handle,n,x,incx,y,incy,batch_count) bind(c, name="rocblas_zcopy_batched")
      use iso_c_binding
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocblas_zcopy_batched_orig
      type(c_ptr),value :: handle
      integer(c_int),value :: n
      type(c_ptr) :: x
      integer(c_int),value :: incx
      type(c_ptr) :: y
      integer(c_int),value :: incy
      integer(c_int),value :: batch_count
    end function

#ifdef USE_FPOINTER_INTERFACES
    module procedure rocblas_zcopy_batched_full_rank,rocblas_zcopy_batched_rank_0,rocblas_zcopy_batched_rank_1
#endif

  end interface
  
  interface rocblas_scopy_strided_batched
    function rocblas_scopy_strided_batched_orig(handle,n,x,incx,stridex,y,incy,stridey,batch_count) bind(c, name="rocblas_scopy_strided_batched")
      use iso_c_binding
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocblas_scopy_strided_batched_orig
      type(c_ptr),value :: handle
      integer(c_int),value :: n
      type(c_ptr),value :: x
      integer(c_int),value :: incx
      integer(c_int64_t),value :: stridex
      type(c_ptr),value :: y
      integer(c_int),value :: incy
      integer(c_int64_t),value :: stridey
      integer(c_int),value :: batch_count
    end function

#ifdef USE_FPOINTER_INTERFACES
    module procedure rocblas_scopy_strided_batched_rank_0,rocblas_scopy_strided_batched_rank_1
#endif

  end interface
  
  interface rocblas_dcopy_strided_batched
    function rocblas_dcopy_strided_batched_orig(handle,n,x,incx,stridex,y,incy,stridey,batch_count) bind(c, name="rocblas_dcopy_strided_batched")
      use iso_c_binding
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocblas_dcopy_strided_batched_orig
      type(c_ptr),value :: handle
      integer(c_int),value :: n
      type(c_ptr),value :: x
      integer(c_int),value :: incx
      integer(c_int64_t),value :: stridex
      type(c_ptr),value :: y
      integer(c_int),value :: incy
      integer(c_int64_t),value :: stridey
      integer(c_int),value :: batch_count
    end function

#ifdef USE_FPOINTER_INTERFACES
    module procedure rocblas_dcopy_strided_batched_rank_0,rocblas_dcopy_strided_batched_rank_1
#endif

  end interface
  
  interface rocblas_ccopy_strided_batched
    function rocblas_ccopy_strided_batched_orig(handle,n,x,incx,stridex,y,incy,stridey,batch_count) bind(c, name="rocblas_ccopy_strided_batched")
      use iso_c_binding
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocblas_ccopy_strided_batched_orig
      type(c_ptr),value :: handle
      integer(c_int),value :: n
      type(c_ptr),value :: x
      integer(c_int),value :: incx
      integer(c_int64_t),value :: stridex
      type(c_ptr),value :: y
      integer(c_int),value :: incy
      integer(c_int64_t),value :: stridey
      integer(c_int),value :: batch_count
    end function

#ifdef USE_FPOINTER_INTERFACES
    module procedure rocblas_ccopy_strided_batched_rank_0,rocblas_ccopy_strided_batched_rank_1
#endif

  end interface
  !> ! \brief BLAS Level 1 API
  !> 
  !>     \details
  !>     copy_strided_batched copies each element x_i[j] into y_i[j], for  j = 1 , ... , n; i = 1 , ... , batch_count
  !> 
  !>         y_i := x_i,
  !> 
  !>     where (x_i, y_i) is the i-th instance of the batch.
  !>     x_i and y_i are vectors.
  !> 
  !>     @param[in]
  !>     handle    [rocblas_handle]
  !>               handle to the rocblas library context queue.
  !>     @param[in]
  !>     n         [rocblas_int]
  !>               the number of elements in each x_i to be copied to y_i.
  !>     @param[in]
  !>     x         device pointer to the first vector (x_1) in the batch.
  !>     @param[in]
  !>     incx      [rocblas_int]
  !>               specifies the increments for the elements of vectors x_i.
  !>     @param[in]
  !>     stridex     [rocblas_stride]
  !>                 stride from the start of one vector (x_i) and the next one (x_i+1).
  !>                 There are no restrictions placed on stride_x, however the user should
  !>                 take care to ensure that stride_x is of appropriate size, for a typical
  !>                 case this means stride_x >= n  incx.
  !>     @param[out]
  !>     y         device pointer to the first vector (y_1) in the batch.
  !>     @param[in]
  !>     incy      [rocblas_int]
  !>               specifies the increment for the elements of vectors y_i.
  !>     @param[in]
  !>     stridey     [rocblas_stride]
  !>                 stride from the start of one vector (y_i) and the next one (y_i+1).
  !>                 There are no restrictions placed on stride_y, however the user should
  !>                 take care to ensure that stride_y is of appropriate size, for a typical
  !>                 case this means stride_y >= n  incy. stridey should be non zero.
  !>     @param[in]
  !>     incy      [rocblas_int]
  !>               specifies the increment for the elements of y.
  !>     @param[in]
  !>     batch_count [rocblas_int]
  !>                 number of instances in the batch
  !> 
  !>     
  interface rocblas_zcopy_strided_batched
    function rocblas_zcopy_strided_batched_orig(handle,n,x,incx,stridex,y,incy,stridey,batch_count) bind(c, name="rocblas_zcopy_strided_batched")
      use iso_c_binding
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocblas_zcopy_strided_batched_orig
      type(c_ptr),value :: handle
      integer(c_int),value :: n
      type(c_ptr),value :: x
      integer(c_int),value :: incx
      integer(c_int64_t),value :: stridex
      type(c_ptr),value :: y
      integer(c_int),value :: incy
      integer(c_int64_t),value :: stridey
      integer(c_int),value :: batch_count
    end function

#ifdef USE_FPOINTER_INTERFACES
    module procedure rocblas_zcopy_strided_batched_rank_0,rocblas_zcopy_strided_batched_rank_1
#endif

  end interface
  
  interface rocblas_sdot
    function rocblas_sdot_orig(handle,n,x,incx,y,incy,myResult) bind(c, name="rocblas_sdot")
      use iso_c_binding
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocblas_sdot_orig
      type(c_ptr),value :: handle
      integer(c_int),value :: n
      type(c_ptr),value :: x
      integer(c_int),value :: incx
      type(c_ptr),value :: y
      integer(c_int),value :: incy
      type(c_ptr),value :: myResult
    end function

#ifdef USE_FPOINTER_INTERFACES
    module procedure rocblas_sdot_rank_0,rocblas_sdot_rank_1
#endif

  end interface
  
  interface rocblas_ddot
    function rocblas_ddot_orig(handle,n,x,incx,y,incy,myResult) bind(c, name="rocblas_ddot")
      use iso_c_binding
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocblas_ddot_orig
      type(c_ptr),value :: handle
      integer(c_int),value :: n
      type(c_ptr),value :: x
      integer(c_int),value :: incx
      type(c_ptr),value :: y
      integer(c_int),value :: incy
      type(c_ptr),value :: myResult
    end function

#ifdef USE_FPOINTER_INTERFACES
    module procedure rocblas_ddot_rank_0,rocblas_ddot_rank_1
#endif

  end interface
  
  interface rocblas_cdotu
    function rocblas_cdotu_orig(handle,n,x,incx,y,incy,myResult) bind(c, name="rocblas_cdotu")
      use iso_c_binding
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocblas_cdotu_orig
      type(c_ptr),value :: handle
      integer(c_int),value :: n
      type(c_ptr),value :: x
      integer(c_int),value :: incx
      type(c_ptr),value :: y
      integer(c_int),value :: incy
      type(c_ptr),value :: myResult
    end function

#ifdef USE_FPOINTER_INTERFACES
    module procedure rocblas_cdotu_rank_0,rocblas_cdotu_rank_1
#endif

  end interface
  
  interface rocblas_zdotu
    function rocblas_zdotu_orig(handle,n,x,incx,y,incy,myResult) bind(c, name="rocblas_zdotu")
      use iso_c_binding
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocblas_zdotu_orig
      type(c_ptr),value :: handle
      integer(c_int),value :: n
      type(c_ptr),value :: x
      integer(c_int),value :: incx
      type(c_ptr),value :: y
      integer(c_int),value :: incy
      type(c_ptr),value :: myResult
    end function

#ifdef USE_FPOINTER_INTERFACES
    module procedure rocblas_zdotu_rank_0,rocblas_zdotu_rank_1
#endif

  end interface
  
  interface rocblas_cdotc
    function rocblas_cdotc_orig(handle,n,x,incx,y,incy,myResult) bind(c, name="rocblas_cdotc")
      use iso_c_binding
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocblas_cdotc_orig
      type(c_ptr),value :: handle
      integer(c_int),value :: n
      type(c_ptr),value :: x
      integer(c_int),value :: incx
      type(c_ptr),value :: y
      integer(c_int),value :: incy
      type(c_ptr),value :: myResult
    end function

#ifdef USE_FPOINTER_INTERFACES
    module procedure rocblas_cdotc_rank_0,rocblas_cdotc_rank_1
#endif

  end interface
  !> ! \brief BLAS Level 1 API
  !> 
  !>     \details
  !>     dot(u)  performs the dot product of vectors x and y
  !> 
  !>         result = x  y;
  !> 
  !>     dotc  performs the dot product of the conjugate of complex vector x and complex vector y
  !> 
  !>         result = conjugate (x)  y;
  !> 
  !>     @param[in]
  !>     handle    [rocblas_handle]
  !>               handle to the rocblas library context queue.
  !>     @param[in]
  !>     n         [rocblas_int]
  !>               the number of elements in x and y.
  !>     @param[in]
  !>     x         device pointer storing vector x.
  !>     @param[in]
  !>     incx      [rocblas_int]
  !>               specifies the increment for the elements of y.
  !>     @param[in]
  !>     y         device pointer storing vector y.
  !>     @param[in]
  !>     incy      [rocblas_int]
  !>               specifies the increment for the elements of y.
  !>     @param[inout]
  !>     result
  !>               device pointer or host pointer to store the dot product.
  !>               return is 0.0 if n <= 0.
  !> 
  !>     
  interface rocblas_zdotc
    function rocblas_zdotc_orig(handle,n,x,incx,y,incy,myResult) bind(c, name="rocblas_zdotc")
      use iso_c_binding
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocblas_zdotc_orig
      type(c_ptr),value :: handle
      integer(c_int),value :: n
      type(c_ptr),value :: x
      integer(c_int),value :: incx
      type(c_ptr),value :: y
      integer(c_int),value :: incy
      type(c_ptr),value :: myResult
    end function

#ifdef USE_FPOINTER_INTERFACES
    module procedure rocblas_zdotc_rank_0,rocblas_zdotc_rank_1
#endif

  end interface
  
  interface rocblas_sdot_batched
    function rocblas_sdot_batched_orig(handle,n,x,incx,y,incy,batch_count,myResult) bind(c, name="rocblas_sdot_batched")
      use iso_c_binding
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocblas_sdot_batched_orig
      type(c_ptr),value :: handle
      integer(c_int),value :: n
      type(c_ptr) :: x
      integer(c_int),value :: incx
      type(c_ptr) :: y
      integer(c_int),value :: incy
      integer(c_int),value :: batch_count
      type(c_ptr),value :: myResult
    end function

#ifdef USE_FPOINTER_INTERFACES
    module procedure rocblas_sdot_batched_full_rank,rocblas_sdot_batched_rank_0,rocblas_sdot_batched_rank_1
#endif

  end interface
  
  interface rocblas_ddot_batched
    function rocblas_ddot_batched_orig(handle,n,x,incx,y,incy,batch_count,myResult) bind(c, name="rocblas_ddot_batched")
      use iso_c_binding
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocblas_ddot_batched_orig
      type(c_ptr),value :: handle
      integer(c_int),value :: n
      type(c_ptr) :: x
      integer(c_int),value :: incx
      type(c_ptr) :: y
      integer(c_int),value :: incy
      integer(c_int),value :: batch_count
      type(c_ptr),value :: myResult
    end function

#ifdef USE_FPOINTER_INTERFACES
    module procedure rocblas_ddot_batched_full_rank,rocblas_ddot_batched_rank_0,rocblas_ddot_batched_rank_1
#endif

  end interface
  
  interface rocblas_cdotu_batched
    function rocblas_cdotu_batched_orig(handle,n,x,incx,y,incy,batch_count,myResult) bind(c, name="rocblas_cdotu_batched")
      use iso_c_binding
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocblas_cdotu_batched_orig
      type(c_ptr),value :: handle
      integer(c_int),value :: n
      type(c_ptr) :: x
      integer(c_int),value :: incx
      type(c_ptr) :: y
      integer(c_int),value :: incy
      integer(c_int),value :: batch_count
      type(c_ptr),value :: myResult
    end function

#ifdef USE_FPOINTER_INTERFACES
    module procedure rocblas_cdotu_batched_full_rank,rocblas_cdotu_batched_rank_0,rocblas_cdotu_batched_rank_1
#endif

  end interface
  
  interface rocblas_zdotu_batched
    function rocblas_zdotu_batched_orig(handle,n,x,incx,y,incy,batch_count,myResult) bind(c, name="rocblas_zdotu_batched")
      use iso_c_binding
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocblas_zdotu_batched_orig
      type(c_ptr),value :: handle
      integer(c_int),value :: n
      type(c_ptr) :: x
      integer(c_int),value :: incx
      type(c_ptr) :: y
      integer(c_int),value :: incy
      integer(c_int),value :: batch_count
      type(c_ptr),value :: myResult
    end function

#ifdef USE_FPOINTER_INTERFACES
    module procedure rocblas_zdotu_batched_full_rank,rocblas_zdotu_batched_rank_0,rocblas_zdotu_batched_rank_1
#endif

  end interface
  
  interface rocblas_cdotc_batched
    function rocblas_cdotc_batched_orig(handle,n,x,incx,y,incy,batch_count,myResult) bind(c, name="rocblas_cdotc_batched")
      use iso_c_binding
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocblas_cdotc_batched_orig
      type(c_ptr),value :: handle
      integer(c_int),value :: n
      type(c_ptr) :: x
      integer(c_int),value :: incx
      type(c_ptr) :: y
      integer(c_int),value :: incy
      integer(c_int),value :: batch_count
      type(c_ptr),value :: myResult
    end function

#ifdef USE_FPOINTER_INTERFACES
    module procedure rocblas_cdotc_batched_full_rank,rocblas_cdotc_batched_rank_0,rocblas_cdotc_batched_rank_1
#endif

  end interface
  !> ! \brief BLAS Level 1 API
  !> 
  !>     \details
  !>     dot_batched(u) performs a batch of dot products of vectors x and y
  !> 
  !>         result_i = x_i  y_i;
  !> 
  !>     dotc_batched  performs a batch of dot products of the conjugate of complex vector x and complex vector y
  !> 
  !>         result_i = conjugate (x_i)  y_i;
  !> 
  !>     where (x_i, y_i) is the i-th instance of the batch.
  !>     x_i and y_i are vectors, for i = 1, ..., batch_count
  !> 
  !>     @param[in]
  !>     handle    [rocblas_handle]
  !>               handle to the rocblas library context queue.
  !>     @param[in]
  !>     n         [rocblas_int]
  !>               the number of elements in each x_i and y_i.
  !>     @param[in]
  !>     x         device array of device pointers storing each vector x_i.
  !>     @param[in]
  !>     incx      [rocblas_int]
  !>               specifies the increment for the elements of each x_i.
  !>     @param[in]
  !>     y         device array of device pointers storing each vector y_i.
  !>     @param[in]
  !>     incy      [rocblas_int]
  !>               specifies the increment for the elements of each y_i.
  !>     @param[in]
  !>     batch_count [rocblas_int]
  !>                 number of instances in the batch
  !>     @param[inout]
  !>     result
  !>               device array or host array of batch_count size to store the dot products of each batch.
  !>               return 0.0 for each element if n <= 0.
  !> 
  !>     
  interface rocblas_zdotc_batched
    function rocblas_zdotc_batched_orig(handle,n,x,incx,y,incy,batch_count,myResult) bind(c, name="rocblas_zdotc_batched")
      use iso_c_binding
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocblas_zdotc_batched_orig
      type(c_ptr),value :: handle
      integer(c_int),value :: n
      type(c_ptr) :: x
      integer(c_int),value :: incx
      type(c_ptr) :: y
      integer(c_int),value :: incy
      integer(c_int),value :: batch_count
      type(c_ptr),value :: myResult
    end function

#ifdef USE_FPOINTER_INTERFACES
    module procedure rocblas_zdotc_batched_full_rank,rocblas_zdotc_batched_rank_0,rocblas_zdotc_batched_rank_1
#endif

  end interface
  
  interface rocblas_sdot_strided_batched
    function rocblas_sdot_strided_batched_orig(handle,n,x,incx,stridex,y,incy,stridey,batch_count,myResult) bind(c, name="rocblas_sdot_strided_batched")
      use iso_c_binding
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocblas_sdot_strided_batched_orig
      type(c_ptr),value :: handle
      integer(c_int),value :: n
      type(c_ptr),value :: x
      integer(c_int),value :: incx
      integer(c_int64_t),value :: stridex
      type(c_ptr),value :: y
      integer(c_int),value :: incy
      integer(c_int64_t),value :: stridey
      integer(c_int),value :: batch_count
      type(c_ptr),value :: myResult
    end function

#ifdef USE_FPOINTER_INTERFACES
    module procedure rocblas_sdot_strided_batched_rank_0,rocblas_sdot_strided_batched_rank_1
#endif

  end interface
  
  interface rocblas_ddot_strided_batched
    function rocblas_ddot_strided_batched_orig(handle,n,x,incx,stridex,y,incy,stridey,batch_count,myResult) bind(c, name="rocblas_ddot_strided_batched")
      use iso_c_binding
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocblas_ddot_strided_batched_orig
      type(c_ptr),value :: handle
      integer(c_int),value :: n
      type(c_ptr),value :: x
      integer(c_int),value :: incx
      integer(c_int64_t),value :: stridex
      type(c_ptr),value :: y
      integer(c_int),value :: incy
      integer(c_int64_t),value :: stridey
      integer(c_int),value :: batch_count
      type(c_ptr),value :: myResult
    end function

#ifdef USE_FPOINTER_INTERFACES
    module procedure rocblas_ddot_strided_batched_rank_0,rocblas_ddot_strided_batched_rank_1
#endif

  end interface
  
  interface rocblas_cdotu_strided_batched
    function rocblas_cdotu_strided_batched_orig(handle,n,x,incx,stridex,y,incy,stridey,batch_count,myResult) bind(c, name="rocblas_cdotu_strided_batched")
      use iso_c_binding
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocblas_cdotu_strided_batched_orig
      type(c_ptr),value :: handle
      integer(c_int),value :: n
      type(c_ptr),value :: x
      integer(c_int),value :: incx
      integer(c_int64_t),value :: stridex
      type(c_ptr),value :: y
      integer(c_int),value :: incy
      integer(c_int64_t),value :: stridey
      integer(c_int),value :: batch_count
      type(c_ptr),value :: myResult
    end function

#ifdef USE_FPOINTER_INTERFACES
    module procedure rocblas_cdotu_strided_batched_rank_0,rocblas_cdotu_strided_batched_rank_1
#endif

  end interface
  
  interface rocblas_zdotu_strided_batched
    function rocblas_zdotu_strided_batched_orig(handle,n,x,incx,stridex,y,incy,stridey,batch_count,myResult) bind(c, name="rocblas_zdotu_strided_batched")
      use iso_c_binding
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocblas_zdotu_strided_batched_orig
      type(c_ptr),value :: handle
      integer(c_int),value :: n
      type(c_ptr),value :: x
      integer(c_int),value :: incx
      integer(c_int64_t),value :: stridex
      type(c_ptr),value :: y
      integer(c_int),value :: incy
      integer(c_int64_t),value :: stridey
      integer(c_int),value :: batch_count
      type(c_ptr),value :: myResult
    end function

#ifdef USE_FPOINTER_INTERFACES
    module procedure rocblas_zdotu_strided_batched_rank_0,rocblas_zdotu_strided_batched_rank_1
#endif

  end interface
  
  interface rocblas_cdotc_strided_batched
    function rocblas_cdotc_strided_batched_orig(handle,n,x,incx,stridex,y,incy,stridey,batch_count,myResult) bind(c, name="rocblas_cdotc_strided_batched")
      use iso_c_binding
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocblas_cdotc_strided_batched_orig
      type(c_ptr),value :: handle
      integer(c_int),value :: n
      type(c_ptr),value :: x
      integer(c_int),value :: incx
      integer(c_int64_t),value :: stridex
      type(c_ptr),value :: y
      integer(c_int),value :: incy
      integer(c_int64_t),value :: stridey
      integer(c_int),value :: batch_count
      type(c_ptr),value :: myResult
    end function

#ifdef USE_FPOINTER_INTERFACES
    module procedure rocblas_cdotc_strided_batched_rank_0,rocblas_cdotc_strided_batched_rank_1
#endif

  end interface
  !> ! \brief BLAS Level 1 API
  !> 
  !>     \details
  !>     dot_strided_batched(u)  performs a batch of dot products of vectors x and y
  !> 
  !>         result_i = x_i  y_i;
  !> 
  !>     dotc_strided_batched  performs a batch of dot products of the conjugate of complex vector x and complex vector y
  !> 
  !>         result_i = conjugate (x_i)  y_i;
  !> 
  !>     where (x_i, y_i) is the i-th instance of the batch.
  !>     x_i and y_i are vectors, for i = 1, ..., batch_count
  !> 
  !>     @param[in]
  !>     handle    [rocblas_handle]
  !>               handle to the rocblas library context queue.
  !>     @param[in]
  !>     n         [rocblas_int]
  !>               the number of elements in each x_i and y_i.
  !>     @param[in]
  !>     x         device pointer to the first vector (x_1) in the batch.
  !>     @param[in]
  !>     incx      [rocblas_int]
  !>               specifies the increment for the elements of each x_i.
  !>     @param[in]
  !>     stridex     [rocblas_stride]
  !>                 stride from the start of one vector (x_i) and the next one (x_i+1)
  !>     @param[in]
  !>     y         device pointer to the first vector (y_1) in the batch.
  !>     @param[in]
  !>     incy      [rocblas_int]
  !>               specifies the increment for the elements of each y_i.
  !>     @param[in]
  !>     stridey     [rocblas_stride]
  !>                 stride from the start of one vector (y_i) and the next one (y_i+1)
  !>     @param[in]
  !>     batch_count [rocblas_int]
  !>                 number of instances in the batch
  !>     @param[inout]
  !>     result
  !>               device array or host array of batch_count size to store the dot products of each batch.
  !>               return 0.0 for each element if n <= 0.
  !> 
  !>     
  interface rocblas_zdotc_strided_batched
    function rocblas_zdotc_strided_batched_orig(handle,n,x,incx,stridex,y,incy,stridey,batch_count,myResult) bind(c, name="rocblas_zdotc_strided_batched")
      use iso_c_binding
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocblas_zdotc_strided_batched_orig
      type(c_ptr),value :: handle
      integer(c_int),value :: n
      type(c_ptr),value :: x
      integer(c_int),value :: incx
      integer(c_int64_t),value :: stridex
      type(c_ptr),value :: y
      integer(c_int),value :: incy
      integer(c_int64_t),value :: stridey
      integer(c_int),value :: batch_count
      type(c_ptr),value :: myResult
    end function

#ifdef USE_FPOINTER_INTERFACES
    module procedure rocblas_zdotc_strided_batched_rank_0,rocblas_zdotc_strided_batched_rank_1
#endif

  end interface
  
  interface rocblas_sswap
    function rocblas_sswap_orig(handle,incy) bind(c, name="rocblas_sswap")
      use iso_c_binding
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocblas_sswap_orig
      type(c_ptr),value :: handle
      integer(c_int),value :: incy
    end function


  end interface
  
  interface rocblas_dswap
    function rocblas_dswap_orig(handle,incy) bind(c, name="rocblas_dswap")
      use iso_c_binding
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocblas_dswap_orig
      type(c_ptr),value :: handle
      integer(c_int),value :: incy
    end function


  end interface
  
  interface rocblas_cswap
    function rocblas_cswap_orig(handle,n,x,incx,y,incy) bind(c, name="rocblas_cswap")
      use iso_c_binding
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocblas_cswap_orig
      type(c_ptr),value :: handle
      integer(c_int),value :: n
      type(c_ptr),value :: x
      integer(c_int),value :: incx
      type(c_ptr),value :: y
      integer(c_int),value :: incy
    end function

#ifdef USE_FPOINTER_INTERFACES
    module procedure rocblas_cswap_rank_0,rocblas_cswap_rank_1
#endif

  end interface
  !> ! \brief BLAS Level 1 API
  !> 
  !>     \details
  !>     swap  interchanges vectors x and y.
  !> 
  !>         y := x; x := y
  !> 
  !>     @param[in]
  !>     handle    [rocblas_handle]
  !>               handle to the rocblas library context queue.
  !>     @param[in]
  !>     n         [rocblas_int]
  !>               the number of elements in x and y.
  !>     @param[inout]
  !>     x         device pointer storing vector x.
  !>     @param[in]
  !>     incx      [rocblas_int]
  !>               specifies the increment for the elements of x.
  !>     @param[inout]
  !>     y         device pointer storing vector y.
  !>     @param[in]
  !>     incy      [rocblas_int]
  !>               specifies the increment for the elements of y.
  !> 
  !>     
  interface rocblas_zswap
    function rocblas_zswap_orig(handle,n,x,incx,y,incy) bind(c, name="rocblas_zswap")
      use iso_c_binding
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocblas_zswap_orig
      type(c_ptr),value :: handle
      integer(c_int),value :: n
      type(c_ptr),value :: x
      integer(c_int),value :: incx
      type(c_ptr),value :: y
      integer(c_int),value :: incy
    end function

#ifdef USE_FPOINTER_INTERFACES
    module procedure rocblas_zswap_rank_0,rocblas_zswap_rank_1
#endif

  end interface
  
  interface rocblas_sswap_batched
    function rocblas_sswap_batched_orig(handle,n,x,incx,y,incy,batch_count) bind(c, name="rocblas_sswap_batched")
      use iso_c_binding
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocblas_sswap_batched_orig
      type(c_ptr),value :: handle
      integer(c_int),value :: n
      type(c_ptr) :: x
      integer(c_int),value :: incx
      type(c_ptr) :: y
      integer(c_int),value :: incy
      integer(c_int),value :: batch_count
    end function

#ifdef USE_FPOINTER_INTERFACES
    module procedure rocblas_sswap_batched_full_rank,rocblas_sswap_batched_rank_0,rocblas_sswap_batched_rank_1
#endif

  end interface
  
  interface rocblas_dswap_batched
    function rocblas_dswap_batched_orig(handle,n,x,incx,y,incy,batch_count) bind(c, name="rocblas_dswap_batched")
      use iso_c_binding
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocblas_dswap_batched_orig
      type(c_ptr),value :: handle
      integer(c_int),value :: n
      type(c_ptr) :: x
      integer(c_int),value :: incx
      type(c_ptr) :: y
      integer(c_int),value :: incy
      integer(c_int),value :: batch_count
    end function

#ifdef USE_FPOINTER_INTERFACES
    module procedure rocblas_dswap_batched_full_rank,rocblas_dswap_batched_rank_0,rocblas_dswap_batched_rank_1
#endif

  end interface
  
  interface rocblas_cswap_batched
    function rocblas_cswap_batched_orig(handle,n,x,incx,y,incy,batch_count) bind(c, name="rocblas_cswap_batched")
      use iso_c_binding
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocblas_cswap_batched_orig
      type(c_ptr),value :: handle
      integer(c_int),value :: n
      type(c_ptr) :: x
      integer(c_int),value :: incx
      type(c_ptr) :: y
      integer(c_int),value :: incy
      integer(c_int),value :: batch_count
    end function

#ifdef USE_FPOINTER_INTERFACES
    module procedure rocblas_cswap_batched_full_rank,rocblas_cswap_batched_rank_0,rocblas_cswap_batched_rank_1
#endif

  end interface
  !> ! \brief BLAS Level 1 API
  !> 
  !>     \details
  !>     swap_batched interchanges vectors x_i and y_i, for i = 1 , ... , batch_count
  !> 
  !>         y_i := x_i; x_i := y_i
  !> 
  !>     @param[in]
  !>     handle    [rocblas_handle]
  !>               handle to the rocblas library context queue.
  !>     @param[in]
  !>     n         [rocblas_int]
  !>               the number of elements in each x_i and y_i.
  !>     @param[inout]
  !>     x         device array of device pointers storing each vector x_i.
  !>     @param[in]
  !>     incx      [rocblas_int]
  !>               specifies the increment for the elements of each x_i.
  !>     @param[inout]
  !>     y         device array of device pointers storing each vector y_i.
  !>     @param[in]
  !>     incy      [rocblas_int]
  !>               specifies the increment for the elements of each y_i.
  !>     @param[in]
  !>     batch_count [rocblas_int]
  !>                 number of instances in the batch.
  !> 
  !>     
  interface rocblas_zswap_batched
    function rocblas_zswap_batched_orig(handle,n,x,incx,y,incy,batch_count) bind(c, name="rocblas_zswap_batched")
      use iso_c_binding
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocblas_zswap_batched_orig
      type(c_ptr),value :: handle
      integer(c_int),value :: n
      type(c_ptr) :: x
      integer(c_int),value :: incx
      type(c_ptr) :: y
      integer(c_int),value :: incy
      integer(c_int),value :: batch_count
    end function

#ifdef USE_FPOINTER_INTERFACES
    module procedure rocblas_zswap_batched_full_rank,rocblas_zswap_batched_rank_0,rocblas_zswap_batched_rank_1
#endif

  end interface
  
  interface rocblas_sswap_strided_batched
    function rocblas_sswap_strided_batched_orig(handle,n,x,incx,stridex,y,incy,stridey,batch_count) bind(c, name="rocblas_sswap_strided_batched")
      use iso_c_binding
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocblas_sswap_strided_batched_orig
      type(c_ptr),value :: handle
      integer(c_int),value :: n
      type(c_ptr),value :: x
      integer(c_int),value :: incx
      integer(c_int64_t),value :: stridex
      type(c_ptr),value :: y
      integer(c_int),value :: incy
      integer(c_int64_t),value :: stridey
      integer(c_int),value :: batch_count
    end function

#ifdef USE_FPOINTER_INTERFACES
    module procedure rocblas_sswap_strided_batched_rank_0,rocblas_sswap_strided_batched_rank_1
#endif

  end interface
  
  interface rocblas_dswap_strided_batched
    function rocblas_dswap_strided_batched_orig(handle,n,x,incx,stridex,y,incy,stridey,batch_count) bind(c, name="rocblas_dswap_strided_batched")
      use iso_c_binding
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocblas_dswap_strided_batched_orig
      type(c_ptr),value :: handle
      integer(c_int),value :: n
      type(c_ptr),value :: x
      integer(c_int),value :: incx
      integer(c_int64_t),value :: stridex
      type(c_ptr),value :: y
      integer(c_int),value :: incy
      integer(c_int64_t),value :: stridey
      integer(c_int),value :: batch_count
    end function

#ifdef USE_FPOINTER_INTERFACES
    module procedure rocblas_dswap_strided_batched_rank_0,rocblas_dswap_strided_batched_rank_1
#endif

  end interface
  
  interface rocblas_cswap_strided_batched
    function rocblas_cswap_strided_batched_orig(handle,n,x,incx,stridex,y,incy,stridey,batch_count) bind(c, name="rocblas_cswap_strided_batched")
      use iso_c_binding
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocblas_cswap_strided_batched_orig
      type(c_ptr),value :: handle
      integer(c_int),value :: n
      type(c_ptr),value :: x
      integer(c_int),value :: incx
      integer(c_int64_t),value :: stridex
      type(c_ptr),value :: y
      integer(c_int),value :: incy
      integer(c_int64_t),value :: stridey
      integer(c_int),value :: batch_count
    end function

#ifdef USE_FPOINTER_INTERFACES
    module procedure rocblas_cswap_strided_batched_rank_0,rocblas_cswap_strided_batched_rank_1
#endif

  end interface
  !> ! \brief BLAS Level 1 API
  !> 
  !>     \details
  !>     swap_strided_batched interchanges vectors x_i and y_i, for i = 1 , ... , batch_count
  !> 
  !>         y_i := x_i; x_i := y_i
  !> 
  !>     @param[in]
  !>     handle    [rocblas_handle]
  !>               handle to the rocblas library context queue.
  !>     @param[in]
  !>     n         [rocblas_int]
  !>               the number of elements in each x_i and y_i.
  !>     @param[inout]
  !>     x         device pointer to the first vector x_1.
  !>     @param[in]
  !>     incx      [rocblas_int]
  !>               specifies the increment for the elements of x.
  !>     @param[in]
  !>     stridex   [rocblas_stride]
  !>               stride from the start of one vector (x_i) and the next one (x_i+1).
  !>               There are no restrictions placed on stride_x, however the user should
  !>               take care to ensure that stride_x is of appropriate size, for a typical
  !>               case this means stride_x >= n  incx.
  !>     @param[inout]
  !>     y         device pointer to the first vector y_1.
  !>     @param[in]
  !>     incy      [rocblas_int]
  !>               specifies the increment for the elements of y.
  !>     @param[in]
  !>     stridey   [rocblas_stride]
  !>               stride from the start of one vector (y_i) and the next one (y_i+1).
  !>               There are no restrictions placed on stride_x, however the user should
  !>               take care to ensure that stride_y is of appropriate size, for a typical
  !>               case this means stride_y >= n  incy. stridey should be non zero.
  !>      @param[in]
  !>      batch_count [rocblas_int]
  !>                  number of instances in the batch.
  !> 
  !>     
  interface rocblas_zswap_strided_batched
    function rocblas_zswap_strided_batched_orig(handle,n,x,incx,stridex,y,incy,stridey,batch_count) bind(c, name="rocblas_zswap_strided_batched")
      use iso_c_binding
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocblas_zswap_strided_batched_orig
      type(c_ptr),value :: handle
      integer(c_int),value :: n
      type(c_ptr),value :: x
      integer(c_int),value :: incx
      integer(c_int64_t),value :: stridex
      type(c_ptr),value :: y
      integer(c_int),value :: incy
      integer(c_int64_t),value :: stridey
      integer(c_int),value :: batch_count
    end function

#ifdef USE_FPOINTER_INTERFACES
    module procedure rocblas_zswap_strided_batched_rank_0,rocblas_zswap_strided_batched_rank_1
#endif

  end interface
  
  interface rocblas_saxpy
    function rocblas_saxpy_orig(handle,n,alpha,x,incx,y,incy) bind(c, name="rocblas_saxpy")
      use iso_c_binding
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocblas_saxpy_orig
      type(c_ptr),value :: handle
      integer(c_int),value :: n
      real(c_float) :: alpha
      type(c_ptr),value :: x
      integer(c_int),value :: incx
      type(c_ptr),value :: y
      integer(c_int),value :: incy
    end function

#ifdef USE_FPOINTER_INTERFACES
    module procedure rocblas_saxpy_rank_0,rocblas_saxpy_rank_1
#endif

  end interface
  
  interface rocblas_daxpy
    function rocblas_daxpy_orig(handle,n,alpha,x,incx,y,incy) bind(c, name="rocblas_daxpy")
      use iso_c_binding
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocblas_daxpy_orig
      type(c_ptr),value :: handle
      integer(c_int),value :: n
      real(c_double) :: alpha
      type(c_ptr),value :: x
      integer(c_int),value :: incx
      type(c_ptr),value :: y
      integer(c_int),value :: incy
    end function

#ifdef USE_FPOINTER_INTERFACES
    module procedure rocblas_daxpy_rank_0,rocblas_daxpy_rank_1
#endif

  end interface
  
  interface rocblas_caxpy
    function rocblas_caxpy_orig(handle,n,alpha,x,incx,y,incy) bind(c, name="rocblas_caxpy")
      use iso_c_binding
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocblas_caxpy_orig
      type(c_ptr),value :: handle
      integer(c_int),value :: n
      complex(c_float_complex) :: alpha
      type(c_ptr),value :: x
      integer(c_int),value :: incx
      type(c_ptr),value :: y
      integer(c_int),value :: incy
    end function

#ifdef USE_FPOINTER_INTERFACES
    module procedure rocblas_caxpy_rank_0,rocblas_caxpy_rank_1
#endif

  end interface
  !> ! \brief BLAS Level 1 API
  !> 
  !>     \details
  !>     axpy   computes ant alpha multiplied by vector x, plus vector y
  !> 
  !>         y := alpha  x + y
  !> 
  !>     @param[in]
  !>     handle    [rocblas_handle]
  !>               handle to the rocblas library context queue.
  !>     @param[in]
  !>     n         [rocblas_int]
  !>               the number of elements in x and y.
  !>     @param[in]
  !>     alpha     device pointer or host pointer to specify the scalar alpha.
  !>     @param[in]
  !>     x         device pointer storing vector x.
  !>     @param[in]
  !>     incx      [rocblas_int]
  !>               specifies the increment for the elements of x.
  !>     @param[out]
  !>     y         device pointer storing vector y.
  !>     @param[inout]
  !>     incy      [rocblas_int]
  !>               specifies the increment for the elements of y.
  !> 
  !>     
  interface rocblas_zaxpy
    function rocblas_zaxpy_orig(handle,n,alpha,x,incx,y,incy) bind(c, name="rocblas_zaxpy")
      use iso_c_binding
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocblas_zaxpy_orig
      type(c_ptr),value :: handle
      integer(c_int),value :: n
      complex(c_double_complex) :: alpha
      type(c_ptr),value :: x
      integer(c_int),value :: incx
      type(c_ptr),value :: y
      integer(c_int),value :: incy
    end function

#ifdef USE_FPOINTER_INTERFACES
    module procedure rocblas_zaxpy_rank_0,rocblas_zaxpy_rank_1
#endif

  end interface
  
  interface rocblas_saxpy_batched
    function rocblas_saxpy_batched_orig(handle,n,alpha,x,incx,y,incy,batch_count) bind(c, name="rocblas_saxpy_batched")
      use iso_c_binding
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocblas_saxpy_batched_orig
      type(c_ptr),value :: handle
      integer(c_int),value :: n
      real(c_float) :: alpha
      type(c_ptr) :: x
      integer(c_int),value :: incx
      type(c_ptr) :: y
      integer(c_int),value :: incy
      integer(c_int),value :: batch_count
    end function

#ifdef USE_FPOINTER_INTERFACES
    module procedure rocblas_saxpy_batched_full_rank,rocblas_saxpy_batched_rank_0,rocblas_saxpy_batched_rank_1
#endif

  end interface
  
  interface rocblas_daxpy_batched
    function rocblas_daxpy_batched_orig(handle,n,alpha,x,incx,y,incy,batch_count) bind(c, name="rocblas_daxpy_batched")
      use iso_c_binding
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocblas_daxpy_batched_orig
      type(c_ptr),value :: handle
      integer(c_int),value :: n
      real(c_double) :: alpha
      type(c_ptr) :: x
      integer(c_int),value :: incx
      type(c_ptr) :: y
      integer(c_int),value :: incy
      integer(c_int),value :: batch_count
    end function

#ifdef USE_FPOINTER_INTERFACES
    module procedure rocblas_daxpy_batched_full_rank,rocblas_daxpy_batched_rank_0,rocblas_daxpy_batched_rank_1
#endif

  end interface
  
  interface rocblas_caxpy_batched
    function rocblas_caxpy_batched_orig(handle,n,alpha,x,incx,y,incy,batch_count) bind(c, name="rocblas_caxpy_batched")
      use iso_c_binding
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocblas_caxpy_batched_orig
      type(c_ptr),value :: handle
      integer(c_int),value :: n
      complex(c_float_complex) :: alpha
      type(c_ptr) :: x
      integer(c_int),value :: incx
      type(c_ptr) :: y
      integer(c_int),value :: incy
      integer(c_int),value :: batch_count
    end function

#ifdef USE_FPOINTER_INTERFACES
    module procedure rocblas_caxpy_batched_full_rank,rocblas_caxpy_batched_rank_0,rocblas_caxpy_batched_rank_1
#endif

  end interface
  !> ! \brief BLAS Level 1 API
  !> 
  !>     \details
  !>     axpy_batched   compute y := alpha  x + y over a set of batched vectors.
  !> 
  !>     @param[in]
  !>     handle    rocblas_handle
  !>               handle to the rocblas library context queue.
  !>     @param[in]
  !>     n         rocblas_int
  !>     @param[in]
  !>     alpha     specifies the scalar alpha.
  !>     @param[in]
  !>     x         pointer storing vector x on the GPU.
  !>     @param[in]
  !>     incx      rocblas_int
  !>               specifies the increment for the elements of x.
  !>     @param[out]
  !>     y         pointer storing vector y on the GPU.
  !>     @param[inout]
  !>     incy      rocblas_int
  !>               specifies the increment for the elements of y.
  !> 
  !>     @param[in]
  !>     batch_count rocblas_int
  !>               number of instances in the batch
  !> 
  !>     
  interface rocblas_zaxpy_batched
    function rocblas_zaxpy_batched_orig(handle,n,alpha,x,incx,y,incy,batch_count) bind(c, name="rocblas_zaxpy_batched")
      use iso_c_binding
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocblas_zaxpy_batched_orig
      type(c_ptr),value :: handle
      integer(c_int),value :: n
      complex(c_double_complex) :: alpha
      type(c_ptr) :: x
      integer(c_int),value :: incx
      type(c_ptr) :: y
      integer(c_int),value :: incy
      integer(c_int),value :: batch_count
    end function

#ifdef USE_FPOINTER_INTERFACES
    module procedure rocblas_zaxpy_batched_full_rank,rocblas_zaxpy_batched_rank_0,rocblas_zaxpy_batched_rank_1
#endif

  end interface
  
  interface rocblas_saxpy_strided_batched
    function rocblas_saxpy_strided_batched_orig(handle,n,alpha,x,incx,stridex,y,incy,stridey,batch_count) bind(c, name="rocblas_saxpy_strided_batched")
      use iso_c_binding
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocblas_saxpy_strided_batched_orig
      type(c_ptr),value :: handle
      integer(c_int),value :: n
      real(c_float) :: alpha
      type(c_ptr),value :: x
      integer(c_int),value :: incx
      integer(c_int64_t),value :: stridex
      type(c_ptr),value :: y
      integer(c_int),value :: incy
      integer(c_int64_t),value :: stridey
      integer(c_int),value :: batch_count
    end function

#ifdef USE_FPOINTER_INTERFACES
    module procedure rocblas_saxpy_strided_batched_rank_0,rocblas_saxpy_strided_batched_rank_1
#endif

  end interface
  
  interface rocblas_daxpy_strided_batched
    function rocblas_daxpy_strided_batched_orig(handle,n,alpha,x,incx,stridex,y,incy,stridey,batch_count) bind(c, name="rocblas_daxpy_strided_batched")
      use iso_c_binding
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocblas_daxpy_strided_batched_orig
      type(c_ptr),value :: handle
      integer(c_int),value :: n
      real(c_double) :: alpha
      type(c_ptr),value :: x
      integer(c_int),value :: incx
      integer(c_int64_t),value :: stridex
      type(c_ptr),value :: y
      integer(c_int),value :: incy
      integer(c_int64_t),value :: stridey
      integer(c_int),value :: batch_count
    end function

#ifdef USE_FPOINTER_INTERFACES
    module procedure rocblas_daxpy_strided_batched_rank_0,rocblas_daxpy_strided_batched_rank_1
#endif

  end interface
  
  interface rocblas_caxpy_strided_batched
    function rocblas_caxpy_strided_batched_orig(handle,n,alpha,x,incx,stridex,y,incy,stridey,batch_count) bind(c, name="rocblas_caxpy_strided_batched")
      use iso_c_binding
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocblas_caxpy_strided_batched_orig
      type(c_ptr),value :: handle
      integer(c_int),value :: n
      complex(c_float_complex) :: alpha
      type(c_ptr),value :: x
      integer(c_int),value :: incx
      integer(c_int64_t),value :: stridex
      type(c_ptr),value :: y
      integer(c_int),value :: incy
      integer(c_int64_t),value :: stridey
      integer(c_int),value :: batch_count
    end function

#ifdef USE_FPOINTER_INTERFACES
    module procedure rocblas_caxpy_strided_batched_rank_0,rocblas_caxpy_strided_batched_rank_1
#endif

  end interface
  !> ! \brief BLAS Level 1 API
  !> 
  !>     \details
  !>     axpy_strided_batched   compute y := alpha  x + y over a set of strided batched vectors.
  !> 
  !>     @param[in]
  !>     handle    rocblas_handle
  !>               handle to the rocblas library context queue.
  !>     @param[in]
  !>     n         rocblas_int
  !>     @param[in]
  !>     alpha     specifies the scalar alpha.
  !>     @param[in]
  !>     x         pointer storing vector x on the GPU.
  !>     @param[in]
  !>     incx      rocblas_int
  !>               specifies the increment for the elements of x.
  !>     @param[in]
  !>     stridex   rocblas_stride
  !>               specifies the increment between vectors of x.
  !>     @param[out]
  !>     y         pointer storing vector y on the GPU.
  !>     @param[inout]
  !>     incy      rocblas_int
  !>               specifies the increment for the elements of y.
  !>     @param[in]
  !>     stridey   rocblas_stride
  !>               specifies the increment between vectors of y.
  !> 
  !>     @param[in]
  !>     batch_count rocblas_int
  !>               number of instances in the batch
  !> 
  !>     
  interface rocblas_zaxpy_strided_batched
    function rocblas_zaxpy_strided_batched_orig(handle,n,alpha,x,incx,stridex,y,incy,stridey,batch_count) bind(c, name="rocblas_zaxpy_strided_batched")
      use iso_c_binding
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocblas_zaxpy_strided_batched_orig
      type(c_ptr),value :: handle
      integer(c_int),value :: n
      complex(c_double_complex) :: alpha
      type(c_ptr),value :: x
      integer(c_int),value :: incx
      integer(c_int64_t),value :: stridex
      type(c_ptr),value :: y
      integer(c_int),value :: incy
      integer(c_int64_t),value :: stridey
      integer(c_int),value :: batch_count
    end function

#ifdef USE_FPOINTER_INTERFACES
    module procedure rocblas_zaxpy_strided_batched_rank_0,rocblas_zaxpy_strided_batched_rank_1
#endif

  end interface
  
  interface rocblas_sasum
    function rocblas_sasum_orig(handle,incx,myResult) bind(c, name="rocblas_sasum")
      use iso_c_binding
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocblas_sasum_orig
      type(c_ptr),value :: handle
      integer(c_int),value :: incx
      type(c_ptr),value :: myResult
    end function


  end interface
  
  interface rocblas_dasum
    function rocblas_dasum_orig(handle,incx,myResult) bind(c, name="rocblas_dasum")
      use iso_c_binding
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocblas_dasum_orig
      type(c_ptr),value :: handle
      integer(c_int),value :: incx
      type(c_ptr),value :: myResult
    end function


  end interface
  
  interface rocblas_scasum
    function rocblas_scasum_orig(handle,n,x,incx,myResult) bind(c, name="rocblas_scasum")
      use iso_c_binding
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocblas_scasum_orig
      type(c_ptr),value :: handle
      integer(c_int),value :: n
      type(c_ptr),value :: x
      integer(c_int),value :: incx
      type(c_ptr),value :: myResult
    end function

#ifdef USE_FPOINTER_INTERFACES
    module procedure rocblas_scasum_rank_0,rocblas_scasum_rank_1
#endif

  end interface
  !> ! \brief BLAS Level 1 API
  !> 
  !>     \details
  !>     asum computes the sum of the magnitudes of elements of a real vector x,
  !>          or the sum of magnitudes of the real and imaginary parts of elements if x is a complex
  !>    vector
  !> 
  !>     @param[in]
  !>     handle    [rocblas_handle]
  !>               handle to the rocblas library context queue.
  !>     @param[in]
  !>     n         [rocblas_int]
  !>               the number of elements in x and y.
  !>     @param[in]
  !>     x         device pointer storing vector x.
  !>     @param[in]
  !>     incx      [rocblas_int]
  !>               specifies the increment for the elements of x. incx must be > 0.
  !>     @param[inout]
  !>     result
  !>               device pointer or host pointer to store the asum product.
  !>               return is 0.0 if n <= 0.
  !> 
  !>     
  interface rocblas_dzasum
    function rocblas_dzasum_orig(handle,n,x,incx,myResult) bind(c, name="rocblas_dzasum")
      use iso_c_binding
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocblas_dzasum_orig
      type(c_ptr),value :: handle
      integer(c_int),value :: n
      type(c_ptr),value :: x
      integer(c_int),value :: incx
      type(c_ptr),value :: myResult
    end function

#ifdef USE_FPOINTER_INTERFACES
    module procedure rocblas_dzasum_rank_0,rocblas_dzasum_rank_1
#endif

  end interface
  
  interface rocblas_sasum_batched
    function rocblas_sasum_batched_orig(handle,n,x,incx,batch_count,results) bind(c, name="rocblas_sasum_batched")
      use iso_c_binding
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocblas_sasum_batched_orig
      type(c_ptr),value :: handle
      integer(c_int),value :: n
      type(c_ptr) :: x
      integer(c_int),value :: incx
      integer(c_int),value :: batch_count
      type(c_ptr),value :: results
    end function

#ifdef USE_FPOINTER_INTERFACES
    module procedure rocblas_sasum_batched_full_rank,rocblas_sasum_batched_rank_0,rocblas_sasum_batched_rank_1
#endif

  end interface
  
  interface rocblas_dasum_batched
    function rocblas_dasum_batched_orig(handle,n,x,incx,batch_count,results) bind(c, name="rocblas_dasum_batched")
      use iso_c_binding
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocblas_dasum_batched_orig
      type(c_ptr),value :: handle
      integer(c_int),value :: n
      type(c_ptr) :: x
      integer(c_int),value :: incx
      integer(c_int),value :: batch_count
      type(c_ptr),value :: results
    end function

#ifdef USE_FPOINTER_INTERFACES
    module procedure rocblas_dasum_batched_full_rank,rocblas_dasum_batched_rank_0,rocblas_dasum_batched_rank_1
#endif

  end interface
  
  interface rocblas_scasum_batched
    function rocblas_scasum_batched_orig(handle,n,x,incx,batch_count,results) bind(c, name="rocblas_scasum_batched")
      use iso_c_binding
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocblas_scasum_batched_orig
      type(c_ptr),value :: handle
      integer(c_int),value :: n
      type(c_ptr) :: x
      integer(c_int),value :: incx
      integer(c_int),value :: batch_count
      type(c_ptr),value :: results
    end function

#ifdef USE_FPOINTER_INTERFACES
    module procedure rocblas_scasum_batched_full_rank,rocblas_scasum_batched_rank_0,rocblas_scasum_batched_rank_1
#endif

  end interface
  !> ! \brief BLAS Level 1 API
  !> 
  !>     \details
  !>     asum_batched computes the sum of the magnitudes of the elements in a batch of real vectors x_i,
  !>         or the sum of magnitudes of the real and imaginary parts of elements if x_i is a complex
  !>         vector, for i = 1, ..., batch_count
  !> 
  !>     @param[in]
  !>     handle    [rocblas_handle]
  !>               handle to the rocblas library context queue.
  !>     @param[in]
  !>     n         [rocblas_int]
  !>               number of elements in each vector x_i
  !>     @param[in]
  !>     x         device array of device pointers storing each vector x_i.
  !>     @param[in]
  !>     incx      [rocblas_int]
  !>               specifies the increment for the elements of each x_i. incx must be > 0.
  !>     @param[out]
  !>     results
  !>               device array or host array of batch_count size for results.
  !>               return is 0.0 if n, incx<=0.
  !>     @param[in]
  !>     batch_count [rocblas_int]
  !>               number of instances in the batch.
  !>     
  interface rocblas_dzasum_batched
    function rocblas_dzasum_batched_orig(handle,n,x,incx,batch_count,results) bind(c, name="rocblas_dzasum_batched")
      use iso_c_binding
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocblas_dzasum_batched_orig
      type(c_ptr),value :: handle
      integer(c_int),value :: n
      type(c_ptr) :: x
      integer(c_int),value :: incx
      integer(c_int),value :: batch_count
      type(c_ptr),value :: results
    end function

#ifdef USE_FPOINTER_INTERFACES
    module procedure rocblas_dzasum_batched_full_rank,rocblas_dzasum_batched_rank_0,rocblas_dzasum_batched_rank_1
#endif

  end interface
  
  interface rocblas_sasum_strided_batched
    function rocblas_sasum_strided_batched_orig(handle,n,x,incx,stridex,batch_count,results) bind(c, name="rocblas_sasum_strided_batched")
      use iso_c_binding
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocblas_sasum_strided_batched_orig
      type(c_ptr),value :: handle
      integer(c_int),value :: n
      type(c_ptr),value :: x
      integer(c_int),value :: incx
      integer(c_int64_t),value :: stridex
      integer(c_int),value :: batch_count
      type(c_ptr),value :: results
    end function

#ifdef USE_FPOINTER_INTERFACES
    module procedure rocblas_sasum_strided_batched_rank_0,rocblas_sasum_strided_batched_rank_1
#endif

  end interface
  
  interface rocblas_dasum_strided_batched
    function rocblas_dasum_strided_batched_orig(handle,n,x,incx,stridex,batch_count,results) bind(c, name="rocblas_dasum_strided_batched")
      use iso_c_binding
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocblas_dasum_strided_batched_orig
      type(c_ptr),value :: handle
      integer(c_int),value :: n
      type(c_ptr),value :: x
      integer(c_int),value :: incx
      integer(c_int64_t),value :: stridex
      integer(c_int),value :: batch_count
      type(c_ptr),value :: results
    end function

#ifdef USE_FPOINTER_INTERFACES
    module procedure rocblas_dasum_strided_batched_rank_0,rocblas_dasum_strided_batched_rank_1
#endif

  end interface
  
  interface rocblas_scasum_strided_batched
    function rocblas_scasum_strided_batched_orig(handle,n,x,incx,stridex,batch_count,results) bind(c, name="rocblas_scasum_strided_batched")
      use iso_c_binding
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocblas_scasum_strided_batched_orig
      type(c_ptr),value :: handle
      integer(c_int),value :: n
      type(c_ptr),value :: x
      integer(c_int),value :: incx
      integer(c_int64_t),value :: stridex
      integer(c_int),value :: batch_count
      type(c_ptr),value :: results
    end function

#ifdef USE_FPOINTER_INTERFACES
    module procedure rocblas_scasum_strided_batched_rank_0,rocblas_scasum_strided_batched_rank_1
#endif

  end interface
  !> ! \brief BLAS Level 1 API
  !> 
  !>     \details
  !>     asum_strided_batched computes the sum of the magnitudes of elements of a real vectors x_i,
  !>         or the sum of magnitudes of the real and imaginary parts of elements if x_i is a complex
  !>         vector, for i = 1, ..., batch_count
  !> 
  !>     @param[in]
  !>     handle    [rocblas_handle]
  !>               handle to the rocblas library context queue.
  !>     @param[in]
  !>     n         [rocblas_int]
  !>               number of elements in each vector x_i
  !>     @param[in]
  !>     x         device pointer to the first vector x_1.
  !>     @param[in]
  !>     incx      [rocblas_int]
  !>               specifies the increment for the elements of each x_i. incx must be > 0.
  !>     @param[in]
  !>     stridex   [rocblas_stride]
  !>               stride from the start of one vector (x_i) and the next one (x_i+1).
  !>               There are no restrictions placed on stride_x, however the user should
  !>               take care to ensure that stride_x is of appropriate size, for a typical
  !>               case this means stride_x >= n  incx.
  !>     @param[out]
  !>     results
  !>               device pointer or host pointer to array for storing contiguous batch_count results.
  !>               return is 0.0 if n, incx<=0.
  !>     @param[in]
  !>     batch_count [rocblas_int]
  !>               number of instances in the batch
  !>     
  interface rocblas_dzasum_strided_batched
    function rocblas_dzasum_strided_batched_orig(handle,n,x,incx,stridex,batch_count,results) bind(c, name="rocblas_dzasum_strided_batched")
      use iso_c_binding
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocblas_dzasum_strided_batched_orig
      type(c_ptr),value :: handle
      integer(c_int),value :: n
      type(c_ptr),value :: x
      integer(c_int),value :: incx
      integer(c_int64_t),value :: stridex
      integer(c_int),value :: batch_count
      type(c_ptr),value :: results
    end function

#ifdef USE_FPOINTER_INTERFACES
    module procedure rocblas_dzasum_strided_batched_rank_0,rocblas_dzasum_strided_batched_rank_1
#endif

  end interface
  
  interface rocblas_snrm2
    function rocblas_snrm2_orig(handle,incx,myResult) bind(c, name="rocblas_snrm2")
      use iso_c_binding
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocblas_snrm2_orig
      type(c_ptr),value :: handle
      integer(c_int),value :: incx
      type(c_ptr),value :: myResult
    end function


  end interface
  
  interface rocblas_dnrm2
    function rocblas_dnrm2_orig(handle,incx,myResult) bind(c, name="rocblas_dnrm2")
      use iso_c_binding
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocblas_dnrm2_orig
      type(c_ptr),value :: handle
      integer(c_int),value :: incx
      type(c_ptr),value :: myResult
    end function


  end interface
  
  interface rocblas_scnrm2
    function rocblas_scnrm2_orig(handle,n,x,incx,myResult) bind(c, name="rocblas_scnrm2")
      use iso_c_binding
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocblas_scnrm2_orig
      type(c_ptr),value :: handle
      integer(c_int),value :: n
      type(c_ptr),value :: x
      integer(c_int),value :: incx
      type(c_ptr),value :: myResult
    end function

#ifdef USE_FPOINTER_INTERFACES
    module procedure rocblas_scnrm2_rank_0,rocblas_scnrm2_rank_1
#endif

  end interface
  !> ! \brief BLAS Level 1 API
  !> 
  !>     \details
  !>     nrm2 computes the euclidean norm of a real or complex vector
  !> 
  !>               result := sqrt( x'x ) for real vectors
  !>               result := sqrt( xHx ) for complex vectors
  !> 
  !>     @param[in]
  !>     handle    [rocblas_handle]
  !>               handle to the rocblas library context queue.
  !>     @param[in]
  !>     n         [rocblas_int]
  !>               the number of elements in x.
  !>     @param[in]
  !>     x         device pointer storing vector x.
  !>     @param[in]
  !>     incx      [rocblas_int]
  !>               specifies the increment for the elements of y.
  !>     @param[inout]
  !>     result
  !>               device pointer or host pointer to store the nrm2 product.
  !>               return is 0.0 if n, incx<=0.
  !>     
  interface rocblas_dznrm2
    function rocblas_dznrm2_orig(handle,n,x,incx,myResult) bind(c, name="rocblas_dznrm2")
      use iso_c_binding
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocblas_dznrm2_orig
      type(c_ptr),value :: handle
      integer(c_int),value :: n
      type(c_ptr),value :: x
      integer(c_int),value :: incx
      type(c_ptr),value :: myResult
    end function

#ifdef USE_FPOINTER_INTERFACES
    module procedure rocblas_dznrm2_rank_0,rocblas_dznrm2_rank_1
#endif

  end interface
  
  interface rocblas_snrm2_batched
    function rocblas_snrm2_batched_orig(handle,n,x,incx,batch_count,results) bind(c, name="rocblas_snrm2_batched")
      use iso_c_binding
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocblas_snrm2_batched_orig
      type(c_ptr),value :: handle
      integer(c_int),value :: n
      type(c_ptr) :: x
      integer(c_int),value :: incx
      integer(c_int),value :: batch_count
      type(c_ptr),value :: results
    end function

#ifdef USE_FPOINTER_INTERFACES
    module procedure rocblas_snrm2_batched_full_rank,rocblas_snrm2_batched_rank_0,rocblas_snrm2_batched_rank_1
#endif

  end interface
  
  interface rocblas_dnrm2_batched
    function rocblas_dnrm2_batched_orig(handle,n,x,incx,batch_count,results) bind(c, name="rocblas_dnrm2_batched")
      use iso_c_binding
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocblas_dnrm2_batched_orig
      type(c_ptr),value :: handle
      integer(c_int),value :: n
      type(c_ptr) :: x
      integer(c_int),value :: incx
      integer(c_int),value :: batch_count
      type(c_ptr),value :: results
    end function

#ifdef USE_FPOINTER_INTERFACES
    module procedure rocblas_dnrm2_batched_full_rank,rocblas_dnrm2_batched_rank_0,rocblas_dnrm2_batched_rank_1
#endif

  end interface
  
  interface rocblas_scnrm2_batched
    function rocblas_scnrm2_batched_orig(handle,n,x,incx,batch_count,results) bind(c, name="rocblas_scnrm2_batched")
      use iso_c_binding
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocblas_scnrm2_batched_orig
      type(c_ptr),value :: handle
      integer(c_int),value :: n
      type(c_ptr) :: x
      integer(c_int),value :: incx
      integer(c_int),value :: batch_count
      type(c_ptr),value :: results
    end function

#ifdef USE_FPOINTER_INTERFACES
    module procedure rocblas_scnrm2_batched_full_rank,rocblas_scnrm2_batched_rank_0,rocblas_scnrm2_batched_rank_1
#endif

  end interface
  !> ! \brief BLAS Level 1 API
  !> 
  !>     \details
  !>     nrm2_batched computes the euclidean norm over a batch of real or complex vectors
  !> 
  !>               result := sqrt( x_i'x_i ) for real vectors x, for i = 1, ..., batch_count
  !>               result := sqrt( x_iHx_i ) for complex vectors x, for i = 1, ..., batch_count
  !> 
  !>     @param[in]
  !>     handle    [rocblas_handle]
  !>               handle to the rocblas library context queue.
  !>     @param[in]
  !>     n         [rocblas_int]
  !>               number of elements in each x_i.
  !>     @param[in]
  !>     x         device array of device pointers storing each vector x_i.
  !>     @param[in]
  !>     incx      [rocblas_int]
  !>               specifies the increment for the elements of each x_i. incx must be > 0.
  !>     @param[in]
  !>     batch_count [rocblas_int]
  !>               number of instances in the batch
  !>     @param[out]
  !>     results
  !>               device pointer or host pointer to array of batch_count size for nrm2 results.
  !>               return is 0.0 for each element if n <= 0, incx<=0.
  !> 
  !>     
  interface rocblas_dznrm2_batched
    function rocblas_dznrm2_batched_orig(handle,n,x,incx,batch_count,results) bind(c, name="rocblas_dznrm2_batched")
      use iso_c_binding
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocblas_dznrm2_batched_orig
      type(c_ptr),value :: handle
      integer(c_int),value :: n
      type(c_ptr) :: x
      integer(c_int),value :: incx
      integer(c_int),value :: batch_count
      type(c_ptr),value :: results
    end function

#ifdef USE_FPOINTER_INTERFACES
    module procedure rocblas_dznrm2_batched_full_rank,rocblas_dznrm2_batched_rank_0,rocblas_dznrm2_batched_rank_1
#endif

  end interface
  
  interface rocblas_snrm2_strided_batched
    function rocblas_snrm2_strided_batched_orig(handle,n,x,incx,stridex,batch_count,results) bind(c, name="rocblas_snrm2_strided_batched")
      use iso_c_binding
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocblas_snrm2_strided_batched_orig
      type(c_ptr),value :: handle
      integer(c_int),value :: n
      type(c_ptr),value :: x
      integer(c_int),value :: incx
      integer(c_int64_t),value :: stridex
      integer(c_int),value :: batch_count
      type(c_ptr),value :: results
    end function

#ifdef USE_FPOINTER_INTERFACES
    module procedure rocblas_snrm2_strided_batched_rank_0,rocblas_snrm2_strided_batched_rank_1
#endif

  end interface
  
  interface rocblas_dnrm2_strided_batched
    function rocblas_dnrm2_strided_batched_orig(handle,n,x,incx,stridex,batch_count,results) bind(c, name="rocblas_dnrm2_strided_batched")
      use iso_c_binding
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocblas_dnrm2_strided_batched_orig
      type(c_ptr),value :: handle
      integer(c_int),value :: n
      type(c_ptr),value :: x
      integer(c_int),value :: incx
      integer(c_int64_t),value :: stridex
      integer(c_int),value :: batch_count
      type(c_ptr),value :: results
    end function

#ifdef USE_FPOINTER_INTERFACES
    module procedure rocblas_dnrm2_strided_batched_rank_0,rocblas_dnrm2_strided_batched_rank_1
#endif

  end interface
  
  interface rocblas_scnrm2_strided_batched
    function rocblas_scnrm2_strided_batched_orig(handle,n,x,incx,stridex,batch_count,results) bind(c, name="rocblas_scnrm2_strided_batched")
      use iso_c_binding
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocblas_scnrm2_strided_batched_orig
      type(c_ptr),value :: handle
      integer(c_int),value :: n
      type(c_ptr),value :: x
      integer(c_int),value :: incx
      integer(c_int64_t),value :: stridex
      integer(c_int),value :: batch_count
      type(c_ptr),value :: results
    end function

#ifdef USE_FPOINTER_INTERFACES
    module procedure rocblas_scnrm2_strided_batched_rank_0,rocblas_scnrm2_strided_batched_rank_1
#endif

  end interface
  !> ! \brief BLAS Level 1 API
  !> 
  !>     \details
  !>     nrm2_strided_batched computes the euclidean norm over a batch of real or complex vectors
  !> 
  !>               := sqrt( x_i'x_i ) for real vectors x, for i = 1, ..., batch_count
  !>               := sqrt( x_iHx_i ) for complex vectors, for i = 1, ..., batch_count
  !> 
  !>     @param[in]
  !>     handle    [rocblas_handle]
  !>               handle to the rocblas library context queue.
  !>     @param[in]
  !>     n         [rocblas_int]
  !>               number of elements in each x_i.
  !>     @param[in]
  !>     x         device pointer to the first vector x_1.
  !>     @param[in]
  !>     incx      [rocblas_int]
  !>               specifies the increment for the elements of each x_i. incx must be > 0.
  !>     @param[in]
  !>     stridex   [rocblas_stride]
  !>               stride from the start of one vector (x_i) and the next one (x_i+1).
  !>               There are no restrictions placed on stride_x, however the user should
  !>               take care to ensure that stride_x is of appropriate size, for a typical
  !>               case this means stride_x >= n  incx.
  !>     @param[in]
  !>     batch_count [rocblas_int]
  !>               number of instances in the batch
  !>     @param[out]
  !>     results
  !>               device pointer or host pointer to array for storing contiguous batch_count results.
  !>               return is 0.0 for each element if n <= 0, incx<=0.
  !> 
  !>     
  interface rocblas_dznrm2_strided_batched
    function rocblas_dznrm2_strided_batched_orig(handle,n,x,incx,stridex,batch_count,results) bind(c, name="rocblas_dznrm2_strided_batched")
      use iso_c_binding
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocblas_dznrm2_strided_batched_orig
      type(c_ptr),value :: handle
      integer(c_int),value :: n
      type(c_ptr),value :: x
      integer(c_int),value :: incx
      integer(c_int64_t),value :: stridex
      integer(c_int),value :: batch_count
      type(c_ptr),value :: results
    end function

#ifdef USE_FPOINTER_INTERFACES
    module procedure rocblas_dznrm2_strided_batched_rank_0,rocblas_dznrm2_strided_batched_rank_1
#endif

  end interface
  
  interface rocblas_isamax
    function rocblas_isamax_orig(handle,myResult) bind(c, name="rocblas_isamax")
      use iso_c_binding
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocblas_isamax_orig
      type(c_ptr),value :: handle
      type(c_ptr),value :: myResult
    end function


  end interface
  
  interface rocblas_idamax
    function rocblas_idamax_orig(handle,myResult) bind(c, name="rocblas_idamax")
      use iso_c_binding
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocblas_idamax_orig
      type(c_ptr),value :: handle
      type(c_ptr),value :: myResult
    end function


  end interface
  
  interface rocblas_icamax
    function rocblas_icamax_orig(handle,n,x,incx,myResult) bind(c, name="rocblas_icamax")
      use iso_c_binding
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocblas_icamax_orig
      type(c_ptr),value :: handle
      integer(c_int),value :: n
      type(c_ptr),value :: x
      integer(c_int),value :: incx
      type(c_ptr),value :: myResult
    end function

#ifdef USE_FPOINTER_INTERFACES
    module procedure rocblas_icamax_rank_0,rocblas_icamax_rank_1
#endif

  end interface
  !> ! \brief BLAS Level 1 API
  !> 
  !>     \details
  !>     amax finds the first index of the element of maximum magnitude of a vector x.
  !>    vector
  !> 
  !>     @param[in]
  !>     handle    [rocblas_handle]
  !>               handle to the rocblas library context queue.
  !>     @param[in]
  !>     n         [rocblas_int]
  !>               the number of elements in x.
  !>     @param[in]
  !>     x         device pointer storing vector x.
  !>     @param[in]
  !>     incx      [rocblas_int]
  !>               specifies the increment for the elements of y.
  !>     @param[inout]
  !>     result
  !>               device pointer or host pointer to store the amax index.
  !>               return is 0.0 if n, incx<=0.
  !>     
  interface rocblas_izamax
    function rocblas_izamax_orig(handle,n,x,incx,myResult) bind(c, name="rocblas_izamax")
      use iso_c_binding
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocblas_izamax_orig
      type(c_ptr),value :: handle
      integer(c_int),value :: n
      type(c_ptr),value :: x
      integer(c_int),value :: incx
      type(c_ptr),value :: myResult
    end function

#ifdef USE_FPOINTER_INTERFACES
    module procedure rocblas_izamax_rank_0,rocblas_izamax_rank_1
#endif

  end interface
  
  interface rocblas_isamax_batched
    function rocblas_isamax_batched_orig(handle,n,x,incx,batch_count,myResult) bind(c, name="rocblas_isamax_batched")
      use iso_c_binding
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocblas_isamax_batched_orig
      type(c_ptr),value :: handle
      integer(c_int),value :: n
      type(c_ptr) :: x
      integer(c_int),value :: incx
      integer(c_int),value :: batch_count
      type(c_ptr),value :: myResult
    end function

#ifdef USE_FPOINTER_INTERFACES
    module procedure rocblas_isamax_batched_full_rank,rocblas_isamax_batched_rank_0,rocblas_isamax_batched_rank_1
#endif

  end interface
  
  interface rocblas_idamax_batched
    function rocblas_idamax_batched_orig(handle,n,x,incx,batch_count,myResult) bind(c, name="rocblas_idamax_batched")
      use iso_c_binding
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocblas_idamax_batched_orig
      type(c_ptr),value :: handle
      integer(c_int),value :: n
      type(c_ptr) :: x
      integer(c_int),value :: incx
      integer(c_int),value :: batch_count
      type(c_ptr),value :: myResult
    end function

#ifdef USE_FPOINTER_INTERFACES
    module procedure rocblas_idamax_batched_full_rank,rocblas_idamax_batched_rank_0,rocblas_idamax_batched_rank_1
#endif

  end interface
  
  interface rocblas_icamax_batched
    function rocblas_icamax_batched_orig(handle,n,x,incx,batch_count,myResult) bind(c, name="rocblas_icamax_batched")
      use iso_c_binding
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocblas_icamax_batched_orig
      type(c_ptr),value :: handle
      integer(c_int),value :: n
      type(c_ptr) :: x
      integer(c_int),value :: incx
      integer(c_int),value :: batch_count
      type(c_ptr),value :: myResult
    end function

#ifdef USE_FPOINTER_INTERFACES
    module procedure rocblas_icamax_batched_full_rank,rocblas_icamax_batched_rank_0,rocblas_icamax_batched_rank_1
#endif

  end interface
  !> ! \brief BLAS Level 1 API
  !> 
  !>     \details
  !>      amax_batched finds the first index of the element of maximum magnitude of each vector x_i in a batch, for i = 1, ..., batch_count.
  !> 
  !>     @param[in]
  !>     handle    [rocblas_handle]
  !>               handle to the rocblas library context queue.
  !>     @param[in]
  !>     n         [rocblas_int]
  !>               number of elements in each vector x_i
  !>     @param[in]
  !>     x         device array of device pointers storing each vector x_i.
  !>     @param[in]
  !>     incx      [rocblas_int]
  !>               specifies the increment for the elements of each x_i. incx must be > 0.
  !>     @param[in]
  !>     batch_count [rocblas_int]
  !>               number of instances in the batch, must be > 0.
  !>     @param[out]
  !>     result
  !>               device or host array of pointers of batch_count size for results.
  !>               return is 0 if n, incx<=0.
  !>     
  interface rocblas_izamax_batched
    function rocblas_izamax_batched_orig(handle,n,x,incx,batch_count,myResult) bind(c, name="rocblas_izamax_batched")
      use iso_c_binding
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocblas_izamax_batched_orig
      type(c_ptr),value :: handle
      integer(c_int),value :: n
      type(c_ptr) :: x
      integer(c_int),value :: incx
      integer(c_int),value :: batch_count
      type(c_ptr),value :: myResult
    end function

#ifdef USE_FPOINTER_INTERFACES
    module procedure rocblas_izamax_batched_full_rank,rocblas_izamax_batched_rank_0,rocblas_izamax_batched_rank_1
#endif

  end interface
  
  interface rocblas_isamax_strided_batched
    function rocblas_isamax_strided_batched_orig(handle,n,x,incx,stridex,batch_count,myResult) bind(c, name="rocblas_isamax_strided_batched")
      use iso_c_binding
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocblas_isamax_strided_batched_orig
      type(c_ptr),value :: handle
      integer(c_int),value :: n
      type(c_ptr),value :: x
      integer(c_int),value :: incx
      integer(c_int64_t),value :: stridex
      integer(c_int),value :: batch_count
      type(c_ptr),value :: myResult
    end function

#ifdef USE_FPOINTER_INTERFACES
    module procedure rocblas_isamax_strided_batched_rank_0,rocblas_isamax_strided_batched_rank_1
#endif

  end interface
  
  interface rocblas_idamax_strided_batched
    function rocblas_idamax_strided_batched_orig(handle,n,x,incx,stridex,batch_count,myResult) bind(c, name="rocblas_idamax_strided_batched")
      use iso_c_binding
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocblas_idamax_strided_batched_orig
      type(c_ptr),value :: handle
      integer(c_int),value :: n
      type(c_ptr),value :: x
      integer(c_int),value :: incx
      integer(c_int64_t),value :: stridex
      integer(c_int),value :: batch_count
      type(c_ptr),value :: myResult
    end function

#ifdef USE_FPOINTER_INTERFACES
    module procedure rocblas_idamax_strided_batched_rank_0,rocblas_idamax_strided_batched_rank_1
#endif

  end interface
  
  interface rocblas_icamax_strided_batched
    function rocblas_icamax_strided_batched_orig(handle,n,x,incx,stridex,batch_count,myResult) bind(c, name="rocblas_icamax_strided_batched")
      use iso_c_binding
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocblas_icamax_strided_batched_orig
      type(c_ptr),value :: handle
      integer(c_int),value :: n
      type(c_ptr),value :: x
      integer(c_int),value :: incx
      integer(c_int64_t),value :: stridex
      integer(c_int),value :: batch_count
      type(c_ptr),value :: myResult
    end function

#ifdef USE_FPOINTER_INTERFACES
    module procedure rocblas_icamax_strided_batched_rank_0,rocblas_icamax_strided_batched_rank_1
#endif

  end interface
  !> ! \brief BLAS Level 1 API
  !> 
  !>     \details
  !>      amax_strided_batched finds the first index of the element of maximum magnitude of each vector x_i in a batch, for i = 1, ..., batch_count.
  !> 
  !>     @param[in]
  !>     handle    [rocblas_handle]
  !>               handle to the rocblas library context queue.
  !>     @param[in]
  !>     n         [rocblas_int]
  !>               number of elements in each vector x_i
  !>     @param[in]
  !>     x         device pointer to the first vector x_1.
  !>     @param[in]
  !>     incx      [rocblas_int]
  !>               specifies the increment for the elements of each x_i. incx must be > 0.
  !>     @param[in]
  !>     stridex   [rocblas_stride]
  !>               specifies the pointer increment between one x_i and the next x_(i + 1).
  !>     @param[in]
  !>     batch_count [rocblas_int]
  !>               number of instances in the batch
  !>     @param[out]
  !>     result
  !>               device or host pointer for storing contiguous batch_count results.
  !>               return is 0 if n <= 0, incx<=0.
  !> 
  !>     
  interface rocblas_izamax_strided_batched
    function rocblas_izamax_strided_batched_orig(handle,n,x,incx,stridex,batch_count,myResult) bind(c, name="rocblas_izamax_strided_batched")
      use iso_c_binding
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocblas_izamax_strided_batched_orig
      type(c_ptr),value :: handle
      integer(c_int),value :: n
      type(c_ptr),value :: x
      integer(c_int),value :: incx
      integer(c_int64_t),value :: stridex
      integer(c_int),value :: batch_count
      type(c_ptr),value :: myResult
    end function

#ifdef USE_FPOINTER_INTERFACES
    module procedure rocblas_izamax_strided_batched_rank_0,rocblas_izamax_strided_batched_rank_1
#endif

  end interface
  
  interface rocblas_isamin
    function rocblas_isamin_orig(handle,myResult) bind(c, name="rocblas_isamin")
      use iso_c_binding
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocblas_isamin_orig
      type(c_ptr),value :: handle
      type(c_ptr),value :: myResult
    end function


  end interface
  
  interface rocblas_idamin
    function rocblas_idamin_orig(handle,myResult) bind(c, name="rocblas_idamin")
      use iso_c_binding
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocblas_idamin_orig
      type(c_ptr),value :: handle
      type(c_ptr),value :: myResult
    end function


  end interface
  
  interface rocblas_icamin
    function rocblas_icamin_orig(handle,n,x,incx,myResult) bind(c, name="rocblas_icamin")
      use iso_c_binding
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocblas_icamin_orig
      type(c_ptr),value :: handle
      integer(c_int),value :: n
      type(c_ptr),value :: x
      integer(c_int),value :: incx
      type(c_ptr),value :: myResult
    end function

#ifdef USE_FPOINTER_INTERFACES
    module procedure rocblas_icamin_rank_0,rocblas_icamin_rank_1
#endif

  end interface
  !> ! \brief BLAS Level 1 API
  !> 
  !>     \details
  !>     amin finds the first index of the element of minimum magnitude of a vector x.
  !> 
  !>    vector
  !> 
  !>     @param[in]
  !>     handle    [rocblas_handle]
  !>               handle to the rocblas library context queue.
  !>     @param[in]
  !>     n         [rocblas_int]
  !>               the number of elements in x.
  !>     @param[in]
  !>     x         device pointer storing vector x.
  !>     @param[in]
  !>     incx      [rocblas_int]
  !>               specifies the increment for the elements of y.
  !>     @param[inout]
  !>     result
  !>               device pointer or host pointer to store the amin index.
  !>               return is 0.0 if n, incx<=0.
  !>     
  interface rocblas_izamin
    function rocblas_izamin_orig(handle,n,x,incx,myResult) bind(c, name="rocblas_izamin")
      use iso_c_binding
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocblas_izamin_orig
      type(c_ptr),value :: handle
      integer(c_int),value :: n
      type(c_ptr),value :: x
      integer(c_int),value :: incx
      type(c_ptr),value :: myResult
    end function

#ifdef USE_FPOINTER_INTERFACES
    module procedure rocblas_izamin_rank_0,rocblas_izamin_rank_1
#endif

  end interface
  
  interface rocblas_isamin_batched
    function rocblas_isamin_batched_orig(handle,n,x,incx,batch_count,myResult) bind(c, name="rocblas_isamin_batched")
      use iso_c_binding
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocblas_isamin_batched_orig
      type(c_ptr),value :: handle
      integer(c_int),value :: n
      type(c_ptr) :: x
      integer(c_int),value :: incx
      integer(c_int),value :: batch_count
      type(c_ptr),value :: myResult
    end function

#ifdef USE_FPOINTER_INTERFACES
    module procedure rocblas_isamin_batched_full_rank,rocblas_isamin_batched_rank_0,rocblas_isamin_batched_rank_1
#endif

  end interface
  
  interface rocblas_idamin_batched
    function rocblas_idamin_batched_orig(handle,n,x,incx,batch_count,myResult) bind(c, name="rocblas_idamin_batched")
      use iso_c_binding
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocblas_idamin_batched_orig
      type(c_ptr),value :: handle
      integer(c_int),value :: n
      type(c_ptr) :: x
      integer(c_int),value :: incx
      integer(c_int),value :: batch_count
      type(c_ptr),value :: myResult
    end function

#ifdef USE_FPOINTER_INTERFACES
    module procedure rocblas_idamin_batched_full_rank,rocblas_idamin_batched_rank_0,rocblas_idamin_batched_rank_1
#endif

  end interface
  
  interface rocblas_icamin_batched
    function rocblas_icamin_batched_orig(handle,n,x,incx,batch_count,myResult) bind(c, name="rocblas_icamin_batched")
      use iso_c_binding
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocblas_icamin_batched_orig
      type(c_ptr),value :: handle
      integer(c_int),value :: n
      type(c_ptr) :: x
      integer(c_int),value :: incx
      integer(c_int),value :: batch_count
      type(c_ptr),value :: myResult
    end function

#ifdef USE_FPOINTER_INTERFACES
    module procedure rocblas_icamin_batched_full_rank,rocblas_icamin_batched_rank_0,rocblas_icamin_batched_rank_1
#endif

  end interface
  !> ! \brief BLAS Level 1 API
  !> 
  !>     \details
  !>     amin_batched finds the first index of the element of minimum magnitude of each vector x_i in a batch, for i = 1, ..., batch_count.
  !> 
  !>     @param[in]
  !>     handle    [rocblas_handle]
  !>               handle to the rocblas library context queue.
  !>     @param[in]
  !>     n         [rocblas_int]
  !>               number of elements in each vector x_i
  !>     @param[in]
  !>     x         device array of device pointers storing each vector x_i.
  !>     @param[in]
  !>     incx      [rocblas_int]
  !>               specifies the increment for the elements of each x_i. incx must be > 0.
  !>     @param[in]
  !>     batch_count [rocblas_int]
  !>               number of instances in the batch, must be > 0.
  !>     @param[out]
  !>     result
  !>               device or host pointers to array of batch_count size for results.
  !>               return is 0 if n, incx<=0.
  !>     
  interface rocblas_izamin_batched
    function rocblas_izamin_batched_orig(handle,n,x,incx,batch_count,myResult) bind(c, name="rocblas_izamin_batched")
      use iso_c_binding
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocblas_izamin_batched_orig
      type(c_ptr),value :: handle
      integer(c_int),value :: n
      type(c_ptr) :: x
      integer(c_int),value :: incx
      integer(c_int),value :: batch_count
      type(c_ptr),value :: myResult
    end function

#ifdef USE_FPOINTER_INTERFACES
    module procedure rocblas_izamin_batched_full_rank,rocblas_izamin_batched_rank_0,rocblas_izamin_batched_rank_1
#endif

  end interface
  
  interface rocblas_isamin_strided_batched
    function rocblas_isamin_strided_batched_orig(handle,n,x,incx,stridex,batch_count,myResult) bind(c, name="rocblas_isamin_strided_batched")
      use iso_c_binding
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocblas_isamin_strided_batched_orig
      type(c_ptr),value :: handle
      integer(c_int),value :: n
      type(c_ptr),value :: x
      integer(c_int),value :: incx
      integer(c_int64_t),value :: stridex
      integer(c_int),value :: batch_count
      type(c_ptr),value :: myResult
    end function

#ifdef USE_FPOINTER_INTERFACES
    module procedure rocblas_isamin_strided_batched_rank_0,rocblas_isamin_strided_batched_rank_1
#endif

  end interface
  
  interface rocblas_idamin_strided_batched
    function rocblas_idamin_strided_batched_orig(handle,n,x,incx,stridex,batch_count,myResult) bind(c, name="rocblas_idamin_strided_batched")
      use iso_c_binding
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocblas_idamin_strided_batched_orig
      type(c_ptr),value :: handle
      integer(c_int),value :: n
      type(c_ptr),value :: x
      integer(c_int),value :: incx
      integer(c_int64_t),value :: stridex
      integer(c_int),value :: batch_count
      type(c_ptr),value :: myResult
    end function

#ifdef USE_FPOINTER_INTERFACES
    module procedure rocblas_idamin_strided_batched_rank_0,rocblas_idamin_strided_batched_rank_1
#endif

  end interface
  
  interface rocblas_icamin_strided_batched
    function rocblas_icamin_strided_batched_orig(handle,n,x,incx,stridex,batch_count,myResult) bind(c, name="rocblas_icamin_strided_batched")
      use iso_c_binding
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocblas_icamin_strided_batched_orig
      type(c_ptr),value :: handle
      integer(c_int),value :: n
      type(c_ptr),value :: x
      integer(c_int),value :: incx
      integer(c_int64_t),value :: stridex
      integer(c_int),value :: batch_count
      type(c_ptr),value :: myResult
    end function

#ifdef USE_FPOINTER_INTERFACES
    module procedure rocblas_icamin_strided_batched_rank_0,rocblas_icamin_strided_batched_rank_1
#endif

  end interface
  !> ! \brief BLAS Level 1 API
  !> 
  !>     \details
  !>      amin_strided_batched finds the first index of the element of minimum magnitude of each vector x_i in a batch, for i = 1, ..., batch_count.
  !> 
  !>     @param[in]
  !>     handle    [rocblas_handle]
  !>               handle to the rocblas library context queue.
  !>     @param[in]
  !>     n         [rocblas_int]
  !>               number of elements in each vector x_i
  !>     @param[in]
  !>     x         device pointer to the first vector x_1.
  !>     @param[in]
  !>     incx      [rocblas_int]
  !>               specifies the increment for the elements of each x_i. incx must be > 0.
  !>     @param[in]
  !>     stridex   [rocblas_stride]
  !>               specifies the pointer increment between one x_i and the next x_(i + 1)
  !>     @param[in]
  !>     batch_count [rocblas_int]
  !>               number of instances in the batch
  !>     @param[out]
  !>     result
  !>               device or host pointer to array for storing contiguous batch_count results.
  !>               return is 0 if n <= 0, incx<=0.
  !> 
  !>     
  interface rocblas_izamin_strided_batched
    function rocblas_izamin_strided_batched_orig(handle,n,x,incx,stridex,batch_count,myResult) bind(c, name="rocblas_izamin_strided_batched")
      use iso_c_binding
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocblas_izamin_strided_batched_orig
      type(c_ptr),value :: handle
      integer(c_int),value :: n
      type(c_ptr),value :: x
      integer(c_int),value :: incx
      integer(c_int64_t),value :: stridex
      integer(c_int),value :: batch_count
      type(c_ptr),value :: myResult
    end function

#ifdef USE_FPOINTER_INTERFACES
    module procedure rocblas_izamin_strided_batched_rank_0,rocblas_izamin_strided_batched_rank_1
#endif

  end interface
  
  interface rocblas_srot
    function rocblas_srot_orig(handle,n,x,incx,y,incy,c,s) bind(c, name="rocblas_srot")
      use iso_c_binding
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocblas_srot_orig
      type(c_ptr),value :: handle
      integer(c_int),value :: n
      type(c_ptr),value :: x
      integer(c_int),value :: incx
      type(c_ptr),value :: y
      integer(c_int),value :: incy
      type(c_ptr),value :: c
      type(c_ptr),value :: s
    end function

#ifdef USE_FPOINTER_INTERFACES
    module procedure rocblas_srot_rank_0,rocblas_srot_rank_1
#endif

  end interface
  
  interface rocblas_drot
    function rocblas_drot_orig(handle,n,x,incx,y,incy,c,s) bind(c, name="rocblas_drot")
      use iso_c_binding
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocblas_drot_orig
      type(c_ptr),value :: handle
      integer(c_int),value :: n
      type(c_ptr),value :: x
      integer(c_int),value :: incx
      type(c_ptr),value :: y
      integer(c_int),value :: incy
      type(c_ptr),value :: c
      type(c_ptr),value :: s
    end function

#ifdef USE_FPOINTER_INTERFACES
    module procedure rocblas_drot_rank_0,rocblas_drot_rank_1
#endif

  end interface
  
  interface rocblas_crot
    function rocblas_crot_orig(handle,n,x,incx,y,incy,c,s) bind(c, name="rocblas_crot")
      use iso_c_binding
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocblas_crot_orig
      type(c_ptr),value :: handle
      integer(c_int),value :: n
      type(c_ptr),value :: x
      integer(c_int),value :: incx
      type(c_ptr),value :: y
      integer(c_int),value :: incy
      type(c_ptr),value :: c
      type(c_ptr),value :: s
    end function

#ifdef USE_FPOINTER_INTERFACES
    module procedure rocblas_crot_rank_0,rocblas_crot_rank_1
#endif

  end interface
  
  interface rocblas_csrot
    function rocblas_csrot_orig(handle,n,x,incx,y,incy,c,s) bind(c, name="rocblas_csrot")
      use iso_c_binding
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocblas_csrot_orig
      type(c_ptr),value :: handle
      integer(c_int),value :: n
      type(c_ptr),value :: x
      integer(c_int),value :: incx
      type(c_ptr),value :: y
      integer(c_int),value :: incy
      type(c_ptr),value :: c
      type(c_ptr),value :: s
    end function

#ifdef USE_FPOINTER_INTERFACES
    module procedure rocblas_csrot_rank_0,rocblas_csrot_rank_1
#endif

  end interface
  
  interface rocblas_zrot
    function rocblas_zrot_orig(handle,n,x,incx,y,incy,c,s) bind(c, name="rocblas_zrot")
      use iso_c_binding
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocblas_zrot_orig
      type(c_ptr),value :: handle
      integer(c_int),value :: n
      type(c_ptr),value :: x
      integer(c_int),value :: incx
      type(c_ptr),value :: y
      integer(c_int),value :: incy
      type(c_ptr),value :: c
      type(c_ptr),value :: s
    end function

#ifdef USE_FPOINTER_INTERFACES
    module procedure rocblas_zrot_rank_0,rocblas_zrot_rank_1
#endif

  end interface
  !> ! \brief BLAS Level 1 API
  !> 
  !>     \details
  !>     rot applies the Givens rotation matrix defined by c=cos(alpha) and s=sin(alpha) to vectors x and y.
  !>         Scalars c and s may be stored in either host or device memory, location is specified by calling rocblas_set_pointer_mode.
  !> 
  !>     @param[in]
  !>     handle  [rocblas_handle]
  !>             handle to the rocblas library context queue.
  !>     @param[in]
  !>     n       [rocblas_int]
  !>             number of elements in the x and y vectors.
  !>     @param[inout]
  !>     x       device pointer storing vector x.
  !>     @param[in]
  !>     incx    [rocblas_int]
  !>             specifies the increment between elements of x.
  !>     @param[inout]
  !>     y       device pointer storing vector y.
  !>     @param[in]
  !>     incy    [rocblas_int]
  !>             specifies the increment between elements of y.
  !>     @param[in]
  !>     c       device pointer or host pointer storing scalar cosine component of the rotation matrix.
  !>     @param[in]
  !>     s       device pointer or host pointer storing scalar sine component of the rotation matrix.
  !> 
  !>     
  interface rocblas_zdrot
    function rocblas_zdrot_orig(handle,n,x,incx,y,incy,c,s) bind(c, name="rocblas_zdrot")
      use iso_c_binding
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocblas_zdrot_orig
      type(c_ptr),value :: handle
      integer(c_int),value :: n
      type(c_ptr),value :: x
      integer(c_int),value :: incx
      type(c_ptr),value :: y
      integer(c_int),value :: incy
      type(c_ptr),value :: c
      type(c_ptr),value :: s
    end function

#ifdef USE_FPOINTER_INTERFACES
    module procedure rocblas_zdrot_rank_0,rocblas_zdrot_rank_1
#endif

  end interface
  
  interface rocblas_srot_batched
    function rocblas_srot_batched_orig(handle,n,x,incx,y,incy,c,s,batch_count) bind(c, name="rocblas_srot_batched")
      use iso_c_binding
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocblas_srot_batched_orig
      type(c_ptr),value :: handle
      integer(c_int),value :: n
      type(c_ptr) :: x
      integer(c_int),value :: incx
      type(c_ptr) :: y
      integer(c_int),value :: incy
      type(c_ptr),value :: c
      type(c_ptr),value :: s
      integer(c_int),value :: batch_count
    end function

#ifdef USE_FPOINTER_INTERFACES
    module procedure rocblas_srot_batched_full_rank,rocblas_srot_batched_rank_0,rocblas_srot_batched_rank_1
#endif

  end interface
  
  interface rocblas_drot_batched
    function rocblas_drot_batched_orig(handle,n,x,incx,y,incy,c,s,batch_count) bind(c, name="rocblas_drot_batched")
      use iso_c_binding
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocblas_drot_batched_orig
      type(c_ptr),value :: handle
      integer(c_int),value :: n
      type(c_ptr) :: x
      integer(c_int),value :: incx
      type(c_ptr) :: y
      integer(c_int),value :: incy
      type(c_ptr),value :: c
      type(c_ptr),value :: s
      integer(c_int),value :: batch_count
    end function

#ifdef USE_FPOINTER_INTERFACES
    module procedure rocblas_drot_batched_full_rank,rocblas_drot_batched_rank_0,rocblas_drot_batched_rank_1
#endif

  end interface
  
  interface rocblas_crot_batched
    function rocblas_crot_batched_orig(handle,n,x,incx,y,incy,c,s,batch_count) bind(c, name="rocblas_crot_batched")
      use iso_c_binding
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocblas_crot_batched_orig
      type(c_ptr),value :: handle
      integer(c_int),value :: n
      type(c_ptr) :: x
      integer(c_int),value :: incx
      type(c_ptr) :: y
      integer(c_int),value :: incy
      type(c_ptr),value :: c
      type(c_ptr),value :: s
      integer(c_int),value :: batch_count
    end function

#ifdef USE_FPOINTER_INTERFACES
    module procedure rocblas_crot_batched_full_rank,rocblas_crot_batched_rank_0,rocblas_crot_batched_rank_1
#endif

  end interface
  
  interface rocblas_csrot_batched
    function rocblas_csrot_batched_orig(handle,n,x,incx,y,incy,c,s,batch_count) bind(c, name="rocblas_csrot_batched")
      use iso_c_binding
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocblas_csrot_batched_orig
      type(c_ptr),value :: handle
      integer(c_int),value :: n
      type(c_ptr) :: x
      integer(c_int),value :: incx
      type(c_ptr) :: y
      integer(c_int),value :: incy
      type(c_ptr),value :: c
      type(c_ptr),value :: s
      integer(c_int),value :: batch_count
    end function

#ifdef USE_FPOINTER_INTERFACES
    module procedure rocblas_csrot_batched_full_rank,rocblas_csrot_batched_rank_0,rocblas_csrot_batched_rank_1
#endif

  end interface
  
  interface rocblas_zrot_batched
    function rocblas_zrot_batched_orig(handle,n,x,incx,y,incy,c,s,batch_count) bind(c, name="rocblas_zrot_batched")
      use iso_c_binding
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocblas_zrot_batched_orig
      type(c_ptr),value :: handle
      integer(c_int),value :: n
      type(c_ptr) :: x
      integer(c_int),value :: incx
      type(c_ptr) :: y
      integer(c_int),value :: incy
      type(c_ptr),value :: c
      type(c_ptr),value :: s
      integer(c_int),value :: batch_count
    end function

#ifdef USE_FPOINTER_INTERFACES
    module procedure rocblas_zrot_batched_full_rank,rocblas_zrot_batched_rank_0,rocblas_zrot_batched_rank_1
#endif

  end interface
  !> ! \brief BLAS Level 1 API
  !> 
  !>     \details
  !>     rot_batched applies the Givens rotation matrix defined by c=cos(alpha) and s=sin(alpha) to batched vectors x_i and y_i, for i = 1, ..., batch_count.
  !>         Scalars c and s may be stored in either host or device memory, location is specified by calling rocblas_set_pointer_mode.
  !> 
  !>     @param[in]
  !>     handle  [rocblas_handle]
  !>             handle to the rocblas library context queue.
  !>     @param[in]
  !>     n       [rocblas_int]
  !>             number of elements in each x_i and y_i vectors.
  !>     @param[inout]
  !>     x       device array of deivce pointers storing each vector x_i.
  !>     @param[in]
  !>     incx    [rocblas_int]
  !>             specifies the increment between elements of each x_i.
  !>     @param[inout]
  !>     y       device array of device pointers storing each vector y_i.
  !>     @param[in]
  !>     incy    [rocblas_int]
  !>             specifies the increment between elements of each y_i.
  !>     @param[in]
  !>     c       device pointer or host pointer to scalar cosine component of the rotation matrix.
  !>     @param[in]
  !>     s       device pointer or host pointer to scalar sine component of the rotation matrix.
  !>     @param[in]
  !>     batch_count [rocblas_int]
  !>                 the number of x and y arrays, i.e. the number of batches.
  !> 
  !>     
  interface rocblas_zdrot_batched
    function rocblas_zdrot_batched_orig(handle,n,x,incx,y,incy,c,s,batch_count) bind(c, name="rocblas_zdrot_batched")
      use iso_c_binding
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocblas_zdrot_batched_orig
      type(c_ptr),value :: handle
      integer(c_int),value :: n
      type(c_ptr) :: x
      integer(c_int),value :: incx
      type(c_ptr) :: y
      integer(c_int),value :: incy
      type(c_ptr),value :: c
      type(c_ptr),value :: s
      integer(c_int),value :: batch_count
    end function

#ifdef USE_FPOINTER_INTERFACES
    module procedure rocblas_zdrot_batched_full_rank,rocblas_zdrot_batched_rank_0,rocblas_zdrot_batched_rank_1
#endif

  end interface
  
  interface rocblas_srot_strided_batched
    function rocblas_srot_strided_batched_orig(handle,n,x,incx,stride_x,y,incy,stride_y,c,s,batch_count) bind(c, name="rocblas_srot_strided_batched")
      use iso_c_binding
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocblas_srot_strided_batched_orig
      type(c_ptr),value :: handle
      integer(c_int),value :: n
      type(c_ptr),value :: x
      integer(c_int),value :: incx
      integer(c_int64_t),value :: stride_x
      type(c_ptr),value :: y
      integer(c_int),value :: incy
      integer(c_int64_t),value :: stride_y
      type(c_ptr),value :: c
      type(c_ptr),value :: s
      integer(c_int),value :: batch_count
    end function

#ifdef USE_FPOINTER_INTERFACES
    module procedure rocblas_srot_strided_batched_rank_0,rocblas_srot_strided_batched_rank_1
#endif

  end interface
  
  interface rocblas_drot_strided_batched
    function rocblas_drot_strided_batched_orig(handle,n,x,incx,stride_x,y,incy,stride_y,c,s,batch_count) bind(c, name="rocblas_drot_strided_batched")
      use iso_c_binding
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocblas_drot_strided_batched_orig
      type(c_ptr),value :: handle
      integer(c_int),value :: n
      type(c_ptr),value :: x
      integer(c_int),value :: incx
      integer(c_int64_t),value :: stride_x
      type(c_ptr),value :: y
      integer(c_int),value :: incy
      integer(c_int64_t),value :: stride_y
      type(c_ptr),value :: c
      type(c_ptr),value :: s
      integer(c_int),value :: batch_count
    end function

#ifdef USE_FPOINTER_INTERFACES
    module procedure rocblas_drot_strided_batched_rank_0,rocblas_drot_strided_batched_rank_1
#endif

  end interface
  
  interface rocblas_crot_strided_batched
    function rocblas_crot_strided_batched_orig(handle,n,x,incx,stride_x,y,incy,stride_y,c,s,batch_count) bind(c, name="rocblas_crot_strided_batched")
      use iso_c_binding
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocblas_crot_strided_batched_orig
      type(c_ptr),value :: handle
      integer(c_int),value :: n
      type(c_ptr),value :: x
      integer(c_int),value :: incx
      integer(c_int64_t),value :: stride_x
      type(c_ptr),value :: y
      integer(c_int),value :: incy
      integer(c_int64_t),value :: stride_y
      type(c_ptr),value :: c
      type(c_ptr),value :: s
      integer(c_int),value :: batch_count
    end function

#ifdef USE_FPOINTER_INTERFACES
    module procedure rocblas_crot_strided_batched_rank_0,rocblas_crot_strided_batched_rank_1
#endif

  end interface
  
  interface rocblas_csrot_strided_batched
    function rocblas_csrot_strided_batched_orig(handle,n,x,incx,stride_x,y,incy,stride_y,c,s,batch_count) bind(c, name="rocblas_csrot_strided_batched")
      use iso_c_binding
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocblas_csrot_strided_batched_orig
      type(c_ptr),value :: handle
      integer(c_int),value :: n
      type(c_ptr),value :: x
      integer(c_int),value :: incx
      integer(c_int64_t),value :: stride_x
      type(c_ptr),value :: y
      integer(c_int),value :: incy
      integer(c_int64_t),value :: stride_y
      type(c_ptr),value :: c
      type(c_ptr),value :: s
      integer(c_int),value :: batch_count
    end function

#ifdef USE_FPOINTER_INTERFACES
    module procedure rocblas_csrot_strided_batched_rank_0,rocblas_csrot_strided_batched_rank_1
#endif

  end interface
  
  interface rocblas_zrot_strided_batched
    function rocblas_zrot_strided_batched_orig(handle,n,x,incx,stride_x,y,incy,stride_y,c,s,batch_count) bind(c, name="rocblas_zrot_strided_batched")
      use iso_c_binding
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocblas_zrot_strided_batched_orig
      type(c_ptr),value :: handle
      integer(c_int),value :: n
      type(c_ptr),value :: x
      integer(c_int),value :: incx
      integer(c_int64_t),value :: stride_x
      type(c_ptr),value :: y
      integer(c_int),value :: incy
      integer(c_int64_t),value :: stride_y
      type(c_ptr),value :: c
      type(c_ptr),value :: s
      integer(c_int),value :: batch_count
    end function

#ifdef USE_FPOINTER_INTERFACES
    module procedure rocblas_zrot_strided_batched_rank_0,rocblas_zrot_strided_batched_rank_1
#endif

  end interface
  !> ! \brief BLAS Level 1 API
  !> 
  !>     \details
  !>     rot_strided_batched applies the Givens rotation matrix defined by c=cos(alpha) and s=sin(alpha) to strided batched vectors x_i and y_i, for i = 1, ..., batch_count.
  !>         Scalars c and s may be stored in either host or device memory, location is specified by calling rocblas_set_pointer_mode.
  !> 
  !>     @param[in]
  !>     handle  [rocblas_handle]
  !>             handle to the rocblas library context queue.
  !>     @param[in]
  !>     n       [rocblas_int]
  !>             number of elements in each x_i and y_i vectors.
  !>     @param[inout]
  !>     x       device pointer to the first vector x_1.
  !>     @param[in]
  !>     incx    [rocblas_int]
  !>             specifies the increment between elements of each x_i.
  !>     @param[in]
  !>     stride_x [rocblas_stride]
  !>              specifies the increment from the beginning of x_i to the beginning of x_(i+1)
  !>     @param[inout]
  !>     y       device pointer to the first vector y_1.
  !>     @param[in]
  !>     incy    [rocblas_int]
  !>             specifies the increment between elements of each y_i.
  !>     @param[in]
  !>     stride_y [rocblas_stride]
  !>              specifies the increment from the beginning of y_i to the beginning of y_(i+1)
  !>     @param[in]
  !>     c       device pointer or host pointer to scalar cosine component of the rotation matrix.
  !>     @param[in]
  !>     s       device pointer or host pointer to scalar sine component of the rotation matrix.
  !>     @param[in]
  !>     batch_count [rocblas_int]
  !>             the number of x and y arrays, i.e. the number of batches.
  !> 
  !>     
  interface rocblas_zdrot_strided_batched
    function rocblas_zdrot_strided_batched_orig(handle,n,x,incx,stride_x,y,incy,stride_y,c,s,batch_count) bind(c, name="rocblas_zdrot_strided_batched")
      use iso_c_binding
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocblas_zdrot_strided_batched_orig
      type(c_ptr),value :: handle
      integer(c_int),value :: n
      type(c_ptr),value :: x
      integer(c_int),value :: incx
      integer(c_int64_t),value :: stride_x
      type(c_ptr),value :: y
      integer(c_int),value :: incy
      integer(c_int64_t),value :: stride_y
      type(c_ptr),value :: c
      type(c_ptr),value :: s
      integer(c_int),value :: batch_count
    end function

#ifdef USE_FPOINTER_INTERFACES
    module procedure rocblas_zdrot_strided_batched_rank_0,rocblas_zdrot_strided_batched_rank_1
#endif

  end interface
  
  interface rocblas_srotg
    function rocblas_srotg_orig(handle,a,b,c,s) bind(c, name="rocblas_srotg")
      use iso_c_binding
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocblas_srotg_orig
      type(c_ptr),value :: handle
      type(c_ptr),value :: a
      type(c_ptr),value :: b
      type(c_ptr),value :: c
      type(c_ptr),value :: s
    end function


  end interface
  
  interface rocblas_drotg
    function rocblas_drotg_orig(handle,a,b,c,s) bind(c, name="rocblas_drotg")
      use iso_c_binding
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocblas_drotg_orig
      type(c_ptr),value :: handle
      type(c_ptr),value :: a
      type(c_ptr),value :: b
      type(c_ptr),value :: c
      type(c_ptr),value :: s
    end function


  end interface
  
  interface rocblas_crotg
    function rocblas_crotg_orig(handle,a,b,c,s) bind(c, name="rocblas_crotg")
      use iso_c_binding
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocblas_crotg_orig
      type(c_ptr),value :: handle
      type(c_ptr),value :: a
      type(c_ptr),value :: b
      type(c_ptr),value :: c
      type(c_ptr),value :: s
    end function


  end interface
  !> ! \brief BLAS Level 1 API
  !> 
  !>     \details
  !>     rotg creates the Givens rotation matrix for the vector (a b).
  !>          Scalars c and s and arrays a and b may be stored in either host or device memory, location is specified by calling rocblas_set_pointer_mode.
  !>          If the pointer mode is set to rocblas_pointer_mode_host, this function blocks the CPU until the GPU has finished and the results are available in host memory.
  !>          If the pointer mode is set to rocblas_pointer_mode_device, this function returns immediately and synchronization is required to read the results.
  !> 
  !>     @param[in]
  !>     handle  [rocblas_handle]
  !>             handle to the rocblas library context queue.
  !>     @param[inout]
  !>     a       device pointer or host pointer to input vector element, overwritten with r.
  !>     @param[inout]
  !>     b       device pointer or host pointer to input vector element, overwritten with z.
  !>     @param[inout]
  !>     c       device pointer or host pointer to cosine element of Givens rotation.
  !>     @param[inout]
  !>     s       device pointer or host pointer sine element of Givens rotation.
  !> 
  !>     
  interface rocblas_zrotg
    function rocblas_zrotg_orig(handle,a,b,c,s) bind(c, name="rocblas_zrotg")
      use iso_c_binding
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocblas_zrotg_orig
      type(c_ptr),value :: handle
      type(c_ptr),value :: a
      type(c_ptr),value :: b
      type(c_ptr),value :: c
      type(c_ptr),value :: s
    end function


  end interface
  
  interface rocblas_srotg_batched
    function rocblas_srotg_batched_orig(handle,a,b,c,s,batch_count) bind(c, name="rocblas_srotg_batched")
      use iso_c_binding
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocblas_srotg_batched_orig
      type(c_ptr),value :: handle
      type(c_ptr) :: a
      type(c_ptr) :: b
      type(c_ptr) :: c
      type(c_ptr) :: s
      integer(c_int),value :: batch_count
    end function


  end interface
  
  interface rocblas_drotg_batched
    function rocblas_drotg_batched_orig(handle,a,b,c,s,batch_count) bind(c, name="rocblas_drotg_batched")
      use iso_c_binding
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocblas_drotg_batched_orig
      type(c_ptr),value :: handle
      type(c_ptr) :: a
      type(c_ptr) :: b
      type(c_ptr) :: c
      type(c_ptr) :: s
      integer(c_int),value :: batch_count
    end function


  end interface
  
  interface rocblas_crotg_batched
    function rocblas_crotg_batched_orig(handle,a,b,c,s,batch_count) bind(c, name="rocblas_crotg_batched")
      use iso_c_binding
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocblas_crotg_batched_orig
      type(c_ptr),value :: handle
      type(c_ptr) :: a
      type(c_ptr) :: b
      type(c_ptr) :: c
      type(c_ptr) :: s
      integer(c_int),value :: batch_count
    end function


  end interface
  !> ! \brief BLAS Level 1 API
  !> 
  !>     \details
  !>     rotg_batched creates the Givens rotation matrix for the batched vectors (a_i b_i), for i = 1, ..., batch_count.
  !>          a, b, c, and s may be stored in either host or device memory, location is specified by calling rocblas_set_pointer_mode.
  !>          If the pointer mode is set to rocblas_pointer_mode_host, this function blocks the CPU until the GPU has finished and the results are available in host memory.
  !>          If the pointer mode is set to rocblas_pointer_mode_device, this function returns immediately and synchronization is required to read the results.
  !> 
  !>     @param[in]
  !>     handle  [rocblas_handle]
  !>             handle to the rocblas library context queue.
  !>     @param[inout]
  !>     a       device array of device pointers storing each single input vector element a_i, overwritten with r_i.
  !>     @param[inout]
  !>     b       device array of device pointers storing each single input vector element b_i, overwritten with z_i.
  !>     @param[inout]
  !>     c       device array of device pointers storing each cosine element of Givens rotation for the batch.
  !>     @param[inout]
  !>     s       device array of device pointers storing each sine element of Givens rotation for the batch.
  !>     @param[in]
  !>     batch_count [rocblas_int]
  !>                 number of batches (length of arrays a, b, c, and s).
  !> 
  !>     
  interface rocblas_zrotg_batched
    function rocblas_zrotg_batched_orig(handle,a,b,c,s,batch_count) bind(c, name="rocblas_zrotg_batched")
      use iso_c_binding
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocblas_zrotg_batched_orig
      type(c_ptr),value :: handle
      type(c_ptr) :: a
      type(c_ptr) :: b
      type(c_ptr) :: c
      type(c_ptr) :: s
      integer(c_int),value :: batch_count
    end function


  end interface
  
  interface rocblas_srotg_strided_batched
    function rocblas_srotg_strided_batched_orig(handle,a,stride_a,b,stride_b,c,stride_c,s,stride_s,batch_count) bind(c, name="rocblas_srotg_strided_batched")
      use iso_c_binding
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocblas_srotg_strided_batched_orig
      type(c_ptr),value :: handle
      type(c_ptr),value :: a
      integer(c_int64_t),value :: stride_a
      type(c_ptr),value :: b
      integer(c_int64_t),value :: stride_b
      type(c_ptr),value :: c
      integer(c_int64_t),value :: stride_c
      type(c_ptr),value :: s
      integer(c_int64_t),value :: stride_s
      integer(c_int),value :: batch_count
    end function


  end interface
  
  interface rocblas_drotg_strided_batched
    function rocblas_drotg_strided_batched_orig(handle,a,stride_a,b,stride_b,c,stride_c,s,stride_s,batch_count) bind(c, name="rocblas_drotg_strided_batched")
      use iso_c_binding
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocblas_drotg_strided_batched_orig
      type(c_ptr),value :: handle
      type(c_ptr),value :: a
      integer(c_int64_t),value :: stride_a
      type(c_ptr),value :: b
      integer(c_int64_t),value :: stride_b
      type(c_ptr),value :: c
      integer(c_int64_t),value :: stride_c
      type(c_ptr),value :: s
      integer(c_int64_t),value :: stride_s
      integer(c_int),value :: batch_count
    end function


  end interface
  
  interface rocblas_crotg_strided_batched
    function rocblas_crotg_strided_batched_orig(handle,a,stride_a,b,stride_b,c,stride_c,s,stride_s,batch_count) bind(c, name="rocblas_crotg_strided_batched")
      use iso_c_binding
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocblas_crotg_strided_batched_orig
      type(c_ptr),value :: handle
      type(c_ptr),value :: a
      integer(c_int64_t),value :: stride_a
      type(c_ptr),value :: b
      integer(c_int64_t),value :: stride_b
      type(c_ptr),value :: c
      integer(c_int64_t),value :: stride_c
      type(c_ptr),value :: s
      integer(c_int64_t),value :: stride_s
      integer(c_int),value :: batch_count
    end function


  end interface
  !> ! \brief BLAS Level 1 API
  !> 
  !>     \details
  !>     rotg_strided_batched creates the Givens rotation matrix for the strided batched vectors (a_i b_i), for i = 1, ..., batch_count.
  !>          a, b, c, and s may be stored in either host or device memory, location is specified by calling rocblas_set_pointer_mode.
  !>          If the pointer mode is set to rocblas_pointer_mode_host, this function blocks the CPU until the GPU has finished and the results are available in host memory.
  !>          If the pointer mode is set to rocblas_pointer_mode_device, this function returns immediately and synchronization is required to read the results.
  !> 
  !>     @param[in]
  !>     handle  [rocblas_handle]
  !>             handle to the rocblas library context queue.
  !>     @param[inout]
  !>     a       device strided_batched pointer or host strided_batched pointer to first single input vector element a_1, overwritten with r.
  !>     @param[in]
  !>     stride_a [rocblas_stride]
  !>              distance between elements of a in batch (distance between a_i and a_(i + 1))
  !>     @param[inout]
  !>     b       device strided_batched pointer or host strided_batched pointer to first single input vector element b_1, overwritten with z.
  !>     @param[in]
  !>     stride_b [rocblas_stride]
  !>              distance between elements of b in batch (distance between b_i and b_(i + 1))
  !>     @param[inout]
  !>     c       device strided_batched pointer or host strided_batched pointer to first cosine element of Givens rotations c_1.
  !>     @param[in]
  !>     stride_c [rocblas_stride]
  !>              distance between elements of c in batch (distance between c_i and c_(i + 1))
  !>     @param[inout]
  !>     s       device strided_batched pointer or host strided_batched pointer to sine element of Givens rotations s_1.
  !>     @param[in]
  !>     stride_s [rocblas_stride]
  !>              distance between elements of s in batch (distance between s_i and s_(i + 1))
  !>     @param[in]
  !>     batch_count [rocblas_int]
  !>                 number of batches (length of arrays a, b, c, and s).
  !> 
  !>     
  interface rocblas_zrotg_strided_batched
    function rocblas_zrotg_strided_batched_orig(handle,a,stride_a,b,stride_b,c,stride_c,s,stride_s,batch_count) bind(c, name="rocblas_zrotg_strided_batched")
      use iso_c_binding
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocblas_zrotg_strided_batched_orig
      type(c_ptr),value :: handle
      type(c_ptr),value :: a
      integer(c_int64_t),value :: stride_a
      type(c_ptr),value :: b
      integer(c_int64_t),value :: stride_b
      type(c_ptr),value :: c
      integer(c_int64_t),value :: stride_c
      type(c_ptr),value :: s
      integer(c_int64_t),value :: stride_s
      integer(c_int),value :: batch_count
    end function


  end interface
  
  interface rocblas_srotm
    function rocblas_srotm_orig(handle,n,x,incx,y,incy,param) bind(c, name="rocblas_srotm")
      use iso_c_binding
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocblas_srotm_orig
      type(c_ptr),value :: handle
      integer(c_int),value :: n
      type(c_ptr),value :: x
      integer(c_int),value :: incx
      type(c_ptr),value :: y
      integer(c_int),value :: incy
      type(c_ptr),value :: param
    end function

#ifdef USE_FPOINTER_INTERFACES
    module procedure rocblas_srotm_rank_0,rocblas_srotm_rank_1
#endif

  end interface
  !> ! \brief BLAS Level 1 API
  !> 
  !>     \details
  !>     rotm applies the modified Givens rotation matrix defined by param to vectors x and y.
  !> 
  !>     @param[in]
  !>     handle  [rocblas_handle]
  !>             handle to the rocblas library context queue.
  !>     @param[in]
  !>     n       [rocblas_int]
  !>             number of elements in the x and y vectors.
  !>     @param[inout]
  !>     x       device pointer storing vector x.
  !>     @param[in]
  !>     incx    [rocblas_int]
  !>             specifies the increment between elements of x.
  !>     @param[inout]
  !>     y       device pointer storing vector y.
  !>     @param[in]
  !>     incy    [rocblas_int]
  !>             specifies the increment between elements of y.
  !>     @param[in]
  !>     param   device vector or host vector of 5 elements defining the rotation.
  !>             param[0] = flag
  !>             param[1] = H11
  !>             param[2] = H21
  !>             param[3] = H12
  !>             param[4] = H22
  !>             The flag parameter defines the form of H:
  !>             flag = -1 => H = ( H11 H12 H21 H22 )
  !>             flag =  0 => H = ( 1.0 H12 H21 1.0 )
  !>             flag =  1 => H = ( H11 1.0 -1.0 H22 )
  !>             flag = -2 => H = ( 1.0 0.0 0.0 1.0 )
  !>             param may be stored in either host or device memory, location is specified by calling rocblas_set_pointer_mode.
  !> 
  !>     
  interface rocblas_drotm
    function rocblas_drotm_orig(handle,n,x,incx,y,incy,param) bind(c, name="rocblas_drotm")
      use iso_c_binding
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocblas_drotm_orig
      type(c_ptr),value :: handle
      integer(c_int),value :: n
      type(c_ptr),value :: x
      integer(c_int),value :: incx
      type(c_ptr),value :: y
      integer(c_int),value :: incy
      type(c_ptr),value :: param
    end function

#ifdef USE_FPOINTER_INTERFACES
    module procedure rocblas_drotm_rank_0,rocblas_drotm_rank_1
#endif

  end interface
  
  interface rocblas_srotm_batched
    function rocblas_srotm_batched_orig(handle,n,x,incx,y,incy,param,batch_count) bind(c, name="rocblas_srotm_batched")
      use iso_c_binding
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocblas_srotm_batched_orig
      type(c_ptr),value :: handle
      integer(c_int),value :: n
      type(c_ptr) :: x
      integer(c_int),value :: incx
      type(c_ptr) :: y
      integer(c_int),value :: incy
      type(c_ptr) :: param
      integer(c_int),value :: batch_count
    end function

#ifdef USE_FPOINTER_INTERFACES
    module procedure rocblas_srotm_batched_full_rank,rocblas_srotm_batched_rank_0,rocblas_srotm_batched_rank_1
#endif

  end interface
  !> ! \brief BLAS Level 1 API
  !> 
  !>     \details
  !>     rotm_batched applies the modified Givens rotation matrix defined by param_i to batched vectors x_i and y_i, for i = 1, ..., batch_count.
  !> 
  !>     @param[in]
  !>     handle  [rocblas_handle]
  !>             handle to the rocblas library context queue.
  !>     @param[in]
  !>     n       [rocblas_int]
  !>             number of elements in the x and y vectors.
  !>     @param[inout]
  !>     x       device array of device pointers storing each vector x_i.
  !>     @param[in]
  !>     incx    [rocblas_int]
  !>             specifies the increment between elements of each x_i.
  !>     @param[inout]
  !>     y       device array of device pointers storing each vector y_1.
  !>     @param[in]
  !>     incy    [rocblas_int]
  !>             specifies the increment between elements of each y_i.
  !>     @param[in]
  !>     param   device array of device vectors of 5 elements defining the rotation.
  !>             param[0] = flag
  !>             param[1] = H11
  !>             param[2] = H21
  !>             param[3] = H12
  !>             param[4] = H22
  !>             The flag parameter defines the form of H:
  !>             flag = -1 => H = ( H11 H12 H21 H22 )
  !>             flag =  0 => H = ( 1.0 H12 H21 1.0 )
  !>             flag =  1 => H = ( H11 1.0 -1.0 H22 )
  !>             flag = -2 => H = ( 1.0 0.0 0.0 1.0 )
  !>             param may ONLY be stored on the device for the batched version of this function.
  !>     @param[in]
  !>     batch_count [rocblas_int]
  !>                 the number of x and y arrays, i.e. the number of batches.
  !> 
  !>     
  interface rocblas_drotm_batched
    function rocblas_drotm_batched_orig(handle,n,x,incx,y,incy,param,batch_count) bind(c, name="rocblas_drotm_batched")
      use iso_c_binding
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocblas_drotm_batched_orig
      type(c_ptr),value :: handle
      integer(c_int),value :: n
      type(c_ptr) :: x
      integer(c_int),value :: incx
      type(c_ptr) :: y
      integer(c_int),value :: incy
      type(c_ptr) :: param
      integer(c_int),value :: batch_count
    end function

#ifdef USE_FPOINTER_INTERFACES
    module procedure rocblas_drotm_batched_full_rank,rocblas_drotm_batched_rank_0,rocblas_drotm_batched_rank_1
#endif

  end interface
  
  interface rocblas_srotm_strided_batched
    function rocblas_srotm_strided_batched_orig(handle,n,x,incx,stride_x,y,incy,stride_y,param,stride_param,batch_count) bind(c, name="rocblas_srotm_strided_batched")
      use iso_c_binding
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocblas_srotm_strided_batched_orig
      type(c_ptr),value :: handle
      integer(c_int),value :: n
      type(c_ptr),value :: x
      integer(c_int),value :: incx
      integer(c_int64_t),value :: stride_x
      type(c_ptr),value :: y
      integer(c_int),value :: incy
      integer(c_int64_t),value :: stride_y
      type(c_ptr),value :: param
      integer(c_int64_t),value :: stride_param
      integer(c_int),value :: batch_count
    end function

#ifdef USE_FPOINTER_INTERFACES
    module procedure rocblas_srotm_strided_batched_rank_0,rocblas_srotm_strided_batched_rank_1
#endif

  end interface
  !> ! \brief BLAS Level 1 API
  !> 
  !>     \details
  !>     rotm_strided_batched applies the modified Givens rotation matrix defined by param_i to strided batched vectors x_i and y_i, for i = 1, ..., batch_count
  !> 
  !>     @param[in]
  !>     handle  [rocblas_handle]
  !>             handle to the rocblas library context queue.
  !>     @param[in]
  !>     n       [rocblas_int]
  !>             number of elements in the x and y vectors.
  !>     @param[inout]
  !>     x       device pointer pointing to first strided batched vector x_1.
  !>     @param[in]
  !>     incx    [rocblas_int]
  !>             specifies the increment between elements of each x_i.
  !>     @param[in]
  !>     stride_x [rocblas_stride]
  !>              specifies the increment between the beginning of x_i and x_(i + 1)
  !>     @param[inout]
  !>     y       device pointer pointing to first strided batched vector y_1.
  !>     @param[in]
  !>     incy    [rocblas_int]
  !>             specifies the increment between elements of each y_i.
  !>     @param[in]
  !>     stride_y [rocblas_stride]
  !>              specifies the increment between the beginning of y_i and y_(i + 1)
  !>     @param[in]
  !>     param   device pointer pointing to first array of 5 elements defining the rotation (param_1).
  !>             param[0] = flag
  !>             param[1] = H11
  !>             param[2] = H21
  !>             param[3] = H12
  !>             param[4] = H22
  !>             The flag parameter defines the form of H:
  !>             flag = -1 => H = ( H11 H12 H21 H22 )
  !>             flag =  0 => H = ( 1.0 H12 H21 1.0 )
  !>             flag =  1 => H = ( H11 1.0 -1.0 H22 )
  !>             flag = -2 => H = ( 1.0 0.0 0.0 1.0 )
  !>             param may ONLY be stored on the device for the strided_batched version of this function.
  !>     @param[in]
  !>     stride_param [rocblas_stride]
  !>                  specifies the increment between the beginning of param_i and param_(i + 1)
  !>     @param[in]
  !>     batch_count [rocblas_int]
  !>                 the number of x and y arrays, i.e. the number of batches.
  !> 
  !>     
  interface rocblas_drotm_strided_batched
    function rocblas_drotm_strided_batched_orig(handle,n,x,incx,stride_x,y,incy,stride_y,param,stride_param,batch_count) bind(c, name="rocblas_drotm_strided_batched")
      use iso_c_binding
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocblas_drotm_strided_batched_orig
      type(c_ptr),value :: handle
      integer(c_int),value :: n
      type(c_ptr),value :: x
      integer(c_int),value :: incx
      integer(c_int64_t),value :: stride_x
      type(c_ptr),value :: y
      integer(c_int),value :: incy
      integer(c_int64_t),value :: stride_y
      type(c_ptr),value :: param
      integer(c_int64_t),value :: stride_param
      integer(c_int),value :: batch_count
    end function

#ifdef USE_FPOINTER_INTERFACES
    module procedure rocblas_drotm_strided_batched_rank_0,rocblas_drotm_strided_batched_rank_1
#endif

  end interface
  
  interface rocblas_srotmg
    function rocblas_srotmg_orig(handle,d1,d2,x1,y1,param) bind(c, name="rocblas_srotmg")
      use iso_c_binding
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocblas_srotmg_orig
      type(c_ptr),value :: handle
      type(c_ptr),value :: d1
      type(c_ptr),value :: d2
      type(c_ptr),value :: x1
      type(c_ptr),value :: y1
      type(c_ptr),value :: param
    end function


  end interface
  !> ! \brief BLAS Level 1 API
  !> 
  !>     \details
  !>     rotmg creates the modified Givens rotation matrix for the vector (d1  x1, d2  y1).
  !>           Parameters may be stored in either host or device memory, location is specified by calling rocblas_set_pointer_mode.
  !>           If the pointer mode is set to rocblas_pointer_mode_host, this function blocks the CPU until the GPU has finished and the results are available in host memory.
  !>           If the pointer mode is set to rocblas_pointer_mode_device, this function returns immediately and synchronization is required to read the results.
  !> 
  !>     @param[in]
  !>     handle  [rocblas_handle]
  !>             handle to the rocblas library context queue.
  !>     @param[inout]
  !>     d1      device pointer or host pointer to input scalar that is overwritten.
  !>     @param[inout]
  !>     d2      device pointer or host pointer to input scalar that is overwritten.
  !>     @param[inout]
  !>     x1      device pointer or host pointer to input scalar that is overwritten.
  !>     @param[in]
  !>     y1      device pointer or host pointer to input scalar.
  !>     @param[out]
  !>     param   device vector or host vector of 5 elements defining the rotation.
  !>             param[0] = flag
  !>             param[1] = H11
  !>             param[2] = H21
  !>             param[3] = H12
  !>             param[4] = H22
  !>             The flag parameter defines the form of H:
  !>             flag = -1 => H = ( H11 H12 H21 H22 )
  !>             flag =  0 => H = ( 1.0 H12 H21 1.0 )
  !>             flag =  1 => H = ( H11 1.0 -1.0 H22 )
  !>             flag = -2 => H = ( 1.0 0.0 0.0 1.0 )
  !>             param may be stored in either host or device memory, location is specified by calling rocblas_set_pointer_mode.
  !> 
  !>     
  interface rocblas_drotmg
    function rocblas_drotmg_orig(handle,d1,d2,x1,y1,param) bind(c, name="rocblas_drotmg")
      use iso_c_binding
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocblas_drotmg_orig
      type(c_ptr),value :: handle
      type(c_ptr),value :: d1
      type(c_ptr),value :: d2
      type(c_ptr),value :: x1
      type(c_ptr),value :: y1
      type(c_ptr),value :: param
    end function


  end interface
  
  interface rocblas_srotmg_batched
    function rocblas_srotmg_batched_orig(handle,d1,d2,x1,y1,param,batch_count) bind(c, name="rocblas_srotmg_batched")
      use iso_c_binding
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocblas_srotmg_batched_orig
      type(c_ptr),value :: handle
      type(c_ptr) :: d1
      type(c_ptr) :: d2
      type(c_ptr) :: x1
      type(c_ptr) :: y1
      type(c_ptr) :: param
      integer(c_int),value :: batch_count
    end function


  end interface
  !> ! \brief BLAS Level 1 API
  !> 
  !>     \details
  !>     rotmg_batched creates the modified Givens rotation matrix for the batched vectors (d1_i  x1_i, d2_i  y1_i), for i = 1, ..., batch_count.
  !>           Parameters may be stored in either host or device memory, location is specified by calling rocblas_set_pointer_mode.
  !>           If the pointer mode is set to rocblas_pointer_mode_host, this function blocks the CPU until the GPU has finished and the results are available in host memory.
  !>           If the pointer mode is set to rocblas_pointer_mode_device, this function returns immediately and synchronization is required to read the results.
  !> 
  !>     @param[in]
  !>     handle  [rocblas_handle]
  !>             handle to the rocblas library context queue.
  !>     @param[inout]
  !>     d1      device batched array or host batched array of input scalars that is overwritten.
  !>     @param[inout]
  !>     d2      device batched array or host batched array of input scalars that is overwritten.
  !>     @param[inout]
  !>     x1      device batched array or host batched array of input scalars that is overwritten.
  !>     @param[in]
  !>     y1      device batched array or host batched array of input scalars.
  !>     @param[out]
  !>     param   device batched array or host batched array of vectors of 5 elements defining the rotation.
  !>             param[0] = flag
  !>             param[1] = H11
  !>             param[2] = H21
  !>             param[3] = H12
  !>             param[4] = H22
  !>             The flag parameter defines the form of H:
  !>             flag = -1 => H = ( H11 H12 H21 H22 )
  !>             flag =  0 => H = ( 1.0 H12 H21 1.0 )
  !>             flag =  1 => H = ( H11 1.0 -1.0 H22 )
  !>             flag = -2 => H = ( 1.0 0.0 0.0 1.0 )
  !>             param may be stored in either host or device memory, location is specified by calling rocblas_set_pointer_mode.
  !>     @param[in]
  !>     batch_count [rocblas_int]
  !>                 the number of instances in the batch.
  !> 
  !>     
  interface rocblas_drotmg_batched
    function rocblas_drotmg_batched_orig(handle,d1,d2,x1,y1,param,batch_count) bind(c, name="rocblas_drotmg_batched")
      use iso_c_binding
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocblas_drotmg_batched_orig
      type(c_ptr),value :: handle
      type(c_ptr) :: d1
      type(c_ptr) :: d2
      type(c_ptr) :: x1
      type(c_ptr) :: y1
      type(c_ptr) :: param
      integer(c_int),value :: batch_count
    end function


  end interface
  
  interface rocblas_srotmg_strided_batched
    function rocblas_srotmg_strided_batched_orig(handle,d1,stride_d1,d2,stride_d2,x1,stride_x1,y1,stride_y1,param,stride_param,batch_count) bind(c, name="rocblas_srotmg_strided_batched")
      use iso_c_binding
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocblas_srotmg_strided_batched_orig
      type(c_ptr),value :: handle
      type(c_ptr),value :: d1
      integer(c_int64_t),value :: stride_d1
      type(c_ptr),value :: d2
      integer(c_int64_t),value :: stride_d2
      type(c_ptr),value :: x1
      integer(c_int64_t),value :: stride_x1
      type(c_ptr),value :: y1
      integer(c_int64_t),value :: stride_y1
      type(c_ptr),value :: param
      integer(c_int64_t),value :: stride_param
      integer(c_int),value :: batch_count
    end function


  end interface
  !> ! \brief BLAS Level 1 API
  !> 
  !>     \details
  !>     rotmg_strided_batched creates the modified Givens rotation matrix for the strided batched vectors (d1_i  x1_i, d2_i  y1_i), for i = 1, ..., batch_count.
  !>           Parameters may be stored in either host or device memory, location is specified by calling rocblas_set_pointer_mode.
  !>           If the pointer mode is set to rocblas_pointer_mode_host, this function blocks the CPU until the GPU has finished and the results are available in host memory.
  !>           If the pointer mode is set to rocblas_pointer_mode_device, this function returns immediately and synchronization is required to read the results.
  !> 
  !>     @param[in]
  !>     handle  [rocblas_handle]
  !>             handle to the rocblas library context queue.
  !>     @param[inout]
  !>     d1      device strided_batched array or host strided_batched array of input scalars that is overwritten.
  !>     @param[in]
  !>     stride_d1 [rocblas_stride]
  !>               specifies the increment between the beginning of d1_i and d1_(i+1)
  !>     @param[inout]
  !>     d2      device strided_batched array or host strided_batched array of input scalars that is overwritten.
  !>     @param[in]
  !>     stride_d2 [rocblas_stride]
  !>               specifies the increment between the beginning of d2_i and d2_(i+1)
  !>     @param[inout]
  !>     x1      device strided_batched array or host strided_batched array of input scalars that is overwritten.
  !>     @param[in]
  !>     stride_x1 [rocblas_stride]
  !>               specifies the increment between the beginning of x1_i and x1_(i+1)
  !>     @param[in]
  !>     y1      device strided_batched array or host strided_batched array of input scalars.
  !>     @param[in]
  !>     stride_y1 [rocblas_stride]
  !>               specifies the increment between the beginning of y1_i and y1_(i+1)
  !>     @param[out]
  !>     param   device strided_batched array or host strided_batched array of vectors of 5 elements defining the rotation.
  !>             param[0] = flag
  !>             param[1] = H11
  !>             param[2] = H21
  !>             param[3] = H12
  !>             param[4] = H22
  !>             The flag parameter defines the form of H:
  !>             flag = -1 => H = ( H11 H12 H21 H22 )
  !>             flag =  0 => H = ( 1.0 H12 H21 1.0 )
  !>             flag =  1 => H = ( H11 1.0 -1.0 H22 )
  !>             flag = -2 => H = ( 1.0 0.0 0.0 1.0 )
  !>             param may be stored in either host or device memory, location is specified by calling rocblas_set_pointer_mode.
  !>     @param[in]
  !>     stride_param [rocblas_stride]
  !>                  specifies the increment between the beginning of param_i and param_(i + 1)
  !>     @param[in]
  !>     batch_count [rocblas_int]
  !>                 the number of instances in the batch.
  !> 
  !>     
  interface rocblas_drotmg_strided_batched
    function rocblas_drotmg_strided_batched_orig(handle,d1,stride_d1,d2,stride_d2,x1,stride_x1,y1,stride_y1,param,stride_param,batch_count) bind(c, name="rocblas_drotmg_strided_batched")
      use iso_c_binding
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocblas_drotmg_strided_batched_orig
      type(c_ptr),value :: handle
      type(c_ptr),value :: d1
      integer(c_int64_t),value :: stride_d1
      type(c_ptr),value :: d2
      integer(c_int64_t),value :: stride_d2
      type(c_ptr),value :: x1
      integer(c_int64_t),value :: stride_x1
      type(c_ptr),value :: y1
      integer(c_int64_t),value :: stride_y1
      type(c_ptr),value :: param
      integer(c_int64_t),value :: stride_param
      integer(c_int),value :: batch_count
    end function


  end interface
  !> 
  !>   ===========================================================================
  !>      level 2 BLAS
  !>   ===========================================================================
  !>  
  interface rocblas_sgbmv
    function rocblas_sgbmv_orig(handle,trans,m,n,kl,ku,alpha,A,lda,x,incx,beta,y,incy) bind(c, name="rocblas_sgbmv")
      use iso_c_binding
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocblas_sgbmv_orig
      type(c_ptr),value :: handle
      integer(kind(rocblas_operation_none)),value :: trans
      integer(c_int),value :: m
      integer(c_int),value :: n
      integer(c_int),value :: kl
      integer(c_int),value :: ku
      real(c_float) :: alpha
      type(c_ptr),value :: A
      integer(c_int),value :: lda
      type(c_ptr),value :: x
      integer(c_int),value :: incx
      real(c_float) :: beta
      type(c_ptr),value :: y
      integer(c_int),value :: incy
    end function

#ifdef USE_FPOINTER_INTERFACES
    module procedure rocblas_sgbmv_full_rank,rocblas_sgbmv_rank_0,rocblas_sgbmv_rank_1
#endif

  end interface
  
  interface rocblas_dgbmv
    function rocblas_dgbmv_orig(handle,trans,m,n,kl,ku,alpha,A,lda,x,incx,beta,y,incy) bind(c, name="rocblas_dgbmv")
      use iso_c_binding
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocblas_dgbmv_orig
      type(c_ptr),value :: handle
      integer(kind(rocblas_operation_none)),value :: trans
      integer(c_int),value :: m
      integer(c_int),value :: n
      integer(c_int),value :: kl
      integer(c_int),value :: ku
      real(c_double) :: alpha
      type(c_ptr),value :: A
      integer(c_int),value :: lda
      type(c_ptr),value :: x
      integer(c_int),value :: incx
      real(c_double) :: beta
      type(c_ptr),value :: y
      integer(c_int),value :: incy
    end function

#ifdef USE_FPOINTER_INTERFACES
    module procedure rocblas_dgbmv_full_rank,rocblas_dgbmv_rank_0,rocblas_dgbmv_rank_1
#endif

  end interface
  
  interface rocblas_cgbmv
    function rocblas_cgbmv_orig(handle,trans,m,n,kl,ku,alpha,A,lda,x,incx,beta,y,incy) bind(c, name="rocblas_cgbmv")
      use iso_c_binding
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocblas_cgbmv_orig
      type(c_ptr),value :: handle
      integer(kind(rocblas_operation_none)),value :: trans
      integer(c_int),value :: m
      integer(c_int),value :: n
      integer(c_int),value :: kl
      integer(c_int),value :: ku
      complex(c_float_complex) :: alpha
      type(c_ptr),value :: A
      integer(c_int),value :: lda
      type(c_ptr),value :: x
      integer(c_int),value :: incx
      complex(c_float_complex) :: beta
      type(c_ptr),value :: y
      integer(c_int),value :: incy
    end function

#ifdef USE_FPOINTER_INTERFACES
    module procedure rocblas_cgbmv_full_rank,rocblas_cgbmv_rank_0,rocblas_cgbmv_rank_1
#endif

  end interface
  !> ! \brief BLAS Level 2 API
  !> 
  !>     \details
  !>     xGBMV performs one of the matrix-vector operations
  !> 
  !>         y := alphaAx    + betay,   or
  !>         y := alphaATx + betay,   or
  !>         y := alphaAHx + betay,
  !> 
  !>     where alpha and beta are scalars, x and y are vectors and A is an
  !>     m by n banded matrix with kl sub-diagonals and ku super-diagonals.
  !> 
  !>     @param[in]
  !>     handle    [rocblas_handle]
  !>               handle to the rocblas library context queue.
  !>     @param[in]
  !>     trans     [rocblas_operation]
  !>               indicates whether matrix A is tranposed (conjugated) or not
  !>     @param[in]
  !>     m         [rocblas_int]
  !>               number of rows of matrix A
  !>     @param[in]
  !>     n         [rocblas_int]
  !>               number of columns of matrix A
  !>     @param[in]
  !>     kl        [rocblas_int]
  !>               number of sub-diagonals of A
  !>     @param[in]
  !>     ku        [rocblas_int]
  !>               number of super-diagonals of A
  !>     @param[in]
  !>     alpha     device pointer or host pointer to scalar alpha.
  !>     @param[in]
  !>         A     device pointer storing banded matrix A.
  !>               Leading (kl + ku + 1) by n part of the matrix contains the coefficients
  !>               of the banded matrix. The leading diagonal resides in row (ku + 1) with
  !>               the first super-diagonal above on the RHS of row ku. The first sub-diagonal
  !>               resides below on the LHS of row ku + 2. This propogates up and down across
  !>               subsuper-diagonals.
  !>                 Ex: (m = n = 7; ku = 2, kl = 2)
  !>                 1 2 3 0 0 0 0             0 0 3 3 3 3 3
  !>                 4 1 2 3 0 0 0             0 2 2 2 2 2 2
  !>                 5 4 1 2 3 0 0    ---->    1 1 1 1 1 1 1
  !>                 0 5 4 1 2 3 0             4 4 4 4 4 4 0
  !>                 0 0 5 4 1 2 0             5 5 5 5 5 0 0
  !>                 0 0 0 5 4 1 2             0 0 0 0 0 0 0
  !>                 0 0 0 0 5 4 1             0 0 0 0 0 0 0
  !>               Note that the empty elements which don't correspond to data will not
  !>               be referenced.
  !>     @param[in]
  !>     lda       [rocblas_int]
  !>               specifies the leading dimension of A. Must be >= (kl + ku + 1)
  !>     @param[in]
  !>     x         device pointer storing vector x.
  !>     @param[in]
  !>     incx      [rocblas_int]
  !>               specifies the increment for the elements of x.
  !>     @param[in]
  !>     beta      device pointer or host pointer to scalar beta.
  !>     @param[inout]
  !>     y         device pointer storing vector y.
  !>     @param[in]
  !>     incy      [rocblas_int]
  !>               specifies the increment for the elements of y.
  !> 
  !>     
  interface rocblas_zgbmv
    function rocblas_zgbmv_orig(handle,trans,m,n,kl,ku,alpha,A,lda,x,incx,beta,y,incy) bind(c, name="rocblas_zgbmv")
      use iso_c_binding
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocblas_zgbmv_orig
      type(c_ptr),value :: handle
      integer(kind(rocblas_operation_none)),value :: trans
      integer(c_int),value :: m
      integer(c_int),value :: n
      integer(c_int),value :: kl
      integer(c_int),value :: ku
      complex(c_double_complex) :: alpha
      type(c_ptr),value :: A
      integer(c_int),value :: lda
      type(c_ptr),value :: x
      integer(c_int),value :: incx
      complex(c_double_complex) :: beta
      type(c_ptr),value :: y
      integer(c_int),value :: incy
    end function

#ifdef USE_FPOINTER_INTERFACES
    module procedure rocblas_zgbmv_full_rank,rocblas_zgbmv_rank_0,rocblas_zgbmv_rank_1
#endif

  end interface
  
  interface rocblas_sgbmv_batched
    function rocblas_sgbmv_batched_orig(handle,trans,m,n,kl,ku,alpha,A,lda,x,incx,beta,y,incy,batch_count) bind(c, name="rocblas_sgbmv_batched")
      use iso_c_binding
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocblas_sgbmv_batched_orig
      type(c_ptr),value :: handle
      integer(kind(rocblas_operation_none)),value :: trans
      integer(c_int),value :: m
      integer(c_int),value :: n
      integer(c_int),value :: kl
      integer(c_int),value :: ku
      real(c_float) :: alpha
      type(c_ptr) :: A
      integer(c_int),value :: lda
      type(c_ptr) :: x
      integer(c_int),value :: incx
      real(c_float) :: beta
      type(c_ptr) :: y
      integer(c_int),value :: incy
      integer(c_int),value :: batch_count
    end function

#ifdef USE_FPOINTER_INTERFACES
    module procedure rocblas_sgbmv_batched_full_rank,rocblas_sgbmv_batched_rank_0,rocblas_sgbmv_batched_rank_1
#endif

  end interface
  
  interface rocblas_dgbmv_batched
    function rocblas_dgbmv_batched_orig(handle,trans,m,n,kl,ku,alpha,A,lda,x,incx,beta,y,incy,batch_count) bind(c, name="rocblas_dgbmv_batched")
      use iso_c_binding
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocblas_dgbmv_batched_orig
      type(c_ptr),value :: handle
      integer(kind(rocblas_operation_none)),value :: trans
      integer(c_int),value :: m
      integer(c_int),value :: n
      integer(c_int),value :: kl
      integer(c_int),value :: ku
      real(c_double) :: alpha
      type(c_ptr) :: A
      integer(c_int),value :: lda
      type(c_ptr) :: x
      integer(c_int),value :: incx
      real(c_double) :: beta
      type(c_ptr) :: y
      integer(c_int),value :: incy
      integer(c_int),value :: batch_count
    end function

#ifdef USE_FPOINTER_INTERFACES
    module procedure rocblas_dgbmv_batched_full_rank,rocblas_dgbmv_batched_rank_0,rocblas_dgbmv_batched_rank_1
#endif

  end interface
  
  interface rocblas_cgbmv_batched
    function rocblas_cgbmv_batched_orig(handle,trans,m,n,kl,ku,alpha,A,lda,x,incx,beta,y,incy,batch_count) bind(c, name="rocblas_cgbmv_batched")
      use iso_c_binding
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocblas_cgbmv_batched_orig
      type(c_ptr),value :: handle
      integer(kind(rocblas_operation_none)),value :: trans
      integer(c_int),value :: m
      integer(c_int),value :: n
      integer(c_int),value :: kl
      integer(c_int),value :: ku
      complex(c_float_complex) :: alpha
      type(c_ptr) :: A
      integer(c_int),value :: lda
      type(c_ptr) :: x
      integer(c_int),value :: incx
      complex(c_float_complex) :: beta
      type(c_ptr) :: y
      integer(c_int),value :: incy
      integer(c_int),value :: batch_count
    end function

#ifdef USE_FPOINTER_INTERFACES
    module procedure rocblas_cgbmv_batched_full_rank,rocblas_cgbmv_batched_rank_0,rocblas_cgbmv_batched_rank_1
#endif

  end interface
  !> ! \brief BLAS Level 2 API
  !> 
  !>     \details
  !>     xGBMV_BATCHED performs one of the matrix-vector operations
  !> 
  !>         y_i := alphaA_ix_i    + betay_i,   or
  !>         y_i := alphaA_iTx_i + betay_i,   or
  !>         y_i := alphaA_iHx_i + betay_i,
  !> 
  !>     where (A_i, x_i, y_i) is the i-th instance of the batch.
  !>     alpha and beta are scalars, x_i and y_i are vectors and A_i is an
  !>     m by n banded matrix with kl sub-diagonals and ku super-diagonals,
  !>     for i = 1, ..., batch_count.
  !> 
  !>     @param[in]
  !>     handle    [rocblas_handle]
  !>               handle to the rocblas library context queue.
  !>     @param[in]
  !>     trans     [rocblas_operation]
  !>               indicates whether matrix A is tranposed (conjugated) or not
  !>     @param[in]
  !>     m         [rocblas_int]
  !>               number of rows of each matrix A_i
  !>     @param[in]
  !>     n         [rocblas_int]
  !>               number of columns of each matrix A_i
  !>     @param[in]
  !>     kl        [rocblas_int]
  !>               number of sub-diagonals of each A_i
  !>     @param[in]
  !>     ku        [rocblas_int]
  !>               number of super-diagonals of each A_i
  !>     @param[in]
  !>     alpha     device pointer or host pointer to scalar alpha.
  !>     @param[in]
  !>         A     device array of device pointers storing each banded matrix A_i.
  !>               Leading (kl + ku + 1) by n part of the matrix contains the coefficients
  !>               of the banded matrix. The leading diagonal resides in row (ku + 1) with
  !>               the first super-diagonal above on the RHS of row ku. The first sub-diagonal
  !>               resides below on the LHS of row ku + 2. This propogates up and down across
  !>               subsuper-diagonals.
  !>                 Ex: (m = n = 7; ku = 2, kl = 2)
  !>                 1 2 3 0 0 0 0             0 0 3 3 3 3 3
  !>                 4 1 2 3 0 0 0             0 2 2 2 2 2 2
  !>                 5 4 1 2 3 0 0    ---->    1 1 1 1 1 1 1
  !>                 0 5 4 1 2 3 0             4 4 4 4 4 4 0
  !>                 0 0 5 4 1 2 0             5 5 5 5 5 0 0
  !>                 0 0 0 5 4 1 2             0 0 0 0 0 0 0
  !>                 0 0 0 0 5 4 1             0 0 0 0 0 0 0
  !>               Note that the empty elements which don't correspond to data will not
  !>               be referenced.
  !>     @param[in]
  !>     lda       [rocblas_int]
  !>               specifies the leading dimension of each A_i. Must be >= (kl + ku + 1)
  !>     @param[in]
  !>     x         device array of device pointers storing each vector x_i.
  !>     @param[in]
  !>     incx      [rocblas_int]
  !>               specifies the increment for the elements of each x_i.
  !>     @param[in]
  !>     beta      device pointer or host pointer to scalar beta.
  !>     @param[inout]
  !>     y         device array of device pointers storing each vector y_i.
  !>     @param[in]
  !>     incy      [rocblas_int]
  !>               specifies the increment for the elements of each y_i.
  !>     @param[in]
  !>     batch_count [rocblas_int]
  !>                 specifies the number of instances in the batch.
  !> 
  !>     
  interface rocblas_zgbmv_batched
    function rocblas_zgbmv_batched_orig(handle,trans,m,n,kl,ku,alpha,A,lda,x,incx,beta,y,incy,batch_count) bind(c, name="rocblas_zgbmv_batched")
      use iso_c_binding
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocblas_zgbmv_batched_orig
      type(c_ptr),value :: handle
      integer(kind(rocblas_operation_none)),value :: trans
      integer(c_int),value :: m
      integer(c_int),value :: n
      integer(c_int),value :: kl
      integer(c_int),value :: ku
      complex(c_double_complex) :: alpha
      type(c_ptr) :: A
      integer(c_int),value :: lda
      type(c_ptr) :: x
      integer(c_int),value :: incx
      complex(c_double_complex) :: beta
      type(c_ptr) :: y
      integer(c_int),value :: incy
      integer(c_int),value :: batch_count
    end function

#ifdef USE_FPOINTER_INTERFACES
    module procedure rocblas_zgbmv_batched_full_rank,rocblas_zgbmv_batched_rank_0,rocblas_zgbmv_batched_rank_1
#endif

  end interface
  
  interface rocblas_sgbmv_strided_batched
    function rocblas_sgbmv_strided_batched_orig(handle,trans,m,n,kl,ku,alpha,A,lda,stride_A,x,incx,stride_x,beta,y,incy,stride_y,batch_count) bind(c, name="rocblas_sgbmv_strided_batched")
      use iso_c_binding
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocblas_sgbmv_strided_batched_orig
      type(c_ptr),value :: handle
      integer(kind(rocblas_operation_none)),value :: trans
      integer(c_int),value :: m
      integer(c_int),value :: n
      integer(c_int),value :: kl
      integer(c_int),value :: ku
      real(c_float) :: alpha
      type(c_ptr),value :: A
      integer(c_int),value :: lda
      integer(c_int64_t),value :: stride_A
      type(c_ptr),value :: x
      integer(c_int),value :: incx
      integer(c_int64_t),value :: stride_x
      real(c_float) :: beta
      type(c_ptr),value :: y
      integer(c_int),value :: incy
      integer(c_int64_t),value :: stride_y
      integer(c_int),value :: batch_count
    end function

#ifdef USE_FPOINTER_INTERFACES
    module procedure rocblas_sgbmv_strided_batched_full_rank,rocblas_sgbmv_strided_batched_rank_0,rocblas_sgbmv_strided_batched_rank_1
#endif

  end interface
  
  interface rocblas_dgbmv_strided_batched
    function rocblas_dgbmv_strided_batched_orig(handle,trans,m,n,kl,ku,alpha,A,lda,stride_A,x,incx,stride_x,beta,y,incy,stride_y,batch_count) bind(c, name="rocblas_dgbmv_strided_batched")
      use iso_c_binding
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocblas_dgbmv_strided_batched_orig
      type(c_ptr),value :: handle
      integer(kind(rocblas_operation_none)),value :: trans
      integer(c_int),value :: m
      integer(c_int),value :: n
      integer(c_int),value :: kl
      integer(c_int),value :: ku
      real(c_double) :: alpha
      type(c_ptr),value :: A
      integer(c_int),value :: lda
      integer(c_int64_t),value :: stride_A
      type(c_ptr),value :: x
      integer(c_int),value :: incx
      integer(c_int64_t),value :: stride_x
      real(c_double) :: beta
      type(c_ptr),value :: y
      integer(c_int),value :: incy
      integer(c_int64_t),value :: stride_y
      integer(c_int),value :: batch_count
    end function

#ifdef USE_FPOINTER_INTERFACES
    module procedure rocblas_dgbmv_strided_batched_full_rank,rocblas_dgbmv_strided_batched_rank_0,rocblas_dgbmv_strided_batched_rank_1
#endif

  end interface
  
  interface rocblas_cgbmv_strided_batched
    function rocblas_cgbmv_strided_batched_orig(handle,trans,m,n,kl,ku,alpha,A,lda,stride_A,x,incx,stride_x,beta,y,incy,stride_y,batch_count) bind(c, name="rocblas_cgbmv_strided_batched")
      use iso_c_binding
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocblas_cgbmv_strided_batched_orig
      type(c_ptr),value :: handle
      integer(kind(rocblas_operation_none)),value :: trans
      integer(c_int),value :: m
      integer(c_int),value :: n
      integer(c_int),value :: kl
      integer(c_int),value :: ku
      complex(c_float_complex) :: alpha
      type(c_ptr),value :: A
      integer(c_int),value :: lda
      integer(c_int64_t),value :: stride_A
      type(c_ptr),value :: x
      integer(c_int),value :: incx
      integer(c_int64_t),value :: stride_x
      complex(c_float_complex) :: beta
      type(c_ptr),value :: y
      integer(c_int),value :: incy
      integer(c_int64_t),value :: stride_y
      integer(c_int),value :: batch_count
    end function

#ifdef USE_FPOINTER_INTERFACES
    module procedure rocblas_cgbmv_strided_batched_full_rank,rocblas_cgbmv_strided_batched_rank_0,rocblas_cgbmv_strided_batched_rank_1
#endif

  end interface
  !> ! \brief BLAS Level 2 API
  !> 
  !>     \details
  !>     xGBMV_STRIDED_BATCHED performs one of the matrix-vector operations
  !> 
  !>         y_i := alphaA_ix_i    + betay_i,   or
  !>         y_i := alphaA_iTx_i + betay_i,   or
  !>         y_i := alphaA_iHx_i + betay_i,
  !> 
  !>     where (A_i, x_i, y_i) is the i-th instance of the batch.
  !>     alpha and beta are scalars, x_i and y_i are vectors and A_i is an
  !>     m by n banded matrix with kl sub-diagonals and ku super-diagonals,
  !>     for i = 1, ..., batch_count.
  !> 
  !>     @param[in]
  !>     handle    [rocblas_handle]
  !>               handle to the rocblas library context queue.
  !>     @param[in]
  !>     trans     [rocblas_operation]
  !>               indicates whether matrix A is tranposed (conjugated) or not
  !>     @param[in]
  !>     m         [rocblas_int]
  !>               number of rows of matrix A
  !>     @param[in]
  !>     n         [rocblas_int]
  !>               number of columns of matrix A
  !>     @param[in]
  !>     kl        [rocblas_int]
  !>               number of sub-diagonals of A
  !>     @param[in]
  !>     ku        [rocblas_int]
  !>               number of super-diagonals of A
  !>     @param[in]
  !>     alpha     device pointer or host pointer to scalar alpha.
  !>     @param[in]
  !>         A     device pointer to first banded matrix (A_1).
  !>               Leading (kl + ku + 1) by n part of the matrix contains the coefficients
  !>               of the banded matrix. The leading diagonal resides in row (ku + 1) with
  !>               the first super-diagonal above on the RHS of row ku. The first sub-diagonal
  !>               resides below on the LHS of row ku + 2. This propogates up and down across
  !>               subsuper-diagonals.
  !>                 Ex: (m = n = 7; ku = 2, kl = 2)
  !>                 1 2 3 0 0 0 0             0 0 3 3 3 3 3
  !>                 4 1 2 3 0 0 0             0 2 2 2 2 2 2
  !>                 5 4 1 2 3 0 0    ---->    1 1 1 1 1 1 1
  !>                 0 5 4 1 2 3 0             4 4 4 4 4 4 0
  !>                 0 0 5 4 1 2 0             5 5 5 5 5 0 0
  !>                 0 0 0 5 4 1 2             0 0 0 0 0 0 0
  !>                 0 0 0 0 5 4 1             0 0 0 0 0 0 0
  !>               Note that the empty elements which don't correspond to data will not
  !>               be referenced.
  !>     @param[in]
  !>     lda       [rocblas_int]
  !>               specifies the leading dimension of A. Must be >= (kl + ku + 1)
  !>     @param[in]
  !>     stride_A  [rocblas_stride]
  !>               stride from the start of one matrix (A_i) and the next one (A_i+1)
  !>     @param[in]
  !>     x         device pointer to first vector (x_1).
  !>     @param[in]
  !>     incx      [rocblas_int]
  !>               specifies the increment for the elements of x.
  !>     @param[in]
  !>     stride_x  [rocblas_stride]
  !>               stride from the start of one vector (x_i) and the next one (x_i+1)
  !>     @param[in]
  !>     beta      device pointer or host pointer to scalar beta.
  !>     @param[inout]
  !>     y         device pointer to first vector (y_1).
  !>     @param[in]
  !>     incy      [rocblas_int]
  !>               specifies the increment for the elements of y.
  !>     @param[in]
  !>     stride_y  [rocblas_stride]
  !>               stride from the start of one vector (y_i) and the next one (x_i+1)
  !>     @param[in]
  !>     batch_count [rocblas_int]
  !>                 specifies the number of instances in the batch.
  !> 
  !>     
  interface rocblas_zgbmv_strided_batched
    function rocblas_zgbmv_strided_batched_orig(handle,trans,m,n,kl,ku,alpha,A,lda,stride_A,x,incx,stride_x,beta,y,incy,stride_y,batch_count) bind(c, name="rocblas_zgbmv_strided_batched")
      use iso_c_binding
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocblas_zgbmv_strided_batched_orig
      type(c_ptr),value :: handle
      integer(kind(rocblas_operation_none)),value :: trans
      integer(c_int),value :: m
      integer(c_int),value :: n
      integer(c_int),value :: kl
      integer(c_int),value :: ku
      complex(c_double_complex) :: alpha
      type(c_ptr),value :: A
      integer(c_int),value :: lda
      integer(c_int64_t),value :: stride_A
      type(c_ptr),value :: x
      integer(c_int),value :: incx
      integer(c_int64_t),value :: stride_x
      complex(c_double_complex) :: beta
      type(c_ptr),value :: y
      integer(c_int),value :: incy
      integer(c_int64_t),value :: stride_y
      integer(c_int),value :: batch_count
    end function

#ifdef USE_FPOINTER_INTERFACES
    module procedure rocblas_zgbmv_strided_batched_full_rank,rocblas_zgbmv_strided_batched_rank_0,rocblas_zgbmv_strided_batched_rank_1
#endif

  end interface
  
  interface rocblas_sgemv
    function rocblas_sgemv_orig(handle,trans,m,n,alpha,A,lda,x,incx,beta,y,incy) bind(c, name="rocblas_sgemv")
      use iso_c_binding
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocblas_sgemv_orig
      type(c_ptr),value :: handle
      integer(kind(rocblas_operation_none)),value :: trans
      integer(c_int),value :: m
      integer(c_int),value :: n
      real(c_float) :: alpha
      type(c_ptr),value :: A
      integer(c_int),value :: lda
      type(c_ptr),value :: x
      integer(c_int),value :: incx
      real(c_float) :: beta
      type(c_ptr),value :: y
      integer(c_int),value :: incy
    end function

#ifdef USE_FPOINTER_INTERFACES
    module procedure rocblas_sgemv_full_rank,rocblas_sgemv_rank_0,rocblas_sgemv_rank_1
#endif

  end interface
  
  interface rocblas_dgemv
    function rocblas_dgemv_orig(handle,trans,m,n,alpha,A,lda,x,incx,beta,y,incy) bind(c, name="rocblas_dgemv")
      use iso_c_binding
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocblas_dgemv_orig
      type(c_ptr),value :: handle
      integer(kind(rocblas_operation_none)),value :: trans
      integer(c_int),value :: m
      integer(c_int),value :: n
      real(c_double) :: alpha
      type(c_ptr),value :: A
      integer(c_int),value :: lda
      type(c_ptr),value :: x
      integer(c_int),value :: incx
      real(c_double) :: beta
      type(c_ptr),value :: y
      integer(c_int),value :: incy
    end function

#ifdef USE_FPOINTER_INTERFACES
    module procedure rocblas_dgemv_full_rank,rocblas_dgemv_rank_0,rocblas_dgemv_rank_1
#endif

  end interface
  
  interface rocblas_cgemv
    function rocblas_cgemv_orig(handle,trans,m,n,alpha,A,lda,x,incx,beta,y,incy) bind(c, name="rocblas_cgemv")
      use iso_c_binding
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocblas_cgemv_orig
      type(c_ptr),value :: handle
      integer(kind(rocblas_operation_none)),value :: trans
      integer(c_int),value :: m
      integer(c_int),value :: n
      complex(c_float_complex) :: alpha
      type(c_ptr),value :: A
      integer(c_int),value :: lda
      type(c_ptr),value :: x
      integer(c_int),value :: incx
      complex(c_float_complex) :: beta
      type(c_ptr),value :: y
      integer(c_int),value :: incy
    end function

#ifdef USE_FPOINTER_INTERFACES
    module procedure rocblas_cgemv_full_rank,rocblas_cgemv_rank_0,rocblas_cgemv_rank_1
#endif

  end interface
  !> ! \brief BLAS Level 2 API
  !> 
  !>     \details
  !>     xGEMV performs one of the matrix-vector operations
  !> 
  !>         y := alphaAx    + betay,   or
  !>         y := alphaATx + betay,   or
  !>         y := alphaAHx + betay,
  !> 
  !>     where alpha and beta are scalars, x and y are vectors and A is an
  !>     m by n matrix.
  !> 
  !>     @param[in]
  !>     handle    [rocblas_handle]
  !>               handle to the rocblas library context queue.
  !>     @param[in]
  !>     trans     [rocblas_operation]
  !>               indicates whether matrix A is tranposed (conjugated) or not
  !>     @param[in]
  !>     m         [rocblas_int]
  !>               number of rows of matrix A
  !>     @param[in]
  !>     n         [rocblas_int]
  !>               number of columns of matrix A
  !>     @param[in]
  !>     alpha     device pointer or host pointer to scalar alpha.
  !>     @param[in]
  !>     A         device pointer storing matrix A.
  !>     @param[in]
  !>     lda       [rocblas_int]
  !>               specifies the leading dimension of A.
  !>     @param[in]
  !>     x         device pointer storing vector x.
  !>     @param[in]
  !>     incx      [rocblas_int]
  !>               specifies the increment for the elements of x.
  !>     @param[in]
  !>     beta      device pointer or host pointer to scalar beta.
  !>     @param[inout]
  !>     y         device pointer storing vector y.
  !>     @param[in]
  !>     incy      [rocblas_int]
  !>               specifies the increment for the elements of y.
  !> 
  !>     
  interface rocblas_zgemv
    function rocblas_zgemv_orig(handle,trans,m,n,alpha,A,lda,x,incx,beta,y,incy) bind(c, name="rocblas_zgemv")
      use iso_c_binding
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocblas_zgemv_orig
      type(c_ptr),value :: handle
      integer(kind(rocblas_operation_none)),value :: trans
      integer(c_int),value :: m
      integer(c_int),value :: n
      complex(c_double_complex) :: alpha
      type(c_ptr),value :: A
      integer(c_int),value :: lda
      type(c_ptr),value :: x
      integer(c_int),value :: incx
      complex(c_double_complex) :: beta
      type(c_ptr),value :: y
      integer(c_int),value :: incy
    end function

#ifdef USE_FPOINTER_INTERFACES
    module procedure rocblas_zgemv_full_rank,rocblas_zgemv_rank_0,rocblas_zgemv_rank_1
#endif

  end interface
  
  interface rocblas_sgemv_batched
    function rocblas_sgemv_batched_orig(handle,trans,m,n,alpha,A,lda,x,incx,beta,y,incy,batch_count) bind(c, name="rocblas_sgemv_batched")
      use iso_c_binding
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocblas_sgemv_batched_orig
      type(c_ptr),value :: handle
      integer(kind(rocblas_operation_none)),value :: trans
      integer(c_int),value :: m
      integer(c_int),value :: n
      real(c_float) :: alpha
      type(c_ptr) :: A
      integer(c_int),value :: lda
      type(c_ptr) :: x
      integer(c_int),value :: incx
      real(c_float) :: beta
      type(c_ptr) :: y
      integer(c_int),value :: incy
      integer(c_int),value :: batch_count
    end function

#ifdef USE_FPOINTER_INTERFACES
    module procedure rocblas_sgemv_batched_full_rank,rocblas_sgemv_batched_rank_0,rocblas_sgemv_batched_rank_1
#endif

  end interface
  
  interface rocblas_dgemv_batched
    function rocblas_dgemv_batched_orig(handle,trans,m,n,alpha,A,lda,x,incx,beta,y,incy,batch_count) bind(c, name="rocblas_dgemv_batched")
      use iso_c_binding
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocblas_dgemv_batched_orig
      type(c_ptr),value :: handle
      integer(kind(rocblas_operation_none)),value :: trans
      integer(c_int),value :: m
      integer(c_int),value :: n
      real(c_double) :: alpha
      type(c_ptr) :: A
      integer(c_int),value :: lda
      type(c_ptr) :: x
      integer(c_int),value :: incx
      real(c_double) :: beta
      type(c_ptr) :: y
      integer(c_int),value :: incy
      integer(c_int),value :: batch_count
    end function

#ifdef USE_FPOINTER_INTERFACES
    module procedure rocblas_dgemv_batched_full_rank,rocblas_dgemv_batched_rank_0,rocblas_dgemv_batched_rank_1
#endif

  end interface
  
  interface rocblas_cgemv_batched
    function rocblas_cgemv_batched_orig(handle,trans,m,n,alpha,A,lda,x,incx,beta,y,incy,batch_count) bind(c, name="rocblas_cgemv_batched")
      use iso_c_binding
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocblas_cgemv_batched_orig
      type(c_ptr),value :: handle
      integer(kind(rocblas_operation_none)),value :: trans
      integer(c_int),value :: m
      integer(c_int),value :: n
      complex(c_float_complex) :: alpha
      type(c_ptr) :: A
      integer(c_int),value :: lda
      type(c_ptr) :: x
      integer(c_int),value :: incx
      complex(c_float_complex) :: beta
      type(c_ptr) :: y
      integer(c_int),value :: incy
      integer(c_int),value :: batch_count
    end function

#ifdef USE_FPOINTER_INTERFACES
    module procedure rocblas_cgemv_batched_full_rank,rocblas_cgemv_batched_rank_0,rocblas_cgemv_batched_rank_1
#endif

  end interface
  !> ! \brief BLAS Level 2 API
  !> 
  !>     \details
  !>     xGEMV_BATCHED performs a batch of matrix-vector operations
  !> 
  !>         y_i := alphaA_ix_i    + betay_i,   or
  !>         y_i := alphaA_iTx_i + betay_i,   or
  !>         y_i := alphaA_iHx_i + betay_i,
  !> 
  !>     where (A_i, x_i, y_i) is the i-th instance of the batch.
  !>     alpha and beta are scalars, x_i and y_i are vectors and A_i is an
  !>     m by n matrix, for i = 1, ..., batch_count.
  !> 
  !>     @param[in]
  !>     handle      [rocblas_handle]
  !>                 handle to the rocblas library context queue.
  !>     @param[in]
  !>     trans       [rocblas_operation]
  !>                 indicates whether matrices A_i are tranposed (conjugated) or not
  !>     @param[in]
  !>     m           [rocblas_int]
  !>                 number of rows of each matrix A_i
  !>     @param[in]
  !>     n           [rocblas_int]
  !>                 number of columns of each matrix A_i
  !>     @param[in]
  !>     alpha       device pointer or host pointer to scalar alpha.
  !>     @param[in]
  !>     A           device array of device pointers storing each matrix A_i.
  !>     @param[in]
  !>     lda         [rocblas_int]
  !>                 specifies the leading dimension of each matrix A_i.
  !>     @param[in]
  !>     x           device array of device pointers storing each vector x_i.
  !>     @param[in]
  !>     incx        [rocblas_int]
  !>                 specifies the increment for the elements of each vector x_i.
  !>     @param[in]
  !>     beta        device pointer or host pointer to scalar beta.
  !>     @param[inout]
  !>     y           device array of device pointers storing each vector y_i.
  !>     @param[in]
  !>     incy        [rocblas_int]
  !>                 specifies the increment for the elements of each vector y_i.
  !>     @param[in]
  !>     batch_count [rocblas_int]
  !>                 number of instances in the batch
  !> 
  !>     
  interface rocblas_zgemv_batched
    function rocblas_zgemv_batched_orig(handle,trans,m,n,alpha,A,lda,x,incx,beta,y,incy,batch_count) bind(c, name="rocblas_zgemv_batched")
      use iso_c_binding
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocblas_zgemv_batched_orig
      type(c_ptr),value :: handle
      integer(kind(rocblas_operation_none)),value :: trans
      integer(c_int),value :: m
      integer(c_int),value :: n
      complex(c_double_complex) :: alpha
      type(c_ptr) :: A
      integer(c_int),value :: lda
      type(c_ptr) :: x
      integer(c_int),value :: incx
      complex(c_double_complex) :: beta
      type(c_ptr) :: y
      integer(c_int),value :: incy
      integer(c_int),value :: batch_count
    end function

#ifdef USE_FPOINTER_INTERFACES
    module procedure rocblas_zgemv_batched_full_rank,rocblas_zgemv_batched_rank_0,rocblas_zgemv_batched_rank_1
#endif

  end interface
  
  interface rocblas_sgemv_strided_batched
    function rocblas_sgemv_strided_batched_orig(handle,transA,m,n,alpha,A,lda,strideA,x,incx,stridex,beta,y,incy,stridey,batch_count) bind(c, name="rocblas_sgemv_strided_batched")
      use iso_c_binding
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocblas_sgemv_strided_batched_orig
      type(c_ptr),value :: handle
      integer(kind(rocblas_operation_none)),value :: transA
      integer(c_int),value :: m
      integer(c_int),value :: n
      real(c_float) :: alpha
      type(c_ptr),value :: A
      integer(c_int),value :: lda
      integer(c_int64_t),value :: strideA
      type(c_ptr),value :: x
      integer(c_int),value :: incx
      integer(c_int64_t),value :: stridex
      real(c_float) :: beta
      type(c_ptr),value :: y
      integer(c_int),value :: incy
      integer(c_int64_t),value :: stridey
      integer(c_int),value :: batch_count
    end function

#ifdef USE_FPOINTER_INTERFACES
    module procedure rocblas_sgemv_strided_batched_full_rank,rocblas_sgemv_strided_batched_rank_0,rocblas_sgemv_strided_batched_rank_1
#endif

  end interface
  
  interface rocblas_dgemv_strided_batched
    function rocblas_dgemv_strided_batched_orig(handle,transA,m,n,alpha,A,lda,strideA,x,incx,stridex,beta,y,incy,stridey,batch_count) bind(c, name="rocblas_dgemv_strided_batched")
      use iso_c_binding
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocblas_dgemv_strided_batched_orig
      type(c_ptr),value :: handle
      integer(kind(rocblas_operation_none)),value :: transA
      integer(c_int),value :: m
      integer(c_int),value :: n
      real(c_double) :: alpha
      type(c_ptr),value :: A
      integer(c_int),value :: lda
      integer(c_int64_t),value :: strideA
      type(c_ptr),value :: x
      integer(c_int),value :: incx
      integer(c_int64_t),value :: stridex
      real(c_double) :: beta
      type(c_ptr),value :: y
      integer(c_int),value :: incy
      integer(c_int64_t),value :: stridey
      integer(c_int),value :: batch_count
    end function

#ifdef USE_FPOINTER_INTERFACES
    module procedure rocblas_dgemv_strided_batched_full_rank,rocblas_dgemv_strided_batched_rank_0,rocblas_dgemv_strided_batched_rank_1
#endif

  end interface
  
  interface rocblas_cgemv_strided_batched
    function rocblas_cgemv_strided_batched_orig(handle,transA,m,n,alpha,A,lda,strideA,x,incx,stridex,beta,y,incy,stridey,batch_count) bind(c, name="rocblas_cgemv_strided_batched")
      use iso_c_binding
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocblas_cgemv_strided_batched_orig
      type(c_ptr),value :: handle
      integer(kind(rocblas_operation_none)),value :: transA
      integer(c_int),value :: m
      integer(c_int),value :: n
      complex(c_float_complex) :: alpha
      type(c_ptr),value :: A
      integer(c_int),value :: lda
      integer(c_int64_t),value :: strideA
      type(c_ptr),value :: x
      integer(c_int),value :: incx
      integer(c_int64_t),value :: stridex
      complex(c_float_complex) :: beta
      type(c_ptr),value :: y
      integer(c_int),value :: incy
      integer(c_int64_t),value :: stridey
      integer(c_int),value :: batch_count
    end function

#ifdef USE_FPOINTER_INTERFACES
    module procedure rocblas_cgemv_strided_batched_full_rank,rocblas_cgemv_strided_batched_rank_0,rocblas_cgemv_strided_batched_rank_1
#endif

  end interface
  !> ! \brief BLAS Level 2 API
  !> 
  !>     \details
  !>     xGEMV_STRIDED_BATCHED performs a batch of matrix-vector operations
  !> 
  !>         y_i := alphaA_ix_i    + betay_i,   or
  !>         y_i := alphaA_iTx_i + betay_i,   or
  !>         y_i := alphaA_iHx_i + betay_i,
  !> 
  !>     where (A_i, x_i, y_i) is the i-th instance of the batch.
  !>     alpha and beta are scalars, x_i and y_i are vectors and A_i is an
  !>     m by n matrix, for i = 1, ..., batch_count.
  !> 
  !>     @param[in]
  !>     handle      [rocblas_handle]
  !>                 handle to the rocblas library context queue.
  !>     @param[in]
  !>     transA      [rocblas_operation]
  !>                 indicates whether matrices A_i are tranposed (conjugated) or not
  !>     @param[in]
  !>     m           [rocblas_int]
  !>                 number of rows of matrices A_i
  !>     @param[in]
  !>     n           [rocblas_int]
  !>                 number of columns of matrices A_i
  !>     @param[in]
  !>     alpha       device pointer or host pointer to scalar alpha.
  !>     @param[in]
  !>     A           device pointer to the first matrix (A_1) in the batch.
  !>     @param[in]
  !>     lda         [rocblas_int]
  !>                 specifies the leading dimension of matrices A_i.
  !>     @param[in]
  !>     strideA     [rocblas_stride]
  !>                 stride from the start of one matrix (A_i) and the next one (A_i+1)
  !>     @param[in]
  !>     x           device pointer to the first vector (x_1) in the batch.
  !>     @param[in]
  !>     incx        [rocblas_int]
  !>                 specifies the increment for the elements of vectors x_i.
  !>     @param[in]
  !>     stridex     [rocblas_stride]
  !>                 stride from the start of one vector (x_i) and the next one (x_i+1).
  !>                 There are no restrictions placed on stride_x, however the user should
  !>                 take care to ensure that stride_x is of appropriate size. When trans equals rocblas_operation_none
  !>                 this typically means stride_x >= n  incx, otherwise stride_x >= m  incx.
  !>     @param[in]
  !>     beta        device pointer or host pointer to scalar beta.
  !>     @param[inout]
  !>     y           device pointer to the first vector (y_1) in the batch.
  !>     @param[in]
  !>     incy        [rocblas_int]
  !>                 specifies the increment for the elements of vectors y_i.
  !>     @param[in]
  !>     stridey     [rocblas_stride]
  !>                 stride from the start of one vector (y_i) and the next one (y_i+1).
  !>                 There are no restrictions placed on stride_y, however the user should
  !>                 take care to ensure that stride_y is of appropriate size. When trans equals rocblas_operation_none
  !>                 this typically means stride_y >= m  incy, otherwise stride_y >= n  incy. stridey should be non zero.
  !>     @param[in]
  !>     batch_count [rocblas_int]
  !>                 number of instances in the batch
  !> 
  !>     
  interface rocblas_zgemv_strided_batched
    function rocblas_zgemv_strided_batched_orig(handle,transA,m,n,alpha,A,lda,strideA,x,incx,stridex,beta,y,incy,stridey,batch_count) bind(c, name="rocblas_zgemv_strided_batched")
      use iso_c_binding
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocblas_zgemv_strided_batched_orig
      type(c_ptr),value :: handle
      integer(kind(rocblas_operation_none)),value :: transA
      integer(c_int),value :: m
      integer(c_int),value :: n
      complex(c_double_complex) :: alpha
      type(c_ptr),value :: A
      integer(c_int),value :: lda
      integer(c_int64_t),value :: strideA
      type(c_ptr),value :: x
      integer(c_int),value :: incx
      integer(c_int64_t),value :: stridex
      complex(c_double_complex) :: beta
      type(c_ptr),value :: y
      integer(c_int),value :: incy
      integer(c_int64_t),value :: stridey
      integer(c_int),value :: batch_count
    end function

#ifdef USE_FPOINTER_INTERFACES
    module procedure rocblas_zgemv_strided_batched_full_rank,rocblas_zgemv_strided_batched_rank_0,rocblas_zgemv_strided_batched_rank_1
#endif

  end interface
  
  interface rocblas_chbmv
    function rocblas_chbmv_orig(handle,uplo,n,k,alpha,A,lda,x,incx,beta,y,incy) bind(c, name="rocblas_chbmv")
      use iso_c_binding
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocblas_chbmv_orig
      type(c_ptr),value :: handle
      integer(kind(rocblas_fill_upper)),value :: uplo
      integer(c_int),value :: n
      integer(c_int),value :: k
      complex(c_float_complex) :: alpha
      type(c_ptr),value :: A
      integer(c_int),value :: lda
      type(c_ptr),value :: x
      integer(c_int),value :: incx
      complex(c_float_complex) :: beta
      type(c_ptr),value :: y
      integer(c_int),value :: incy
    end function

#ifdef USE_FPOINTER_INTERFACES
    module procedure rocblas_chbmv_full_rank,rocblas_chbmv_rank_0,rocblas_chbmv_rank_1
#endif

  end interface
  !> ! \brief BLAS Level 2 API
  !> 
  !>     \details
  !>     xHBMV performs the matrix-vector operations
  !> 
  !>         y := alphaAx + betay
  !> 
  !>     where alpha and beta are scalars, x and y are n element vectors and A is an
  !>     n by n Hermitian band matrix, with k super-diagonals.
  !> 
  !>     @param[in]
  !>     handle    [rocblas_handle]
  !>               handle to the rocblas library context queue.
  !>     @param[in]
  !>     uplo      [rocblas_fill]
  !>               rocblas_fill_upper: The upper triangular part of A is being supplied.
  !>               rocblas_fill_lower: The lower triangular part of A is being supplied.
  !>     @param[in]
  !>     n         [rocblas_int]
  !>               the order of the matrix A.
  !>     @param[in]
  !>     k         [rocblas_int]
  !>               the number of super-diagonals of the matrix A. Must be >= 0.
  !>     @param[in]
  !>     alpha     device pointer or host pointer to scalar alpha.
  !>     @param[in]
  !>     A         device pointer storing matrix A. Of dimension (lda, n).
  !>               if uplo == rocblas_fill_upper:
  !>                 The leading (k + 1) by n part of A must contain the upper
  !>                 triangular band part of the Hermitian matrix, with the leading
  !>                 diagonal in row (k + 1), the first super-diagonal on the RHS
  !>                 of row k, etc.
  !>                 The top left k by x triangle of A will not be referenced.
  !>                     Ex (upper, lda = n = 4, k = 1):
  !>                     A                             Represented matrix
  !>                     (0,0) (5,9) (6,8) (7,7)       (1, 0) (5, 9) (0, 0) (0, 0)
  !>                     (1,0) (2,0) (3,0) (4,0)       (5,-9) (2, 0) (6, 8) (0, 0)
  !>                     (0,0) (0,0) (0,0) (0,0)       (0, 0) (6,-8) (3, 0) (7, 7)
  !>                     (0,0) (0,0) (0,0) (0,0)       (0, 0) (0, 0) (7,-7) (4, 0)
  !> 
  !>               if uplo == rocblas_fill_lower:
  !>                 The leading (k + 1) by n part of A must contain the lower
  !>                 triangular band part of the Hermitian matrix, with the leading
  !>                 diagonal in row (1), the first sub-diagonal on the LHS of
  !>                 row 2, etc.
  !>                 The bottom right k by k triangle of A will not be referenced.
  !>                     Ex (lower, lda = 2, n = 4, k = 1):
  !>                     A                               Represented matrix
  !>                     (1,0) (2,0) (3,0) (4,0)         (1, 0) (5,-9) (0, 0) (0, 0)
  !>                     (5,9) (6,8) (7,7) (0,0)         (5, 9) (2, 0) (6,-8) (0, 0)
  !>                                                     (0, 0) (6, 8) (3, 0) (7,-7)
  !>                                                     (0, 0) (0, 0) (7, 7) (4, 0)
  !> 
  !>               As a Hermitian matrix, the imaginary part of the main diagonal
  !>               of A will not be referenced and is assumed to be == 0.
  !>     @param[in]
  !>     lda       [rocblas_int]
  !>               specifies the leading dimension of A. must be >= k + 1
  !>     @param[in]
  !>     x         device pointer storing vector x.
  !>     @param[in]
  !>     incx      [rocblas_int]
  !>               specifies the increment for the elements of x.
  !>     @param[in]
  !>     beta      device pointer or host pointer to scalar beta.
  !>     @param[inout]
  !>     y         device pointer storing vector y.
  !>     @param[in]
  !>     incy      [rocblas_int]
  !>               specifies the increment for the elements of y.
  !> 
  !>     
  interface rocblas_zhbmv
    function rocblas_zhbmv_orig(handle,uplo,n,k,alpha,A,lda,x,incx,beta,y,incy) bind(c, name="rocblas_zhbmv")
      use iso_c_binding
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocblas_zhbmv_orig
      type(c_ptr),value :: handle
      integer(kind(rocblas_fill_upper)),value :: uplo
      integer(c_int),value :: n
      integer(c_int),value :: k
      complex(c_double_complex) :: alpha
      type(c_ptr),value :: A
      integer(c_int),value :: lda
      type(c_ptr),value :: x
      integer(c_int),value :: incx
      complex(c_double_complex) :: beta
      type(c_ptr),value :: y
      integer(c_int),value :: incy
    end function

#ifdef USE_FPOINTER_INTERFACES
    module procedure rocblas_zhbmv_full_rank,rocblas_zhbmv_rank_0,rocblas_zhbmv_rank_1
#endif

  end interface
  
  interface rocblas_chbmv_batched
    function rocblas_chbmv_batched_orig(handle,uplo,n,k,alpha,A,lda,x,incx,beta,y,incy,batch_count) bind(c, name="rocblas_chbmv_batched")
      use iso_c_binding
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocblas_chbmv_batched_orig
      type(c_ptr),value :: handle
      integer(kind(rocblas_fill_upper)),value :: uplo
      integer(c_int),value :: n
      integer(c_int),value :: k
      complex(c_float_complex) :: alpha
      type(c_ptr) :: A
      integer(c_int),value :: lda
      type(c_ptr) :: x
      integer(c_int),value :: incx
      complex(c_float_complex) :: beta
      type(c_ptr) :: y
      integer(c_int),value :: incy
      integer(c_int),value :: batch_count
    end function

#ifdef USE_FPOINTER_INTERFACES
    module procedure rocblas_chbmv_batched_full_rank,rocblas_chbmv_batched_rank_0,rocblas_chbmv_batched_rank_1
#endif

  end interface
  !> ! \brief BLAS Level 2 API
  !> 
  !>     \details
  !>     xHBMV_BATCHED performs one of the matrix-vector operations
  !> 
  !>         y_i := alphaA_ix_i + betay_i
  !> 
  !>     where alpha and beta are scalars, x_i and y_i are n element vectors and A_i is an
  !>     n by n Hermitian band matrix with k super-diagonals, for each batch in i = [1, batch_count].
  !> 
  !>     @param[in]
  !>     handle    [rocblas_handle]
  !>               handle to the rocblas library context queue.
  !>     @param[in]
  !>     uplo      [rocblas_fill]
  !>               rocblas_fill_upper: The upper triangular part of each A_i is being supplied.
  !>               rocblas_fill_lower: The lower triangular part of each A_i is being supplied.
  !>     @param[in]
  !>     n         [rocblas_int]
  !>               the order of each matrix A_i.
  !>     @param[in]
  !>     k         [rocblas_int]
  !>               the number of super-diagonals of each matrix A_i. Must be >= 0.
  !>     @param[in]
  !>     alpha     device pointer or host pointer to scalar alpha.
  !>     @param[in]
  !>     A         device array of device pointers storing each matrix_i A of dimension (lda, n).
  !>               if uplo == rocblas_fill_upper:
  !>                 The leading (k + 1) by n part of each A_i must contain the upper
  !>                 triangular band part of the Hermitian matrix, with the leading
  !>                 diagonal in row (k + 1), the first super-diagonal on the RHS
  !>                 of row k, etc.
  !>                 The top left k by x triangle of each A_i will not be referenced.
  !>                     Ex (upper, lda = n = 4, k = 1):
  !>                     A                             Represented matrix
  !>                     (0,0) (5,9) (6,8) (7,7)       (1, 0) (5, 9) (0, 0) (0, 0)
  !>                     (1,0) (2,0) (3,0) (4,0)       (5,-9) (2, 0) (6, 8) (0, 0)
  !>                     (0,0) (0,0) (0,0) (0,0)       (0, 0) (6,-8) (3, 0) (7, 7)
  !>                     (0,0) (0,0) (0,0) (0,0)       (0, 0) (0, 0) (7,-7) (4, 0)
  !> 
  !>               if uplo == rocblas_fill_lower:
  !>                 The leading (k + 1) by n part of each A_i must contain the lower
  !>                 triangular band part of the Hermitian matrix, with the leading
  !>                 diagonal in row (1), the first sub-diagonal on the LHS of
  !>                 row 2, etc.
  !>                 The bottom right k by k triangle of each A_i will not be referenced.
  !>                     Ex (lower, lda = 2, n = 4, k = 1):
  !>                     A                               Represented matrix
  !>                     (1,0) (2,0) (3,0) (4,0)         (1, 0) (5,-9) (0, 0) (0, 0)
  !>                     (5,9) (6,8) (7,7) (0,0)         (5, 9) (2, 0) (6,-8) (0, 0)
  !>                                                     (0, 0) (6, 8) (3, 0) (7,-7)
  !>                                                     (0, 0) (0, 0) (7, 7) (4, 0)
  !> 
  !>               As a Hermitian matrix, the imaginary part of the main diagonal
  !>               of each A_i will not be referenced and is assumed to be == 0.
  !>     @param[in]
  !>     lda       [rocblas_int]
  !>               specifies the leading dimension of each A_i. must be >= max(1, n)
  !>     @param[in]
  !>     x         device array of device pointers storing each vector x_i.
  !>     @param[in]
  !>     incx      [rocblas_int]
  !>               specifies the increment for the elements of each x_i.
  !>     @param[in]
  !>     beta      device pointer or host pointer to scalar beta.
  !>     @param[inout]
  !>     y         device array of device pointers storing each vector y_i.
  !>     @param[in]
  !>     incy      [rocblas_int]
  !>               specifies the increment for the elements of y.
  !>     @param[in]
  !>     batch_count [rocblas_int]
  !>                 number of instances in the batch.
  !> 
  !>     
  interface rocblas_zhbmv_batched
    function rocblas_zhbmv_batched_orig(handle,uplo,n,k,alpha,A,lda,x,incx,beta,y,incy,batch_count) bind(c, name="rocblas_zhbmv_batched")
      use iso_c_binding
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocblas_zhbmv_batched_orig
      type(c_ptr),value :: handle
      integer(kind(rocblas_fill_upper)),value :: uplo
      integer(c_int),value :: n
      integer(c_int),value :: k
      complex(c_double_complex) :: alpha
      type(c_ptr) :: A
      integer(c_int),value :: lda
      type(c_ptr) :: x
      integer(c_int),value :: incx
      complex(c_double_complex) :: beta
      type(c_ptr) :: y
      integer(c_int),value :: incy
      integer(c_int),value :: batch_count
    end function

#ifdef USE_FPOINTER_INTERFACES
    module procedure rocblas_zhbmv_batched_full_rank,rocblas_zhbmv_batched_rank_0,rocblas_zhbmv_batched_rank_1
#endif

  end interface
  
  interface rocblas_chbmv_strided_batched
    function rocblas_chbmv_strided_batched_orig(handle,uplo,n,k,alpha,A,lda,stride_A,x,incx,stride_x,beta,y,incy,stride_y,batch_count) bind(c, name="rocblas_chbmv_strided_batched")
      use iso_c_binding
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocblas_chbmv_strided_batched_orig
      type(c_ptr),value :: handle
      integer(kind(rocblas_fill_upper)),value :: uplo
      integer(c_int),value :: n
      integer(c_int),value :: k
      complex(c_float_complex) :: alpha
      type(c_ptr),value :: A
      integer(c_int),value :: lda
      integer(c_int64_t),value :: stride_A
      type(c_ptr),value :: x
      integer(c_int),value :: incx
      integer(c_int64_t),value :: stride_x
      complex(c_float_complex) :: beta
      type(c_ptr),value :: y
      integer(c_int),value :: incy
      integer(c_int64_t),value :: stride_y
      integer(c_int),value :: batch_count
    end function

#ifdef USE_FPOINTER_INTERFACES
    module procedure rocblas_chbmv_strided_batched_full_rank,rocblas_chbmv_strided_batched_rank_0,rocblas_chbmv_strided_batched_rank_1
#endif

  end interface
  !> ! \brief BLAS Level 2 API
  !> 
  !>     \details
  !>     xHBMV_STRIDED_BATCHED performs one of the matrix-vector operations
  !> 
  !>         y_i := alphaA_ix_i + betay_i
  !> 
  !>     where alpha and beta are scalars, x_i and y_i are n element vectors and A_i is an
  !>     n by n Hermitian band matrix with k super-diagonals, for each batch in i = [1, batch_count].
  !> 
  !>     @param[in]
  !>     handle    [rocblas_handle]
  !>               handle to the rocblas library context queue.
  !>     @param[in]
  !>     uplo      [rocblas_fill]
  !>               rocblas_fill_upper: The upper triangular part of each A_i is being supplied.
  !>               rocblas_fill_lower: The lower triangular part of each A_i is being supplied.
  !>     @param[in]
  !>     n         [rocblas_int]
  !>               the order of each matrix A_i.
  !>     @param[in]
  !>     k         [rocblas_int]
  !>               the number of super-diagonals of each matrix A_i. Must be >= 0.
  !>     @param[in]
  !>     alpha     device pointer or host pointer to scalar alpha.
  !>     @param[in]
  !>     A         device array pointing to the first matrix A_1. Each A_i is of dimension (lda, n).
  !>               if uplo == rocblas_fill_upper:
  !>                 The leading (k + 1) by n part of each A_i must contain the upper
  !>                 triangular band part of the Hermitian matrix, with the leading
  !>                 diagonal in row (k + 1), the first super-diagonal on the RHS
  !>                 of row k, etc.
  !>                 The top left k by x triangle of each A_i will not be referenced.
  !>                     Ex (upper, lda = n = 4, k = 1):
  !>                     A                             Represented matrix
  !>                     (0,0) (5,9) (6,8) (7,7)       (1, 0) (5, 9) (0, 0) (0, 0)
  !>                     (1,0) (2,0) (3,0) (4,0)       (5,-9) (2, 0) (6, 8) (0, 0)
  !>                     (0,0) (0,0) (0,0) (0,0)       (0, 0) (6,-8) (3, 0) (7, 7)
  !>                     (0,0) (0,0) (0,0) (0,0)       (0, 0) (0, 0) (7,-7) (4, 0)
  !> 
  !>               if uplo == rocblas_fill_lower:
  !>                 The leading (k + 1) by n part of each A_i must contain the lower
  !>                 triangular band part of the Hermitian matrix, with the leading
  !>                 diagonal in row (1), the first sub-diagonal on the LHS of
  !>                 row 2, etc.
  !>                 The bottom right k by k triangle of each A_i will not be referenced.
  !>                     Ex (lower, lda = 2, n = 4, k = 1):
  !>                     A                               Represented matrix
  !>                     (1,0) (2,0) (3,0) (4,0)         (1, 0) (5,-9) (0, 0) (0, 0)
  !>                     (5,9) (6,8) (7,7) (0,0)         (5, 9) (2, 0) (6,-8) (0, 0)
  !>                                                     (0, 0) (6, 8) (3, 0) (7,-7)
  !>                                                     (0, 0) (0, 0) (7, 7) (4, 0)
  !> 
  !>               As a Hermitian matrix, the imaginary part of the main diagonal
  !>               of each A_i will not be referenced and is assumed to be == 0.
  !>     @param[in]
  !>     lda       [rocblas_int]
  !>               specifies the leading dimension of each A_i. must be >= max(1, n)
  !>     @param[in]
  !>     stride_A  [rocblas_stride]
  !>               stride from the start of one matrix (A_i) and the next one (A_i+1)
  !>     @param[in]
  !>     x         device array pointing to the first vector y_1.
  !>     @param[in]
  !>     incx      [rocblas_int]
  !>               specifies the increment for the elements of each x_i.
  !>     @param[in]
  !>     stride_x  [rocblas_stride]
  !>               stride from the start of one vector (x_i) and the next one (x_i+1)
  !>     @param[in]
  !>     beta      device pointer or host pointer to scalar beta.
  !>     @param[inout]
  !>     y         device array pointing to the first vector y_1.
  !>     @param[in]
  !>     incy      [rocblas_int]
  !>               specifies the increment for the elements of y.
  !>     @param[in]
  !>     stride_y  [rocblas_stride]
  !>               stride from the start of one vector (y_i) and the next one (y_i+1)
  !>     @param[in]
  !>     batch_count [rocblas_int]
  !>                 number of instances in the batch.
  !> 
  !>     
  interface rocblas_zhbmv_strided_batched
    function rocblas_zhbmv_strided_batched_orig(handle,uplo,n,k,alpha,A,lda,stride_A,x,incx,stride_x,beta,y,incy,stride_y,batch_count) bind(c, name="rocblas_zhbmv_strided_batched")
      use iso_c_binding
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocblas_zhbmv_strided_batched_orig
      type(c_ptr),value :: handle
      integer(kind(rocblas_fill_upper)),value :: uplo
      integer(c_int),value :: n
      integer(c_int),value :: k
      complex(c_double_complex) :: alpha
      type(c_ptr),value :: A
      integer(c_int),value :: lda
      integer(c_int64_t),value :: stride_A
      type(c_ptr),value :: x
      integer(c_int),value :: incx
      integer(c_int64_t),value :: stride_x
      complex(c_double_complex) :: beta
      type(c_ptr),value :: y
      integer(c_int),value :: incy
      integer(c_int64_t),value :: stride_y
      integer(c_int),value :: batch_count
    end function

#ifdef USE_FPOINTER_INTERFACES
    module procedure rocblas_zhbmv_strided_batched_full_rank,rocblas_zhbmv_strided_batched_rank_0,rocblas_zhbmv_strided_batched_rank_1
#endif

  end interface
  
  interface rocblas_chemv
    function rocblas_chemv_orig(handle,uplo,n,alpha,A,lda,x,incx,beta,y,incy) bind(c, name="rocblas_chemv")
      use iso_c_binding
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocblas_chemv_orig
      type(c_ptr),value :: handle
      integer(kind(rocblas_fill_upper)),value :: uplo
      integer(c_int),value :: n
      complex(c_float_complex) :: alpha
      type(c_ptr),value :: A
      integer(c_int),value :: lda
      type(c_ptr),value :: x
      integer(c_int),value :: incx
      complex(c_float_complex) :: beta
      type(c_ptr),value :: y
      integer(c_int),value :: incy
    end function

#ifdef USE_FPOINTER_INTERFACES
    module procedure rocblas_chemv_full_rank,rocblas_chemv_rank_0,rocblas_chemv_rank_1
#endif

  end interface
  !> ! \brief BLAS Level 2 API
  !> 
  !>     \details
  !>     xHEMV performs one of the matrix-vector operations
  !> 
  !>         y := alphaAx + betay
  !> 
  !>     where alpha and beta are scalars, x and y are n element vectors and A is an
  !>     n by n Hermitian matrix.
  !> 
  !>     @param[in]
  !>     handle    [rocblas_handle]
  !>               handle to the rocblas library context queue.
  !>     @param[in]
  !>     uplo      [rocblas_fill]
  !>               rocblas_fill_upper: the upper triangular part of the Hermitian matrix A is supplied.
  !>               rocblas_fill_lower: the lower triangular part of the Hermitian matrix A is supplied.
  !>     @param[in]
  !>     n         [rocblas_int]
  !>               the order of the matrix A.
  !>     @param[in]
  !>     alpha     device pointer or host pointer to scalar alpha.
  !>     @param[in]
  !>     A         device pointer storing matrix A. Of dimension (lda, n).
  !>               if uplo == rocblas_fill_upper:
  !>                 The upper triangular part of A must contain
  !>                 the upper triangular part of a Hermitian matrix. The lower
  !>                 triangular part of A will not be referenced.
  !>               if uplo == rocblas_fill_lower:
  !>                 The lower triangular part of A must contain
  !>                 the lower triangular part of a Hermitian matrix. The upper
  !>                 triangular part of A will not be referenced.
  !>               As a Hermitian matrix, the imaginary part of the main diagonal
  !>               of A will not be referenced and is assumed to be == 0.
  !>     @param[in]
  !>     lda       [rocblas_int]
  !>               specifies the leading dimension of A. must be >= max(1, n)
  !>     @param[in]
  !>     x         device pointer storing vector x.
  !>     @param[in]
  !>     incx      [rocblas_int]
  !>               specifies the increment for the elements of x.
  !>     @param[in]
  !>     beta      device pointer or host pointer to scalar beta.
  !>     @param[inout]
  !>     y         device pointer storing vector y.
  !>     @param[in]
  !>     incy      [rocblas_int]
  !>               specifies the increment for the elements of y.
  !> 
  !>     
  interface rocblas_zhemv
    function rocblas_zhemv_orig(handle,uplo,n,alpha,A,lda,x,incx,beta,y,incy) bind(c, name="rocblas_zhemv")
      use iso_c_binding
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocblas_zhemv_orig
      type(c_ptr),value :: handle
      integer(kind(rocblas_fill_upper)),value :: uplo
      integer(c_int),value :: n
      complex(c_double_complex) :: alpha
      type(c_ptr),value :: A
      integer(c_int),value :: lda
      type(c_ptr),value :: x
      integer(c_int),value :: incx
      complex(c_double_complex) :: beta
      type(c_ptr),value :: y
      integer(c_int),value :: incy
    end function

#ifdef USE_FPOINTER_INTERFACES
    module procedure rocblas_zhemv_full_rank,rocblas_zhemv_rank_0,rocblas_zhemv_rank_1
#endif

  end interface
  
  interface rocblas_chemv_batched
    function rocblas_chemv_batched_orig(handle,uplo,n,alpha,A,lda,x,incx,beta,y,incy,batch_count) bind(c, name="rocblas_chemv_batched")
      use iso_c_binding
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocblas_chemv_batched_orig
      type(c_ptr),value :: handle
      integer(kind(rocblas_fill_upper)),value :: uplo
      integer(c_int),value :: n
      complex(c_float_complex) :: alpha
      type(c_ptr) :: A
      integer(c_int),value :: lda
      type(c_ptr) :: x
      integer(c_int),value :: incx
      complex(c_float_complex) :: beta
      type(c_ptr) :: y
      integer(c_int),value :: incy
      integer(c_int),value :: batch_count
    end function

#ifdef USE_FPOINTER_INTERFACES
    module procedure rocblas_chemv_batched_full_rank,rocblas_chemv_batched_rank_0,rocblas_chemv_batched_rank_1
#endif

  end interface
  !> ! \brief BLAS Level 2 API
  !> 
  !>     \details
  !>     xHEMV_BATCHED performs one of the matrix-vector operations
  !> 
  !>         y_i := alphaA_ix_i + betay_i
  !> 
  !>     where alpha and beta are scalars, x_i and y_i are n element vectors and A_i is an
  !>     n by n Hermitian matrix, for each batch in i = [1, batch_count].
  !> 
  !>     @param[in]
  !>     handle    [rocblas_handle]
  !>               handle to the rocblas library context queue.
  !>     @param[in]
  !>     uplo      [rocblas_fill]
  !>               rocblas_fill_upper: the upper triangular part of the Hermitian matrix A is supplied.
  !>               rocblas_fill_lower: the lower triangular part of the Hermitian matrix A is supplied.
  !>     @param[in]
  !>     n         [rocblas_int]
  !>               the order of each matrix A_i.
  !>     @param[in]
  !>     alpha     device pointer or host pointer to scalar alpha.
  !>     @param[in]
  !>     A         device array of device pointers storing each matrix A_i of dimension (lda, n).
  !>               if uplo == rocblas_fill_upper:
  !>                 The upper triangular part of each A_i must contain
  !>                 the upper triangular part of a Hermitian matrix. The lower
  !>                 triangular part of each A_i will not be referenced.
  !>               if uplo == rocblas_fill_lower:
  !>                 The lower triangular part of each A_i must contain
  !>                 the lower triangular part of a Hermitian matrix. The upper
  !>                 triangular part of each A_i will not be referenced.
  !>               As a Hermitian matrix, the imaginary part of the main diagonal
  !>               of each A_i will not be referenced and is assumed to be == 0.
  !>     @param[in]
  !>     lda       [rocblas_int]
  !>               specifies the leading dimension of each A_i. must be >= max(1, n)
  !>     @param[in]
  !>     x         device array of device pointers storing each vector x_i.
  !>     @param[in]
  !>     incx      [rocblas_int]
  !>               specifies the increment for the elements of each x_i.
  !>     @param[in]
  !>     beta      device pointer or host pointer to scalar beta.
  !>     @param[inout]
  !>     y         device array of device pointers storing each vector y_i.
  !>     @param[in]
  !>     incy      [rocblas_int]
  !>               specifies the increment for the elements of y.
  !>     @param[in]
  !>     batch_count [rocblas_int]
  !>                 number of instances in the batch.
  !> 
  !>     
  interface rocblas_zhemv_batched
    function rocblas_zhemv_batched_orig(handle,uplo,n,alpha,A,lda,x,incx,beta,y,incy,batch_count) bind(c, name="rocblas_zhemv_batched")
      use iso_c_binding
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocblas_zhemv_batched_orig
      type(c_ptr),value :: handle
      integer(kind(rocblas_fill_upper)),value :: uplo
      integer(c_int),value :: n
      complex(c_double_complex) :: alpha
      type(c_ptr) :: A
      integer(c_int),value :: lda
      type(c_ptr) :: x
      integer(c_int),value :: incx
      complex(c_double_complex) :: beta
      type(c_ptr) :: y
      integer(c_int),value :: incy
      integer(c_int),value :: batch_count
    end function

#ifdef USE_FPOINTER_INTERFACES
    module procedure rocblas_zhemv_batched_full_rank,rocblas_zhemv_batched_rank_0,rocblas_zhemv_batched_rank_1
#endif

  end interface
  
  interface rocblas_chemv_strided_batched
    function rocblas_chemv_strided_batched_orig(handle,uplo,n,alpha,A,lda,stride_A,x,incx,stride_x,beta,y,incy,stride_y,batch_count) bind(c, name="rocblas_chemv_strided_batched")
      use iso_c_binding
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocblas_chemv_strided_batched_orig
      type(c_ptr),value :: handle
      integer(kind(rocblas_fill_upper)),value :: uplo
      integer(c_int),value :: n
      complex(c_float_complex) :: alpha
      type(c_ptr),value :: A
      integer(c_int),value :: lda
      integer(c_int64_t),value :: stride_A
      type(c_ptr),value :: x
      integer(c_int),value :: incx
      integer(c_int64_t),value :: stride_x
      complex(c_float_complex) :: beta
      type(c_ptr),value :: y
      integer(c_int),value :: incy
      integer(c_int64_t),value :: stride_y
      integer(c_int),value :: batch_count
    end function

#ifdef USE_FPOINTER_INTERFACES
    module procedure rocblas_chemv_strided_batched_full_rank,rocblas_chemv_strided_batched_rank_0,rocblas_chemv_strided_batched_rank_1
#endif

  end interface
  !> ! \brief BLAS Level 2 API
  !> 
  !>     \details
  !>     xHEMV_STRIDED_BATCHED performs one of the matrix-vector operations
  !> 
  !>         y_i := alphaA_ix_i + betay_i
  !> 
  !>     where alpha and beta are scalars, x_i and y_i are n element vectors and A_i is an
  !>     n by n Hermitian matrix, for each batch in i = [1, batch_count].
  !> 
  !>     @param[in]
  !>     handle    [rocblas_handle]
  !>               handle to the rocblas library context queue.
  !>     @param[in]
  !>     uplo      [rocblas_fill]
  !>               rocblas_fill_upper: the upper triangular part of the Hermitian matrix A is supplied.
  !>               rocblas_fill_lower: the lower triangular part of the Hermitian matrix A is supplied.
  !>     @param[in]
  !>     n         [rocblas_int]
  !>               the order of each matrix A_i.
  !>     @param[in]
  !>     alpha     device pointer or host pointer to scalar alpha.
  !>     @param[in]
  !>     A         device array of device pointers storing each matrix A_i of dimension (lda, n).
  !>               if uplo == rocblas_fill_upper:
  !>                 The upper triangular part of each A_i must contain
  !>                 the upper triangular part of a Hermitian matrix. The lower
  !>                 triangular part of each A_i will not be referenced.
  !>               if uplo == rocblas_fill_lower:
  !>                 The lower triangular part of each A_i must contain
  !>                 the lower triangular part of a Hermitian matrix. The upper
  !>                 triangular part of each A_i will not be referenced.
  !>               As a Hermitian matrix, the imaginary part of the main diagonal
  !>               of each A_i will not be referenced and is assumed to be == 0.
  !>     @param[in]
  !>     lda       [rocblas_int]
  !>               specifies the leading dimension of each A_i. must be >= max(1, n)
  !>     @param[in]
  !>     x         device array of device pointers storing each vector x_i.
  !>     @param[in]
  !>     incx      [rocblas_int]
  !>               specifies the increment for the elements of each x_i.
  !>     @param[in]
  !>     beta      device pointer or host pointer to scalar beta.
  !>     @param[inout]
  !>     y         device array of device pointers storing each vector y_i.
  !>     @param[in]
  !>     incy      [rocblas_int]
  !>               specifies the increment for the elements of y.
  !>     @param[in]
  !>     batch_count [rocblas_int]
  !>                 number of instances in the batch.
  !> 
  !>     
  interface rocblas_zhemv_strided_batched
    function rocblas_zhemv_strided_batched_orig(handle,uplo,n,alpha,A,lda,stride_A,x,incx,stride_x,beta,y,incy,stride_y,batch_count) bind(c, name="rocblas_zhemv_strided_batched")
      use iso_c_binding
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocblas_zhemv_strided_batched_orig
      type(c_ptr),value :: handle
      integer(kind(rocblas_fill_upper)),value :: uplo
      integer(c_int),value :: n
      complex(c_double_complex) :: alpha
      type(c_ptr),value :: A
      integer(c_int),value :: lda
      integer(c_int64_t),value :: stride_A
      type(c_ptr),value :: x
      integer(c_int),value :: incx
      integer(c_int64_t),value :: stride_x
      complex(c_double_complex) :: beta
      type(c_ptr),value :: y
      integer(c_int),value :: incy
      integer(c_int64_t),value :: stride_y
      integer(c_int),value :: batch_count
    end function

#ifdef USE_FPOINTER_INTERFACES
    module procedure rocblas_zhemv_strided_batched_full_rank,rocblas_zhemv_strided_batched_rank_0,rocblas_zhemv_strided_batched_rank_1
#endif

  end interface
  
  interface rocblas_cher
    function rocblas_cher_orig(handle,uplo,n,alpha,x,incx,A,lda) bind(c, name="rocblas_cher")
      use iso_c_binding
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocblas_cher_orig
      type(c_ptr),value :: handle
      integer(kind(rocblas_fill_upper)),value :: uplo
      integer(c_int),value :: n
      real(c_float) :: alpha
      type(c_ptr),value :: x
      integer(c_int),value :: incx
      type(c_ptr),value :: A
      integer(c_int),value :: lda
    end function

#ifdef USE_FPOINTER_INTERFACES
    module procedure rocblas_cher_full_rank,rocblas_cher_rank_0,rocblas_cher_rank_1
#endif

  end interface
  !> ! \brief BLAS Level 2 API
  !> 
  !>     \details
  !>     xHER performs the matrix-vector operations
  !> 
  !>         A := A + alphaxxH
  !> 
  !>     where alpha is a real scalar, x is a vector, and A is an
  !>     n by n Hermitian matrix.
  !> 
  !>     @param[in]
  !>     handle    [rocblas_handle]
  !>               handle to the rocblas library context queue.
  !>     @param[in]
  !>     uplo      [rocblas_fill]
  !>               specifies whether the upper 'rocblas_fill_upper' or lower 'rocblas_fill_lower'
  !>               rocblas_fill_upper: The upper triangular part of A is supplied in A.
  !>               rocblas_fill_lower: The lower triangular part of A is supplied in A.
  !>     @param[in]
  !>     n         [rocblas_int]
  !>               the number of rows and columns of matrix A, must be at least 0.
  !>     @param[in]
  !>     alpha
  !>               device pointer or host pointer to scalar alpha.
  !>     @param[in]
  !>     x         device pointer storing vector x.
  !>     @param[in]
  !>     incx      [rocblas_int]
  !>               specifies the increment for the elements of x.
  !>     @param[inout]
  !>     A         device pointer storing the specified triangular portion of
  !>               the Hermitian matrix A. Of size (lda  n).
  !>               if uplo == rocblas_fill_upper:
  !>                 The upper triangular portion of the Hermitian matrix A is supplied. The lower
  !>                 triangluar portion will not be touched.
  !>             if uplo == rocblas_fill_lower:
  !>                 The lower triangular portion of the Hermitian matrix A is supplied. The upper
  !>                 triangular portion will not be touched.
  !>             Note that the imaginary part of the diagonal elements are not accessed and are assumed
  !>             to be 0.
  !>     @param[in]
  !>     lda       [rocblas_int]
  !>               specifies the leading dimension of A. Must be at least max(1, n).
  !>     
  interface rocblas_zher
    function rocblas_zher_orig(handle,uplo,n,alpha,x,incx,A,lda) bind(c, name="rocblas_zher")
      use iso_c_binding
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocblas_zher_orig
      type(c_ptr),value :: handle
      integer(kind(rocblas_fill_upper)),value :: uplo
      integer(c_int),value :: n
      real(c_double) :: alpha
      type(c_ptr),value :: x
      integer(c_int),value :: incx
      type(c_ptr),value :: A
      integer(c_int),value :: lda
    end function

#ifdef USE_FPOINTER_INTERFACES
    module procedure rocblas_zher_full_rank,rocblas_zher_rank_0,rocblas_zher_rank_1
#endif

  end interface
  
  interface rocblas_cher_batched
    function rocblas_cher_batched_orig(handle,uplo,n,alpha,x,incx,A,lda,batch_count) bind(c, name="rocblas_cher_batched")
      use iso_c_binding
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocblas_cher_batched_orig
      type(c_ptr),value :: handle
      integer(kind(rocblas_fill_upper)),value :: uplo
      integer(c_int),value :: n
      real(c_float) :: alpha
      type(c_ptr) :: x
      integer(c_int),value :: incx
      type(c_ptr) :: A
      integer(c_int),value :: lda
      integer(c_int),value :: batch_count
    end function

#ifdef USE_FPOINTER_INTERFACES
    module procedure rocblas_cher_batched_full_rank,rocblas_cher_batched_rank_0,rocblas_cher_batched_rank_1
#endif

  end interface
  !> ! \brief BLAS Level 2 API
  !> 
  !>     \details
  !>     xHER_BATCHED performs the matrix-vector operations
  !> 
  !>         A_i := A_i + alphax_ix_iH
  !> 
  !>     where alpha is a real scalar, x_i is a vector, and A_i is an
  !>     n by n symmetric matrix, for i = 1, ..., batch_count.
  !> 
  !>     @param[in]
  !>     handle    [rocblas_handle]
  !>               handle to the rocblas library context queue.
  !>     @param[in]
  !>     uplo      [rocblas_fill]
  !>               specifies whether the upper 'rocblas_fill_upper' or lower 'rocblas_fill_lower'
  !>               rocblas_fill_upper: The upper triangular part of each A_i is supplied in A.
  !>               rocblas_fill_lower: The lower triangular part of each A_i is supplied in A.
  !>     @param[in]
  !>     n         [rocblas_int]
  !>               the number of rows and columns of each matrix A_i, must be at least 0.
  !>     @param[in]
  !>     alpha
  !>               device pointer or host pointer to scalar alpha.
  !>     @param[in]
  !>     x         device array of device pointers storing each vector x_i.
  !>     @param[in]
  !>     incx      [rocblas_int]
  !>               specifies the increment for the elements of each x_i.
  !>     @param[inout]
  !>     A         device array of device pointers storing the specified triangular portion of
  !>               each Hermitian matrix A_i of at least size ((n  (n + 1))  2). Array is of at least size batch_count.
  !>               if uplo == rocblas_fill_upper:
  !>                 The upper triangular portion of each Hermitian matrix A_i is supplied. The lower triangular portion
  !>                 of each A_i will not be touched.
  !>             if uplo == rocblas_fill_lower:
  !>                 The lower triangular portion of each Hermitian matrix A_i is supplied. The upper triangular portion
  !>                 of each A_i will not be touched.
  !>             Note that the imaginary part of the diagonal elements are not accessed and are assumed
  !>             to be 0.
  !>     @param[in]
  !>     lda       [rocblas_int]
  !>               specifies the leading dimension of each A_i. Must be at least max(1, n).
  !>     @param[in]
  !>     batch_count [rocblas_int]
  !>                 number of instances in the batch.
  !>     
  interface rocblas_zher_batched
    function rocblas_zher_batched_orig(handle,uplo,n,alpha,x,incx,A,lda,batch_count) bind(c, name="rocblas_zher_batched")
      use iso_c_binding
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocblas_zher_batched_orig
      type(c_ptr),value :: handle
      integer(kind(rocblas_fill_upper)),value :: uplo
      integer(c_int),value :: n
      real(c_double) :: alpha
      type(c_ptr) :: x
      integer(c_int),value :: incx
      type(c_ptr) :: A
      integer(c_int),value :: lda
      integer(c_int),value :: batch_count
    end function

#ifdef USE_FPOINTER_INTERFACES
    module procedure rocblas_zher_batched_full_rank,rocblas_zher_batched_rank_0,rocblas_zher_batched_rank_1
#endif

  end interface
  
  interface rocblas_cher_strided_batched
    function rocblas_cher_strided_batched_orig(handle,uplo,n,alpha,x,incx,stride_x,A,lda,stride_A,batch_count) bind(c, name="rocblas_cher_strided_batched")
      use iso_c_binding
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocblas_cher_strided_batched_orig
      type(c_ptr),value :: handle
      integer(kind(rocblas_fill_upper)),value :: uplo
      integer(c_int),value :: n
      real(c_float) :: alpha
      type(c_ptr),value :: x
      integer(c_int),value :: incx
      integer(c_int64_t),value :: stride_x
      type(c_ptr),value :: A
      integer(c_int),value :: lda
      integer(c_int64_t),value :: stride_A
      integer(c_int),value :: batch_count
    end function

#ifdef USE_FPOINTER_INTERFACES
    module procedure rocblas_cher_strided_batched_full_rank,rocblas_cher_strided_batched_rank_0,rocblas_cher_strided_batched_rank_1
#endif

  end interface
  !> ! \brief BLAS Level 2 API
  !> 
  !>     \details
  !>     xHER_STRIDED_BATCHED performs the matrix-vector operations
  !> 
  !>         A_i := A_i + alphax_ix_iH
  !> 
  !>     where alpha is a real scalar, x_i is a vector, and A_i is an
  !>     n by n Hermitian matrix, for i = 1, ..., batch_count.
  !> 
  !>     @param[in]
  !>     handle    [rocblas_handle]
  !>               handle to the rocblas library context queue.
  !>     @param[in]
  !>     uplo      [rocblas_fill]
  !>               specifies whether the upper 'rocblas_fill_upper' or lower 'rocblas_fill_lower'
  !>               rocblas_fill_upper: The upper triangular part of each A_i is supplied in A.
  !>               rocblas_fill_lower: The lower triangular part of each A_i is supplied in A.
  !>     @param[in]
  !>     n         [rocblas_int]
  !>               the number of rows and columns of each matrix A_i, must be at least 0.
  !>     @param[in]
  !>     alpha
  !>               device pointer or host pointer to scalar alpha.
  !>     @param[in]
  !>     x         device pointer pointing to the first vector (x_1).
  !>     @param[in]
  !>     incx      [rocblas_int]
  !>               specifies the increment for the elements of each x_i.
  !>     @param[in]
  !>     stride_x  [rocblas_stride]
  !>               stride from the start of one vector (x_i) and the next one (x_i+1).
  !>     @param[inout]
  !>     A         device array of device pointers storing the specified triangular portion of
  !>               each Hermitian matrix A_i. Points to the first matrix (A_1).
  !>               if uplo == rocblas_fill_upper:
  !>                 The upper triangular portion of each Hermitian matrix A_i is supplied. The lower triangular
  !>                 portion of each A_i will not be touched.
  !>             if uplo == rocblas_fill_lower:
  !>                 The lower triangular portion of each Hermitian matrix A_i is supplied. The upper triangular
  !>                 portion of each A_i will not be touched.
  !>             Note that the imaginary part of the diagonal elements are not accessed and are assumed
  !>             to be 0.
  !>     @param[in]
  !>     lda       [rocblas_int]
  !>               specifies the leading dimension of each A_i.
  !>     @param[in]
  !>     stride_A    [rocblas_stride]
  !>                 stride from the start of one (A_i) and the next (A_i+1)
  !>     @param[in]
  !>     batch_count [rocblas_int]
  !>                 number of instances in the batch.
  !>     
  interface rocblas_zher_strided_batched
    function rocblas_zher_strided_batched_orig(handle,uplo,n,alpha,x,incx,stride_x,A,lda,stride_A,batch_count) bind(c, name="rocblas_zher_strided_batched")
      use iso_c_binding
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocblas_zher_strided_batched_orig
      type(c_ptr),value :: handle
      integer(kind(rocblas_fill_upper)),value :: uplo
      integer(c_int),value :: n
      real(c_double) :: alpha
      type(c_ptr),value :: x
      integer(c_int),value :: incx
      integer(c_int64_t),value :: stride_x
      type(c_ptr),value :: A
      integer(c_int),value :: lda
      integer(c_int64_t),value :: stride_A
      integer(c_int),value :: batch_count
    end function

#ifdef USE_FPOINTER_INTERFACES
    module procedure rocblas_zher_strided_batched_full_rank,rocblas_zher_strided_batched_rank_0,rocblas_zher_strided_batched_rank_1
#endif

  end interface
  
  interface rocblas_cher2
    function rocblas_cher2_orig(handle,uplo,n,alpha,x,incx,y,incy,A,lda) bind(c, name="rocblas_cher2")
      use iso_c_binding
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocblas_cher2_orig
      type(c_ptr),value :: handle
      integer(kind(rocblas_fill_upper)),value :: uplo
      integer(c_int),value :: n
      complex(c_float_complex) :: alpha
      type(c_ptr),value :: x
      integer(c_int),value :: incx
      type(c_ptr),value :: y
      integer(c_int),value :: incy
      type(c_ptr),value :: A
      integer(c_int),value :: lda
    end function

#ifdef USE_FPOINTER_INTERFACES
    module procedure rocblas_cher2_full_rank,rocblas_cher2_rank_0,rocblas_cher2_rank_1
#endif

  end interface
  !> ! \brief BLAS Level 2 API
  !> 
  !>     \details
  !>     xHER2 performs the matrix-vector operations
  !> 
  !>         A := A + alphaxyH + conj(alpha)yxH
  !> 
  !>     where alpha is a complex scalar, x and y are vectors, and A is an
  !>     n by n Hermitian matrix.
  !> 
  !>     @param[in]
  !>     handle    [rocblas_handle]
  !>               handle to the rocblas library context queue.
  !>     @param[in]
  !>     uplo      [rocblas_fill]
  !>               specifies whether the upper 'rocblas_fill_upper' or lower 'rocblas_fill_lower'
  !>               rocblas_fill_upper: The upper triangular part of A is supplied.
  !>               rocblas_fill_lower: The lower triangular part of A is supplied.
  !>     @param[in]
  !>     n         [rocblas_int]
  !>               the number of rows and columns of matrix A, must be at least 0.
  !>     @param[in]
  !>     alpha
  !>               device pointer or host pointer to scalar alpha.
  !>     @param[in]
  !>     x         device pointer storing vector x.
  !>     @param[in]
  !>     incx      [rocblas_int]
  !>               specifies the increment for the elements of x.
  !>     @param[in]
  !>     y         device pointer storing vector y.
  !>     @param[in]
  !>     incy      [rocblas_int]
  !>               specifies the increment for the elements of y.
  !>     @param[inout]
  !>     A         device pointer storing the specified triangular portion of
  !>               the Hermitian matrix A. Of size (lda, n).
  !>               if uplo == rocblas_fill_upper:
  !>                 The upper triangular portion of the Hermitian matrix A is supplied. The lower triangular
  !>                 portion of A will not be touched.
  !>             if uplo == rocblas_fill_lower:
  !>                 The lower triangular portion of the Hermitian matrix A is supplied. The upper triangular
  !>                 portion of A will not be touched.
  !>             Note that the imaginary part of the diagonal elements are not accessed and are assumed
  !>             to be 0.
  !>     @param[in]
  !>     lda       [rocblas_int]
  !>               specifies the leading dimension of A. Must be at least max(lda, 1).
  !>     
  interface rocblas_zher2
    function rocblas_zher2_orig(handle,uplo,n,alpha,x,incx,y,incy,A,lda) bind(c, name="rocblas_zher2")
      use iso_c_binding
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocblas_zher2_orig
      type(c_ptr),value :: handle
      integer(kind(rocblas_fill_upper)),value :: uplo
      integer(c_int),value :: n
      complex(c_double_complex) :: alpha
      type(c_ptr),value :: x
      integer(c_int),value :: incx
      type(c_ptr),value :: y
      integer(c_int),value :: incy
      type(c_ptr),value :: A
      integer(c_int),value :: lda
    end function

#ifdef USE_FPOINTER_INTERFACES
    module procedure rocblas_zher2_full_rank,rocblas_zher2_rank_0,rocblas_zher2_rank_1
#endif

  end interface
  
  interface rocblas_cher2_batched
    function rocblas_cher2_batched_orig(handle,uplo,n,alpha,x,incx,y,incy,A,lda,batch_count) bind(c, name="rocblas_cher2_batched")
      use iso_c_binding
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocblas_cher2_batched_orig
      type(c_ptr),value :: handle
      integer(kind(rocblas_fill_upper)),value :: uplo
      integer(c_int),value :: n
      complex(c_float_complex) :: alpha
      type(c_ptr) :: x
      integer(c_int),value :: incx
      type(c_ptr) :: y
      integer(c_int),value :: incy
      type(c_ptr) :: A
      integer(c_int),value :: lda
      integer(c_int),value :: batch_count
    end function

#ifdef USE_FPOINTER_INTERFACES
    module procedure rocblas_cher2_batched_full_rank,rocblas_cher2_batched_rank_0,rocblas_cher2_batched_rank_1
#endif

  end interface
  !> ! \brief BLAS Level 2 API
  !> 
  !>     \details
  !>     xHER2_BATCHED performs the matrix-vector operations
  !> 
  !>         A_i := A_i + alphax_iy_iH + conj(alpha)y_ix_iH
  !> 
  !>     where alpha is a complex scalar, x_i and y_i are vectors, and A_i is an
  !>     n by n Hermitian matrix for each batch in i = [1, batch_count].
  !> 
  !>     @param[in]
  !>     handle    [rocblas_handle]
  !>               handle to the rocblas library context queue.
  !>     @param[in]
  !>     uplo      [rocblas_fill]
  !>               specifies whether the upper 'rocblas_fill_upper' or lower 'rocblas_fill_lower'
  !>               rocblas_fill_upper: The upper triangular part of each A_i is supplied.
  !>               rocblas_fill_lower: The lower triangular part of each A_i is supplied.
  !>     @param[in]
  !>     n         [rocblas_int]
  !>               the number of rows and columns of each matrix A_i, must be at least 0.
  !>     @param[in]
  !>     alpha
  !>               device pointer or host pointer to scalar alpha.
  !>     @param[in]
  !>     x         device array of device pointers storing each vector x_i.
  !>     @param[in]
  !>     incx      [rocblas_int]
  !>               specifies the increment for the elements of x.
  !>     @param[in]
  !>     y         device array of device pointers storing each vector y_i.
  !>     @param[in]
  !>     incy      [rocblas_int]
  !>               specifies the increment for the elements of each y_i.
  !>     @param[inout]
  !>     A         device array of device pointers storing the specified triangular portion of
  !>               each Hermitian matrix A_i of size (lda, n).
  !>               if uplo == rocblas_fill_upper:
  !>                 The upper triangular portion of each Hermitian matrix A_i is supplied. The lower triangular
  !>                 portion of each A_i will not be touched.
  !>             if uplo == rocblas_fill_lower:
  !>                 The lower triangular portion of each Hermitian matrix A_i is supplied. The upper triangular
  !>                 portion of each A_i will not be touched.
  !>             Note that the imaginary part of the diagonal elements are not accessed and are assumed
  !>             to be 0.
  !>     @param[in]
  !>     lda       [rocblas_int]
  !>               specifies the leading dimension of each A_i. Must be at least max(lda, 1).
  !>     @param[in]
  !>     batch_count [rocblas_int]
  !>                 number of instances in the batch.
  !>     
  interface rocblas_zher2_batched
    function rocblas_zher2_batched_orig(handle,uplo,n,alpha,x,incx,y,incy,A,lda,batch_count) bind(c, name="rocblas_zher2_batched")
      use iso_c_binding
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocblas_zher2_batched_orig
      type(c_ptr),value :: handle
      integer(kind(rocblas_fill_upper)),value :: uplo
      integer(c_int),value :: n
      complex(c_double_complex) :: alpha
      type(c_ptr) :: x
      integer(c_int),value :: incx
      type(c_ptr) :: y
      integer(c_int),value :: incy
      type(c_ptr) :: A
      integer(c_int),value :: lda
      integer(c_int),value :: batch_count
    end function

#ifdef USE_FPOINTER_INTERFACES
    module procedure rocblas_zher2_batched_full_rank,rocblas_zher2_batched_rank_0,rocblas_zher2_batched_rank_1
#endif

  end interface
  
  interface rocblas_cher2_strided_batched
    function rocblas_cher2_strided_batched_orig(handle,uplo,n,alpha,x,incx,stride_x,y,incy,stride_y,A,lda,stride_A,batch_count) bind(c, name="rocblas_cher2_strided_batched")
      use iso_c_binding
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocblas_cher2_strided_batched_orig
      type(c_ptr),value :: handle
      integer(kind(rocblas_fill_upper)),value :: uplo
      integer(c_int),value :: n
      complex(c_float_complex) :: alpha
      type(c_ptr),value :: x
      integer(c_int),value :: incx
      integer(c_int64_t),value :: stride_x
      type(c_ptr),value :: y
      integer(c_int),value :: incy
      integer(c_int64_t),value :: stride_y
      type(c_ptr),value :: A
      integer(c_int),value :: lda
      integer(c_int64_t),value :: stride_A
      integer(c_int),value :: batch_count
    end function

#ifdef USE_FPOINTER_INTERFACES
    module procedure rocblas_cher2_strided_batched_full_rank,rocblas_cher2_strided_batched_rank_0,rocblas_cher2_strided_batched_rank_1
#endif

  end interface
  !> ! \brief BLAS Level 2 API
  !> 
  !>     \details
  !>     xHER2_STRIDED_BATCHED performs the matrix-vector operations
  !> 
  !>         A_i := A_i + alphax_iy_iH + conj(alpha)y_ix_iH
  !> 
  !>     where alpha is a complex scalar, x_i and y_i are vectors, and A_i is an
  !>     n by n Hermitian matrix for each batch in i = [1, batch_count].
  !> 
  !>     @param[in]
  !>     handle    [rocblas_handle]
  !>               handle to the rocblas library context queue.
  !>     @param[in]
  !>     uplo      [rocblas_fill]
  !>               specifies whether the upper 'rocblas_fill_upper' or lower 'rocblas_fill_lower'
  !>               rocblas_fill_upper: The upper triangular part of each A_i is supplied.
  !>               rocblas_fill_lower: The lower triangular part of each A_i is supplied.
  !>     @param[in]
  !>     n         [rocblas_int]
  !>               the number of rows and columns of each matrix A_i, must be at least 0.
  !>     @param[in]
  !>     alpha
  !>               device pointer or host pointer to scalar alpha.
  !>     @param[in]
  !>     x         device pointer pointing to the first vector x_1.
  !>     @param[in]
  !>     incx      [rocblas_int]
  !>               specifies the increment for the elements of each x_i.
  !>     @param[in]
  !>     stride_x  [rocblas_stride]
  !>               specifies the stride between the beginning of one vector (x_i) and the next (x_i+1).
  !>     @param[in]
  !>     y         device pointer pointing to the first vector y_i.
  !>     @param[in]
  !>     incy      [rocblas_int]
  !>               specifies the increment for the elements of each y_i.
  !>     @param[in]
  !>     stride_y  [rocblas_stride]
  !>               specifies the stride between the beginning of one vector (y_i) and the next (y_i+1).
  !>     @param[inout]
  !>     A         device pointer pointing to the first matrix (A_1). Stores the specified triangular portion of
  !>               each Hermitian matrix A_i.
  !>               if uplo == rocblas_fill_upper:
  !>                 The upper triangular portion of each Hermitian matrix A_i is supplied. The lower triangular
  !>                 portion of each A_i will not be touched.
  !>             if uplo == rocblas_fill_lower:
  !>                 The lower triangular portion of each Hermitian matrix A_i is supplied. The upper triangular
  !>                 portion of each A_i will not be touched.
  !>             Note that the imaginary part of the diagonal elements are not accessed and are assumed
  !>             to be 0.
  !>     @param[in]
  !>     lda       [rocblas_int]
  !>               specifies the leading dimension of each A_i. Must be at least max(lda, 1).
  !>     @param[in]
  !>     stride_A  [rocblas_stride]
  !>               specifies the stride between the beginning of one matrix (A_i) and the next (A_i+1).
  !>     @param[in]
  !>     batch_count [rocblas_int]
  !>                 number of instances in the batch.
  !>     
  interface rocblas_zher2_strided_batched
    function rocblas_zher2_strided_batched_orig(handle,uplo,n,alpha,x,incx,stride_x,y,incy,stride_y,A,lda,stride_A,batch_count) bind(c, name="rocblas_zher2_strided_batched")
      use iso_c_binding
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocblas_zher2_strided_batched_orig
      type(c_ptr),value :: handle
      integer(kind(rocblas_fill_upper)),value :: uplo
      integer(c_int),value :: n
      complex(c_double_complex) :: alpha
      type(c_ptr),value :: x
      integer(c_int),value :: incx
      integer(c_int64_t),value :: stride_x
      type(c_ptr),value :: y
      integer(c_int),value :: incy
      integer(c_int64_t),value :: stride_y
      type(c_ptr),value :: A
      integer(c_int),value :: lda
      integer(c_int64_t),value :: stride_A
      integer(c_int),value :: batch_count
    end function

#ifdef USE_FPOINTER_INTERFACES
    module procedure rocblas_zher2_strided_batched_full_rank,rocblas_zher2_strided_batched_rank_0,rocblas_zher2_strided_batched_rank_1
#endif

  end interface
  
  interface rocblas_chpmv
    function rocblas_chpmv_orig(handle,uplo,n,alpha,AP,x,incx,beta,y,incy) bind(c, name="rocblas_chpmv")
      use iso_c_binding
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocblas_chpmv_orig
      type(c_ptr),value :: handle
      integer(kind(rocblas_fill_upper)),value :: uplo
      integer(c_int),value :: n
      complex(c_float_complex) :: alpha
      type(c_ptr),value :: AP
      type(c_ptr),value :: x
      integer(c_int),value :: incx
      complex(c_float_complex) :: beta
      type(c_ptr),value :: y
      integer(c_int),value :: incy
    end function

#ifdef USE_FPOINTER_INTERFACES
    module procedure rocblas_chpmv_rank_0,rocblas_chpmv_rank_1
#endif

  end interface
  !> ! \brief BLAS Level 2 API
  !> 
  !>     \details
  !>     xHPMV performs the matrix-vector operation
  !> 
  !>         y := alphaAx + betay
  !> 
  !>     where alpha and beta are scalars, x and y are n element vectors and A is an
  !>     n by n Hermitian matrix, supplied in packed form (see description below).
  !> 
  !>     @param[in]
  !>     handle    [rocblas_handle]
  !>               handle to the rocblas library context queue.
  !>     @param[in]
  !>     uplo      [rocblas_fill]
  !>               rocblas_fill_upper: the upper triangular part of the Hermitian matrix A is supplied in AP.
  !>               rocblas_fill_lower: the lower triangular part of the Hermitian matrix A is supplied in AP.
  !>     @param[in]
  !>     n         [rocblas_int]
  !>               the order of the matrix A, must be >= 0.
  !>     @param[in]
  !>     alpha     device pointer or host pointer to scalar alpha.
  !>     @param[in]
  !>     AP        device pointer storing the packed version of the specified triangular portion of
  !>               the Hermitian matrix A. Of at least size ((n  (n + 1))  2).
  !>               if uplo == rocblas_fill_upper:
  !>                 The upper triangular portion of the Hermitian matrix A is supplied.
  !>                 The matrix is compacted so that AP contains the triangular portion column-by-column
  !>                 so that:
  !>                 AP(0) = A(0,0)
  !>                 AP(1) = A(0,1)
  !>                 AP(2) = A(1,1), etc.
  !>                     Ex: (rocblas_fill_upper; n = 3)
  !>                         (1, 0) (2, 1) (3, 2)
  !>                         (2,-1) (4, 0) (5,-1)    -----> [(1,0), (2,1), (4,0), (3,2), (5,-1), (6,0)]
  !>                         (3,-2) (5, 1) (6, 0)
  !>             if uplo == rocblas_fill_lower:
  !>                 The lower triangular portion of the Hermitian matrix A is supplied.
  !>                 The matrix is compacted so that AP contains the triangular portion column-by-column
  !>                 so that:
  !>                 AP(0) = A(0,0)
  !>                 AP(1) = A(1,0)
  !>                 AP(2) = A(2,1), etc.
  !>                     Ex: (rocblas_fill_lower; n = 3)
  !>                         (1, 0) (2, 1) (3, 2)
  !>                         (2,-1) (4, 0) (5,-1)    -----> [(1,0), (2,-1), (3,-2), (4,0), (5,1), (6,0)]
  !>                         (3,-2) (5, 1) (6, 0)
  !>             Note that the imaginary part of the diagonal elements are not accessed and are assumed
  !>             to be 0.
  !>     @param[in]
  !>     x         device pointer storing vector x.
  !>     @param[in]
  !>     incx      [rocblas_int]
  !>               specifies the increment for the elements of x.
  !>     @param[in]
  !>     beta      device pointer or host pointer to scalar beta.
  !>     @param[inout]
  !>     y         device pointer storing vector y.
  !>     @param[in]
  !>     incy      [rocblas_int]
  !>               specifies the increment for the elements of y.
  !> 
  !>     
  interface rocblas_zhpmv
    function rocblas_zhpmv_orig(handle,uplo,n,alpha,AP,x,incx,beta,y,incy) bind(c, name="rocblas_zhpmv")
      use iso_c_binding
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocblas_zhpmv_orig
      type(c_ptr),value :: handle
      integer(kind(rocblas_fill_upper)),value :: uplo
      integer(c_int),value :: n
      complex(c_double_complex) :: alpha
      type(c_ptr),value :: AP
      type(c_ptr),value :: x
      integer(c_int),value :: incx
      complex(c_double_complex) :: beta
      type(c_ptr),value :: y
      integer(c_int),value :: incy
    end function

#ifdef USE_FPOINTER_INTERFACES
    module procedure rocblas_zhpmv_rank_0,rocblas_zhpmv_rank_1
#endif

  end interface
  
  interface rocblas_chpmv_batched
    function rocblas_chpmv_batched_orig(handle,uplo,n,alpha,AP,x,incx,beta,y,incy,batch_count) bind(c, name="rocblas_chpmv_batched")
      use iso_c_binding
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocblas_chpmv_batched_orig
      type(c_ptr),value :: handle
      integer(kind(rocblas_fill_upper)),value :: uplo
      integer(c_int),value :: n
      complex(c_float_complex) :: alpha
      type(c_ptr) :: AP
      type(c_ptr) :: x
      integer(c_int),value :: incx
      complex(c_float_complex) :: beta
      type(c_ptr) :: y
      integer(c_int),value :: incy
      integer(c_int),value :: batch_count
    end function

#ifdef USE_FPOINTER_INTERFACES
    module procedure rocblas_chpmv_batched_full_rank,rocblas_chpmv_batched_rank_0,rocblas_chpmv_batched_rank_1
#endif

  end interface
  !> ! \brief BLAS Level 2 API
  !> 
  !>     \details
  !>     xHPMV_BATCHED performs the matrix-vector operation
  !> 
  !>         y_i := alphaA_ix_i + betay_i
  !> 
  !>     where alpha and beta are scalars, x_i and y_i are n element vectors and A_i is an
  !>     n by n Hermitian matrix, supplied in packed form (see description below),
  !>     for each batch in i = [1, batch_count].
  !> 
  !>     @param[in]
  !>     handle    [rocblas_handle]
  !>               handle to the rocblas library context queue.
  !>     @param[in]
  !>     uplo      [rocblas_fill]
  !>               rocblas_fill_upper: the upper triangular part of each Hermitian matrix A_i is supplied in AP.
  !>               rocblas_fill_lower: the lower triangular part of each Hermitian matrix A_i is supplied in AP.
  !>     @param[in]
  !>     n         [rocblas_int]
  !>               the order of each matrix A_i.
  !>     @param[in]
  !>     alpha     device pointer or host pointer to scalar alpha.
  !>     @param[in]
  !>     AP      device pointer of device pointers storing the packed version of the specified triangular
  !>             portion of each Hermitian matrix A_i. Each A_i is of at least size ((n  (n + 1))  2).
  !>             if uplo == rocblas_fill_upper:
  !>             The upper triangular portion of each Hermitian matrix A_i is supplied.
  !>             The matrix is compacted so that each AP_i contains the triangular portion column-by-column
  !>             so that:
  !>             AP(0) = A(0,0)
  !>             AP(1) = A(0,1)
  !>             AP(2) = A(1,1), etc.
  !>                 Ex: (rocblas_fill_upper; n = 3)
  !>                     (1, 0) (2, 1) (3, 2)
  !>                     (2,-1) (4, 0) (5,-1)    -----> [(1,0), (2,1), (4,0), (3,2), (5,-1), (6,0)]
  !>                     (3,-2) (5, 1) (6, 0)
  !>         if uplo == rocblas_fill_lower:
  !>             The lower triangular portion of each Hermitian matrix A_i is supplied.
  !>             The matrix is compacted so that each AP_i contains the triangular portion column-by-column
  !>             so that:
  !>             AP(0) = A(0,0)
  !>             AP(1) = A(1,0)
  !>             AP(2) = A(2,1), etc.
  !>                 Ex: (rocblas_fill_lower; n = 3)
  !>                     (1, 0) (2, 1) (3, 2)
  !>                     (2,-1) (4, 0) (5,-1)    -----> [(1,0), (2,-1), (3,-2), (4,0), (5,1), (6,0)]
  !>                     (3,-2) (5, 1) (6, 0)
  !>         Note that the imaginary part of the diagonal elements are not accessed and are assumed
  !>         to be 0.
  !>     @param[in]
  !>     x         device array of device pointers storing each vector x_i.
  !>     @param[in]
  !>     incx      [rocblas_int]
  !>               specifies the increment for the elements of each x_i.
  !>     @param[in]
  !>     beta      device pointer or host pointer to scalar beta.
  !>     @param[inout]
  !>     y         device array of device pointers storing each vector y_i.
  !>     @param[in]
  !>     incy      [rocblas_int]
  !>               specifies the increment for the elements of y.
  !>     @param[in]
  !>     batch_count [rocblas_int]
  !>                 number of instances in the batch.
  !> 
  !>     
  interface rocblas_zhpmv_batched
    function rocblas_zhpmv_batched_orig(handle,uplo,n,alpha,AP,x,incx,beta,y,incy,batch_count) bind(c, name="rocblas_zhpmv_batched")
      use iso_c_binding
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocblas_zhpmv_batched_orig
      type(c_ptr),value :: handle
      integer(kind(rocblas_fill_upper)),value :: uplo
      integer(c_int),value :: n
      complex(c_double_complex) :: alpha
      type(c_ptr) :: AP
      type(c_ptr) :: x
      integer(c_int),value :: incx
      complex(c_double_complex) :: beta
      type(c_ptr) :: y
      integer(c_int),value :: incy
      integer(c_int),value :: batch_count
    end function

#ifdef USE_FPOINTER_INTERFACES
    module procedure rocblas_zhpmv_batched_full_rank,rocblas_zhpmv_batched_rank_0,rocblas_zhpmv_batched_rank_1
#endif

  end interface
  
  interface rocblas_chpmv_strided_batched
    function rocblas_chpmv_strided_batched_orig(handle,uplo,n,alpha,AP,stride_A,x,incx,stride_x,beta,y,incy,stride_y,batch_count) bind(c, name="rocblas_chpmv_strided_batched")
      use iso_c_binding
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocblas_chpmv_strided_batched_orig
      type(c_ptr),value :: handle
      integer(kind(rocblas_fill_upper)),value :: uplo
      integer(c_int),value :: n
      complex(c_float_complex) :: alpha
      type(c_ptr),value :: AP
      integer(c_int64_t),value :: stride_A
      type(c_ptr),value :: x
      integer(c_int),value :: incx
      integer(c_int64_t),value :: stride_x
      complex(c_float_complex) :: beta
      type(c_ptr),value :: y
      integer(c_int),value :: incy
      integer(c_int64_t),value :: stride_y
      integer(c_int),value :: batch_count
    end function

#ifdef USE_FPOINTER_INTERFACES
    module procedure rocblas_chpmv_strided_batched_rank_0,rocblas_chpmv_strided_batched_rank_1
#endif

  end interface
  !> ! \brief BLAS Level 2 API
  !> 
  !>     \details
  !>     xHPMV_STRIDED_BATCHED performs the matrix-vector operation
  !> 
  !>         y_i := alphaA_ix_i + betay_i
  !> 
  !>     where alpha and beta are scalars, x_i and y_i are n element vectors and A_i is an
  !>     n by n Hermitian matrix, supplied in packed form (see description below),
  !>     for each batch in i = [1, batch_count].
  !> 
  !>     @param[in]
  !>     handle    [rocblas_handle]
  !>               handle to the rocblas library context queue.
  !>     @param[in]
  !>     uplo      [rocblas_fill]
  !>               rocblas_fill_upper: the upper triangular part of each Hermitian matrix A_i is supplied in AP.
  !>               rocblas_fill_lower: the lower triangular part of each Hermitian matrix A_i is supplied in AP.
  !>     @param[in]
  !>     n         [rocblas_int]
  !>               the order of each matrix A_i.
  !>     @param[in]
  !>     alpha     device pointer or host pointer to scalar alpha.
  !>     @param[in]
  !>     AP        device pointer pointing to the beginning of the first matrix (AP_1). Stores the packed
  !>               version of the specified triangular portion of each Hermitian matrix AP_i of size ((n  (n + 1))  2).
  !>               if uplo == rocblas_fill_upper:
  !>                 The upper triangular portion of each Hermitian matrix A_i is supplied.
  !>                 The matrix is compacted so that each AP_i contains the triangular portion column-by-column
  !>                 so that:
  !>                 AP(0) = A(0,0)
  !>                 AP(1) = A(0,1)
  !>                 AP(2) = A(1,1), etc.
  !>                     Ex: (rocblas_fill_upper; n = 3)
  !>                         (1, 0) (2, 1) (3, 2)
  !>                         (2,-1) (4, 0) (5,-1)    -----> [(1,0), (2,1), (4,0), (3,2), (5,-1), (6,0)]
  !>                         (3,-2) (5, 1) (6, 0)
  !>             if uplo == rocblas_fill_lower:
  !>                 The lower triangular portion of each Hermitian matrix A_i is supplied.
  !>                 The matrix is compacted so that each AP_i contains the triangular portion column-by-column
  !>                 so that:
  !>                 AP(0) = A(0,0)
  !>                 AP(1) = A(1,0)
  !>                 AP(2) = A(2,1), etc.
  !>                     Ex: (rocblas_fill_lower; n = 3)
  !>                         (1, 0) (2, 1) (3, 2)
  !>                         (2,-1) (4, 0) (5,-1)    -----> [(1,0), (2,-1), (3,-2), (4,0), (5,1), (6,0)]
  !>                         (3,-2) (5, 1) (6, 0)
  !>         Note that the imaginary part of the diagonal elements are not accessed and are assumed
  !>         to be 0.
  !>     @param[in]
  !>     stride_A  [rocblas_stride]
  !>               stride from the start of one matrix (AP_i) and the next one (AP_i+1).
  !>     @param[in]
  !>     x         device array pointing to the beginning of the first vector (x_1).
  !>     @param[in]
  !>     incx      [rocblas_int]
  !>               specifies the increment for the elements of each x_i.
  !>     @param[in]
  !>     stride_x  [rocblas_stride]
  !>               stride from the start of one vector (x_i) and the next one (x_i+1).
  !>     @param[in]
  !>     beta      device pointer or host pointer to scalar beta.
  !>     @param[inout]
  !>     y         device array pointing to the beginning of the first vector (y_1).
  !>     @param[in]
  !>     incy      [rocblas_int]
  !>               specifies the increment for the elements of y.
  !>     @param[in]
  !>     stride_y  [rocblas_stride]
  !>               stride from the start of one vector (y_i) and the next one (y_i+1).
  !>     @param[in]
  !>     batch_count [rocblas_int]
  !>                 number of instances in the batch.
  !> 
  !>     
  interface rocblas_zhpmv_strided_batched
    function rocblas_zhpmv_strided_batched_orig(handle,uplo,n,alpha,AP,stride_A,x,incx,stride_x,beta,y,incy,stride_y,batch_count) bind(c, name="rocblas_zhpmv_strided_batched")
      use iso_c_binding
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocblas_zhpmv_strided_batched_orig
      type(c_ptr),value :: handle
      integer(kind(rocblas_fill_upper)),value :: uplo
      integer(c_int),value :: n
      complex(c_double_complex) :: alpha
      type(c_ptr),value :: AP
      integer(c_int64_t),value :: stride_A
      type(c_ptr),value :: x
      integer(c_int),value :: incx
      integer(c_int64_t),value :: stride_x
      complex(c_double_complex) :: beta
      type(c_ptr),value :: y
      integer(c_int),value :: incy
      integer(c_int64_t),value :: stride_y
      integer(c_int),value :: batch_count
    end function

#ifdef USE_FPOINTER_INTERFACES
    module procedure rocblas_zhpmv_strided_batched_rank_0,rocblas_zhpmv_strided_batched_rank_1
#endif

  end interface
  
  interface rocblas_chpr
    function rocblas_chpr_orig(handle,uplo,n,alpha,x,incx,AP) bind(c, name="rocblas_chpr")
      use iso_c_binding
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocblas_chpr_orig
      type(c_ptr),value :: handle
      integer(kind(rocblas_fill_upper)),value :: uplo
      integer(c_int),value :: n
      real(c_float) :: alpha
      type(c_ptr),value :: x
      integer(c_int),value :: incx
      type(c_ptr),value :: AP
    end function

#ifdef USE_FPOINTER_INTERFACES
    module procedure rocblas_chpr_rank_0,rocblas_chpr_rank_1
#endif

  end interface
  !> ! \brief BLAS Level 2 API
  !> 
  !>     \details
  !>     xHPR performs the matrix-vector operations
  !> 
  !>         A := A + alphaxxH
  !> 
  !>     where alpha is a real scalar, x is a vector, and A is an
  !>     n by n Hermitian matrix, supplied in packed form.
  !> 
  !>     @param[in]
  !>     handle    [rocblas_handle]
  !>               handle to the rocblas library context queue.
  !>     @param[in]
  !>     uplo      [rocblas_fill]
  !>               specifies whether the upper 'rocblas_fill_upper' or lower 'rocblas_fill_lower'
  !>               rocblas_fill_upper: The upper triangular part of A is supplied in AP.
  !>               rocblas_fill_lower: The lower triangular part of A is supplied in AP.
  !>     @param[in]
  !>     n         [rocblas_int]
  !>               the number of rows and columns of matrix A, must be at least 0.
  !>     @param[in]
  !>     alpha
  !>               device pointer or host pointer to scalar alpha.
  !>     @param[in]
  !>     x         device pointer storing vector x.
  !>     @param[in]
  !>     incx      [rocblas_int]
  !>               specifies the increment for the elements of x.
  !>     @param[inout]
  !>     AP        device pointer storing the packed version of the specified triangular portion of
  !>               the Hermitian matrix A. Of at least size ((n  (n + 1))  2).
  !>               if uplo == rocblas_fill_upper:
  !>                 The upper triangular portion of the Hermitian matrix A is supplied.
  !>                 The matrix is compacted so that AP contains the triangular portion column-by-column
  !>                 so that:
  !>                 AP(0) = A(0,0)
  !>                 AP(1) = A(0,1)
  !>                 AP(2) = A(1,1), etc.
  !>                     Ex: (rocblas_fill_upper; n = 3)
  !>                         (1, 0) (2, 1) (4,9)
  !>                         (2,-1) (3, 0) (5,3)  -----> [(1,0), (2,1), (3,0), (4,9), (5,3), (6,0)]
  !>                         (4,-9) (5,-3) (6,0)
  !>             if uplo == rocblas_fill_lower:
  !>                 The lower triangular portion of the Hermitian matrix A is supplied.
  !>                 The matrix is compacted so that AP contains the triangular portion column-by-column
  !>                 so that:
  !>                 AP(0) = A(0,0)
  !>                 AP(1) = A(1,0)
  !>                 AP(2) = A(2,1), etc.
  !>                     Ex: (rocblas_fill_lower; n = 3)
  !>                         (1, 0) (2, 1) (4,9)
  !>                         (2,-1) (3, 0) (5,3)  -----> [(1,0), (2,-1), (4,-9), (3,0), (5,-3), (6,0)]
  !>                         (4,-9) (5,-3) (6,0)
  !>             Note that the imaginary part of the diagonal elements are not accessed and are assumed
  !>             to be 0.
  !>     
  interface rocblas_zhpr
    function rocblas_zhpr_orig(handle,uplo,n,alpha,x,incx,AP) bind(c, name="rocblas_zhpr")
      use iso_c_binding
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocblas_zhpr_orig
      type(c_ptr),value :: handle
      integer(kind(rocblas_fill_upper)),value :: uplo
      integer(c_int),value :: n
      real(c_double) :: alpha
      type(c_ptr),value :: x
      integer(c_int),value :: incx
      type(c_ptr),value :: AP
    end function

#ifdef USE_FPOINTER_INTERFACES
    module procedure rocblas_zhpr_rank_0,rocblas_zhpr_rank_1
#endif

  end interface
  
  interface rocblas_chpr_batched
    function rocblas_chpr_batched_orig(handle,uplo,n,alpha,x,incx,AP,batch_count) bind(c, name="rocblas_chpr_batched")
      use iso_c_binding
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocblas_chpr_batched_orig
      type(c_ptr),value :: handle
      integer(kind(rocblas_fill_upper)),value :: uplo
      integer(c_int),value :: n
      real(c_float) :: alpha
      type(c_ptr) :: x
      integer(c_int),value :: incx
      type(c_ptr) :: AP
      integer(c_int),value :: batch_count
    end function

#ifdef USE_FPOINTER_INTERFACES
    module procedure rocblas_chpr_batched_full_rank,rocblas_chpr_batched_rank_0,rocblas_chpr_batched_rank_1
#endif

  end interface
  !> ! \brief BLAS Level 2 API
  !> 
  !>     \details
  !>     xHPR_BATCHED performs the matrix-vector operations
  !> 
  !>         A_i := A_i + alphax_ix_iH
  !> 
  !>     where alpha is a real scalar, x_i is a vector, and A_i is an
  !>     n by n symmetric matrix, supplied in packed form, for i = 1, ..., batch_count.
  !> 
  !>     @param[in]
  !>     handle    [rocblas_handle]
  !>               handle to the rocblas library context queue.
  !>     @param[in]
  !>     uplo      [rocblas_fill]
  !>               specifies whether the upper 'rocblas_fill_upper' or lower 'rocblas_fill_lower'
  !>               rocblas_fill_upper: The upper triangular part of each A_i is supplied in AP.
  !>               rocblas_fill_lower: The lower triangular part of each A_i is supplied in AP.
  !>     @param[in]
  !>     n         [rocblas_int]
  !>               the number of rows and columns of each matrix A_i, must be at least 0.
  !>     @param[in]
  !>     alpha
  !>               device pointer or host pointer to scalar alpha.
  !>     @param[in]
  !>     x         device array of device pointers storing each vector x_i.
  !>     @param[in]
  !>     incx      [rocblas_int]
  !>               specifies the increment for the elements of each x_i.
  !>     @param[inout]
  !>     AP        device array of device pointers storing the packed version of the specified triangular portion of
  !>               each Hermitian matrix A_i of at least size ((n  (n + 1))  2). Array is of at least size batch_count.
  !>               if uplo == rocblas_fill_upper:
  !>                 The upper triangular portion of each Hermitian matrix A_i is supplied.
  !>                 The matrix is compacted so that AP contains the triangular portion column-by-column
  !>                 so that:
  !>                 AP(0) = A(0,0)
  !>                 AP(1) = A(0,1)
  !>                 AP(2) = A(1,1), etc.
  !>                     Ex: (rocblas_fill_upper; n = 3)
  !>                         (1, 0) (2, 1) (4,9)
  !>                         (2,-1) (3, 0) (5,3)  -----> [(1,0), (2,1), (3,0), (4,9), (5,3), (6,0)]
  !>                         (4,-9) (5,-3) (6,0)
  !>             if uplo == rocblas_fill_lower:
  !>                 The lower triangular portion of each Hermitian matrix A_i is supplied.
  !>                 The matrix is compacted so that AP contains the triangular portion column-by-column
  !>                 so that:
  !>                 AP(0) = A(0,0)
  !>                 AP(1) = A(1,0)
  !>                 AP(2) = A(2,1), etc.
  !>                     Ex: (rocblas_fill_lower; n = 3)
  !>                         (1, 0) (2, 1) (4,9)
  !>                         (2,-1) (3, 0) (5,3)  -----> [(1,0), (2,-1), (4,-9), (3,0), (5,-3), (6,0)]
  !>                         (4,-9) (5,-3) (6,0)
  !>             Note that the imaginary part of the diagonal elements are not accessed and are assumed
  !>             to be 0.
  !>     @param[in]
  !>     batch_count [rocblas_int]
  !>                 number of instances in the batch.
  !>     
  interface rocblas_zhpr_batched
    function rocblas_zhpr_batched_orig(handle,uplo,n,alpha,x,incx,AP,batch_count) bind(c, name="rocblas_zhpr_batched")
      use iso_c_binding
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocblas_zhpr_batched_orig
      type(c_ptr),value :: handle
      integer(kind(rocblas_fill_upper)),value :: uplo
      integer(c_int),value :: n
      real(c_double) :: alpha
      type(c_ptr) :: x
      integer(c_int),value :: incx
      type(c_ptr) :: AP
      integer(c_int),value :: batch_count
    end function

#ifdef USE_FPOINTER_INTERFACES
    module procedure rocblas_zhpr_batched_full_rank,rocblas_zhpr_batched_rank_0,rocblas_zhpr_batched_rank_1
#endif

  end interface
  
  interface rocblas_chpr_strided_batched
    function rocblas_chpr_strided_batched_orig(handle,uplo,n,alpha,x,incx,stride_x,AP,stride_A,batch_count) bind(c, name="rocblas_chpr_strided_batched")
      use iso_c_binding
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocblas_chpr_strided_batched_orig
      type(c_ptr),value :: handle
      integer(kind(rocblas_fill_upper)),value :: uplo
      integer(c_int),value :: n
      real(c_float) :: alpha
      type(c_ptr),value :: x
      integer(c_int),value :: incx
      integer(c_int64_t),value :: stride_x
      type(c_ptr),value :: AP
      integer(c_int64_t),value :: stride_A
      integer(c_int),value :: batch_count
    end function

#ifdef USE_FPOINTER_INTERFACES
    module procedure rocblas_chpr_strided_batched_rank_0,rocblas_chpr_strided_batched_rank_1
#endif

  end interface
  !> ! \brief BLAS Level 2 API
  !> 
  !>     \details
  !>     xHPR_STRIDED_BATCHED performs the matrix-vector operations
  !> 
  !>         A_i := A_i + alphax_ix_iH
  !> 
  !>     where alpha is a real scalar, x_i is a vector, and A_i is an
  !>     n by n symmetric matrix, supplied in packed form, for i = 1, ..., batch_count.
  !> 
  !>     @param[in]
  !>     handle    [rocblas_handle]
  !>               handle to the rocblas library context queue.
  !>     @param[in]
  !>     uplo      [rocblas_fill]
  !>               specifies whether the upper 'rocblas_fill_upper' or lower 'rocblas_fill_lower'
  !>               rocblas_fill_upper: The upper triangular part of each A_i is supplied in AP.
  !>               rocblas_fill_lower: The lower triangular part of each A_i is supplied in AP.
  !>     @param[in]
  !>     n         [rocblas_int]
  !>               the number of rows and columns of each matrix A_i, must be at least 0.
  !>     @param[in]
  !>     alpha
  !>               device pointer or host pointer to scalar alpha.
  !>     @param[in]
  !>     x         device pointer pointing to the first vector (x_1).
  !>     @param[in]
  !>     incx      [rocblas_int]
  !>               specifies the increment for the elements of each x_i.
  !>     @param[in]
  !>     stride_x  [rocblas_stride]
  !>               stride from the start of one vector (x_i) and the next one (x_i+1).
  !>     @param[inout]
  !>     AP        device array of device pointers storing the packed version of the specified triangular portion of
  !>               each Hermitian matrix A_i. Points to the first matrix (A_1).
  !>               if uplo == rocblas_fill_upper:
  !>                 The upper triangular portion of each Hermitian matrix A_i is supplied.
  !>                 The matrix is compacted so that AP contains the triangular portion column-by-column
  !>                 so that:
  !>                 AP(0) = A(0,0)
  !>                 AP(1) = A(0,1)
  !>                 AP(2) = A(1,1), etc.
  !>                     Ex: (rocblas_fill_upper; n = 3)
  !>                         (1, 0) (2, 1) (4,9)
  !>                         (2,-1) (3, 0) (5,3)  -----> [(1,0), (2,1), (3,0), (4,9), (5,3), (6,0)]
  !>                         (4,-9) (5,-3) (6,0)
  !>             if uplo == rocblas_fill_lower:
  !>                 The lower triangular portion of each Hermitian matrix A_i is supplied.
  !>                 The matrix is compacted so that AP contains the triangular portion column-by-column
  !>                 so that:
  !>                 AP(0) = A(0,0)
  !>                 AP(1) = A(1,0)
  !>                 AP(2) = A(2,1), etc.
  !>                     Ex: (rocblas_fill_lower; n = 3)
  !>                         (1, 0) (2, 1) (4,9)
  !>                         (2,-1) (3, 0) (5,3)  -----> [(1,0), (2,-1), (4,-9), (3,0), (5,-3), (6,0)]
  !>                         (4,-9) (5,-3) (6,0)
  !>             Note that the imaginary part of the diagonal elements are not accessed and are assumed
  !>             to be 0.
  !>     @param[in]
  !>     stride_A    [rocblas_stride]
  !>                 stride from the start of one (A_i) and the next (A_i+1)
  !>     @param[in]
  !>     batch_count [rocblas_int]
  !>                 number of instances in the batch.
  !>     
  interface rocblas_zhpr_strided_batched
    function rocblas_zhpr_strided_batched_orig(handle,uplo,n,alpha,x,incx,stride_x,AP,stride_A,batch_count) bind(c, name="rocblas_zhpr_strided_batched")
      use iso_c_binding
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocblas_zhpr_strided_batched_orig
      type(c_ptr),value :: handle
      integer(kind(rocblas_fill_upper)),value :: uplo
      integer(c_int),value :: n
      real(c_double) :: alpha
      type(c_ptr),value :: x
      integer(c_int),value :: incx
      integer(c_int64_t),value :: stride_x
      type(c_ptr),value :: AP
      integer(c_int64_t),value :: stride_A
      integer(c_int),value :: batch_count
    end function

#ifdef USE_FPOINTER_INTERFACES
    module procedure rocblas_zhpr_strided_batched_rank_0,rocblas_zhpr_strided_batched_rank_1
#endif

  end interface
  
  interface rocblas_chpr2
    function rocblas_chpr2_orig(handle,uplo,n,alpha,x,incx,y,incy,AP) bind(c, name="rocblas_chpr2")
      use iso_c_binding
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocblas_chpr2_orig
      type(c_ptr),value :: handle
      integer(kind(rocblas_fill_upper)),value :: uplo
      integer(c_int),value :: n
      complex(c_float_complex) :: alpha
      type(c_ptr),value :: x
      integer(c_int),value :: incx
      type(c_ptr),value :: y
      integer(c_int),value :: incy
      type(c_ptr),value :: AP
    end function

#ifdef USE_FPOINTER_INTERFACES
    module procedure rocblas_chpr2_rank_0,rocblas_chpr2_rank_1
#endif

  end interface
  !> ! \brief BLAS Level 2 API
  !> 
  !>     \details
  !>     xHPR2 performs the matrix-vector operations
  !> 
  !>         A := A + alphaxyH + conj(alpha)yxH
  !> 
  !>     where alpha is a complex scalar, x and y are vectors, and A is an
  !>     n by n Hermitian matrix, supplied in packed form.
  !> 
  !>     @param[in]
  !>     handle    [rocblas_handle]
  !>               handle to the rocblas library context queue.
  !>     @param[in]
  !>     uplo      [rocblas_fill]
  !>               specifies whether the upper 'rocblas_fill_upper' or lower 'rocblas_fill_lower'
  !>               rocblas_fill_upper: The upper triangular part of A is supplied in AP.
  !>               rocblas_fill_lower: The lower triangular part of A is supplied in AP.
  !>     @param[in]
  !>     n         [rocblas_int]
  !>               the number of rows and columns of matrix A, must be at least 0.
  !>     @param[in]
  !>     alpha
  !>               device pointer or host pointer to scalar alpha.
  !>     @param[in]
  !>     x         device pointer storing vector x.
  !>     @param[in]
  !>     incx      [rocblas_int]
  !>               specifies the increment for the elements of x.
  !>     @param[in]
  !>     y         device pointer storing vector y.
  !>     @param[in]
  !>     incy      [rocblas_int]
  !>               specifies the increment for the elements of y.
  !>     @param[inout]
  !>     AP        device pointer storing the packed version of the specified triangular portion of
  !>               the Hermitian matrix A. Of at least size ((n  (n + 1))  2).
  !>               if uplo == rocblas_fill_upper:
  !>                 The upper triangular portion of the Hermitian matrix A is supplied.
  !>                 The matrix is compacted so that AP contains the triangular portion column-by-column
  !>                 so that:
  !>                 AP(0) = A(0,0)
  !>                 AP(1) = A(0,1)
  !>                 AP(2) = A(1,1), etc.
  !>                     Ex: (rocblas_fill_upper; n = 3)
  !>                         (1, 0) (2, 1) (4,9)
  !>                         (2,-1) (3, 0) (5,3)  -----> [(1,0), (2,1), (3,0), (4,9), (5,3), (6,0)]
  !>                         (4,-9) (5,-3) (6,0)
  !>             if uplo == rocblas_fill_lower:
  !>                 The lower triangular portion of the Hermitian matrix A is supplied.
  !>                 The matrix is compacted so that AP contains the triangular portion column-by-column
  !>                 so that:
  !>                 AP(0) = A(0,0)
  !>                 AP(1) = A(1,0)
  !>                 AP(2) = A(2,1), etc.
  !>                     Ex: (rocblas_fill_lower; n = 3)
  !>                         (1, 0) (2, 1) (4,9)
  !>                         (2,-1) (3, 0) (5,3)  -----> [(1,0), (2,-1), (4,-9), (3,0), (5,-3), (6,0)]
  !>                         (4,-9) (5,-3) (6,0)
  !>             Note that the imaginary part of the diagonal elements are not accessed and are assumed
  !>             to be 0.
  !>     
  interface rocblas_zhpr2
    function rocblas_zhpr2_orig(handle,uplo,n,alpha,x,incx,y,incy,AP) bind(c, name="rocblas_zhpr2")
      use iso_c_binding
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocblas_zhpr2_orig
      type(c_ptr),value :: handle
      integer(kind(rocblas_fill_upper)),value :: uplo
      integer(c_int),value :: n
      complex(c_double_complex) :: alpha
      type(c_ptr),value :: x
      integer(c_int),value :: incx
      type(c_ptr),value :: y
      integer(c_int),value :: incy
      type(c_ptr),value :: AP
    end function

#ifdef USE_FPOINTER_INTERFACES
    module procedure rocblas_zhpr2_rank_0,rocblas_zhpr2_rank_1
#endif

  end interface
  
  interface rocblas_chpr2_batched
    function rocblas_chpr2_batched_orig(handle,uplo,n,alpha,x,incx,y,incy,AP,batch_count) bind(c, name="rocblas_chpr2_batched")
      use iso_c_binding
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocblas_chpr2_batched_orig
      type(c_ptr),value :: handle
      integer(kind(rocblas_fill_upper)),value :: uplo
      integer(c_int),value :: n
      complex(c_float_complex) :: alpha
      type(c_ptr) :: x
      integer(c_int),value :: incx
      type(c_ptr) :: y
      integer(c_int),value :: incy
      type(c_ptr) :: AP
      integer(c_int),value :: batch_count
    end function

#ifdef USE_FPOINTER_INTERFACES
    module procedure rocblas_chpr2_batched_full_rank,rocblas_chpr2_batched_rank_0,rocblas_chpr2_batched_rank_1
#endif

  end interface
  !> ! \brief BLAS Level 2 API
  !> 
  !>     \details
  !>     xHPR2_BATCHED performs the matrix-vector operations
  !> 
  !>         A_i := A_i + alphax_iy_iH + conj(alpha)y_ix_iH
  !> 
  !>     where alpha is a complex scalar, x_i and y_i are vectors, and A_i is an
  !>     n by n symmetric matrix, supplied in packed form, for i = 1, ..., batch_count.
  !> 
  !>     @param[in]
  !>     handle    [rocblas_handle]
  !>               handle to the rocblas library context queue.
  !>     @param[in]
  !>     uplo      [rocblas_fill]
  !>               specifies whether the upper 'rocblas_fill_upper' or lower 'rocblas_fill_lower'
  !>               rocblas_fill_upper: The upper triangular part of each A_i is supplied in AP.
  !>               rocblas_fill_lower: The lower triangular part of each A_i is supplied in AP.
  !>     @param[in]
  !>     n         [rocblas_int]
  !>               the number of rows and columns of each matrix A_i, must be at least 0.
  !>     @param[in]
  !>     alpha
  !>               device pointer or host pointer to scalar alpha.
  !>     @param[in]
  !>     x         device array of device pointers storing each vector x_i.
  !>     @param[in]
  !>     incx      [rocblas_int]
  !>               specifies the increment for the elements of each x_i.
  !>     @param[in]
  !>     y         device array of device pointers storing each vector y_i.
  !>     @param[in]
  !>     incy      [rocblas_int]
  !>               specifies the increment for the elements of each y_i.
  !>     @param[inout]
  !>     AP        device array of device pointers storing the packed version of the specified triangular portion of
  !>               each Hermitian matrix A_i of at least size ((n  (n + 1))  2). Array is of at least size batch_count.
  !>               if uplo == rocblas_fill_upper:
  !>                 The upper triangular portion of each Hermitian matrix A_i is supplied.
  !>                 The matrix is compacted so that AP contains the triangular portion column-by-column
  !>                 so that:
  !>                 AP(0) = A(0,0)
  !>                 AP(1) = A(0,1)
  !>                 AP(2) = A(1,1), etc.
  !>                     Ex: (rocblas_fill_upper; n = 3)
  !>                         (1, 0) (2, 1) (4,9)
  !>                         (2,-1) (3, 0) (5,3)  -----> [(1,0), (2,1), (3,0), (4,9), (5,3), (6,0)]
  !>                         (4,-9) (5,-3) (6,0)
  !>             if uplo == rocblas_fill_lower:
  !>                 The lower triangular portion of each Hermitian matrix A_i is supplied.
  !>                 The matrix is compacted so that AP contains the triangular portion column-by-column
  !>                 so that:
  !>                 AP(0) = A(0,0)
  !>                 AP(1) = A(1,0)
  !>                 AP(2) = A(2,1), etc.
  !>                     Ex: (rocblas_fill_lower; n = 3)
  !>                         (1, 0) (2, 1) (4,9)
  !>                         (2,-1) (3, 0) (5,3)  -----> [(1,0), (2,-1), (4,-9), (3,0), (5,-3), (6,0)]
  !>                         (4,-9) (5,-3) (6,0)
  !>             Note that the imaginary part of the diagonal elements are not accessed and are assumed
  !>             to be 0.
  !>     @param[in]
  !>     batch_count [rocblas_int]
  !>                 number of instances in the batch.
  !>     
  interface rocblas_zhpr2_batched
    function rocblas_zhpr2_batched_orig(handle,uplo,n,alpha,x,incx,y,incy,AP,batch_count) bind(c, name="rocblas_zhpr2_batched")
      use iso_c_binding
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocblas_zhpr2_batched_orig
      type(c_ptr),value :: handle
      integer(kind(rocblas_fill_upper)),value :: uplo
      integer(c_int),value :: n
      complex(c_double_complex) :: alpha
      type(c_ptr) :: x
      integer(c_int),value :: incx
      type(c_ptr) :: y
      integer(c_int),value :: incy
      type(c_ptr) :: AP
      integer(c_int),value :: batch_count
    end function

#ifdef USE_FPOINTER_INTERFACES
    module procedure rocblas_zhpr2_batched_full_rank,rocblas_zhpr2_batched_rank_0,rocblas_zhpr2_batched_rank_1
#endif

  end interface
  
  interface rocblas_chpr2_strided_batched
    function rocblas_chpr2_strided_batched_orig(handle,uplo,n,alpha,x,incx,stride_x,y,incy,stride_y,AP,stride_A,batch_count) bind(c, name="rocblas_chpr2_strided_batched")
      use iso_c_binding
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocblas_chpr2_strided_batched_orig
      type(c_ptr),value :: handle
      integer(kind(rocblas_fill_upper)),value :: uplo
      integer(c_int),value :: n
      complex(c_float_complex) :: alpha
      type(c_ptr),value :: x
      integer(c_int),value :: incx
      integer(c_int64_t),value :: stride_x
      type(c_ptr),value :: y
      integer(c_int),value :: incy
      integer(c_int64_t),value :: stride_y
      type(c_ptr),value :: AP
      integer(c_int64_t),value :: stride_A
      integer(c_int),value :: batch_count
    end function

#ifdef USE_FPOINTER_INTERFACES
    module procedure rocblas_chpr2_strided_batched_rank_0,rocblas_chpr2_strided_batched_rank_1
#endif

  end interface
  !> ! \brief BLAS Level 2 API
  !> 
  !>     \details
  !>     xHPR2_STRIDED_BATCHED performs the matrix-vector operations
  !> 
  !>         A_i := A_i + alphax_iy_iH + conj(alpha)y_ix_iH
  !> 
  !>     where alpha is a complex scalar, x_i and y_i are vectors, and A_i is an
  !>     n by n symmetric matrix, supplied in packed form, for i = 1, ..., batch_count.
  !> 
  !>     @param[in]
  !>     handle    [rocblas_handle]
  !>               handle to the rocblas library context queue.
  !>     @param[in]
  !>     uplo      [rocblas_fill]
  !>               specifies whether the upper 'rocblas_fill_upper' or lower 'rocblas_fill_lower'
  !>               rocblas_fill_upper: The upper triangular part of each A_i is supplied in AP.
  !>               rocblas_fill_lower: The lower triangular part of each A_i is supplied in AP.
  !>     @param[in]
  !>     n         [rocblas_int]
  !>               the number of rows and columns of each matrix A_i, must be at least 0.
  !>     @param[in]
  !>     alpha
  !>               device pointer or host pointer to scalar alpha.
  !>     @param[in]
  !>     x         device pointer pointing to the first vector (x_1).
  !>     @param[in]
  !>     incx      [rocblas_int]
  !>               specifies the increment for the elements of each x_i.
  !>     @param[in]
  !>     stride_x  [rocblas_stride]
  !>               stride from the start of one vector (x_i) and the next one (x_i+1).
  !>     @param[in]
  !>     y         device pointer pointing to the first vector (y_1).
  !>     @param[in]
  !>     incy      [rocblas_int]
  !>               specifies the increment for the elements of each y_i.
  !>     @param[in]
  !>     stride_y  [rocblas_stride]
  !>               stride from the start of one vector (y_i) and the next one (y_i+1).
  !>     @param[inout]
  !>     AP        device array of device pointers storing the packed version of the specified triangular portion of
  !>               each Hermitian matrix A_i. Points to the first matrix (A_1).
  !>               if uplo == rocblas_fill_upper:
  !>                 The upper triangular portion of each Hermitian matrix A_i is supplied.
  !>                 The matrix is compacted so that AP contains the triangular portion column-by-column
  !>                 so that:
  !>                 AP(0) = A(0,0)
  !>                 AP(1) = A(0,1)
  !>                 AP(2) = A(1,1), etc.
  !>                     Ex: (rocblas_fill_upper; n = 3)
  !>                         (1, 0) (2, 1) (4,9)
  !>                         (2,-1) (3, 0) (5,3)  -----> [(1,0), (2,1), (3,0), (4,9), (5,3), (6,0)]
  !>                         (4,-9) (5,-3) (6,0)
  !>             if uplo == rocblas_fill_lower:
  !>                 The lower triangular portion of each Hermitian matrix A_i is supplied.
  !>                 The matrix is compacted so that AP contains the triangular portion column-by-column
  !>                 so that:
  !>                 AP(0) = A(0,0)
  !>                 AP(1) = A(1,0)
  !>                 AP(2) = A(2,1), etc.
  !>                     Ex: (rocblas_fill_lower; n = 3)
  !>                         (1, 0) (2, 1) (4,9)
  !>                         (2,-1) (3, 0) (5,3)  -----> [(1,0), (2,-1), (4,-9), (3,0), (5,-3), (6,0)]
  !>                         (4,-9) (5,-3) (6,0)
  !>             Note that the imaginary part of the diagonal elements are not accessed and are assumed
  !>             to be 0.
  !>     @param[in]
  !>     stride_A    [rocblas_stride]
  !>                 stride from the start of one (A_i) and the next (A_i+1)
  !>     @param[in]
  !>     batch_count [rocblas_int]
  !>                 number of instances in the batch.
  !>     
  interface rocblas_zhpr2_strided_batched
    function rocblas_zhpr2_strided_batched_orig(handle,uplo,n,alpha,x,incx,stride_x,y,incy,stride_y,AP,stride_A,batch_count) bind(c, name="rocblas_zhpr2_strided_batched")
      use iso_c_binding
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocblas_zhpr2_strided_batched_orig
      type(c_ptr),value :: handle
      integer(kind(rocblas_fill_upper)),value :: uplo
      integer(c_int),value :: n
      complex(c_double_complex) :: alpha
      type(c_ptr),value :: x
      integer(c_int),value :: incx
      integer(c_int64_t),value :: stride_x
      type(c_ptr),value :: y
      integer(c_int),value :: incy
      integer(c_int64_t),value :: stride_y
      type(c_ptr),value :: AP
      integer(c_int64_t),value :: stride_A
      integer(c_int),value :: batch_count
    end function

#ifdef USE_FPOINTER_INTERFACES
    module procedure rocblas_zhpr2_strided_batched_rank_0,rocblas_zhpr2_strided_batched_rank_1
#endif

  end interface
  
  interface rocblas_strmv
    function rocblas_strmv_orig(handle,uplo,transA,diag,m,A,lda,x,incx) bind(c, name="rocblas_strmv")
      use iso_c_binding
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocblas_strmv_orig
      type(c_ptr),value :: handle
      integer(kind(rocblas_fill_upper)),value :: uplo
      integer(kind(rocblas_operation_none)),value :: transA
      integer(kind(rocblas_diagonal_non_unit)),value :: diag
      integer(c_int),value :: m
      type(c_ptr),value :: A
      integer(c_int),value :: lda
      type(c_ptr),value :: x
      integer(c_int),value :: incx
    end function

#ifdef USE_FPOINTER_INTERFACES
    module procedure rocblas_strmv_full_rank,rocblas_strmv_rank_0,rocblas_strmv_rank_1
#endif

  end interface
  
  interface rocblas_dtrmv
    function rocblas_dtrmv_orig(handle,uplo,transA,diag,m,A,lda,x,incx) bind(c, name="rocblas_dtrmv")
      use iso_c_binding
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocblas_dtrmv_orig
      type(c_ptr),value :: handle
      integer(kind(rocblas_fill_upper)),value :: uplo
      integer(kind(rocblas_operation_none)),value :: transA
      integer(kind(rocblas_diagonal_non_unit)),value :: diag
      integer(c_int),value :: m
      type(c_ptr),value :: A
      integer(c_int),value :: lda
      type(c_ptr),value :: x
      integer(c_int),value :: incx
    end function

#ifdef USE_FPOINTER_INTERFACES
    module procedure rocblas_dtrmv_full_rank,rocblas_dtrmv_rank_0,rocblas_dtrmv_rank_1
#endif

  end interface
  
  interface rocblas_ctrmv
    function rocblas_ctrmv_orig(handle,uplo,transA,diag,m,A,lda,x,incx) bind(c, name="rocblas_ctrmv")
      use iso_c_binding
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocblas_ctrmv_orig
      type(c_ptr),value :: handle
      integer(kind(rocblas_fill_upper)),value :: uplo
      integer(kind(rocblas_operation_none)),value :: transA
      integer(kind(rocblas_diagonal_non_unit)),value :: diag
      integer(c_int),value :: m
      type(c_ptr),value :: A
      integer(c_int),value :: lda
      type(c_ptr),value :: x
      integer(c_int),value :: incx
    end function

#ifdef USE_FPOINTER_INTERFACES
    module procedure rocblas_ctrmv_full_rank,rocblas_ctrmv_rank_0,rocblas_ctrmv_rank_1
#endif

  end interface
  !> ! \brief BLAS Level 2 API
  !> 
  !>     \details
  !>     trmv performs one of the matrix-vector operations
  !> 
  !>          x = Ax or x = ATx,
  !> 
  !>     where x is an n element vector and A is an n by n unit, or non-unit, upper or lower triangular matrix.
  !> 
  !>     The vector x is overwritten.
  !> 
  !>     @param[in]
  !>     handle    [rocblas_handle]
  !>               handle to the rocblas library context queue.
  !> 
  !>     @param[in]
  !>     uplo    [rocblas_fill]
  !>             rocblas_fill_upper:  A is an upper triangular matrix.
  !>             rocblas_fill_lower:  A is a  lower triangular matrix.
  !> 
  !>     @param[in]
  !>     transA     [rocblas_operation]
  !> 
  !>     @param[in]
  !>     diag    [rocblas_diagonal]
  !>             rocblas_diagonal_unit:     A is assumed to be unit triangular.
  !>             rocblas_diagonal_non_unit:  A is not assumed to be unit triangular.
  !> 
  !>     @param[in]
  !>     m         [rocblas_int]
  !>               m specifies the number of rows of A. m >= 0.
  !> 
  !>     @param[in]
  !>     A         device pointer storing matrix A,
  !>               of dimension ( lda, m )
  !> 
  !>     @param[in]
  !>     lda       [rocblas_int]
  !>               specifies the leading dimension of A.
  !>               lda = max( 1, m ).
  !> 
  !>     @param[in]
  !>     x         device pointer storing vector x.
  !> 
  !>     @param[in]
  !>     incx      [rocblas_int]
  !>               specifies the increment for the elements of x.
  !> 
  !>     
  interface rocblas_ztrmv
    function rocblas_ztrmv_orig(handle,uplo,transA,diag,m,A,lda,x,incx) bind(c, name="rocblas_ztrmv")
      use iso_c_binding
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocblas_ztrmv_orig
      type(c_ptr),value :: handle
      integer(kind(rocblas_fill_upper)),value :: uplo
      integer(kind(rocblas_operation_none)),value :: transA
      integer(kind(rocblas_diagonal_non_unit)),value :: diag
      integer(c_int),value :: m
      type(c_ptr),value :: A
      integer(c_int),value :: lda
      type(c_ptr),value :: x
      integer(c_int),value :: incx
    end function

#ifdef USE_FPOINTER_INTERFACES
    module procedure rocblas_ztrmv_full_rank,rocblas_ztrmv_rank_0,rocblas_ztrmv_rank_1
#endif

  end interface
  
  interface rocblas_strmv_strided_batched
    function rocblas_strmv_strided_batched_orig(handle,uplo,transA,diag,m,A,lda,stridea,x,incx,stridex,batch_count) bind(c, name="rocblas_strmv_strided_batched")
      use iso_c_binding
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocblas_strmv_strided_batched_orig
      type(c_ptr),value :: handle
      integer(kind(rocblas_fill_upper)),value :: uplo
      integer(kind(rocblas_operation_none)),value :: transA
      integer(kind(rocblas_diagonal_non_unit)),value :: diag
      integer(c_int),value :: m
      type(c_ptr),value :: A
      integer(c_int),value :: lda
      integer(c_int64_t),value :: stridea
      type(c_ptr),value :: x
      integer(c_int),value :: incx
      integer(c_int64_t),value :: stridex
      integer(c_int),value :: batch_count
    end function

#ifdef USE_FPOINTER_INTERFACES
    module procedure rocblas_strmv_strided_batched_full_rank,rocblas_strmv_strided_batched_rank_0,rocblas_strmv_strided_batched_rank_1
#endif

  end interface
  
  interface rocblas_dtrmv_strided_batched
    function rocblas_dtrmv_strided_batched_orig(handle,uplo,transA,diag,m,A,lda,stridea,x,incx,stridex,batch_count) bind(c, name="rocblas_dtrmv_strided_batched")
      use iso_c_binding
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocblas_dtrmv_strided_batched_orig
      type(c_ptr),value :: handle
      integer(kind(rocblas_fill_upper)),value :: uplo
      integer(kind(rocblas_operation_none)),value :: transA
      integer(kind(rocblas_diagonal_non_unit)),value :: diag
      integer(c_int),value :: m
      type(c_ptr),value :: A
      integer(c_int),value :: lda
      integer(c_int64_t),value :: stridea
      type(c_ptr),value :: x
      integer(c_int),value :: incx
      integer(c_int64_t),value :: stridex
      integer(c_int),value :: batch_count
    end function

#ifdef USE_FPOINTER_INTERFACES
    module procedure rocblas_dtrmv_strided_batched_full_rank,rocblas_dtrmv_strided_batched_rank_0,rocblas_dtrmv_strided_batched_rank_1
#endif

  end interface
  
  interface rocblas_ctrmv_strided_batched
    function rocblas_ctrmv_strided_batched_orig(handle,uplo,transA,diag,m,A,lda,stridea,x,incx,stridex,batch_count) bind(c, name="rocblas_ctrmv_strided_batched")
      use iso_c_binding
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocblas_ctrmv_strided_batched_orig
      type(c_ptr),value :: handle
      integer(kind(rocblas_fill_upper)),value :: uplo
      integer(kind(rocblas_operation_none)),value :: transA
      integer(kind(rocblas_diagonal_non_unit)),value :: diag
      integer(c_int),value :: m
      type(c_ptr),value :: A
      integer(c_int),value :: lda
      integer(c_int64_t),value :: stridea
      type(c_ptr),value :: x
      integer(c_int),value :: incx
      integer(c_int64_t),value :: stridex
      integer(c_int),value :: batch_count
    end function

#ifdef USE_FPOINTER_INTERFACES
    module procedure rocblas_ctrmv_strided_batched_full_rank,rocblas_ctrmv_strided_batched_rank_0,rocblas_ctrmv_strided_batched_rank_1
#endif

  end interface
  !> ! \brief BLAS Level 2 API
  !> 
  !>     \details
  !>     trmv_strided_batched performs one of the matrix-vector operations
  !> 
  !>          x_i = A_ix_i or x_i = ATx_i, 0 \le i < batch_count
  !> 
  !>     where x_i is an n element vector and A_i is an n by n (unit, or non-unit, upper or lower triangular matrix)
  !>     with strides specifying how to retrieve $x_i$ (resp. $A_i$) from $x_{i-1}$ (resp. $A_i$).
  !> 
  !>     The vectors x_i are overwritten.
  !> 
  !>     @param[in]
  !>     handle    [rocblas_handle]
  !>               handle to the rocblas library context queue.
  !> 
  !>     @param[in]
  !>     uplo    [rocblas_fill]
  !>             rocblas_fill_upper:  A_i is an upper triangular matrix.
  !>             rocblas_fill_lower:  A_i is a  lower triangular matrix.
  !> 
  !>     @param[in]
  !>     transA     [rocblas_operation]
  !> 
  !>     @param[in]
  !>     diag    [rocblas_diagonal]
  !>             rocblas_diagonal_unit:     A_i is assumed to be unit triangular.
  !>             rocblas_diagonal_non_unit:  A_i is not assumed to be unit triangular.
  !> 
  !>     @param[in]
  !>     m         [rocblas_int]
  !>               m specifies the number of rows of matrices A_i. m >= 0.
  !> 
  !>     @param[in]
  !>     A         device pointer of the matrix A_0,
  !>               of dimension ( lda, m )
  !> 
  !>     @param[in]
  !>     lda       [rocblas_int]
  !>               specifies the leading dimension of A_i.
  !>               lda >= max( 1, m ).
  !> 
  !>     @param[in]
  !>     stride_a  [rocblas_stride]
  !>               stride from the start of one A_i matrix to the next A_{i + 1}
  !> 
  !>     @param[in]
  !>     x         device pointer storing the vector x_0.
  !> 
  !>     @param[in]
  !>     incx      [rocblas_int]
  !>               specifies the increment for the elements of one vector x.
  !> 
  !>     @param[in]
  !>     stride_x  [rocblas_stride]
  !>               stride from the start of one x_i vector to the next x_{i + 1}
  !> 
  !>     @param[in]
  !>     batch_count [rocblas_int]
  !>               The number of batched matricesvectors.
  !> 
  !> 
  !>     
  interface rocblas_ztrmv_strided_batched
    function rocblas_ztrmv_strided_batched_orig(handle,uplo,transA,diag,m,A,lda,stridea,x,incx,stridex,batch_count) bind(c, name="rocblas_ztrmv_strided_batched")
      use iso_c_binding
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocblas_ztrmv_strided_batched_orig
      type(c_ptr),value :: handle
      integer(kind(rocblas_fill_upper)),value :: uplo
      integer(kind(rocblas_operation_none)),value :: transA
      integer(kind(rocblas_diagonal_non_unit)),value :: diag
      integer(c_int),value :: m
      type(c_ptr),value :: A
      integer(c_int),value :: lda
      integer(c_int64_t),value :: stridea
      type(c_ptr),value :: x
      integer(c_int),value :: incx
      integer(c_int64_t),value :: stridex
      integer(c_int),value :: batch_count
    end function

#ifdef USE_FPOINTER_INTERFACES
    module procedure rocblas_ztrmv_strided_batched_full_rank,rocblas_ztrmv_strided_batched_rank_0,rocblas_ztrmv_strided_batched_rank_1
#endif

  end interface
  
  interface rocblas_stpmv
    function rocblas_stpmv_orig(handle,uplo,transA,diag,m,A,x,incx) bind(c, name="rocblas_stpmv")
      use iso_c_binding
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocblas_stpmv_orig
      type(c_ptr),value :: handle
      integer(kind(rocblas_fill_upper)),value :: uplo
      integer(kind(rocblas_operation_none)),value :: transA
      integer(kind(rocblas_diagonal_non_unit)),value :: diag
      integer(c_int),value :: m
      type(c_ptr),value :: A
      type(c_ptr),value :: x
      integer(c_int),value :: incx
    end function

#ifdef USE_FPOINTER_INTERFACES
    module procedure rocblas_stpmv_full_rank,rocblas_stpmv_rank_0,rocblas_stpmv_rank_1
#endif

  end interface
  
  interface rocblas_dtpmv
    function rocblas_dtpmv_orig(handle,uplo,transA,diag,m,A,x,incx) bind(c, name="rocblas_dtpmv")
      use iso_c_binding
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocblas_dtpmv_orig
      type(c_ptr),value :: handle
      integer(kind(rocblas_fill_upper)),value :: uplo
      integer(kind(rocblas_operation_none)),value :: transA
      integer(kind(rocblas_diagonal_non_unit)),value :: diag
      integer(c_int),value :: m
      type(c_ptr),value :: A
      type(c_ptr),value :: x
      integer(c_int),value :: incx
    end function

#ifdef USE_FPOINTER_INTERFACES
    module procedure rocblas_dtpmv_full_rank,rocblas_dtpmv_rank_0,rocblas_dtpmv_rank_1
#endif

  end interface
  
  interface rocblas_ctpmv
    function rocblas_ctpmv_orig(handle,uplo,transA,diag,m,A,x,incx) bind(c, name="rocblas_ctpmv")
      use iso_c_binding
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocblas_ctpmv_orig
      type(c_ptr),value :: handle
      integer(kind(rocblas_fill_upper)),value :: uplo
      integer(kind(rocblas_operation_none)),value :: transA
      integer(kind(rocblas_diagonal_non_unit)),value :: diag
      integer(c_int),value :: m
      type(c_ptr),value :: A
      type(c_ptr),value :: x
      integer(c_int),value :: incx
    end function

#ifdef USE_FPOINTER_INTERFACES
    module procedure rocblas_ctpmv_full_rank,rocblas_ctpmv_rank_0,rocblas_ctpmv_rank_1
#endif

  end interface
  !> ! \brief BLAS Level 2 API
  !> 
  !>     \details
  !>     tpmv performs one of the matrix-vector operations
  !> 
  !>          x = Ax or x = ATx,
  !> 
  !>     where x is an n element vector and A is an n by n unit, or non-unit, upper or lower triangular matrix, supplied in the pack form.
  !> 
  !>     The vector x is overwritten.
  !> 
  !>     @param[in]
  !>     handle    [rocblas_handle]
  !>               handle to the rocblas library context queue.
  !> 
  !>     @param[in]
  !>     uplo    [rocblas_fill]
  !>             rocblas_fill_upper:  A is an upper triangular matrix.
  !>             rocblas_fill_lower:  A is a  lower triangular matrix.
  !> 
  !>     @param[in]
  !>     transA     [rocblas_operation]
  !> 
  !>     @param[in]
  !>     diag    [rocblas_diagonal]
  !>             rocblas_diagonal_unit:     A is assumed to be unit triangular.
  !>             rocblas_diagonal_non_unit:  A is not assumed to be unit triangular.
  !> 
  !>     @param[in]
  !>     m       [rocblas_int]
  !>             m specifies the number of rows of A. m >= 0.
  !> 
  !>     @param[in]
  !>     A       device pointer storing matrix A,
  !>             of dimension at leat ( m  ( m + 1 )  2 ).
  !>           Before entry with uplo = rocblas_fill_upper, the array A
  !>           must contain the upper triangular matrix packed sequentially,
  !>           column by column, so that A[0] contains a_{0,0}, A[1] and A[2] contain
  !>           a_{0,1} and a_{1, 1} respectively, and so on.
  !>           Before entry with uplo = rocblas_fill_lower, the array A
  !>           must contain the lower triangular matrix packed sequentially,
  !>           column by column, so that A[0] contains a_{0,0}, A[1] and A[2] contain
  !>           a_{1,0} and a_{2,0} respectively, and so on.
  !>           Note that when DIAG = rocblas_diagonal_unit, the diagonal elements of A are
  !>           not referenced, but are assumed to be unity.
  !> 
  !>     @param[in]
  !>     x       device pointer storing vector x.
  !> 
  !>     @param[in]
  !>     incx    [rocblas_int]
  !>             specifies the increment for the elements of x. incx must not be zero.
  !> 
  !>     
  interface rocblas_ztpmv
    function rocblas_ztpmv_orig(handle,uplo,transA,diag,m,A,x,incx) bind(c, name="rocblas_ztpmv")
      use iso_c_binding
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocblas_ztpmv_orig
      type(c_ptr),value :: handle
      integer(kind(rocblas_fill_upper)),value :: uplo
      integer(kind(rocblas_operation_none)),value :: transA
      integer(kind(rocblas_diagonal_non_unit)),value :: diag
      integer(c_int),value :: m
      type(c_ptr),value :: A
      type(c_ptr),value :: x
      integer(c_int),value :: incx
    end function

#ifdef USE_FPOINTER_INTERFACES
    module procedure rocblas_ztpmv_full_rank,rocblas_ztpmv_rank_0,rocblas_ztpmv_rank_1
#endif

  end interface
  
  interface rocblas_stpmv_strided_batched
    function rocblas_stpmv_strided_batched_orig(handle,uplo,transA,diag,m,A,stridea,x,incx,stridex,batch_count) bind(c, name="rocblas_stpmv_strided_batched")
      use iso_c_binding
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocblas_stpmv_strided_batched_orig
      type(c_ptr),value :: handle
      integer(kind(rocblas_fill_upper)),value :: uplo
      integer(kind(rocblas_operation_none)),value :: transA
      integer(kind(rocblas_diagonal_non_unit)),value :: diag
      integer(c_int),value :: m
      type(c_ptr),value :: A
      integer(c_int64_t),value :: stridea
      type(c_ptr),value :: x
      integer(c_int),value :: incx
      integer(c_int64_t),value :: stridex
      integer(c_int),value :: batch_count
    end function

#ifdef USE_FPOINTER_INTERFACES
    module procedure rocblas_stpmv_strided_batched_full_rank,rocblas_stpmv_strided_batched_rank_0,rocblas_stpmv_strided_batched_rank_1
#endif

  end interface
  
  interface rocblas_dtpmv_strided_batched
    function rocblas_dtpmv_strided_batched_orig(handle,uplo,transA,diag,m,A,stridea,x,incx,stridex,batch_count) bind(c, name="rocblas_dtpmv_strided_batched")
      use iso_c_binding
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocblas_dtpmv_strided_batched_orig
      type(c_ptr),value :: handle
      integer(kind(rocblas_fill_upper)),value :: uplo
      integer(kind(rocblas_operation_none)),value :: transA
      integer(kind(rocblas_diagonal_non_unit)),value :: diag
      integer(c_int),value :: m
      type(c_ptr),value :: A
      integer(c_int64_t),value :: stridea
      type(c_ptr),value :: x
      integer(c_int),value :: incx
      integer(c_int64_t),value :: stridex
      integer(c_int),value :: batch_count
    end function

#ifdef USE_FPOINTER_INTERFACES
    module procedure rocblas_dtpmv_strided_batched_full_rank,rocblas_dtpmv_strided_batched_rank_0,rocblas_dtpmv_strided_batched_rank_1
#endif

  end interface
  
  interface rocblas_ctpmv_strided_batched
    function rocblas_ctpmv_strided_batched_orig(handle,uplo,transA,diag,m,A,stridea,x,incx,stridex,batch_count) bind(c, name="rocblas_ctpmv_strided_batched")
      use iso_c_binding
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocblas_ctpmv_strided_batched_orig
      type(c_ptr),value :: handle
      integer(kind(rocblas_fill_upper)),value :: uplo
      integer(kind(rocblas_operation_none)),value :: transA
      integer(kind(rocblas_diagonal_non_unit)),value :: diag
      integer(c_int),value :: m
      type(c_ptr),value :: A
      integer(c_int64_t),value :: stridea
      type(c_ptr),value :: x
      integer(c_int),value :: incx
      integer(c_int64_t),value :: stridex
      integer(c_int),value :: batch_count
    end function

#ifdef USE_FPOINTER_INTERFACES
    module procedure rocblas_ctpmv_strided_batched_full_rank,rocblas_ctpmv_strided_batched_rank_0,rocblas_ctpmv_strided_batched_rank_1
#endif

  end interface
  !> ! \brief BLAS Level 2 API
  !> 
  !>     \details
  !>     tpmv_strided_batched performs one of the matrix-vector operations
  !> 
  !>          x_i = A_ix_i or x_i = ATx_i, 0 \le i < batch_count
  !> 
  !>     where x_i is an n element vector and A_i is an n by n (unit, or non-unit, upper or lower triangular matrix)
  !>     with strides specifying how to retrieve $x_i$ (resp. $A_i$) from $x_{i-1}$ (resp. $A_i$).
  !> 
  !>     The vectors x_i are overwritten.
  !> 
  !>     @param[in]
  !>     handle    [rocblas_handle]
  !>               handle to the rocblas library context queue.
  !> 
  !>     @param[in]
  !>     uplo    [rocblas_fill]
  !>             rocblas_fill_upper:  A_i is an upper triangular matrix.
  !>             rocblas_fill_lower:  A_i is a  lower triangular matrix.
  !> 
  !>     @param[in]
  !>     transA     [rocblas_operation]
  !> 
  !>     @param[in]
  !>     diag    [rocblas_diagonal]
  !>             rocblas_diagonal_unit:     A_i is assumed to be unit triangular.
  !>             rocblas_diagonal_non_unit:  A_i is not assumed to be unit triangular.
  !> 
  !>     @param[in]
  !>     m         [rocblas_int]
  !>               m specifies the number of rows of matrices A_i. m >= 0.
  !> 
  !>     @param[in]
  !>     A         device pointer of the matrix A_0,
  !>               of dimension ( lda, m )
  !> 
  !>     @param[in]
  !>     stride_a  [rocblas_stride]
  !>               stride from the start of one A_i matrix to the next A_{i + 1}
  !> 
  !>     @param[in]
  !>     x         device pointer storing the vector x_0.
  !> 
  !>     @param[in]
  !>     incx      [rocblas_int]
  !>               specifies the increment for the elements of one vector x.
  !> 
  !>     @param[in]
  !>     stride_x  [rocblas_stride]
  !>               stride from the start of one x_i vector to the next x_{i + 1}
  !> 
  !>     @param[in]
  !>     batch_count [rocblas_int]
  !>               The number of batched matricesvectors.
  !> 
  !> 
  !>     
  interface rocblas_ztpmv_strided_batched
    function rocblas_ztpmv_strided_batched_orig(handle,uplo,transA,diag,m,A,stridea,x,incx,stridex,batch_count) bind(c, name="rocblas_ztpmv_strided_batched")
      use iso_c_binding
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocblas_ztpmv_strided_batched_orig
      type(c_ptr),value :: handle
      integer(kind(rocblas_fill_upper)),value :: uplo
      integer(kind(rocblas_operation_none)),value :: transA
      integer(kind(rocblas_diagonal_non_unit)),value :: diag
      integer(c_int),value :: m
      type(c_ptr),value :: A
      integer(c_int64_t),value :: stridea
      type(c_ptr),value :: x
      integer(c_int),value :: incx
      integer(c_int64_t),value :: stridex
      integer(c_int),value :: batch_count
    end function

#ifdef USE_FPOINTER_INTERFACES
    module procedure rocblas_ztpmv_strided_batched_full_rank,rocblas_ztpmv_strided_batched_rank_0,rocblas_ztpmv_strided_batched_rank_1
#endif

  end interface
  
  interface rocblas_stbmv
    function rocblas_stbmv_orig(handle,uplo,trans,diag,m,k,A,lda,x,incx) bind(c, name="rocblas_stbmv")
      use iso_c_binding
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocblas_stbmv_orig
      type(c_ptr),value :: handle
      integer(kind(rocblas_fill_upper)),value :: uplo
      integer(kind(rocblas_operation_none)),value :: trans
      integer(kind(rocblas_diagonal_non_unit)),value :: diag
      integer(c_int),value :: m
      integer(c_int),value :: k
      type(c_ptr),value :: A
      integer(c_int),value :: lda
      type(c_ptr),value :: x
      integer(c_int),value :: incx
    end function

#ifdef USE_FPOINTER_INTERFACES
    module procedure rocblas_stbmv_full_rank,rocblas_stbmv_rank_0,rocblas_stbmv_rank_1
#endif

  end interface
  
  interface rocblas_dtbmv
    function rocblas_dtbmv_orig(handle,uplo,trans,diag,m,k,A,lda,x,incx) bind(c, name="rocblas_dtbmv")
      use iso_c_binding
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocblas_dtbmv_orig
      type(c_ptr),value :: handle
      integer(kind(rocblas_fill_upper)),value :: uplo
      integer(kind(rocblas_operation_none)),value :: trans
      integer(kind(rocblas_diagonal_non_unit)),value :: diag
      integer(c_int),value :: m
      integer(c_int),value :: k
      type(c_ptr),value :: A
      integer(c_int),value :: lda
      type(c_ptr),value :: x
      integer(c_int),value :: incx
    end function

#ifdef USE_FPOINTER_INTERFACES
    module procedure rocblas_dtbmv_full_rank,rocblas_dtbmv_rank_0,rocblas_dtbmv_rank_1
#endif

  end interface
  
  interface rocblas_ctbmv
    function rocblas_ctbmv_orig(handle,uplo,trans,diag,m,k,A,lda,x,incx) bind(c, name="rocblas_ctbmv")
      use iso_c_binding
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocblas_ctbmv_orig
      type(c_ptr),value :: handle
      integer(kind(rocblas_fill_upper)),value :: uplo
      integer(kind(rocblas_operation_none)),value :: trans
      integer(kind(rocblas_diagonal_non_unit)),value :: diag
      integer(c_int),value :: m
      integer(c_int),value :: k
      type(c_ptr),value :: A
      integer(c_int),value :: lda
      type(c_ptr),value :: x
      integer(c_int),value :: incx
    end function

#ifdef USE_FPOINTER_INTERFACES
    module procedure rocblas_ctbmv_full_rank,rocblas_ctbmv_rank_0,rocblas_ctbmv_rank_1
#endif

  end interface
  !> ! \brief BLAS Level 2 API
  !> 
  !>     \details
  !>     xTBMV performs one of the matrix-vector operations
  !> 
  !>         x := Ax      or
  !>         x := ATx   or
  !>         x := AHx,
  !> 
  !>     x is a vectors and A is a banded m by m matrix (see description below).
  !> 
  !>     @param[in]
  !>     handle    [rocblas_handle]
  !>               handle to the rocblas library context queue.
  !>     @param[in]
  !>     uplo      [rocblas_fill]
  !>               rocblas_fill_upper: A is an upper banded triangular matrix.
  !>               rocblas_fill_lower: A is a  lower banded triangular matrix.
  !>     @param[in]
  !>     trans     [rocblas_operation]
  !>               indicates whether matrix A is tranposed (conjugated) or not.
  !>     @param[in]
  !>     diag      [rocblas_diagonal]
  !>               rocblas_diagonal_unit: The main diagonal of A is assumed to consist of only
  !>                                      1's and is not referenced.
  !>               rocblas_diagonal_non_unit: No assumptions are made of A's main diagonal.
  !>     @param[in]
  !>     m         [rocblas_int]
  !>               the number of rows and columns of the matrix represented by A.
  !>     @param[in]
  !>     k         [rocblas_int]
  !>               if uplo == rocblas_fill_upper, k specifies the number of super-diagonals
  !>               of the matrix A.
  !>               if uplo == rocblas_fill_lower, k specifies the number of sub-diagonals
  !>               of the matrix A.
  !>               k must satisfy k > 0 && k < lda.
  !>     @param[in]
  !>     A         device pointer storing banded triangular matrix A.
  !>               if uplo == rocblas_fill_upper:
  !>                 The matrix represented is an upper banded triangular matrix
  !>                 with the main diagonal and k super-diagonals, everything
  !>                 else can be assumed to be 0.
  !>                 The matrix is compacted so that the main diagonal resides on the k'th
  !>                 row, the first super diagonal resides on the RHS of the k-1'th row, etc,
  !>                 with the k'th diagonal on the RHS of the 0'th row.
  !>                    Ex: (rocblas_fill_upper; m = 5; k = 2)
  !>                       1 6 9 0 0              0 0 9 8 7
  !>                       0 2 7 8 0              0 6 7 8 9
  !>                       0 0 3 8 7     ---->    1 2 3 4 5
  !>                       0 0 0 4 9              0 0 0 0 0
  !>                       0 0 0 0 5              0 0 0 0 0
  !>               if uplo == rocblas_fill_lower:
  !>                 The matrix represnted is a lower banded triangular matrix
  !>                 with the main diagonal and k sub-diagonals, everything else can be
  !>                 assumed to be 0.
  !>                 The matrix is compacted so that the main diagonal resides on the 0'th row,
  !>                 working up to the k'th diagonal residing on the LHS of the k'th row.
  !>                    Ex: (rocblas_fill_lower; m = 5; k = 2)
  !>                       1 0 0 0 0              1 2 3 4 5
  !>                       6 2 0 0 0              6 7 8 9 0
  !>                       9 7 3 0 0     ---->    9 8 7 0 0
  !>                       0 8 8 4 0              0 0 0 0 0
  !>                       0 0 7 9 5              0 0 0 0 0
  !>     @param[in]
  !>     lda       [rocblas_int]
  !>               specifies the leading dimension of A. lda must satisfy lda > k.
  !>     @param[inout]
  !>     x         device pointer storing vector x.
  !>     @param[in]
  !>     incx      [rocblas_int]
  !>               specifies the increment for the elements of x.
  !> 
  !>     
  interface rocblas_ztbmv
    function rocblas_ztbmv_orig(handle,uplo,trans,diag,m,k,A,lda,x,incx) bind(c, name="rocblas_ztbmv")
      use iso_c_binding
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocblas_ztbmv_orig
      type(c_ptr),value :: handle
      integer(kind(rocblas_fill_upper)),value :: uplo
      integer(kind(rocblas_operation_none)),value :: trans
      integer(kind(rocblas_diagonal_non_unit)),value :: diag
      integer(c_int),value :: m
      integer(c_int),value :: k
      type(c_ptr),value :: A
      integer(c_int),value :: lda
      type(c_ptr),value :: x
      integer(c_int),value :: incx
    end function

#ifdef USE_FPOINTER_INTERFACES
    module procedure rocblas_ztbmv_full_rank,rocblas_ztbmv_rank_0,rocblas_ztbmv_rank_1
#endif

  end interface
  
  interface rocblas_stbmv_batched
    function rocblas_stbmv_batched_orig(handle,uplo,trans,diag,m,k,A,lda,x,incx,batch_count) bind(c, name="rocblas_stbmv_batched")
      use iso_c_binding
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocblas_stbmv_batched_orig
      type(c_ptr),value :: handle
      integer(kind(rocblas_fill_upper)),value :: uplo
      integer(kind(rocblas_operation_none)),value :: trans
      integer(kind(rocblas_diagonal_non_unit)),value :: diag
      integer(c_int),value :: m
      integer(c_int),value :: k
      type(c_ptr) :: A
      integer(c_int),value :: lda
      type(c_ptr) :: x
      integer(c_int),value :: incx
      integer(c_int),value :: batch_count
    end function

#ifdef USE_FPOINTER_INTERFACES
    module procedure rocblas_stbmv_batched_full_rank,rocblas_stbmv_batched_rank_0,rocblas_stbmv_batched_rank_1
#endif

  end interface
  
  interface rocblas_dtbmv_batched
    function rocblas_dtbmv_batched_orig(handle,uplo,trans,diag,m,k,A,lda,x,incx,batch_count) bind(c, name="rocblas_dtbmv_batched")
      use iso_c_binding
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocblas_dtbmv_batched_orig
      type(c_ptr),value :: handle
      integer(kind(rocblas_fill_upper)),value :: uplo
      integer(kind(rocblas_operation_none)),value :: trans
      integer(kind(rocblas_diagonal_non_unit)),value :: diag
      integer(c_int),value :: m
      integer(c_int),value :: k
      type(c_ptr) :: A
      integer(c_int),value :: lda
      type(c_ptr) :: x
      integer(c_int),value :: incx
      integer(c_int),value :: batch_count
    end function

#ifdef USE_FPOINTER_INTERFACES
    module procedure rocblas_dtbmv_batched_full_rank,rocblas_dtbmv_batched_rank_0,rocblas_dtbmv_batched_rank_1
#endif

  end interface
  
  interface rocblas_ctbmv_batched
    function rocblas_ctbmv_batched_orig(handle,uplo,trans,diag,m,k,A,da,x,incx,batch_count) bind(c, name="rocblas_ctbmv_batched")
      use iso_c_binding
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocblas_ctbmv_batched_orig
      type(c_ptr),value :: handle
      integer(kind(rocblas_fill_upper)),value :: uplo
      integer(kind(rocblas_operation_none)),value :: trans
      integer(kind(rocblas_diagonal_non_unit)),value :: diag
      integer(c_int),value :: m
      integer(c_int),value :: k
      type(c_ptr) :: A
      integer(c_int),value :: da
      type(c_ptr) :: x
      integer(c_int),value :: incx
      integer(c_int),value :: batch_count
    end function

#ifdef USE_FPOINTER_INTERFACES
    module procedure rocblas_ctbmv_batched_full_rank,rocblas_ctbmv_batched_rank_0,rocblas_ctbmv_batched_rank_1
#endif

  end interface
  !> ! \brief BLAS Level 2 API
  !> 
  !>     \details
  !>     xTBMV_BATCHED performs one of the matrix-vector operations
  !> 
  !>         x_i := A_ix_i      or
  !>         x_i := A_iTx_i   or
  !>         x_i := A_iHx_i,
  !> 
  !>     where (A_i, x_i) is the i-th instance of the batch.
  !>     x_i is a vector and A_i is an m by m matrix, for i = 1, ..., batch_count.
  !> 
  !>     @param[in]
  !>     handle    [rocblas_handle]
  !>               handle to the rocblas library context queue.
  !>     @param[in]
  !>     uplo      [rocblas_fill]
  !>               rocblas_fill_upper: each A_i is an upper banded triangular matrix.
  !>               rocblas_fill_lower: each A_i is a  lower banded triangular matrix.
  !>     @param[in]
  !>     trans     [rocblas_operation]
  !>               indicates whether each matrix A_i is tranposed (conjugated) or not.
  !>     @param[in]
  !>     diag      [rocblas_diagonal]
  !>               rocblas_diagonal_unit: The main diagonal of each A_i is assumed to consist of only
  !>                                      1's and is not referenced.
  !>               rocblas_diagonal_non_unit: No assumptions are made of each A_i's main diagonal.
  !>     @param[in]
  !>     m         [rocblas_int]
  !>               the number of rows and columns of the matrix represented by each A_i.
  !>     @param[in]
  !>     k         [rocblas_int]
  !>               if uplo == rocblas_fill_upper, k specifies the number of super-diagonals
  !>               of each matrix A_i.
  !>               if uplo == rocblas_fill_lower, k specifies the number of sub-diagonals
  !>               of each matrix A_i.
  !>               k must satisfy k > 0 && k < lda.
  !>     @param[in]
  !>     A         device array of device pointers storing each banded triangular matrix A_i.
  !>               if uplo == rocblas_fill_upper:
  !>                 The matrix represented is an upper banded triangular matrix
  !>                 with the main diagonal and k super-diagonals, everything
  !>                 else can be assumed to be 0.
  !>                 The matrix is compacted so that the main diagonal resides on the k'th
  !>                 row, the first super diagonal resides on the RHS of the k-1'th row, etc,
  !>                 with the k'th diagonal on the RHS of the 0'th row.
  !>                    Ex: (rocblas_fill_upper; m = 5; k = 2)
  !>                       1 6 9 0 0              0 0 9 8 7
  !>                       0 2 7 8 0              0 6 7 8 9
  !>                       0 0 3 8 7     ---->    1 2 3 4 5
  !>                       0 0 0 4 9              0 0 0 0 0
  !>                       0 0 0 0 5              0 0 0 0 0
  !>               if uplo == rocblas_fill_lower:
  !>                 The matrix represnted is a lower banded triangular matrix
  !>                 with the main diagonal and k sub-diagonals, everything else can be
  !>                 assumed to be 0.
  !>                 The matrix is compacted so that the main diagonal resides on the 0'th row,
  !>                 working up to the k'th diagonal residing on the LHS of the k'th row.
  !>                    Ex: (rocblas_fill_lower; m = 5; k = 2)
  !>                       1 0 0 0 0              1 2 3 4 5
  !>                       6 2 0 0 0              6 7 8 9 0
  !>                       9 7 3 0 0     ---->    9 8 7 0 0
  !>                       0 8 8 4 0              0 0 0 0 0
  !>                       0 0 7 9 5              0 0 0 0 0
  !>     @param[in]
  !>     lda       [rocblas_int]
  !>               specifies the leading dimension of each A_i. lda must satisfy lda > k.
  !>     @param[inout]
  !>     x         device array of device pointer storing each vector x_i.
  !>     @param[in]
  !>     incx      [rocblas_int]
  !>               specifies the increment for the elements of each x_i.
  !>     @param[in]
  !>     batch_count [rocblas_int]
  !>                 number of instances in the batch.
  !> 
  !>     
  interface rocblas_ztbmv_batched
    function rocblas_ztbmv_batched_orig(handle,uplo,trans,diag,m,k,A,lda,x,incx,batch_count) bind(c, name="rocblas_ztbmv_batched")
      use iso_c_binding
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocblas_ztbmv_batched_orig
      type(c_ptr),value :: handle
      integer(kind(rocblas_fill_upper)),value :: uplo
      integer(kind(rocblas_operation_none)),value :: trans
      integer(kind(rocblas_diagonal_non_unit)),value :: diag
      integer(c_int),value :: m
      integer(c_int),value :: k
      type(c_ptr) :: A
      integer(c_int),value :: lda
      type(c_ptr) :: x
      integer(c_int),value :: incx
      integer(c_int),value :: batch_count
    end function

#ifdef USE_FPOINTER_INTERFACES
    module procedure rocblas_ztbmv_batched_full_rank,rocblas_ztbmv_batched_rank_0,rocblas_ztbmv_batched_rank_1
#endif

  end interface
  
  interface rocblas_stbmv_strided_batched
    function rocblas_stbmv_strided_batched_orig(handle,uplo,trans,diag,m,k,A,lda,stride_A,x,incx,stride_x,batch_count) bind(c, name="rocblas_stbmv_strided_batched")
      use iso_c_binding
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocblas_stbmv_strided_batched_orig
      type(c_ptr),value :: handle
      integer(kind(rocblas_fill_upper)),value :: uplo
      integer(kind(rocblas_operation_none)),value :: trans
      integer(kind(rocblas_diagonal_non_unit)),value :: diag
      integer(c_int),value :: m
      integer(c_int),value :: k
      type(c_ptr),value :: A
      integer(c_int),value :: lda
      integer(c_int64_t),value :: stride_A
      type(c_ptr),value :: x
      integer(c_int),value :: incx
      integer(c_int64_t),value :: stride_x
      integer(c_int),value :: batch_count
    end function

#ifdef USE_FPOINTER_INTERFACES
    module procedure rocblas_stbmv_strided_batched_full_rank,rocblas_stbmv_strided_batched_rank_0,rocblas_stbmv_strided_batched_rank_1
#endif

  end interface
  
  interface rocblas_dtbmv_strided_batched
    function rocblas_dtbmv_strided_batched_orig(handle,uplo,trans,diag,m,k,A,lda,stride_A,x,incx,stride_x,batch_count) bind(c, name="rocblas_dtbmv_strided_batched")
      use iso_c_binding
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocblas_dtbmv_strided_batched_orig
      type(c_ptr),value :: handle
      integer(kind(rocblas_fill_upper)),value :: uplo
      integer(kind(rocblas_operation_none)),value :: trans
      integer(kind(rocblas_diagonal_non_unit)),value :: diag
      integer(c_int),value :: m
      integer(c_int),value :: k
      type(c_ptr),value :: A
      integer(c_int),value :: lda
      integer(c_int64_t),value :: stride_A
      type(c_ptr),value :: x
      integer(c_int),value :: incx
      integer(c_int64_t),value :: stride_x
      integer(c_int),value :: batch_count
    end function

#ifdef USE_FPOINTER_INTERFACES
    module procedure rocblas_dtbmv_strided_batched_full_rank,rocblas_dtbmv_strided_batched_rank_0,rocblas_dtbmv_strided_batched_rank_1
#endif

  end interface
  
  interface rocblas_ctbmv_strided_batched
    function rocblas_ctbmv_strided_batched_orig(handle,uplo,trans,diag,m,k,A,lda,stride_A,x,incx,stride_x,batch_count) bind(c, name="rocblas_ctbmv_strided_batched")
      use iso_c_binding
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocblas_ctbmv_strided_batched_orig
      type(c_ptr),value :: handle
      integer(kind(rocblas_fill_upper)),value :: uplo
      integer(kind(rocblas_operation_none)),value :: trans
      integer(kind(rocblas_diagonal_non_unit)),value :: diag
      integer(c_int),value :: m
      integer(c_int),value :: k
      type(c_ptr),value :: A
      integer(c_int),value :: lda
      integer(c_int64_t),value :: stride_A
      type(c_ptr),value :: x
      integer(c_int),value :: incx
      integer(c_int64_t),value :: stride_x
      integer(c_int),value :: batch_count
    end function

#ifdef USE_FPOINTER_INTERFACES
    module procedure rocblas_ctbmv_strided_batched_full_rank,rocblas_ctbmv_strided_batched_rank_0,rocblas_ctbmv_strided_batched_rank_1
#endif

  end interface
  !> ! \brief BLAS Level 2 API
  !> 
  !>     \details
  !>     xTBMV_STRIDED_BATCHED performs one of the matrix-vector operations
  !> 
  !>         x_i := A_ix_i      or
  !>         x_i := A_iTx_i   or
  !>         x_i := A_iHx_i,
  !> 
  !>     where (A_i, x_i) is the i-th instance of the batch.
  !>     x_i is a vector and A_i is an m by m matrix, for i = 1, ..., batch_count.
  !> 
  !>     @param[in]
  !>     handle    [rocblas_handle]
  !>               handle to the rocblas library context queue.
  !>     @param[in]
  !>     uplo      [rocblas_fill]
  !>               rocblas_fill_upper: each A_i is an upper banded triangular matrix.
  !>               rocblas_fill_lower: each A_i is a  lower banded triangular matrix.
  !>     @param[in]
  !>     trans     [rocblas_operation]
  !>               indicates whether each matrix A_i is tranposed (conjugated) or not.
  !>     @param[in]
  !>     diag      [rocblas_diagonal]
  !>               rocblas_diagonal_unit: The main diagonal of each A_i is assumed to consist of only
  !>                                      1's and is not referenced.
  !>               rocblas_diagonal_non_unit: No assumptions are made of each A_i's main diagonal.
  !>     @param[in]
  !>     m         [rocblas_int]
  !>               the number of rows and columns of the matrix represented by each A_i.
  !>     @param[in]
  !>     k         [rocblas_int]
  !>               if uplo == rocblas_fill_upper, k specifies the number of super-diagonals
  !>               of each matrix A_i.
  !>               if uplo == rocblas_fill_lower, k specifies the number of sub-diagonals
  !>               of each matrix A_i.
  !>               k must satisfy k > 0 && k < lda.
  !>     @param[in]
  !>     A         device array to the first matrix A_i of the batch. Stores each banded triangular matrix A_i.
  !>               if uplo == rocblas_fill_upper:
  !>                 The matrix represented is an upper banded triangular matrix
  !>                 with the main diagonal and k super-diagonals, everything
  !>                 else can be assumed to be 0.
  !>                 The matrix is compacted so that the main diagonal resides on the k'th
  !>                 row, the first super diagonal resides on the RHS of the k-1'th row, etc,
  !>                 with the k'th diagonal on the RHS of the 0'th row.
  !>                    Ex: (rocblas_fill_upper; m = 5; k = 2)
  !>                       1 6 9 0 0              0 0 9 8 7
  !>                       0 2 7 8 0              0 6 7 8 9
  !>                       0 0 3 8 7     ---->    1 2 3 4 5
  !>                       0 0 0 4 9              0 0 0 0 0
  !>                       0 0 0 0 5              0 0 0 0 0
  !>               if uplo == rocblas_fill_lower:
  !>                 The matrix represnted is a lower banded triangular matrix
  !>                 with the main diagonal and k sub-diagonals, everything else can be
  !>                 assumed to be 0.
  !>                 The matrix is compacted so that the main diagonal resides on the 0'th row,
  !>                 working up to the k'th diagonal residing on the LHS of the k'th row.
  !>                    Ex: (rocblas_fill_lower; m = 5; k = 2)
  !>                       1 0 0 0 0              1 2 3 4 5
  !>                       6 2 0 0 0              6 7 8 9 0
  !>                       9 7 3 0 0     ---->    9 8 7 0 0
  !>                       0 8 8 4 0              0 0 0 0 0
  !>                       0 0 7 9 5              0 0 0 0 0
  !>     @param[in]
  !>     lda       [rocblas_int]
  !>               specifies the leading dimension of each A_i. lda must satisfy lda > k.
  !>     @param[in]
  !>     stride_A  [rocblas_stride]
  !>               stride from the start of one A_i matrix to the next A_(i + 1).
  !>     @param[inout]
  !>     x         device array to the first vector x_i of the batch.
  !>     @param[in]
  !>     incx      [rocblas_int]
  !>               specifies the increment for the elements of each x_i.
  !>     @param[in]
  !>     stride_x  [rocblas_stride]
  !>               stride from the start of one x_i matrix to the next x_(i + 1).
  !>     @param[in]
  !>     batch_count [rocblas_int]
  !>                 number of instances in the batch.
  !> 
  !>     
  interface rocblas_ztbmv_strided_batched
    function rocblas_ztbmv_strided_batched_orig(handle,uplo,trans,diag,m,k,A,lda,stride_A,x,incx,stride_x,batch_count) bind(c, name="rocblas_ztbmv_strided_batched")
      use iso_c_binding
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocblas_ztbmv_strided_batched_orig
      type(c_ptr),value :: handle
      integer(kind(rocblas_fill_upper)),value :: uplo
      integer(kind(rocblas_operation_none)),value :: trans
      integer(kind(rocblas_diagonal_non_unit)),value :: diag
      integer(c_int),value :: m
      integer(c_int),value :: k
      type(c_ptr),value :: A
      integer(c_int),value :: lda
      integer(c_int64_t),value :: stride_A
      type(c_ptr),value :: x
      integer(c_int),value :: incx
      integer(c_int64_t),value :: stride_x
      integer(c_int),value :: batch_count
    end function

#ifdef USE_FPOINTER_INTERFACES
    module procedure rocblas_ztbmv_strided_batched_full_rank,rocblas_ztbmv_strided_batched_rank_0,rocblas_ztbmv_strided_batched_rank_1
#endif

  end interface
  
  interface rocblas_stbsv
    function rocblas_stbsv_orig(handle,uplo,transA,diag,n,k,A,lda,x,incx) bind(c, name="rocblas_stbsv")
      use iso_c_binding
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocblas_stbsv_orig
      type(c_ptr),value :: handle
      integer(kind(rocblas_fill_upper)),value :: uplo
      integer(kind(rocblas_operation_none)),value :: transA
      integer(kind(rocblas_diagonal_non_unit)),value :: diag
      integer(c_int),value :: n
      integer(c_int),value :: k
      type(c_ptr),value :: A
      integer(c_int),value :: lda
      type(c_ptr),value :: x
      integer(c_int),value :: incx
    end function

#ifdef USE_FPOINTER_INTERFACES
    module procedure rocblas_stbsv_full_rank,rocblas_stbsv_rank_0,rocblas_stbsv_rank_1
#endif

  end interface
  
  interface rocblas_dtbsv
    function rocblas_dtbsv_orig(handle,uplo,transA,diag,n,k,A,lda,x,incx) bind(c, name="rocblas_dtbsv")
      use iso_c_binding
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocblas_dtbsv_orig
      type(c_ptr),value :: handle
      integer(kind(rocblas_fill_upper)),value :: uplo
      integer(kind(rocblas_operation_none)),value :: transA
      integer(kind(rocblas_diagonal_non_unit)),value :: diag
      integer(c_int),value :: n
      integer(c_int),value :: k
      type(c_ptr),value :: A
      integer(c_int),value :: lda
      type(c_ptr),value :: x
      integer(c_int),value :: incx
    end function

#ifdef USE_FPOINTER_INTERFACES
    module procedure rocblas_dtbsv_full_rank,rocblas_dtbsv_rank_0,rocblas_dtbsv_rank_1
#endif

  end interface
  
  interface rocblas_ctbsv
    function rocblas_ctbsv_orig(handle,uplo,transA,diag,n,k,A,lda,x,incx) bind(c, name="rocblas_ctbsv")
      use iso_c_binding
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocblas_ctbsv_orig
      type(c_ptr),value :: handle
      integer(kind(rocblas_fill_upper)),value :: uplo
      integer(kind(rocblas_operation_none)),value :: transA
      integer(kind(rocblas_diagonal_non_unit)),value :: diag
      integer(c_int),value :: n
      integer(c_int),value :: k
      type(c_ptr),value :: A
      integer(c_int),value :: lda
      type(c_ptr),value :: x
      integer(c_int),value :: incx
    end function

#ifdef USE_FPOINTER_INTERFACES
    module procedure rocblas_ctbsv_full_rank,rocblas_ctbsv_rank_0,rocblas_ctbsv_rank_1
#endif

  end interface
  !> ! \brief BLAS Level 2 API
  !> 
  !>     \details
  !>     tbsv solves
  !> 
  !>          Ax = b or ATx = b or AHx = b,
  !> 
  !>     where x and b are vectors and A is a banded triangular matrix.
  !> 
  !>     @param[in]
  !>     handle    [rocblas_handle]
  !>               handle to the rocblas library context queue.
  !> 
  !>     @param[in]
  !>     uplo    [rocblas_fill]
  !>             rocblas_fill_upper:  A is an upper triangular matrix.
  !>             rocblas_fill_lower:  A is a  lower triangular matrix.
  !> 
  !>     @param[in]
  !>     transA     [rocblas_operation]
  !>                rocblas_operation_none: Solves Ax = b
  !>                rocblas_operation_transpose: Solves ATx = b
  !>                rocblas_operation_conjugate_transpose: Solves AHx = b
  !> 
  !>     @param[in]
  !>     diag    [rocblas_diagonal]
  !>             rocblas_diagonal_unit:     A is assumed to be unit triangular (i.e. the diagonal elements
  !>                                        of A are not used in computations).
  !>             rocblas_diagonal_non_unit: A is not assumed to be unit triangular.
  !> 
  !>     @param[in]
  !>     n         [rocblas_int]
  !>               n specifies the number of rows of b. n >= 0.
  !>     @param[in]
  !>     k         [rocblas_int]
  !>               if(uplo == rocblas_fill_upper)
  !>                 k specifies the number of super-diagonals of A.
  !>               if(uplo == rocblas_fill_lower)
  !>                 k specifies the number of sub-diagonals of A.
  !>               k >= 0.
  !> 
  !>     @param[in]
  !>     A         device pointer storing the matrix A in banded format.
  !> 
  !>     @param[in]
  !>     lda       [rocblas_int]
  !>               specifies the leading dimension of A.
  !>               lda >= (k + 1).
  !> 
  !>     @param[inout]
  !>     x         device pointer storing input vector b. Overwritten by the output vector x.
  !> 
  !>     @param[in]
  !>     incx      [rocblas_int]
  !>               specifies the increment for the elements of x.
  !> 
  !>     
  interface rocblas_ztbsv
    function rocblas_ztbsv_orig(handle,uplo,transA,diag,n,k,A,lda,x,incx) bind(c, name="rocblas_ztbsv")
      use iso_c_binding
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocblas_ztbsv_orig
      type(c_ptr),value :: handle
      integer(kind(rocblas_fill_upper)),value :: uplo
      integer(kind(rocblas_operation_none)),value :: transA
      integer(kind(rocblas_diagonal_non_unit)),value :: diag
      integer(c_int),value :: n
      integer(c_int),value :: k
      type(c_ptr),value :: A
      integer(c_int),value :: lda
      type(c_ptr),value :: x
      integer(c_int),value :: incx
    end function

#ifdef USE_FPOINTER_INTERFACES
    module procedure rocblas_ztbsv_full_rank,rocblas_ztbsv_rank_0,rocblas_ztbsv_rank_1
#endif

  end interface
  
  interface rocblas_stbsv_batched
    function rocblas_stbsv_batched_orig(handle,uplo,transA,diag,n,k,A,lda,x,incx,batch_count) bind(c, name="rocblas_stbsv_batched")
      use iso_c_binding
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocblas_stbsv_batched_orig
      type(c_ptr),value :: handle
      integer(kind(rocblas_fill_upper)),value :: uplo
      integer(kind(rocblas_operation_none)),value :: transA
      integer(kind(rocblas_diagonal_non_unit)),value :: diag
      integer(c_int),value :: n
      integer(c_int),value :: k
      type(c_ptr) :: A
      integer(c_int),value :: lda
      type(c_ptr) :: x
      integer(c_int),value :: incx
      integer(c_int),value :: batch_count
    end function

#ifdef USE_FPOINTER_INTERFACES
    module procedure rocblas_stbsv_batched_full_rank,rocblas_stbsv_batched_rank_0,rocblas_stbsv_batched_rank_1
#endif

  end interface
  
  interface rocblas_dtbsv_batched
    function rocblas_dtbsv_batched_orig(handle,uplo,transA,diag,n,k,A,lda,x,incx,batch_count) bind(c, name="rocblas_dtbsv_batched")
      use iso_c_binding
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocblas_dtbsv_batched_orig
      type(c_ptr),value :: handle
      integer(kind(rocblas_fill_upper)),value :: uplo
      integer(kind(rocblas_operation_none)),value :: transA
      integer(kind(rocblas_diagonal_non_unit)),value :: diag
      integer(c_int),value :: n
      integer(c_int),value :: k
      type(c_ptr) :: A
      integer(c_int),value :: lda
      type(c_ptr) :: x
      integer(c_int),value :: incx
      integer(c_int),value :: batch_count
    end function

#ifdef USE_FPOINTER_INTERFACES
    module procedure rocblas_dtbsv_batched_full_rank,rocblas_dtbsv_batched_rank_0,rocblas_dtbsv_batched_rank_1
#endif

  end interface
  
  interface rocblas_ctbsv_batched
    function rocblas_ctbsv_batched_orig(handle,uplo,transA,diag,n,k,A,lda,x,incx,batch_count) bind(c, name="rocblas_ctbsv_batched")
      use iso_c_binding
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocblas_ctbsv_batched_orig
      type(c_ptr),value :: handle
      integer(kind(rocblas_fill_upper)),value :: uplo
      integer(kind(rocblas_operation_none)),value :: transA
      integer(kind(rocblas_diagonal_non_unit)),value :: diag
      integer(c_int),value :: n
      integer(c_int),value :: k
      type(c_ptr) :: A
      integer(c_int),value :: lda
      type(c_ptr) :: x
      integer(c_int),value :: incx
      integer(c_int),value :: batch_count
    end function

#ifdef USE_FPOINTER_INTERFACES
    module procedure rocblas_ctbsv_batched_full_rank,rocblas_ctbsv_batched_rank_0,rocblas_ctbsv_batched_rank_1
#endif

  end interface
  !> ! \brief BLAS Level 2 API
  !> 
  !>     \details
  !>     tbsv_batched solves
  !> 
  !>          A_ix_i = b_i or A_iTx_i = b_i or A_iHx_i = b_i,
  !> 
  !>     where x_i and b_i are vectors and A_i is a banded triangular matrix,
  !>     for i = [1, batch_count].
  !> 
  !>     The input vectors b_i are overwritten by the output vectors x_i.
  !> 
  !>     @param[in]
  !>     handle    [rocblas_handle]
  !>               handle to the rocblas library context queue.
  !> 
  !>     @param[in]
  !>     uplo    [rocblas_fill]
  !>             rocblas_fill_upper:  A_i is an upper triangular matrix.
  !>             rocblas_fill_lower:  A_i is a  lower triangular matrix.
  !> 
  !>     @param[in]
  !>     transA     [rocblas_operation]
  !>                rocblas_operation_none: Solves A_ix_i = b_i
  !>                rocblas_operation_transpose: Solves A_iTx_i = b_i
  !>                rocblas_operation_conjugate_transpose: Solves A_iHx_i = b_i
  !> 
  !>     @param[in]
  !>     diag    [rocblas_diagonal]
  !>             rocblas_diagonal_unit:     each A_i is assumed to be unit triangular (i.e. the diagonal elements
  !>                                        of each A_i are not used in computations).
  !>             rocblas_diagonal_non_unit: each A_i is not assumed to be unit triangular.
  !> 
  !>     @param[in]
  !>     n         [rocblas_int]
  !>               n specifies the number of rows of each b_i. n >= 0.
  !>     @param[in]
  !>     k         [rocblas_int]
  !>               if(uplo == rocblas_fill_upper)
  !>                 k specifies the number of super-diagonals of each A_i.
  !>               if(uplo == rocblas_fill_lower)
  !>                 k specifies the number of sub-diagonals of each A_i.
  !>               k >= 0.
  !> 
  !>     @param[in]
  !>     A         device vector of device pointers storing each matrix A_i in banded format.
  !> 
  !>     @param[in]
  !>     lda       [rocblas_int]
  !>               specifies the leading dimension of each A_i.
  !>               lda >= (k + 1).
  !> 
  !>     @param[inout]
  !>     x         device vector of device pointers storing each input vector b_i. Overwritten by each output
  !>               vector x_i.
  !>     @param[in]
  !>     incx      [rocblas_int]
  !>               specifies the increment for the elements of each x_i.
  !>     @param[in]
  !>     batch_count [rocblas_int]
  !>                 number of instances in the batch.
  !> 
  !>     
  interface rocblas_ztbsv_batched
    function rocblas_ztbsv_batched_orig(handle,uplo,transA,diag,n,k,A,lda,x,incx,batch_count) bind(c, name="rocblas_ztbsv_batched")
      use iso_c_binding
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocblas_ztbsv_batched_orig
      type(c_ptr),value :: handle
      integer(kind(rocblas_fill_upper)),value :: uplo
      integer(kind(rocblas_operation_none)),value :: transA
      integer(kind(rocblas_diagonal_non_unit)),value :: diag
      integer(c_int),value :: n
      integer(c_int),value :: k
      type(c_ptr) :: A
      integer(c_int),value :: lda
      type(c_ptr) :: x
      integer(c_int),value :: incx
      integer(c_int),value :: batch_count
    end function

#ifdef USE_FPOINTER_INTERFACES
    module procedure rocblas_ztbsv_batched_full_rank,rocblas_ztbsv_batched_rank_0,rocblas_ztbsv_batched_rank_1
#endif

  end interface
  
  interface rocblas_stbsv_strided_batched
    function rocblas_stbsv_strided_batched_orig(handle,uplo,transA,diag,n,k,A,lda,stride_A,x,incx,stride_x,batch_count) bind(c, name="rocblas_stbsv_strided_batched")
      use iso_c_binding
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocblas_stbsv_strided_batched_orig
      type(c_ptr),value :: handle
      integer(kind(rocblas_fill_upper)),value :: uplo
      integer(kind(rocblas_operation_none)),value :: transA
      integer(kind(rocblas_diagonal_non_unit)),value :: diag
      integer(c_int),value :: n
      integer(c_int),value :: k
      type(c_ptr),value :: A
      integer(c_int),value :: lda
      integer(c_int64_t),value :: stride_A
      type(c_ptr),value :: x
      integer(c_int),value :: incx
      integer(c_int64_t),value :: stride_x
      integer(c_int),value :: batch_count
    end function

#ifdef USE_FPOINTER_INTERFACES
    module procedure rocblas_stbsv_strided_batched_full_rank,rocblas_stbsv_strided_batched_rank_0,rocblas_stbsv_strided_batched_rank_1
#endif

  end interface
  
  interface rocblas_dtbsv_strided_batched
    function rocblas_dtbsv_strided_batched_orig(handle,uplo,transA,diag,n,k,A,lda,stride_A,x,incx,stride_x,batch_count) bind(c, name="rocblas_dtbsv_strided_batched")
      use iso_c_binding
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocblas_dtbsv_strided_batched_orig
      type(c_ptr),value :: handle
      integer(kind(rocblas_fill_upper)),value :: uplo
      integer(kind(rocblas_operation_none)),value :: transA
      integer(kind(rocblas_diagonal_non_unit)),value :: diag
      integer(c_int),value :: n
      integer(c_int),value :: k
      type(c_ptr),value :: A
      integer(c_int),value :: lda
      integer(c_int64_t),value :: stride_A
      type(c_ptr),value :: x
      integer(c_int),value :: incx
      integer(c_int64_t),value :: stride_x
      integer(c_int),value :: batch_count
    end function

#ifdef USE_FPOINTER_INTERFACES
    module procedure rocblas_dtbsv_strided_batched_full_rank,rocblas_dtbsv_strided_batched_rank_0,rocblas_dtbsv_strided_batched_rank_1
#endif

  end interface
  
  interface rocblas_ctbsv_strided_batched
    function rocblas_ctbsv_strided_batched_orig(handle,uplo,transA,diag,n,k,A,lda,stride_A,x,incx,stride_x,batch_count) bind(c, name="rocblas_ctbsv_strided_batched")
      use iso_c_binding
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocblas_ctbsv_strided_batched_orig
      type(c_ptr),value :: handle
      integer(kind(rocblas_fill_upper)),value :: uplo
      integer(kind(rocblas_operation_none)),value :: transA
      integer(kind(rocblas_diagonal_non_unit)),value :: diag
      integer(c_int),value :: n
      integer(c_int),value :: k
      type(c_ptr),value :: A
      integer(c_int),value :: lda
      integer(c_int64_t),value :: stride_A
      type(c_ptr),value :: x
      integer(c_int),value :: incx
      integer(c_int64_t),value :: stride_x
      integer(c_int),value :: batch_count
    end function

#ifdef USE_FPOINTER_INTERFACES
    module procedure rocblas_ctbsv_strided_batched_full_rank,rocblas_ctbsv_strided_batched_rank_0,rocblas_ctbsv_strided_batched_rank_1
#endif

  end interface
  !> ! \brief BLAS Level 2 API
  !> 
  !>     \details
  !>     tbsv_strided_batched solves
  !> 
  !>          A_ix_i = b_i or A_iTx_i = b_i or A_iHx_i = b_i,
  !> 
  !>     where x_i and b_i are vectors and A_i is a banded triangular matrix,
  !>     for i = [1, batch_count].
  !> 
  !>     The input vectors b_i are overwritten by the output vectors x_i.
  !> 
  !>     @param[in]
  !>     handle    [rocblas_handle]
  !>               handle to the rocblas library context queue.
  !> 
  !>     @param[in]
  !>     uplo    [rocblas_fill]
  !>             rocblas_fill_upper:  A_i is an upper triangular matrix.
  !>             rocblas_fill_lower:  A_i is a  lower triangular matrix.
  !> 
  !>     @param[in]
  !>     transA     [rocblas_operation]
  !>                rocblas_operation_none: Solves A_ix_i = b_i
  !>                rocblas_operation_transpose: Solves A_iTx_i = b_i
  !>                rocblas_operation_conjugate_transpose: Solves A_iHx_i = b_i
  !> 
  !>     @param[in]
  !>     diag    [rocblas_diagonal]
  !>             rocblas_diagonal_unit:     each A_i is assumed to be unit triangular (i.e. the diagonal elements
  !>                                        of each A_i are not used in computations).
  !>             rocblas_diagonal_non_unit: each A_i is not assumed to be unit triangular.
  !> 
  !>     @param[in]
  !>     n         [rocblas_int]
  !>               n specifies the number of rows of each b_i. n >= 0.
  !>     @param[in]
  !>     k         [rocblas_int]
  !>               if(uplo == rocblas_fill_upper)
  !>                 k specifies the number of super-diagonals of each A_i.
  !>               if(uplo == rocblas_fill_lower)
  !>                 k specifies the number of sub-diagonals of each A_i.
  !>               k >= 0.
  !> 
  !>     @param[in]
  !>     A         device pointer pointing to the first banded matrix A_1.
  !> 
  !>     @param[in]
  !>     lda       [rocblas_int]
  !>               specifies the leading dimension of each A_i.
  !>               lda >= (k + 1).
  !>     @param[in]
  !>     stride_A  [rocblas_stride]
  !>               specifies the distance between the start of one matrix (A_i) and the next (A_i+1).
  !> 
  !>     @param[inout]
  !>     x         device pointer pointing to the first input vector b_1. Overwritten by output vectors x.
  !>     @param[in]
  !>     incx      [rocblas_int]
  !>               specifies the increment for the elements of each x_i.
  !>     @param[in]
  !>     stride_x  [rocblas_stride]
  !>               specifies the distance between the start of one vector (x_i) and the next (x_i+1).
  !>     @param[in]
  !>     batch_count [rocblas_int]
  !>                 number of instances in the batch.
  !> 
  !>     
  interface rocblas_ztbsv_strided_batched
    function rocblas_ztbsv_strided_batched_orig(handle,uplo,transA,diag,n,k,A,lda,stride_A,x,incx,stride_x,batch_count) bind(c, name="rocblas_ztbsv_strided_batched")
      use iso_c_binding
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocblas_ztbsv_strided_batched_orig
      type(c_ptr),value :: handle
      integer(kind(rocblas_fill_upper)),value :: uplo
      integer(kind(rocblas_operation_none)),value :: transA
      integer(kind(rocblas_diagonal_non_unit)),value :: diag
      integer(c_int),value :: n
      integer(c_int),value :: k
      type(c_ptr),value :: A
      integer(c_int),value :: lda
      integer(c_int64_t),value :: stride_A
      type(c_ptr),value :: x
      integer(c_int),value :: incx
      integer(c_int64_t),value :: stride_x
      integer(c_int),value :: batch_count
    end function

#ifdef USE_FPOINTER_INTERFACES
    module procedure rocblas_ztbsv_strided_batched_full_rank,rocblas_ztbsv_strided_batched_rank_0,rocblas_ztbsv_strided_batched_rank_1
#endif

  end interface
  
  interface rocblas_strsv
    function rocblas_strsv_orig(handle,uplo,transA,diag,m,A,lda,x,incx) bind(c, name="rocblas_strsv")
      use iso_c_binding
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocblas_strsv_orig
      type(c_ptr),value :: handle
      integer(kind(rocblas_fill_upper)),value :: uplo
      integer(kind(rocblas_operation_none)),value :: transA
      integer(kind(rocblas_diagonal_non_unit)),value :: diag
      integer(c_int),value :: m
      type(c_ptr),value :: A
      integer(c_int),value :: lda
      type(c_ptr),value :: x
      integer(c_int),value :: incx
    end function

#ifdef USE_FPOINTER_INTERFACES
    module procedure rocblas_strsv_full_rank,rocblas_strsv_rank_0,rocblas_strsv_rank_1
#endif

  end interface
  
  interface rocblas_dtrsv
    function rocblas_dtrsv_orig(handle,uplo,transA,diag,m,A,lda,x,incx) bind(c, name="rocblas_dtrsv")
      use iso_c_binding
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocblas_dtrsv_orig
      type(c_ptr),value :: handle
      integer(kind(rocblas_fill_upper)),value :: uplo
      integer(kind(rocblas_operation_none)),value :: transA
      integer(kind(rocblas_diagonal_non_unit)),value :: diag
      integer(c_int),value :: m
      type(c_ptr),value :: A
      integer(c_int),value :: lda
      type(c_ptr),value :: x
      integer(c_int),value :: incx
    end function

#ifdef USE_FPOINTER_INTERFACES
    module procedure rocblas_dtrsv_full_rank,rocblas_dtrsv_rank_0,rocblas_dtrsv_rank_1
#endif

  end interface
  
  interface rocblas_ctrsv
    function rocblas_ctrsv_orig(handle,uplo,transA,diag,m,A,lda,x,incx) bind(c, name="rocblas_ctrsv")
      use iso_c_binding
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocblas_ctrsv_orig
      type(c_ptr),value :: handle
      integer(kind(rocblas_fill_upper)),value :: uplo
      integer(kind(rocblas_operation_none)),value :: transA
      integer(kind(rocblas_diagonal_non_unit)),value :: diag
      integer(c_int),value :: m
      type(c_ptr),value :: A
      integer(c_int),value :: lda
      type(c_ptr),value :: x
      integer(c_int),value :: incx
    end function

#ifdef USE_FPOINTER_INTERFACES
    module procedure rocblas_ctrsv_full_rank,rocblas_ctrsv_rank_0,rocblas_ctrsv_rank_1
#endif

  end interface
  !> ! \brief BLAS Level 2 API
  !> 
  !>     \details
  !>     trsv solves
  !> 
  !>          Ax = b or ATx = b,
  !> 
  !>     where x and b are vectors and A is a triangular matrix.
  !> 
  !>     The vector x is overwritten on b.
  !> 
  !>     @param[in]
  !>     handle    [rocblas_handle]
  !>               handle to the rocblas library context queue.
  !> 
  !>     @param[in]
  !>     uplo    [rocblas_fill]
  !>             rocblas_fill_upper:  A is an upper triangular matrix.
  !>             rocblas_fill_lower:  A is a  lower triangular matrix.
  !> 
  !>     @param[in]
  !>     transA     [rocblas_operation]
  !> 
  !>     @param[in]
  !>     diag    [rocblas_diagonal]
  !>             rocblas_diagonal_unit:     A is assumed to be unit triangular.
  !>             rocblas_diagonal_non_unit:  A is not assumed to be unit triangular.
  !> 
  !>     @param[in]
  !>     m         [rocblas_int]
  !>               m specifies the number of rows of b. m >= 0.
  !> 
  !>     @param[in]
  !>     A         device pointer storing matrix A,
  !>               of dimension ( lda, m )
  !> 
  !>     @param[in]
  !>     lda       [rocblas_int]
  !>               specifies the leading dimension of A.
  !>               lda = max( 1, m ).
  !> 
  !>     @param[in]
  !>     x         device pointer storing vector x.
  !> 
  !>     @param[in]
  !>     incx      [rocblas_int]
  !>               specifies the increment for the elements of x.
  !> 
  !>     
  interface rocblas_ztrsv
    function rocblas_ztrsv_orig(handle,uplo,transA,diag,m,A,lda,x,incx) bind(c, name="rocblas_ztrsv")
      use iso_c_binding
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocblas_ztrsv_orig
      type(c_ptr),value :: handle
      integer(kind(rocblas_fill_upper)),value :: uplo
      integer(kind(rocblas_operation_none)),value :: transA
      integer(kind(rocblas_diagonal_non_unit)),value :: diag
      integer(c_int),value :: m
      type(c_ptr),value :: A
      integer(c_int),value :: lda
      type(c_ptr),value :: x
      integer(c_int),value :: incx
    end function

#ifdef USE_FPOINTER_INTERFACES
    module procedure rocblas_ztrsv_full_rank,rocblas_ztrsv_rank_0,rocblas_ztrsv_rank_1
#endif

  end interface
  
  interface rocblas_strsv_batched
    function rocblas_strsv_batched_orig(handle,uplo,transA,diag,m,A,lda,x,incx,batch_count) bind(c, name="rocblas_strsv_batched")
      use iso_c_binding
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocblas_strsv_batched_orig
      type(c_ptr),value :: handle
      integer(kind(rocblas_fill_upper)),value :: uplo
      integer(kind(rocblas_operation_none)),value :: transA
      integer(kind(rocblas_diagonal_non_unit)),value :: diag
      integer(c_int),value :: m
      type(c_ptr) :: A
      integer(c_int),value :: lda
      type(c_ptr) :: x
      integer(c_int),value :: incx
      integer(c_int),value :: batch_count
    end function

#ifdef USE_FPOINTER_INTERFACES
    module procedure rocblas_strsv_batched_full_rank,rocblas_strsv_batched_rank_0,rocblas_strsv_batched_rank_1
#endif

  end interface
  
  interface rocblas_dtrsv_batched
    function rocblas_dtrsv_batched_orig(handle,uplo,transA,diag,m,A,lda,x,incx,batch_count) bind(c, name="rocblas_dtrsv_batched")
      use iso_c_binding
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocblas_dtrsv_batched_orig
      type(c_ptr),value :: handle
      integer(kind(rocblas_fill_upper)),value :: uplo
      integer(kind(rocblas_operation_none)),value :: transA
      integer(kind(rocblas_diagonal_non_unit)),value :: diag
      integer(c_int),value :: m
      type(c_ptr) :: A
      integer(c_int),value :: lda
      type(c_ptr) :: x
      integer(c_int),value :: incx
      integer(c_int),value :: batch_count
    end function

#ifdef USE_FPOINTER_INTERFACES
    module procedure rocblas_dtrsv_batched_full_rank,rocblas_dtrsv_batched_rank_0,rocblas_dtrsv_batched_rank_1
#endif

  end interface
  
  interface rocblas_ctrsv_batched
    function rocblas_ctrsv_batched_orig(handle,uplo,transA,diag,m,A,lda,x,incx,batch_count) bind(c, name="rocblas_ctrsv_batched")
      use iso_c_binding
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocblas_ctrsv_batched_orig
      type(c_ptr),value :: handle
      integer(kind(rocblas_fill_upper)),value :: uplo
      integer(kind(rocblas_operation_none)),value :: transA
      integer(kind(rocblas_diagonal_non_unit)),value :: diag
      integer(c_int),value :: m
      type(c_ptr) :: A
      integer(c_int),value :: lda
      type(c_ptr) :: x
      integer(c_int),value :: incx
      integer(c_int),value :: batch_count
    end function

#ifdef USE_FPOINTER_INTERFACES
    module procedure rocblas_ctrsv_batched_full_rank,rocblas_ctrsv_batched_rank_0,rocblas_ctrsv_batched_rank_1
#endif

  end interface
  !> ! \brief BLAS Level 2 API
  !> 
  !>     \details
  !>     trsv_batched solves
  !> 
  !>          A_ix_i = b_i or A_iTx_i = b_i,
  !> 
  !>     where (A_i, x_i, b_i) is the i-th instance of the batch.
  !>     x_i and b_i are vectors and A_i is an
  !>     m by m triangular matrix.
  !> 
  !>     The vector x is overwritten on b.
  !> 
  !>     @param[in]
  !>     handle    [rocblas_handle]
  !>               handle to the rocblas library context queue.
  !> 
  !>     @param[in]
  !>     uplo    [rocblas_fill]
  !>             rocblas_fill_upper:  A is an upper triangular matrix.
  !>             rocblas_fill_lower:  A is a  lower triangular matrix.
  !> 
  !>     @param[in]
  !>     transA     [rocblas_operation]
  !> 
  !>     @param[in]
  !>     diag    [rocblas_diagonal]
  !>             rocblas_diagonal_unit:     A is assumed to be unit triangular.
  !>             rocblas_diagonal_non_unit:  A is not assumed to be unit triangular.
  !> 
  !>     @param[in]
  !>     m         [rocblas_int]
  !>               m specifies the number of rows of b. m >= 0.
  !> 
  !>     @param[in]
  !>     A         device array of device pointers storing each matrix A_i.
  !> 
  !>     @param[in]
  !>     lda       [rocblas_int]
  !>               specifies the leading dimension of each A_i.
  !>               lda = max(1, m)
  !> 
  !>     @param[in]
  !>     x         device array of device pointers storing each vector x_i.
  !> 
  !>     @param[in]
  !>     incx      [rocblas_int]
  !>               specifies the increment for the elements of x.
  !> 
  !>     @param[in]
  !>     batch_count [rocblas_int]
  !>                 number of instances in the batch
  !> 
  !>     
  interface rocblas_ztrsv_batched
    function rocblas_ztrsv_batched_orig(handle,uplo,transA,diag,m,A,lda,x,incx,batch_count) bind(c, name="rocblas_ztrsv_batched")
      use iso_c_binding
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocblas_ztrsv_batched_orig
      type(c_ptr),value :: handle
      integer(kind(rocblas_fill_upper)),value :: uplo
      integer(kind(rocblas_operation_none)),value :: transA
      integer(kind(rocblas_diagonal_non_unit)),value :: diag
      integer(c_int),value :: m
      type(c_ptr) :: A
      integer(c_int),value :: lda
      type(c_ptr) :: x
      integer(c_int),value :: incx
      integer(c_int),value :: batch_count
    end function

#ifdef USE_FPOINTER_INTERFACES
    module procedure rocblas_ztrsv_batched_full_rank,rocblas_ztrsv_batched_rank_0,rocblas_ztrsv_batched_rank_1
#endif

  end interface
  
  interface rocblas_strsv_strided_batched
    function rocblas_strsv_strided_batched_orig(handle,uplo,transA,diag,m,A,lda,stride_A,x,incx,stride_x,batch_count) bind(c, name="rocblas_strsv_strided_batched")
      use iso_c_binding
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocblas_strsv_strided_batched_orig
      type(c_ptr),value :: handle
      integer(kind(rocblas_fill_upper)),value :: uplo
      integer(kind(rocblas_operation_none)),value :: transA
      integer(kind(rocblas_diagonal_non_unit)),value :: diag
      integer(c_int),value :: m
      type(c_ptr),value :: A
      integer(c_int),value :: lda
      integer(c_int64_t),value :: stride_A
      type(c_ptr),value :: x
      integer(c_int),value :: incx
      integer(c_int64_t),value :: stride_x
      integer(c_int),value :: batch_count
    end function

#ifdef USE_FPOINTER_INTERFACES
    module procedure rocblas_strsv_strided_batched_full_rank,rocblas_strsv_strided_batched_rank_0,rocblas_strsv_strided_batched_rank_1
#endif

  end interface
  
  interface rocblas_dtrsv_strided_batched
    function rocblas_dtrsv_strided_batched_orig(handle,uplo,transA,diag,m,A,lda,stride_A,x,incx,stride_x,batch_count) bind(c, name="rocblas_dtrsv_strided_batched")
      use iso_c_binding
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocblas_dtrsv_strided_batched_orig
      type(c_ptr),value :: handle
      integer(kind(rocblas_fill_upper)),value :: uplo
      integer(kind(rocblas_operation_none)),value :: transA
      integer(kind(rocblas_diagonal_non_unit)),value :: diag
      integer(c_int),value :: m
      type(c_ptr),value :: A
      integer(c_int),value :: lda
      integer(c_int64_t),value :: stride_A
      type(c_ptr),value :: x
      integer(c_int),value :: incx
      integer(c_int64_t),value :: stride_x
      integer(c_int),value :: batch_count
    end function

#ifdef USE_FPOINTER_INTERFACES
    module procedure rocblas_dtrsv_strided_batched_full_rank,rocblas_dtrsv_strided_batched_rank_0,rocblas_dtrsv_strided_batched_rank_1
#endif

  end interface
  
  interface rocblas_ctrsv_strided_batched
    function rocblas_ctrsv_strided_batched_orig(handle,uplo,transA,diag,m,A,lda,stride_A,x,incx,stride_x,batch_count) bind(c, name="rocblas_ctrsv_strided_batched")
      use iso_c_binding
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocblas_ctrsv_strided_batched_orig
      type(c_ptr),value :: handle
      integer(kind(rocblas_fill_upper)),value :: uplo
      integer(kind(rocblas_operation_none)),value :: transA
      integer(kind(rocblas_diagonal_non_unit)),value :: diag
      integer(c_int),value :: m
      type(c_ptr),value :: A
      integer(c_int),value :: lda
      integer(c_int64_t),value :: stride_A
      type(c_ptr),value :: x
      integer(c_int),value :: incx
      integer(c_int64_t),value :: stride_x
      integer(c_int),value :: batch_count
    end function

#ifdef USE_FPOINTER_INTERFACES
    module procedure rocblas_ctrsv_strided_batched_full_rank,rocblas_ctrsv_strided_batched_rank_0,rocblas_ctrsv_strided_batched_rank_1
#endif

  end interface
  !> ! \brief BLAS Level 2 API
  !> 
  !>     \details
  !>     trsv_strided_batched solves
  !> 
  !>          A_ix_i = b_i or A_iTx_i = b_i,
  !> 
  !>     where (A_i, x_i, b_i) is the i-th instance of the batch.
  !>     x_i and b_i are vectors and A_i is an m by m triangular matrix, for i = 1, ..., batch_count.
  !> 
  !>     The vector x is overwritten on b.
  !> 
  !>     @param[in]
  !>     handle    [rocblas_handle]
  !>               handle to the rocblas library context queue.
  !> 
  !>     @param[in]
  !>     uplo    [rocblas_fill]
  !>             rocblas_fill_upper:  A is an upper triangular matrix.
  !>             rocblas_fill_lower:  A is a  lower triangular matrix.
  !> 
  !>     @param[in]
  !>     transA     [rocblas_operation]
  !> 
  !>     @param[in]
  !>     diag    [rocblas_diagonal]
  !>             rocblas_diagonal_unit:     A is assumed to be unit triangular.
  !>             rocblas_diagonal_non_unit:  A is not assumed to be unit triangular.
  !> 
  !>     @param[in]
  !>     m         [rocblas_int]
  !>               m specifies the number of rows of each b_i. m >= 0.
  !> 
  !>     @param[in]
  !>     A         device pointer to the first matrix (A_1) in the batch, of dimension ( lda, m )
  !> 
  !>     @param[in]
  !>     stride_A  [rocblas_stride]
  !>               stride from the start of one A_i matrix to the next A_(i + 1)
  !> 
  !>     @param[in]
  !>     lda       [rocblas_int]
  !>               specifies the leading dimension of each A_i.
  !>               lda = max( 1, m ).
  !> 
  !>     @param[in, out]
  !>     x         device pointer to the first vector (x_1) in the batch.
  !> 
  !>     @param[in]
  !>     stride_x [rocblas_stride]
  !>              stride from the start of one x_i vector to the next x_(i + 1)
  !> 
  !>     @param[in]
  !>     incx      [rocblas_int]
  !>               specifies the increment for the elements of each x_i.
  !> 
  !>     @param[in]
  !>     batch_count [rocblas_int]
  !>                 number of instances in the batch
  !> 
  !>     
  interface rocblas_ztrsv_strided_batched
    function rocblas_ztrsv_strided_batched_orig(handle,uplo,transA,diag,m,A,lda,stride_A,x,incx,stride_x,batch_count) bind(c, name="rocblas_ztrsv_strided_batched")
      use iso_c_binding
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocblas_ztrsv_strided_batched_orig
      type(c_ptr),value :: handle
      integer(kind(rocblas_fill_upper)),value :: uplo
      integer(kind(rocblas_operation_none)),value :: transA
      integer(kind(rocblas_diagonal_non_unit)),value :: diag
      integer(c_int),value :: m
      type(c_ptr),value :: A
      integer(c_int),value :: lda
      integer(c_int64_t),value :: stride_A
      type(c_ptr),value :: x
      integer(c_int),value :: incx
      integer(c_int64_t),value :: stride_x
      integer(c_int),value :: batch_count
    end function

#ifdef USE_FPOINTER_INTERFACES
    module procedure rocblas_ztrsv_strided_batched_full_rank,rocblas_ztrsv_strided_batched_rank_0,rocblas_ztrsv_strided_batched_rank_1
#endif

  end interface
  
  interface rocblas_stpsv
    function rocblas_stpsv_orig(handle,uplo,transA,diag,n,AP,x,incx) bind(c, name="rocblas_stpsv")
      use iso_c_binding
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocblas_stpsv_orig
      type(c_ptr),value :: handle
      integer(kind(rocblas_fill_upper)),value :: uplo
      integer(kind(rocblas_operation_none)),value :: transA
      integer(kind(rocblas_diagonal_non_unit)),value :: diag
      integer(c_int),value :: n
      type(c_ptr),value :: AP
      type(c_ptr),value :: x
      integer(c_int),value :: incx
    end function

#ifdef USE_FPOINTER_INTERFACES
    module procedure rocblas_stpsv_rank_0,rocblas_stpsv_rank_1
#endif

  end interface
  
  interface rocblas_dtpsv
    function rocblas_dtpsv_orig(handle,uplo,transA,diag,n,AP,x,incx) bind(c, name="rocblas_dtpsv")
      use iso_c_binding
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocblas_dtpsv_orig
      type(c_ptr),value :: handle
      integer(kind(rocblas_fill_upper)),value :: uplo
      integer(kind(rocblas_operation_none)),value :: transA
      integer(kind(rocblas_diagonal_non_unit)),value :: diag
      integer(c_int),value :: n
      type(c_ptr),value :: AP
      type(c_ptr),value :: x
      integer(c_int),value :: incx
    end function

#ifdef USE_FPOINTER_INTERFACES
    module procedure rocblas_dtpsv_rank_0,rocblas_dtpsv_rank_1
#endif

  end interface
  
  interface rocblas_ctpsv
    function rocblas_ctpsv_orig(handle,uplo,transA,diag,n,AP,x,incx) bind(c, name="rocblas_ctpsv")
      use iso_c_binding
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocblas_ctpsv_orig
      type(c_ptr),value :: handle
      integer(kind(rocblas_fill_upper)),value :: uplo
      integer(kind(rocblas_operation_none)),value :: transA
      integer(kind(rocblas_diagonal_non_unit)),value :: diag
      integer(c_int),value :: n
      type(c_ptr),value :: AP
      type(c_ptr),value :: x
      integer(c_int),value :: incx
    end function

#ifdef USE_FPOINTER_INTERFACES
    module procedure rocblas_ctpsv_rank_0,rocblas_ctpsv_rank_1
#endif

  end interface
  !> ! \brief BLAS Level 2 API
  !> 
  !>     \details
  !>     TPSV solves
  !> 
  !>          Ax = b or ATx = b, or AHx = b,
  !> 
  !>     where x and b are vectors and A is a triangular matrix stored in the packed format.
  !> 
  !>     The input vector b is overwritten by the output vector x.
  !> 
  !>     @param[in]
  !>     handle    [rocblas_handle]
  !>               handle to the rocblas library context queue.
  !> 
  !>     @param[in]
  !>     uplo    [rocblas_fill]
  !>             rocblas_fill_upper:  A is an upper triangular matrix.
  !>             rocblas_fill_lower:  A is a  lower triangular matrix.
  !> 
  !>     @param[in]
  !>     transA  [rocblas_operation]
  !>             rocblas_operation_none: Solves Ax = b
  !>             rocblas_operation_transpose: Solves ATx = b
  !>             rocblas_operation_conjugate_transpose: Solves AHx = b
  !> 
  !>     @param[in]
  !>     diag    [rocblas_diagonal]
  !>             rocblas_diagonal_unit:     A is assumed to be unit triangular (i.e. the diagonal elements
  !>                                        of A are not used in computations).
  !>             rocblas_diagonal_non_unit: A is not assumed to be unit triangular.
  !> 
  !>     @param[in]
  !>     n         [rocblas_int]
  !>               n specifies the number of rows of b. n >= 0.
  !> 
  !>     @param[in]
  !>     AP        device pointer storing the packed version of matrix A,
  !>               of dimension >= (n  (n + 1)  2)
  !> 
  !>     @param[inout]
  !>     x         device pointer storing vector b on input, overwritten by x on output.
  !> 
  !>     @param[in]
  !>     incx      [rocblas_int]
  !>               specifies the increment for the elements of x.
  !> 
  !>     
  interface rocblas_ztpsv
    function rocblas_ztpsv_orig(handle,uplo,transA,diag,n,AP,x,incx) bind(c, name="rocblas_ztpsv")
      use iso_c_binding
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocblas_ztpsv_orig
      type(c_ptr),value :: handle
      integer(kind(rocblas_fill_upper)),value :: uplo
      integer(kind(rocblas_operation_none)),value :: transA
      integer(kind(rocblas_diagonal_non_unit)),value :: diag
      integer(c_int),value :: n
      type(c_ptr),value :: AP
      type(c_ptr),value :: x
      integer(c_int),value :: incx
    end function

#ifdef USE_FPOINTER_INTERFACES
    module procedure rocblas_ztpsv_rank_0,rocblas_ztpsv_rank_1
#endif

  end interface
  
  interface rocblas_stpsv_batched
    function rocblas_stpsv_batched_orig(handle,uplo,transA,diag,n,AP,x,incx,batch_count) bind(c, name="rocblas_stpsv_batched")
      use iso_c_binding
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocblas_stpsv_batched_orig
      type(c_ptr),value :: handle
      integer(kind(rocblas_fill_upper)),value :: uplo
      integer(kind(rocblas_operation_none)),value :: transA
      integer(kind(rocblas_diagonal_non_unit)),value :: diag
      integer(c_int),value :: n
      type(c_ptr) :: AP
      type(c_ptr) :: x
      integer(c_int),value :: incx
      integer(c_int),value :: batch_count
    end function

#ifdef USE_FPOINTER_INTERFACES
    module procedure rocblas_stpsv_batched_full_rank,rocblas_stpsv_batched_rank_0,rocblas_stpsv_batched_rank_1
#endif

  end interface
  
  interface rocblas_dtpsv_batched
    function rocblas_dtpsv_batched_orig(handle,uplo,transA,diag,n,AP,x,incx,batch_count) bind(c, name="rocblas_dtpsv_batched")
      use iso_c_binding
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocblas_dtpsv_batched_orig
      type(c_ptr),value :: handle
      integer(kind(rocblas_fill_upper)),value :: uplo
      integer(kind(rocblas_operation_none)),value :: transA
      integer(kind(rocblas_diagonal_non_unit)),value :: diag
      integer(c_int),value :: n
      type(c_ptr) :: AP
      type(c_ptr) :: x
      integer(c_int),value :: incx
      integer(c_int),value :: batch_count
    end function

#ifdef USE_FPOINTER_INTERFACES
    module procedure rocblas_dtpsv_batched_full_rank,rocblas_dtpsv_batched_rank_0,rocblas_dtpsv_batched_rank_1
#endif

  end interface
  
  interface rocblas_ctpsv_batched
    function rocblas_ctpsv_batched_orig(handle,uplo,transA,diag,n,AP,x,incx,batch_count) bind(c, name="rocblas_ctpsv_batched")
      use iso_c_binding
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocblas_ctpsv_batched_orig
      type(c_ptr),value :: handle
      integer(kind(rocblas_fill_upper)),value :: uplo
      integer(kind(rocblas_operation_none)),value :: transA
      integer(kind(rocblas_diagonal_non_unit)),value :: diag
      integer(c_int),value :: n
      type(c_ptr) :: AP
      type(c_ptr) :: x
      integer(c_int),value :: incx
      integer(c_int),value :: batch_count
    end function

#ifdef USE_FPOINTER_INTERFACES
    module procedure rocblas_ctpsv_batched_full_rank,rocblas_ctpsv_batched_rank_0,rocblas_ctpsv_batched_rank_1
#endif

  end interface
  !> ! \brief BLAS Level 2 API
  !> 
  !>     \details
  !>     TPSV_BATCHED solves
  !> 
  !>          A_ix_i = b_i or A_iTx_i = b_i, or A_iHx_i = b_i,
  !> 
  !>     where x_i and b_i are vectors and A_i is a triangular matrix stored in the packed format,
  !>     for i in [1, batch_count].
  !> 
  !>     The input vectors b_i are overwritten by the output vectors x_i.
  !> 
  !>     @param[in]
  !>     handle    [rocblas_handle]
  !>               handle to the rocblas library context queue.
  !> 
  !>     @param[in]
  !>     uplo    [rocblas_fill]
  !>             rocblas_fill_upper:  each A_i is an upper triangular matrix.
  !>             rocblas_fill_lower:  each A_i is a  lower triangular matrix.
  !> 
  !>     @param[in]
  !>     transA  [rocblas_operation]
  !>             rocblas_operation_none: Solves Ax = b
  !>             rocblas_operation_transpose: Solves ATx = b
  !>             rocblas_operation_conjugate_transpose: Solves AHx = b
  !> 
  !>     @param[in]
  !>     diag    [rocblas_diagonal]
  !>             rocblas_diagonal_unit:     each A_i is assumed to be unit triangular (i.e. the diagonal elements
  !>                                        of each A_i are not used in computations).
  !>             rocblas_diagonal_non_unit: each A_i is not assumed to be unit triangular.
  !> 
  !>     @param[in]
  !>     n         [rocblas_int]
  !>               n specifies the number of rows of each b_i. n >= 0.
  !> 
  !>     @param[in]
  !>     AP        device array of device pointers storing the packed versions of each matrix A_i,
  !>               of dimension >= (n  (n + 1)  2)
  !> 
  !>     @param[inout]
  !>     x         device array of device pointers storing each input vector b_i, overwritten by x_i on output.
  !> 
  !>     @param[in]
  !>     incx      [rocblas_int]
  !>               specifies the increment for the elements of each x_i.
  !>     @param[in]
  !>     batch_count [rocblas_int]
  !>                 specifies the number of instances in the batch.
  !> 
  !>     
  interface rocblas_ztpsv_batched
    function rocblas_ztpsv_batched_orig(handle,uplo,transA,diag,n,AP,x,incx,batch_count) bind(c, name="rocblas_ztpsv_batched")
      use iso_c_binding
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocblas_ztpsv_batched_orig
      type(c_ptr),value :: handle
      integer(kind(rocblas_fill_upper)),value :: uplo
      integer(kind(rocblas_operation_none)),value :: transA
      integer(kind(rocblas_diagonal_non_unit)),value :: diag
      integer(c_int),value :: n
      type(c_ptr) :: AP
      type(c_ptr) :: x
      integer(c_int),value :: incx
      integer(c_int),value :: batch_count
    end function

#ifdef USE_FPOINTER_INTERFACES
    module procedure rocblas_ztpsv_batched_full_rank,rocblas_ztpsv_batched_rank_0,rocblas_ztpsv_batched_rank_1
#endif

  end interface
  
  interface rocblas_stpsv_strided_batched
    function rocblas_stpsv_strided_batched_orig(handle,uplo,transA,diag,n,AP,stride_A,x,incx,stride_x,batch_count) bind(c, name="rocblas_stpsv_strided_batched")
      use iso_c_binding
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocblas_stpsv_strided_batched_orig
      type(c_ptr),value :: handle
      integer(kind(rocblas_fill_upper)),value :: uplo
      integer(kind(rocblas_operation_none)),value :: transA
      integer(kind(rocblas_diagonal_non_unit)),value :: diag
      integer(c_int),value :: n
      type(c_ptr),value :: AP
      integer(c_int64_t),value :: stride_A
      type(c_ptr),value :: x
      integer(c_int),value :: incx
      integer(c_int64_t),value :: stride_x
      integer(c_int),value :: batch_count
    end function

#ifdef USE_FPOINTER_INTERFACES
    module procedure rocblas_stpsv_strided_batched_rank_0,rocblas_stpsv_strided_batched_rank_1
#endif

  end interface
  
  interface rocblas_dtpsv_strided_batched
    function rocblas_dtpsv_strided_batched_orig(handle,uplo,transA,diag,n,AP,stride_A,x,incx,stride_x,batch_count) bind(c, name="rocblas_dtpsv_strided_batched")
      use iso_c_binding
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocblas_dtpsv_strided_batched_orig
      type(c_ptr),value :: handle
      integer(kind(rocblas_fill_upper)),value :: uplo
      integer(kind(rocblas_operation_none)),value :: transA
      integer(kind(rocblas_diagonal_non_unit)),value :: diag
      integer(c_int),value :: n
      type(c_ptr),value :: AP
      integer(c_int64_t),value :: stride_A
      type(c_ptr),value :: x
      integer(c_int),value :: incx
      integer(c_int64_t),value :: stride_x
      integer(c_int),value :: batch_count
    end function

#ifdef USE_FPOINTER_INTERFACES
    module procedure rocblas_dtpsv_strided_batched_rank_0,rocblas_dtpsv_strided_batched_rank_1
#endif

  end interface
  
  interface rocblas_ctpsv_strided_batched
    function rocblas_ctpsv_strided_batched_orig(handle,uplo,transA,diag,n,AP,stride_A,x,incx,stride_x,batch_count) bind(c, name="rocblas_ctpsv_strided_batched")
      use iso_c_binding
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocblas_ctpsv_strided_batched_orig
      type(c_ptr),value :: handle
      integer(kind(rocblas_fill_upper)),value :: uplo
      integer(kind(rocblas_operation_none)),value :: transA
      integer(kind(rocblas_diagonal_non_unit)),value :: diag
      integer(c_int),value :: n
      type(c_ptr),value :: AP
      integer(c_int64_t),value :: stride_A
      type(c_ptr),value :: x
      integer(c_int),value :: incx
      integer(c_int64_t),value :: stride_x
      integer(c_int),value :: batch_count
    end function

#ifdef USE_FPOINTER_INTERFACES
    module procedure rocblas_ctpsv_strided_batched_rank_0,rocblas_ctpsv_strided_batched_rank_1
#endif

  end interface
  !> ! \brief BLAS Level 2 API
  !> 
  !>     \details
  !>     TPSV_STRIDED_BATCHED solves
  !> 
  !>          A_ix_i = b_i or A_iTx_i = b_i, or A_iHx_i = b_i,
  !> 
  !>     where x_i and b_i are vectors and A_i is a triangular matrix stored in the packed format,
  !>     for i in [1, batch_count].
  !> 
  !>     The input vectors b_i are overwritten by the output vectors x_i.
  !> 
  !>     @param[in]
  !>     handle    [rocblas_handle]
  !>               handle to the rocblas library context queue.
  !> 
  !>     @param[in]
  !>     uplo    [rocblas_fill]
  !>             rocblas_fill_upper:  each A_i is an upper triangular matrix.
  !>             rocblas_fill_lower:  each A_i is a  lower triangular matrix.
  !> 
  !>     @param[in]
  !>     transA  [rocblas_operation]
  !>             rocblas_operation_none: Solves Ax = b
  !>             rocblas_operation_transpose: Solves ATx = b
  !>             rocblas_operation_conjugate_transpose: Solves AHx = b
  !> 
  !>     @param[in]
  !>     diag    [rocblas_diagonal]
  !>             rocblas_diagonal_unit:     each A_i is assumed to be unit triangular (i.e. the diagonal elements
  !>                                        of each A_i are not used in computations).
  !>             rocblas_diagonal_non_unit: each A_i is not assumed to be unit triangular.
  !> 
  !>     @param[in]
  !>     n         [rocblas_int]
  !>               n specifies the number of rows of each b_i. n >= 0.
  !> 
  !>     @param[in]
  !>     AP        device pointer pointing to the first packed matrix A_1,
  !>               of dimension >= (n  (n + 1)  2)
  !> 
  !>     @param[in]
  !>     stride_A  [rocblas_stride]
  !>               stride from the beginning of one packed matrix (AP_i) and the next (AP_i+1).
  !> 
  !>     @param[inout]
  !>     x         device pointer pointing to the first input vector b_1. Overwritten by each x_i on output.
  !> 
  !>     @param[in]
  !>     incx      [rocblas_int]
  !>               specifies the increment for the elements of each x_i.
  !>     @param[in]
  !>     stride_x  [rocblas_stride]
  !>               stride from the beginning of one vector (x_i) and the next (x_i+1).
  !>     @param[in]
  !>     batch_count [rocblas_int]
  !>                 specifies the number of instances in the batch.
  !> 
  !>     
  interface rocblas_ztpsv_strided_batched
    function rocblas_ztpsv_strided_batched_orig(handle,uplo,transA,diag,n,AP,stride_A,x,incx,stride_x,batch_count) bind(c, name="rocblas_ztpsv_strided_batched")
      use iso_c_binding
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocblas_ztpsv_strided_batched_orig
      type(c_ptr),value :: handle
      integer(kind(rocblas_fill_upper)),value :: uplo
      integer(kind(rocblas_operation_none)),value :: transA
      integer(kind(rocblas_diagonal_non_unit)),value :: diag
      integer(c_int),value :: n
      type(c_ptr),value :: AP
      integer(c_int64_t),value :: stride_A
      type(c_ptr),value :: x
      integer(c_int),value :: incx
      integer(c_int64_t),value :: stride_x
      integer(c_int),value :: batch_count
    end function

#ifdef USE_FPOINTER_INTERFACES
    module procedure rocblas_ztpsv_strided_batched_rank_0,rocblas_ztpsv_strided_batched_rank_1
#endif

  end interface
  
  interface rocblas_ssymv
    function rocblas_ssymv_orig(handle,uplo,n,alpha,A,lda,x,incx,beta,y,incy) bind(c, name="rocblas_ssymv")
      use iso_c_binding
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocblas_ssymv_orig
      type(c_ptr),value :: handle
      integer(kind(rocblas_fill_upper)),value :: uplo
      integer(c_int),value :: n
      real(c_float) :: alpha
      type(c_ptr),value :: A
      integer(c_int),value :: lda
      type(c_ptr),value :: x
      integer(c_int),value :: incx
      real(c_float) :: beta
      type(c_ptr),value :: y
      integer(c_int),value :: incy
    end function

#ifdef USE_FPOINTER_INTERFACES
    module procedure rocblas_ssymv_full_rank,rocblas_ssymv_rank_0,rocblas_ssymv_rank_1
#endif

  end interface
  
  interface rocblas_dsymv
    function rocblas_dsymv_orig(handle,uplo,n,alpha,A,lda,x,incx,beta,y,incy) bind(c, name="rocblas_dsymv")
      use iso_c_binding
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocblas_dsymv_orig
      type(c_ptr),value :: handle
      integer(kind(rocblas_fill_upper)),value :: uplo
      integer(c_int),value :: n
      real(c_double) :: alpha
      type(c_ptr),value :: A
      integer(c_int),value :: lda
      type(c_ptr),value :: x
      integer(c_int),value :: incx
      real(c_double) :: beta
      type(c_ptr),value :: y
      integer(c_int),value :: incy
    end function

#ifdef USE_FPOINTER_INTERFACES
    module procedure rocblas_dsymv_full_rank,rocblas_dsymv_rank_0,rocblas_dsymv_rank_1
#endif

  end interface
  
  interface rocblas_csymv
    function rocblas_csymv_orig(handle,uplo,n,alpha,A,lda,x,incx,beta,y,incy) bind(c, name="rocblas_csymv")
      use iso_c_binding
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocblas_csymv_orig
      type(c_ptr),value :: handle
      integer(kind(rocblas_fill_upper)),value :: uplo
      integer(c_int),value :: n
      complex(c_float_complex) :: alpha
      type(c_ptr),value :: A
      integer(c_int),value :: lda
      type(c_ptr),value :: x
      integer(c_int),value :: incx
      complex(c_float_complex) :: beta
      type(c_ptr),value :: y
      integer(c_int),value :: incy
    end function

#ifdef USE_FPOINTER_INTERFACES
    module procedure rocblas_csymv_full_rank,rocblas_csymv_rank_0,rocblas_csymv_rank_1
#endif

  end interface
  !> ! \brief BLAS Level 2 API
  !> 
  !>     \details
  !>     xSYMV performs the matrix-vector operation:
  !> 
  !>         y := alphaAx + betay,
  !> 
  !>     where alpha and beta are scalars, x and y are n element vectors and
  !>     A should contain an upper or lower triangular n by n symmetric matrix.
  !> 
  !>     @param[in]
  !>     handle    [rocblas_handle]
  !>               handle to the rocblas library context queue.
  !>     @param[in]
  !>     uplo      rocblas_fill
  !>               specifies whether the upper 'rocblas_fill_upper' or lower 'rocblas_fill_lower'
  !>               if rocblas_fill_upper, the lower part of A is not referenced
  !>               if rocblas_fill_lower, the upper part of A is not referenced
  !>     @param[in]
  !>     n         [rocblas_int]
  !>     @param[in]
  !>     alpha
  !>               specifies the scalar alpha
  !>     @param[in]
  !>     A         pointer storing matrix A on the GPU
  !>     @param[in]
  !>     lda       [rocblas_int]
  !>               specifies the leading dimension of A
  !>     @param[in]
  !>     x         pointer storing vector x on the GPU
  !>     @param[in]
  !>     incx      [rocblas_int]
  !>               specifies the increment for the elements of x
  !>     @param[in]
  !>     beta      specifies the scalar beta
  !>     @param[out]
  !>     y         pointer storing vector y on the GPU
  !>     @param[in]
  !>     incy      [rocblas_int]
  !>               specifies the increment for the elements of y
  !> 
  !>     
  interface rocblas_zsymv
    function rocblas_zsymv_orig(handle,uplo,n,alpha,A,lda,x,incx,beta,y,incy) bind(c, name="rocblas_zsymv")
      use iso_c_binding
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocblas_zsymv_orig
      type(c_ptr),value :: handle
      integer(kind(rocblas_fill_upper)),value :: uplo
      integer(c_int),value :: n
      complex(c_double_complex) :: alpha
      type(c_ptr),value :: A
      integer(c_int),value :: lda
      type(c_ptr),value :: x
      integer(c_int),value :: incx
      complex(c_double_complex) :: beta
      type(c_ptr),value :: y
      integer(c_int),value :: incy
    end function

#ifdef USE_FPOINTER_INTERFACES
    module procedure rocblas_zsymv_full_rank,rocblas_zsymv_rank_0,rocblas_zsymv_rank_1
#endif

  end interface
  
  interface rocblas_ssymv_batched
    function rocblas_ssymv_batched_orig(handle,uplo,n,alpha,A,lda,x,incx,beta,y,incy,batch_count) bind(c, name="rocblas_ssymv_batched")
      use iso_c_binding
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocblas_ssymv_batched_orig
      type(c_ptr),value :: handle
      integer(kind(rocblas_fill_upper)),value :: uplo
      integer(c_int),value :: n
      real(c_float) :: alpha
      type(c_ptr) :: A
      integer(c_int),value :: lda
      type(c_ptr) :: x
      integer(c_int),value :: incx
      real(c_float) :: beta
      type(c_ptr) :: y
      integer(c_int),value :: incy
      integer(c_int),value :: batch_count
    end function

#ifdef USE_FPOINTER_INTERFACES
    module procedure rocblas_ssymv_batched_full_rank,rocblas_ssymv_batched_rank_0,rocblas_ssymv_batched_rank_1
#endif

  end interface
  
  interface rocblas_dsymv_batched
    function rocblas_dsymv_batched_orig(handle,uplo,n,alpha,A,lda,x,incx,beta,y,incy,batch_count) bind(c, name="rocblas_dsymv_batched")
      use iso_c_binding
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocblas_dsymv_batched_orig
      type(c_ptr),value :: handle
      integer(kind(rocblas_fill_upper)),value :: uplo
      integer(c_int),value :: n
      real(c_double) :: alpha
      type(c_ptr) :: A
      integer(c_int),value :: lda
      type(c_ptr) :: x
      integer(c_int),value :: incx
      real(c_double) :: beta
      type(c_ptr) :: y
      integer(c_int),value :: incy
      integer(c_int),value :: batch_count
    end function

#ifdef USE_FPOINTER_INTERFACES
    module procedure rocblas_dsymv_batched_full_rank,rocblas_dsymv_batched_rank_0,rocblas_dsymv_batched_rank_1
#endif

  end interface
  
  interface rocblas_csymv_batched
    function rocblas_csymv_batched_orig(handle,uplo,n,alpha,A,lda,x,incx,beta,y,incy,batch_count) bind(c, name="rocblas_csymv_batched")
      use iso_c_binding
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocblas_csymv_batched_orig
      type(c_ptr),value :: handle
      integer(kind(rocblas_fill_upper)),value :: uplo
      integer(c_int),value :: n
      complex(c_float_complex) :: alpha
      type(c_ptr) :: A
      integer(c_int),value :: lda
      type(c_ptr) :: x
      integer(c_int),value :: incx
      complex(c_float_complex) :: beta
      type(c_ptr) :: y
      integer(c_int),value :: incy
      integer(c_int),value :: batch_count
    end function

#ifdef USE_FPOINTER_INTERFACES
    module procedure rocblas_csymv_batched_full_rank,rocblas_csymv_batched_rank_0,rocblas_csymv_batched_rank_1
#endif

  end interface
  !> ! \brief BLAS Level 2 API
  !> 
  !>     \details
  !>     xSYMV_batched performs the matrix-vector operation:
  !> 
  !>         y_i := alphaA_ix_i + betay_i,
  !> 
  !>     where (A_i, x_i, y_i) is the i-th instance of the batch.
  !>     alpha and beta are scalars, x_i and y_i are vectors and A_i is an
  !>     n by n symmetric matrix, for i = 1, ..., batch_count.
  !>     A a should contain an upper or lower triangular symmetric matrix
  !>     and the opposing triangular part of A is not referenced
  !> 
  !>     @param[in]
  !>     handle    [rocblas_handle]
  !>               handle to the rocblas library context queue
  !>     @param[in]
  !>     uplo      [rocblas_fill]
  !>               specifies whether the upper 'rocblas_fill_upper' or lower 'rocblas_fill_lower'
  !>               if rocblas_fill_upper, the lower part of A is not referenced
  !>               if rocblas_fill_lower, the upper part of A is not referenced
  !>     @param[in]
  !>     n         [rocblas_int]
  !>               number of rows and columns of each matrix A_i
  !>     @param[in]
  !>     alpha
  !>               device pointer or host pointer to scalar alpha
  !>     @param[in]
  !>     A         device array of device pointers storing each matrix A_i
  !>     @param[in]
  !>     lda       [rocblas_int]
  !>               specifies the leading dimension of each matrix A_i
  !>     @param[in]
  !>     x         device array of device pointers storing each vector x_i
  !>     @param[in]
  !>     incx      [rocblas_int]
  !>               specifies the increment for the elements of each vector x_i
  !>     @param[in]
  !>     beta      device pointer or host pointer to scalar beta
  !>     @param[out]
  !>     y         device array of device pointers storing each vector y_i
  !>     @param[in]
  !>     incy      [rocblas_int]
  !>               specifies the increment for the elements of each vector y_i
  !>     @param[in]
  !>     batch_count [rocblas_int]
  !>                 number of instances in the batch
  !> 
  !>     
  interface rocblas_zsymv_batched
    function rocblas_zsymv_batched_orig(handle,uplo,n,alpha,A,lda,x,incx,beta,y,incy,batch_count) bind(c, name="rocblas_zsymv_batched")
      use iso_c_binding
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocblas_zsymv_batched_orig
      type(c_ptr),value :: handle
      integer(kind(rocblas_fill_upper)),value :: uplo
      integer(c_int),value :: n
      complex(c_double_complex) :: alpha
      type(c_ptr) :: A
      integer(c_int),value :: lda
      type(c_ptr) :: x
      integer(c_int),value :: incx
      complex(c_double_complex) :: beta
      type(c_ptr) :: y
      integer(c_int),value :: incy
      integer(c_int),value :: batch_count
    end function

#ifdef USE_FPOINTER_INTERFACES
    module procedure rocblas_zsymv_batched_full_rank,rocblas_zsymv_batched_rank_0,rocblas_zsymv_batched_rank_1
#endif

  end interface
  
  interface rocblas_ssymv_strided_batched
    function rocblas_ssymv_strided_batched_orig(handle,uplo,n,alpha,A,lda,strideA,x,incx,stridex,beta,y,incy,stridey,batch_count) bind(c, name="rocblas_ssymv_strided_batched")
      use iso_c_binding
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocblas_ssymv_strided_batched_orig
      type(c_ptr),value :: handle
      integer(kind(rocblas_fill_upper)),value :: uplo
      integer(c_int),value :: n
      real(c_float) :: alpha
      type(c_ptr),value :: A
      integer(c_int),value :: lda
      integer(c_int64_t),value :: strideA
      type(c_ptr),value :: x
      integer(c_int),value :: incx
      integer(c_int64_t),value :: stridex
      real(c_float) :: beta
      type(c_ptr),value :: y
      integer(c_int),value :: incy
      integer(c_int64_t),value :: stridey
      integer(c_int),value :: batch_count
    end function

#ifdef USE_FPOINTER_INTERFACES
    module procedure rocblas_ssymv_strided_batched_full_rank,rocblas_ssymv_strided_batched_rank_0,rocblas_ssymv_strided_batched_rank_1
#endif

  end interface
  
  interface rocblas_dsymv_strided_batched
    function rocblas_dsymv_strided_batched_orig(handle,uplo,n,alpha,A,lda,strideA,x,incx,stridex,beta,y,incy,stridey,batch_count) bind(c, name="rocblas_dsymv_strided_batched")
      use iso_c_binding
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocblas_dsymv_strided_batched_orig
      type(c_ptr),value :: handle
      integer(kind(rocblas_fill_upper)),value :: uplo
      integer(c_int),value :: n
      real(c_double) :: alpha
      type(c_ptr),value :: A
      integer(c_int),value :: lda
      integer(c_int64_t),value :: strideA
      type(c_ptr),value :: x
      integer(c_int),value :: incx
      integer(c_int64_t),value :: stridex
      real(c_double) :: beta
      type(c_ptr),value :: y
      integer(c_int),value :: incy
      integer(c_int64_t),value :: stridey
      integer(c_int),value :: batch_count
    end function

#ifdef USE_FPOINTER_INTERFACES
    module procedure rocblas_dsymv_strided_batched_full_rank,rocblas_dsymv_strided_batched_rank_0,rocblas_dsymv_strided_batched_rank_1
#endif

  end interface
  
  interface rocblas_csymv_strided_batched
    function rocblas_csymv_strided_batched_orig(handle,uplo,n,alpha,A,lda,strideA,x,incx,stridex,beta,y,incy,stridey,batch_count) bind(c, name="rocblas_csymv_strided_batched")
      use iso_c_binding
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocblas_csymv_strided_batched_orig
      type(c_ptr),value :: handle
      integer(kind(rocblas_fill_upper)),value :: uplo
      integer(c_int),value :: n
      complex(c_float_complex) :: alpha
      type(c_ptr),value :: A
      integer(c_int),value :: lda
      integer(c_int64_t),value :: strideA
      type(c_ptr),value :: x
      integer(c_int),value :: incx
      integer(c_int64_t),value :: stridex
      complex(c_float_complex) :: beta
      type(c_ptr),value :: y
      integer(c_int),value :: incy
      integer(c_int64_t),value :: stridey
      integer(c_int),value :: batch_count
    end function

#ifdef USE_FPOINTER_INTERFACES
    module procedure rocblas_csymv_strided_batched_full_rank,rocblas_csymv_strided_batched_rank_0,rocblas_csymv_strided_batched_rank_1
#endif

  end interface
  !> ! \brief BLAS Level 2 API
  !> 
  !>     \details
  !>     xSYMV_strided_batched performs the matrix-vector operation:
  !> 
  !>         y_i := alphaA_ix_i + betay_i,
  !> 
  !>     where (A_i, x_i, y_i) is the i-th instance of the batch.
  !>     alpha and beta are scalars, x_i and y_i are vectors and A_i is an
  !>     n by n symmetric matrix, for i = 1, ..., batch_count.
  !>     A a should contain an upper or lower triangular symmetric matrix
  !>     and the opposing triangular part of A is not referenced
  !> 
  !>     @param[in]
  !>     handle    [rocblas_handle]
  !>               handle to the rocblas library context queue
  !>     @param[in]
  !>     uplo      [rocblas_fill]
  !>               specifies whether the upper 'rocblas_fill_upper' or lower 'rocblas_fill_lower'
  !>               if rocblas_fill_upper, the lower part of A is not referenced
  !>               if rocblas_fill_lower, the upper part of A is not referenced
  !>     @param[in]
  !>     n         [rocblas_int]
  !>               number of rows and columns of each matrix A_i
  !>     @param[in]
  !>     alpha
  !>               device pointer or host pointer to scalar alpha
  !>     @param[in]
  !>     A         Device pointer to the first matrix A_1 on the GPU
  !>     @param[in]
  !>     lda       [rocblas_int]
  !>               specifies the leading dimension of each matrix A_i
  !>     @param[in]
  !>     strideA     [rocblas_stride]
  !>                 stride from the start of one matrix (A_i) and the next one (A_i+1)
  !>     @param[in]
  !>     x         Device pointer to the first vector x_1 on the GPU
  !>     @param[in]
  !>     incx      [rocblas_int]
  !>               specifies the increment for the elements of each vector x_i
  !>     @param[in]
  !>     stridex     [rocblas_stride]
  !>                 stride from the start of one vector (x_i) and the next one (x_i+1).
  !>                 There are no restrictions placed on stride_x, however the user should
  !>                 take care to ensure that stridex is of appropriate size.
  !>                 This typically means stridex >= n  incx. stridex should be non zero.
  !>     @param[in]
  !>     beta      device pointer or host pointer to scalar beta
  !>     @param[out]
  !>     y         Device pointer to the first vector y_1 on the GPU
  !>     @param[in]
  !>     incy      [rocblas_int]
  !>               specifies the increment for the elements of each vector y_i
  !>     @param[in]
  !>     stridey     [rocblas_stride]
  !>                 stride from the start of one vector (y_i) and the next one (y_i+1).
  !>                 There are no restrictions placed on stride_y, however the user should
  !>                 take care to ensure that stridey is of appropriate size.
  !>                 This typically means stridey >= n  incy. stridey should be non zero.
  !>     @param[in]
  !>     batch_count [rocblas_int]
  !>                 number of instances in the batch
  !> 
  !>     
  interface rocblas_zsymv_strided_batched
    function rocblas_zsymv_strided_batched_orig(handle,uplo,n,alpha,A,lda,strideA,x,incx,stridex,beta,y,incy,stridey,batch_count) bind(c, name="rocblas_zsymv_strided_batched")
      use iso_c_binding
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocblas_zsymv_strided_batched_orig
      type(c_ptr),value :: handle
      integer(kind(rocblas_fill_upper)),value :: uplo
      integer(c_int),value :: n
      complex(c_double_complex) :: alpha
      type(c_ptr),value :: A
      integer(c_int),value :: lda
      integer(c_int64_t),value :: strideA
      type(c_ptr),value :: x
      integer(c_int),value :: incx
      integer(c_int64_t),value :: stridex
      complex(c_double_complex) :: beta
      type(c_ptr),value :: y
      integer(c_int),value :: incy
      integer(c_int64_t),value :: stridey
      integer(c_int),value :: batch_count
    end function

#ifdef USE_FPOINTER_INTERFACES
    module procedure rocblas_zsymv_strided_batched_full_rank,rocblas_zsymv_strided_batched_rank_0,rocblas_zsymv_strided_batched_rank_1
#endif

  end interface
  
  interface rocblas_sspmv
    function rocblas_sspmv_orig(handle,uplo,n,alpha,A,x,incx,beta,y,incy) bind(c, name="rocblas_sspmv")
      use iso_c_binding
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocblas_sspmv_orig
      type(c_ptr),value :: handle
      integer(kind(rocblas_fill_upper)),value :: uplo
      integer(c_int),value :: n
      real(c_float) :: alpha
      type(c_ptr),value :: A
      type(c_ptr),value :: x
      integer(c_int),value :: incx
      real(c_float) :: beta
      type(c_ptr),value :: y
      integer(c_int),value :: incy
    end function

#ifdef USE_FPOINTER_INTERFACES
    module procedure rocblas_sspmv_full_rank,rocblas_sspmv_rank_0,rocblas_sspmv_rank_1
#endif

  end interface
  !> ! \brief BLAS Level 2 API
  !> 
  !>     \details
  !>     xSPMV performs the matrix-vector operation:
  !> 
  !>         y := alphaAx + betay,
  !> 
  !>     where alpha and beta are scalars, x and y are n element vectors and
  !>     A should contain an upper or lower triangular n by n packed symmetric matrix.
  !> 
  !>     @param[in]
  !>     handle    [rocblas_handle]
  !>               handle to the rocblas library context queue.
  !>     @param[in]
  !>     uplo      rocblas_fill
  !>               specifies whether the upper 'rocblas_fill_upper' or lower 'rocblas_fill_lower'
  !>               if rocblas_fill_upper, the lower part of A is not referenced
  !>               if rocblas_fill_lower, the upper part of A is not referenced
  !>     @param[in]
  !>     n         [rocblas_int]
  !>     @param[in]
  !>     alpha
  !>               specifies the scalar alpha
  !>     @param[in]
  !>     A         pointer storing matrix A on the GPU
  !>     @param[in]
  !>     x         pointer storing vector x on the GPU
  !>     @param[in]
  !>     incx      [rocblas_int]
  !>               specifies the increment for the elements of x
  !>     @param[in]
  !>     beta      specifies the scalar beta
  !>     @param[out]
  !>     y         pointer storing vector y on the GPU
  !>     @param[in]
  !>     incy      [rocblas_int]
  !>               specifies the increment for the elements of y
  !> 
  !>     
  interface rocblas_dspmv
    function rocblas_dspmv_orig(handle,uplo,n,alpha,A,x,incx,beta,y,incy) bind(c, name="rocblas_dspmv")
      use iso_c_binding
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocblas_dspmv_orig
      type(c_ptr),value :: handle
      integer(kind(rocblas_fill_upper)),value :: uplo
      integer(c_int),value :: n
      real(c_double) :: alpha
      type(c_ptr),value :: A
      type(c_ptr),value :: x
      integer(c_int),value :: incx
      real(c_double) :: beta
      type(c_ptr),value :: y
      integer(c_int),value :: incy
    end function

#ifdef USE_FPOINTER_INTERFACES
    module procedure rocblas_dspmv_full_rank,rocblas_dspmv_rank_0,rocblas_dspmv_rank_1
#endif

  end interface
  
  interface rocblas_sspmv_batched
    function rocblas_sspmv_batched_orig(handle,uplo,n,alpha,A,x,incx,beta,y,incy,batch_count) bind(c, name="rocblas_sspmv_batched")
      use iso_c_binding
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocblas_sspmv_batched_orig
      type(c_ptr),value :: handle
      integer(kind(rocblas_fill_upper)),value :: uplo
      integer(c_int),value :: n
      real(c_float) :: alpha
      type(c_ptr) :: A
      type(c_ptr) :: x
      integer(c_int),value :: incx
      real(c_float) :: beta
      type(c_ptr) :: y
      integer(c_int),value :: incy
      integer(c_int),value :: batch_count
    end function

#ifdef USE_FPOINTER_INTERFACES
    module procedure rocblas_sspmv_batched_full_rank,rocblas_sspmv_batched_rank_0,rocblas_sspmv_batched_rank_1
#endif

  end interface
  !> ! \brief BLAS Level 2 API
  !> 
  !>     \details
  !>     xSPMV_batched performs the matrix-vector operation:
  !> 
  !>         y_i := alphaA_ix_i + betay_i,
  !> 
  !>     where (A_i, x_i, y_i) is the i-th instance of the batch.
  !>     alpha and beta are scalars, x_i and y_i are vectors and A_i is an
  !>     n by n symmetric matrix, for i = 1, ..., batch_count.
  !>     A should contain an upper or lower triangular n by n packed symmetric matrix.
  !> 
  !>     @param[in]
  !>     handle    [rocblas_handle]
  !>               handle to the rocblas library context queue
  !>     @param[in]
  !>     uplo      [rocblas_fill]
  !>               specifies whether the upper 'rocblas_fill_upper' or lower 'rocblas_fill_lower'
  !>               if rocblas_fill_upper, the lower part of A is not referenced
  !>               if rocblas_fill_lower, the upper part of A is not referenced
  !>     @param[in]
  !>     n         [rocblas_int]
  !>               number of rows and columns of each matrix A_i
  !>     @param[in]
  !>     alpha
  !>               device pointer or host pointer to scalar alpha
  !>     @param[in]
  !>     A         device array of device pointers storing each matrix A_i
  !>     @param[in]
  !>     x         device array of device pointers storing each vector x_i
  !>     @param[in]
  !>     incx      [rocblas_int]
  !>               specifies the increment for the elements of each vector x_i
  !>     @param[in]
  !>     beta      device pointer or host pointer to scalar beta
  !>     @param[out]
  !>     y         device array of device pointers storing each vector y_i
  !>     @param[in]
  !>     incy      [rocblas_int]
  !>               specifies the increment for the elements of each vector y_i
  !>     @param[in]
  !>     batch_count [rocblas_int]
  !>                 number of instances in the batch
  !> 
  !>     
  interface rocblas_dspmv_batched
    function rocblas_dspmv_batched_orig(handle,uplo,n,alpha,A,x,incx,beta,y,incy,batch_count) bind(c, name="rocblas_dspmv_batched")
      use iso_c_binding
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocblas_dspmv_batched_orig
      type(c_ptr),value :: handle
      integer(kind(rocblas_fill_upper)),value :: uplo
      integer(c_int),value :: n
      real(c_double) :: alpha
      type(c_ptr) :: A
      type(c_ptr) :: x
      integer(c_int),value :: incx
      real(c_double) :: beta
      type(c_ptr) :: y
      integer(c_int),value :: incy
      integer(c_int),value :: batch_count
    end function

#ifdef USE_FPOINTER_INTERFACES
    module procedure rocblas_dspmv_batched_full_rank,rocblas_dspmv_batched_rank_0,rocblas_dspmv_batched_rank_1
#endif

  end interface
  
  interface rocblas_sspmv_strided_batched
    function rocblas_sspmv_strided_batched_orig(handle,uplo,n,alpha,A,strideA,x,incx,stridex,beta,y,incy,stridey,batch_count) bind(c, name="rocblas_sspmv_strided_batched")
      use iso_c_binding
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocblas_sspmv_strided_batched_orig
      type(c_ptr),value :: handle
      integer(kind(rocblas_fill_upper)),value :: uplo
      integer(c_int),value :: n
      real(c_float) :: alpha
      type(c_ptr),value :: A
      integer(c_int64_t),value :: strideA
      type(c_ptr),value :: x
      integer(c_int),value :: incx
      integer(c_int64_t),value :: stridex
      real(c_float) :: beta
      type(c_ptr),value :: y
      integer(c_int),value :: incy
      integer(c_int64_t),value :: stridey
      integer(c_int),value :: batch_count
    end function

#ifdef USE_FPOINTER_INTERFACES
    module procedure rocblas_sspmv_strided_batched_full_rank,rocblas_sspmv_strided_batched_rank_0,rocblas_sspmv_strided_batched_rank_1
#endif

  end interface
  !> ! \brief BLAS Level 2 API
  !> 
  !>     \details
  !>     xSPMV_strided_batched performs the matrix-vector operation:
  !> 
  !>         y_i := alphaA_ix_i + betay_i,
  !> 
  !>     where (A_i, x_i, y_i) is the i-th instance of the batch.
  !>     alpha and beta are scalars, x_i and y_i are vectors and A_i is an
  !>     n by n symmetric matrix, for i = 1, ..., batch_count.
  !>     A should contain an upper or lower triangular n by n packed symmetric matrix.
  !> 
  !>     @param[in]
  !>     handle    [rocblas_handle]
  !>               handle to the rocblas library context queue
  !>     @param[in]
  !>     uplo      [rocblas_fill]
  !>               specifies whether the upper 'rocblas_fill_upper' or lower 'rocblas_fill_lower'
  !>               if rocblas_fill_upper, the lower part of A is not referenced
  !>               if rocblas_fill_lower, the upper part of A is not referenced
  !>     @param[in]
  !>     n         [rocblas_int]
  !>               number of rows and columns of each matrix A_i
  !>     @param[in]
  !>     alpha
  !>               device pointer or host pointer to scalar alpha
  !>     @param[in]
  !>     A         Device pointer to the first matrix A_1 on the GPU
  !>     @param[in]
  !>     strideA     [rocblas_stride]
  !>                 stride from the start of one matrix (A_i) and the next one (A_i+1)
  !>     @param[in]
  !>     x         Device pointer to the first vector x_1 on the GPU
  !>     @param[in]
  !>     incx      [rocblas_int]
  !>               specifies the increment for the elements of each vector x_i
  !>     @param[in]
  !>     stridex     [rocblas_stride]
  !>                 stride from the start of one vector (x_i) and the next one (x_i+1).
  !>                 There are no restrictions placed on stridex, however the user should
  !>                 take care to ensure that stridex is of appropriate size.
  !>                 This typically means stridex >= n  incx. stridex should be non zero.
  !>     @param[in]
  !>     beta      device pointer or host pointer to scalar beta
  !>     @param[out]
  !>     y         Device pointer to the first vector y_1 on the GPU
  !>     @param[in]
  !>     incy      [rocblas_int]
  !>               specifies the increment for the elements of each vector y_i
  !>     @param[in]
  !>     stridey     [rocblas_stride]
  !>                 stride from the start of one vector (y_i) and the next one (y_i+1).
  !>                 There are no restrictions placed on stridey, however the user should
  !>                 take care to ensure that stridey is of appropriate size.
  !>                 This typically means stridey >= n  incy. stridey should be non zero.
  !>     @param[in]
  !>     batch_count [rocblas_int]
  !>                 number of instances in the batch
  !> 
  !>     
  interface rocblas_dspmv_strided_batched
    function rocblas_dspmv_strided_batched_orig(handle,uplo,n,alpha,A,strideA,x,incx,stridex,beta,y,incy,stridey,batch_count) bind(c, name="rocblas_dspmv_strided_batched")
      use iso_c_binding
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocblas_dspmv_strided_batched_orig
      type(c_ptr),value :: handle
      integer(kind(rocblas_fill_upper)),value :: uplo
      integer(c_int),value :: n
      real(c_double) :: alpha
      type(c_ptr),value :: A
      integer(c_int64_t),value :: strideA
      type(c_ptr),value :: x
      integer(c_int),value :: incx
      integer(c_int64_t),value :: stridex
      real(c_double) :: beta
      type(c_ptr),value :: y
      integer(c_int),value :: incy
      integer(c_int64_t),value :: stridey
      integer(c_int),value :: batch_count
    end function

#ifdef USE_FPOINTER_INTERFACES
    module procedure rocblas_dspmv_strided_batched_full_rank,rocblas_dspmv_strided_batched_rank_0,rocblas_dspmv_strided_batched_rank_1
#endif

  end interface
  
  interface rocblas_ssbmv
    function rocblas_ssbmv_orig(handle,uplo,n,k,alpha,A,lda,x,incx,beta,y,incy) bind(c, name="rocblas_ssbmv")
      use iso_c_binding
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocblas_ssbmv_orig
      type(c_ptr),value :: handle
      integer(kind(rocblas_fill_upper)),value :: uplo
      integer(c_int),value :: n
      integer(c_int),value :: k
      real(c_float) :: alpha
      type(c_ptr),value :: A
      integer(c_int),value :: lda
      type(c_ptr),value :: x
      integer(c_int),value :: incx
      real(c_float) :: beta
      type(c_ptr),value :: y
      integer(c_int),value :: incy
    end function

#ifdef USE_FPOINTER_INTERFACES
    module procedure rocblas_ssbmv_full_rank,rocblas_ssbmv_rank_0,rocblas_ssbmv_rank_1
#endif

  end interface
  !> ! \brief BLAS Level 2 API
  !> 
  !>     \details
  !>     xSBMV performs the matrix-vector operation:
  !> 
  !>         y := alphaAx + betay,
  !> 
  !>     where alpha and beta are scalars, x and y are n element vectors and
  !>     A should contain an upper or lower triangular n by n symmetric banded matrix.
  !> 
  !>     @param[in]
  !>     handle    [rocblas_handle]
  !>               handle to the rocblas library context queue.
  !>     @param[in]
  !>     uplo      rocblas_fill
  !>               specifies whether the upper 'rocblas_fill_upper' or lower 'rocblas_fill_lower'
  !>               if rocblas_fill_upper, the lower part of A is not referenced
  !>               if rocblas_fill_lower, the upper part of A is not referenced
  !>     @param[in]
  !>     n         [rocblas_int]
  !>     @param[in]
  !>     k         [rocblas_int]
  !>               specifies the number of sub- and super-diagonals
  !>     @param[in]
  !>     alpha
  !>               specifies the scalar alpha
  !>     @param[in]
  !>     A         pointer storing matrix A on the GPU
  !>     @param[in]
  !>     lda       [rocblas_int]
  !>               specifies the leading dimension of matrix A
  !>     @param[in]
  !>     x         pointer storing vector x on the GPU
  !>     @param[in]
  !>     incx      [rocblas_int]
  !>               specifies the increment for the elements of x
  !>     @param[in]
  !>     beta      specifies the scalar beta
  !>     @param[out]
  !>     y         pointer storing vector y on the GPU
  !>     @param[in]
  !>     incy      [rocblas_int]
  !>               specifies the increment for the elements of y
  !> 
  !>     
  interface rocblas_dsbmv
    function rocblas_dsbmv_orig(handle,uplo,n,k,alpha,A,lda,x,incx,beta,y,incy) bind(c, name="rocblas_dsbmv")
      use iso_c_binding
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocblas_dsbmv_orig
      type(c_ptr),value :: handle
      integer(kind(rocblas_fill_upper)),value :: uplo
      integer(c_int),value :: n
      integer(c_int),value :: k
      real(c_double) :: alpha
      type(c_ptr),value :: A
      integer(c_int),value :: lda
      type(c_ptr),value :: x
      integer(c_int),value :: incx
      real(c_double) :: beta
      type(c_ptr),value :: y
      integer(c_int),value :: incy
    end function

#ifdef USE_FPOINTER_INTERFACES
    module procedure rocblas_dsbmv_full_rank,rocblas_dsbmv_rank_0,rocblas_dsbmv_rank_1
#endif

  end interface
  
  interface rocblas_dsbmv_batched
    function rocblas_dsbmv_batched_orig(handle,uplo,n,k,alpha,A,lda,x,incx,beta,y,incy,batch_count) bind(c, name="rocblas_dsbmv_batched")
      use iso_c_binding
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocblas_dsbmv_batched_orig
      type(c_ptr),value :: handle
      integer(kind(rocblas_fill_upper)),value :: uplo
      integer(c_int),value :: n
      integer(c_int),value :: k
      real(c_double) :: alpha
      type(c_ptr) :: A
      integer(c_int),value :: lda
      type(c_ptr) :: x
      integer(c_int),value :: incx
      real(c_double) :: beta
      type(c_ptr) :: y
      integer(c_int),value :: incy
      integer(c_int),value :: batch_count
    end function

#ifdef USE_FPOINTER_INTERFACES
    module procedure rocblas_dsbmv_batched_full_rank,rocblas_dsbmv_batched_rank_0,rocblas_dsbmv_batched_rank_1
#endif

  end interface
  !> ! \brief BLAS Level 2 API
  !> 
  !>     \details
  !>     xSBMV_batched performs the matrix-vector operation:
  !> 
  !>         y_i := alphaA_ix_i + betay_i,
  !> 
  !>     where (A_i, x_i, y_i) is the i-th instance of the batch.
  !>     alpha and beta are scalars, x_i and y_i are vectors and A_i is an
  !>     n by n symmetric banded matrix, for i = 1, ..., batch_count.
  !>     A should contain an upper or lower triangular n by n symmetric banded matrix.
  !> 
  !>     @param[in]
  !>     handle    [rocblas_handle]
  !>               handle to the rocblas library context queue
  !>     @param[in]
  !>     uplo      [rocblas_fill]
  !>               specifies whether the upper 'rocblas_fill_upper' or lower 'rocblas_fill_lower'
  !>               if rocblas_fill_upper, the lower part of A is not referenced
  !>               if rocblas_fill_lower, the upper part of A is not referenced
  !>     @param[in]
  !>     n         [rocblas_int]
  !>               number of rows and columns of each matrix A_i
  !>     @param[in]
  !>     k         [rocblas_int]
  !>               specifies the number of sub- and super-diagonals
  !>     @param[in]
  !>     alpha
  !>               device pointer or host pointer to scalar alpha
  !>     @param[in]
  !>     A         device array of device pointers storing each matrix A_i
  !>     @param[in]
  !>     lda       [rocblas_int]
  !>               specifies the leading dimension of each matrix A_i
  !>     @param[in]
  !>     x         device array of device pointers storing each vector x_i
  !>     @param[in]
  !>     incx      [rocblas_int]
  !>               specifies the increment for the elements of each vector x_i
  !>     @param[in]
  !>     beta      device pointer or host pointer to scalar beta
  !>     @param[out]
  !>     y         device array of device pointers storing each vector y_i
  !>     @param[in]
  !>     incy      [rocblas_int]
  !>               specifies the increment for the elements of each vector y_i
  !>     @param[in]
  !>     batch_count [rocblas_int]
  !>                 number of instances in the batch
  !> 
  !>     
  interface rocblas_ssbmv_batched
    function rocblas_ssbmv_batched_orig(handle,uplo,n,k,alpha,A,lda,x,incx,beta,y,incy,batch_count) bind(c, name="rocblas_ssbmv_batched")
      use iso_c_binding
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocblas_ssbmv_batched_orig
      type(c_ptr),value :: handle
      integer(kind(rocblas_fill_upper)),value :: uplo
      integer(c_int),value :: n
      integer(c_int),value :: k
      real(c_float) :: alpha
      type(c_ptr) :: A
      integer(c_int),value :: lda
      type(c_ptr) :: x
      integer(c_int),value :: incx
      real(c_float) :: beta
      type(c_ptr) :: y
      integer(c_int),value :: incy
      integer(c_int),value :: batch_count
    end function

#ifdef USE_FPOINTER_INTERFACES
    module procedure rocblas_ssbmv_batched_full_rank,rocblas_ssbmv_batched_rank_0,rocblas_ssbmv_batched_rank_1
#endif

  end interface
  
  interface rocblas_ssbmv_strided_batched
    function rocblas_ssbmv_strided_batched_orig(handle,uplo,n,k,alpha,A,lda,strideA,x,incx,stridex,beta,y,incy,stridey,batch_count) bind(c, name="rocblas_ssbmv_strided_batched")
      use iso_c_binding
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocblas_ssbmv_strided_batched_orig
      type(c_ptr),value :: handle
      integer(kind(rocblas_fill_upper)),value :: uplo
      integer(c_int),value :: n
      integer(c_int),value :: k
      real(c_float) :: alpha
      type(c_ptr),value :: A
      integer(c_int),value :: lda
      integer(c_int64_t),value :: strideA
      type(c_ptr),value :: x
      integer(c_int),value :: incx
      integer(c_int64_t),value :: stridex
      real(c_float) :: beta
      type(c_ptr),value :: y
      integer(c_int),value :: incy
      integer(c_int64_t),value :: stridey
      integer(c_int),value :: batch_count
    end function

#ifdef USE_FPOINTER_INTERFACES
    module procedure rocblas_ssbmv_strided_batched_full_rank,rocblas_ssbmv_strided_batched_rank_0,rocblas_ssbmv_strided_batched_rank_1
#endif

  end interface
  !> ! \brief BLAS Level 2 API
  !> 
  !>     \details
  !>     xSBMV_strided_batched performs the matrix-vector operation:
  !> 
  !>         y_i := alphaA_ix_i + betay_i,
  !> 
  !>     where (A_i, x_i, y_i) is the i-th instance of the batch.
  !>     alpha and beta are scalars, x_i and y_i are vectors and A_i is an
  !>     n by n symmetric banded matrix, for i = 1, ..., batch_count.
  !>     A should contain an upper or lower triangular n by n symmetric banded matrix.
  !> 
  !>     @param[in]
  !>     handle    [rocblas_handle]
  !>               handle to the rocblas library context queue
  !>     @param[in]
  !>     uplo      [rocblas_fill]
  !>               specifies whether the upper 'rocblas_fill_upper' or lower 'rocblas_fill_lower'
  !>               if rocblas_fill_upper, the lower part of A is not referenced
  !>               if rocblas_fill_lower, the upper part of A is not referenced
  !>     @param[in]
  !>     n         [rocblas_int]
  !>               number of rows and columns of each matrix A_i
  !>     @param[in]
  !>     k         [rocblas_int]
  !>               specifies the number of sub- and super-diagonals
  !>     @param[in]
  !>     alpha
  !>               device pointer or host pointer to scalar alpha
  !>     @param[in]
  !>     A         Device pointer to the first matrix A_1 on the GPU
  !>     @param[in]
  !>     lda       [rocblas_int]
  !>               specifies the leading dimension of each matrix A_i
  !>     @param[in]
  !>     strideA     [rocblas_stride]
  !>                 stride from the start of one matrix (A_i) and the next one (A_i+1)
  !>     @param[in]
  !>     x         Device pointer to the first vector x_1 on the GPU
  !>     @param[in]
  !>     incx      [rocblas_int]
  !>               specifies the increment for the elements of each vector x_i
  !>     @param[in]
  !>     stridex     [rocblas_stride]
  !>                 stride from the start of one vector (x_i) and the next one (x_i+1).
  !>                 There are no restrictions placed on stridex, however the user should
  !>                 take care to ensure that stridex is of appropriate size.
  !>                 This typically means stridex >= n  incx. stridex should be non zero.
  !>     @param[in]
  !>     beta      device pointer or host pointer to scalar beta
  !>     @param[out]
  !>     y         Device pointer to the first vector y_1 on the GPU
  !>     @param[in]
  !>     incy      [rocblas_int]
  !>               specifies the increment for the elements of each vector y_i
  !>     @param[in]
  !>     stridey     [rocblas_stride]
  !>                 stride from the start of one vector (y_i) and the next one (y_i+1).
  !>                 There are no restrictions placed on stridey, however the user should
  !>                 take care to ensure that stridey is of appropriate size.
  !>                 This typically means stridey >= n  incy. stridey should be non zero.
  !>     @param[in]
  !>     batch_count [rocblas_int]
  !>                 number of instances in the batch
  !> 
  !>     
  interface rocblas_dsbmv_strided_batched
    function rocblas_dsbmv_strided_batched_orig(handle,uplo,n,k,alpha,A,lda,strideA,x,incx,stridex,beta,y,incy,stridey,batch_count) bind(c, name="rocblas_dsbmv_strided_batched")
      use iso_c_binding
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocblas_dsbmv_strided_batched_orig
      type(c_ptr),value :: handle
      integer(kind(rocblas_fill_upper)),value :: uplo
      integer(c_int),value :: n
      integer(c_int),value :: k
      real(c_double) :: alpha
      type(c_ptr),value :: A
      integer(c_int),value :: lda
      integer(c_int64_t),value :: strideA
      type(c_ptr),value :: x
      integer(c_int),value :: incx
      integer(c_int64_t),value :: stridex
      real(c_double) :: beta
      type(c_ptr),value :: y
      integer(c_int),value :: incy
      integer(c_int64_t),value :: stridey
      integer(c_int),value :: batch_count
    end function

#ifdef USE_FPOINTER_INTERFACES
    module procedure rocblas_dsbmv_strided_batched_full_rank,rocblas_dsbmv_strided_batched_rank_0,rocblas_dsbmv_strided_batched_rank_1
#endif

  end interface
  
  interface rocblas_sger
    function rocblas_sger_orig(handle,m,n,alpha,x,incx,y,incy,A,lda) bind(c, name="rocblas_sger")
      use iso_c_binding
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocblas_sger_orig
      type(c_ptr),value :: handle
      integer(c_int),value :: m
      integer(c_int),value :: n
      real(c_float) :: alpha
      type(c_ptr),value :: x
      integer(c_int),value :: incx
      type(c_ptr),value :: y
      integer(c_int),value :: incy
      type(c_ptr),value :: A
      integer(c_int),value :: lda
    end function

#ifdef USE_FPOINTER_INTERFACES
    module procedure rocblas_sger_full_rank,rocblas_sger_rank_0,rocblas_sger_rank_1
#endif

  end interface
  
  interface rocblas_dger
    function rocblas_dger_orig(handle,m,n,alpha,x,incx,y,incy,A,lda) bind(c, name="rocblas_dger")
      use iso_c_binding
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocblas_dger_orig
      type(c_ptr),value :: handle
      integer(c_int),value :: m
      integer(c_int),value :: n
      real(c_double) :: alpha
      type(c_ptr),value :: x
      integer(c_int),value :: incx
      type(c_ptr),value :: y
      integer(c_int),value :: incy
      type(c_ptr),value :: A
      integer(c_int),value :: lda
    end function

#ifdef USE_FPOINTER_INTERFACES
    module procedure rocblas_dger_full_rank,rocblas_dger_rank_0,rocblas_dger_rank_1
#endif

  end interface
  
  interface rocblas_cgeru
    function rocblas_cgeru_orig(handle,m,n,alpha,x,incx,y,incy,A,lda) bind(c, name="rocblas_cgeru")
      use iso_c_binding
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocblas_cgeru_orig
      type(c_ptr),value :: handle
      integer(c_int),value :: m
      integer(c_int),value :: n
      complex(c_float_complex) :: alpha
      type(c_ptr),value :: x
      integer(c_int),value :: incx
      type(c_ptr),value :: y
      integer(c_int),value :: incy
      type(c_ptr),value :: A
      integer(c_int),value :: lda
    end function

#ifdef USE_FPOINTER_INTERFACES
    module procedure rocblas_cgeru_full_rank,rocblas_cgeru_rank_0,rocblas_cgeru_rank_1
#endif

  end interface
  
  interface rocblas_zgeru
    function rocblas_zgeru_orig(handle,m,n,alpha,x,incx,y,incy,A,lda) bind(c, name="rocblas_zgeru")
      use iso_c_binding
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocblas_zgeru_orig
      type(c_ptr),value :: handle
      integer(c_int),value :: m
      integer(c_int),value :: n
      complex(c_double_complex) :: alpha
      type(c_ptr),value :: x
      integer(c_int),value :: incx
      type(c_ptr),value :: y
      integer(c_int),value :: incy
      type(c_ptr),value :: A
      integer(c_int),value :: lda
    end function

#ifdef USE_FPOINTER_INTERFACES
    module procedure rocblas_zgeru_full_rank,rocblas_zgeru_rank_0,rocblas_zgeru_rank_1
#endif

  end interface
  
  interface rocblas_cgerc
    function rocblas_cgerc_orig(handle,m,n,alpha,x,incx,y,incy,A,lda) bind(c, name="rocblas_cgerc")
      use iso_c_binding
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocblas_cgerc_orig
      type(c_ptr),value :: handle
      integer(c_int),value :: m
      integer(c_int),value :: n
      complex(c_float_complex) :: alpha
      type(c_ptr),value :: x
      integer(c_int),value :: incx
      type(c_ptr),value :: y
      integer(c_int),value :: incy
      type(c_ptr),value :: A
      integer(c_int),value :: lda
    end function

#ifdef USE_FPOINTER_INTERFACES
    module procedure rocblas_cgerc_full_rank,rocblas_cgerc_rank_0,rocblas_cgerc_rank_1
#endif

  end interface
  !> ! \brief BLAS Level 2 API
  !> 
  !>     \details
  !>     xGER,xGERU,xGERC performs the matrix-vector operations
  !> 
  !>         A := A + alphaxyT , OR
  !>         A := A + alphaxyH for xGERC
  !> 
  !>     where alpha is a scalar, x and y are vectors, and A is an
  !>     m by n matrix.
  !> 
  !>     @param[in]
  !>     handle    [rocblas_handle]
  !>               handle to the rocblas library context queue.
  !>     @param[in]
  !>     m         [rocblas_int]
  !>               the number of rows of the matrix A.
  !>     @param[in]
  !>     n         [rocblas_int]
  !>               the number of columns of the matrix A.
  !>     @param[in]
  !>     alpha
  !>               device pointer or host pointer to scalar alpha.
  !>     @param[in]
  !>     x         device pointer storing vector x.
  !>     @param[in]
  !>     incx      [rocblas_int]
  !>               specifies the increment for the elements of x.
  !>     @param[in]
  !>     y         device pointer storing vector y.
  !>     @param[in]
  !>     incy      [rocblas_int]
  !>               specifies the increment for the elements of y.
  !>     @param[inout]
  !>     A         device pointer storing matrix A.
  !>     @param[in]
  !>     lda       [rocblas_int]
  !>               specifies the leading dimension of A.
  !> 
  !>     
  interface rocblas_zgerc
    function rocblas_zgerc_orig(handle,m,n,alpha,x,incx,y,incy,A,lda) bind(c, name="rocblas_zgerc")
      use iso_c_binding
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocblas_zgerc_orig
      type(c_ptr),value :: handle
      integer(c_int),value :: m
      integer(c_int),value :: n
      complex(c_double_complex) :: alpha
      type(c_ptr),value :: x
      integer(c_int),value :: incx
      type(c_ptr),value :: y
      integer(c_int),value :: incy
      type(c_ptr),value :: A
      integer(c_int),value :: lda
    end function

#ifdef USE_FPOINTER_INTERFACES
    module procedure rocblas_zgerc_full_rank,rocblas_zgerc_rank_0,rocblas_zgerc_rank_1
#endif

  end interface
  
  interface rocblas_sger_batched
    function rocblas_sger_batched_orig(handle,m,n,alpha,x,incx,y,incy,A,lda,batch_count) bind(c, name="rocblas_sger_batched")
      use iso_c_binding
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocblas_sger_batched_orig
      type(c_ptr),value :: handle
      integer(c_int),value :: m
      integer(c_int),value :: n
      real(c_float) :: alpha
      type(c_ptr) :: x
      integer(c_int),value :: incx
      type(c_ptr) :: y
      integer(c_int),value :: incy
      type(c_ptr) :: A
      integer(c_int),value :: lda
      integer(c_int),value :: batch_count
    end function

#ifdef USE_FPOINTER_INTERFACES
    module procedure rocblas_sger_batched_full_rank,rocblas_sger_batched_rank_0,rocblas_sger_batched_rank_1
#endif

  end interface
  
  interface rocblas_dger_batched
    function rocblas_dger_batched_orig(handle,m,n,alpha,x,incx,y,incy,A,lda,batch_count) bind(c, name="rocblas_dger_batched")
      use iso_c_binding
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocblas_dger_batched_orig
      type(c_ptr),value :: handle
      integer(c_int),value :: m
      integer(c_int),value :: n
      real(c_double) :: alpha
      type(c_ptr) :: x
      integer(c_int),value :: incx
      type(c_ptr) :: y
      integer(c_int),value :: incy
      type(c_ptr) :: A
      integer(c_int),value :: lda
      integer(c_int),value :: batch_count
    end function

#ifdef USE_FPOINTER_INTERFACES
    module procedure rocblas_dger_batched_full_rank,rocblas_dger_batched_rank_0,rocblas_dger_batched_rank_1
#endif

  end interface
  
  interface rocblas_cgeru_batched
    function rocblas_cgeru_batched_orig(handle,m,n,alpha,x,incx,y,incy,A,lda,batch_count) bind(c, name="rocblas_cgeru_batched")
      use iso_c_binding
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocblas_cgeru_batched_orig
      type(c_ptr),value :: handle
      integer(c_int),value :: m
      integer(c_int),value :: n
      complex(c_float_complex) :: alpha
      type(c_ptr) :: x
      integer(c_int),value :: incx
      type(c_ptr) :: y
      integer(c_int),value :: incy
      type(c_ptr) :: A
      integer(c_int),value :: lda
      integer(c_int),value :: batch_count
    end function

#ifdef USE_FPOINTER_INTERFACES
    module procedure rocblas_cgeru_batched_full_rank,rocblas_cgeru_batched_rank_0,rocblas_cgeru_batched_rank_1
#endif

  end interface
  
  interface rocblas_zgeru_batched
    function rocblas_zgeru_batched_orig(handle,m,n,alpha,x,incx,y,incy,A,lda,batch_count) bind(c, name="rocblas_zgeru_batched")
      use iso_c_binding
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocblas_zgeru_batched_orig
      type(c_ptr),value :: handle
      integer(c_int),value :: m
      integer(c_int),value :: n
      complex(c_double_complex) :: alpha
      type(c_ptr) :: x
      integer(c_int),value :: incx
      type(c_ptr) :: y
      integer(c_int),value :: incy
      type(c_ptr) :: A
      integer(c_int),value :: lda
      integer(c_int),value :: batch_count
    end function

#ifdef USE_FPOINTER_INTERFACES
    module procedure rocblas_zgeru_batched_full_rank,rocblas_zgeru_batched_rank_0,rocblas_zgeru_batched_rank_1
#endif

  end interface
  
  interface rocblas_cgerc_batched
    function rocblas_cgerc_batched_orig(handle,m,n,alpha,x,incx,y,incy,A,lda,batch_count) bind(c, name="rocblas_cgerc_batched")
      use iso_c_binding
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocblas_cgerc_batched_orig
      type(c_ptr),value :: handle
      integer(c_int),value :: m
      integer(c_int),value :: n
      complex(c_float_complex) :: alpha
      type(c_ptr) :: x
      integer(c_int),value :: incx
      type(c_ptr) :: y
      integer(c_int),value :: incy
      type(c_ptr) :: A
      integer(c_int),value :: lda
      integer(c_int),value :: batch_count
    end function

#ifdef USE_FPOINTER_INTERFACES
    module procedure rocblas_cgerc_batched_full_rank,rocblas_cgerc_batched_rank_0,rocblas_cgerc_batched_rank_1
#endif

  end interface
  !> ! \brief BLAS Level 2 API
  !> 
  !>     \details
  !>     xGER,xGERU,xGERC_BATCHED performs a batch of the matrix-vector operations
  !> 
  !>         A := A + alphaxyT , OR
  !>         A := A + alphaxyH for xGERC
  !> 
  !>     where (A_i, x_i, y_i) is the i-th instance of the batch.
  !>     alpha is a scalar, x_i and y_i are vectors and A_i is an
  !>     m by n matrix, for i = 1, ..., batch_count.
  !> 
  !>     @param[in]
  !>     handle    [rocblas_handle]
  !>               handle to the rocblas library context queue.
  !>     @param[in]
  !>     m         [rocblas_int]
  !>               the number of rows of each matrix A_i.
  !>     @param[in]
  !>     n         [rocblas_int]
  !>               the number of columns of eaceh matrix A_i.
  !>     @param[in]
  !>     alpha
  !>               device pointer or host pointer to scalar alpha.
  !>     @param[in]
  !>     x         device array of device pointers storing each vector x_i.
  !>     @param[in]
  !>     incx      [rocblas_int]
  !>               specifies the increment for the elements of each vector x_i.
  !>     @param[in]
  !>     y         device array of device pointers storing each vector y_i.
  !>     @param[in]
  !>     incy      [rocblas_int]
  !>               specifies the increment for the elements of each vector y_i.
  !>     @param[inout]
  !>     A         device array of device pointers storing each matrix A_i.
  !>     @param[in]
  !>     lda       [rocblas_int]
  !>               specifies the leading dimension of each A_i.
  !>     @param[in]
  !>     batch_count [rocblas_int]
  !>                 number of instances in the batch
  !> 
  !>     
  interface rocblas_zgerc_batched
    function rocblas_zgerc_batched_orig(handle,m,n,alpha,x,incx,y,incy,A,lda,batch_count) bind(c, name="rocblas_zgerc_batched")
      use iso_c_binding
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocblas_zgerc_batched_orig
      type(c_ptr),value :: handle
      integer(c_int),value :: m
      integer(c_int),value :: n
      complex(c_double_complex) :: alpha
      type(c_ptr) :: x
      integer(c_int),value :: incx
      type(c_ptr) :: y
      integer(c_int),value :: incy
      type(c_ptr) :: A
      integer(c_int),value :: lda
      integer(c_int),value :: batch_count
    end function

#ifdef USE_FPOINTER_INTERFACES
    module procedure rocblas_zgerc_batched_full_rank,rocblas_zgerc_batched_rank_0,rocblas_zgerc_batched_rank_1
#endif

  end interface
  
  interface rocblas_sger_strided_batched
    function rocblas_sger_strided_batched_orig(handle,m,n,alpha,x,incx,stridex,y,incy,stridey,A,lda,strideA,batch_count) bind(c, name="rocblas_sger_strided_batched")
      use iso_c_binding
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocblas_sger_strided_batched_orig
      type(c_ptr),value :: handle
      integer(c_int),value :: m
      integer(c_int),value :: n
      real(c_float) :: alpha
      type(c_ptr),value :: x
      integer(c_int),value :: incx
      integer(c_int64_t),value :: stridex
      type(c_ptr),value :: y
      integer(c_int),value :: incy
      integer(c_int64_t),value :: stridey
      type(c_ptr),value :: A
      integer(c_int),value :: lda
      integer(c_int64_t),value :: strideA
      integer(c_int),value :: batch_count
    end function

#ifdef USE_FPOINTER_INTERFACES
    module procedure rocblas_sger_strided_batched_full_rank,rocblas_sger_strided_batched_rank_0,rocblas_sger_strided_batched_rank_1
#endif

  end interface
  
  interface rocblas_dger_strided_batched
    function rocblas_dger_strided_batched_orig(handle,m,n,alpha,x,incx,stridex,y,incy,stridey,A,lda,strideA,batch_count) bind(c, name="rocblas_dger_strided_batched")
      use iso_c_binding
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocblas_dger_strided_batched_orig
      type(c_ptr),value :: handle
      integer(c_int),value :: m
      integer(c_int),value :: n
      real(c_double) :: alpha
      type(c_ptr),value :: x
      integer(c_int),value :: incx
      integer(c_int64_t),value :: stridex
      type(c_ptr),value :: y
      integer(c_int),value :: incy
      integer(c_int64_t),value :: stridey
      type(c_ptr),value :: A
      integer(c_int),value :: lda
      integer(c_int64_t),value :: strideA
      integer(c_int),value :: batch_count
    end function

#ifdef USE_FPOINTER_INTERFACES
    module procedure rocblas_dger_strided_batched_full_rank,rocblas_dger_strided_batched_rank_0,rocblas_dger_strided_batched_rank_1
#endif

  end interface
  
  interface rocblas_cgeru_strided_batched
    function rocblas_cgeru_strided_batched_orig(handle,m,n,alpha,x,incx,stridex,y,incy,stridey,A,lda,strideA,batch_count) bind(c, name="rocblas_cgeru_strided_batched")
      use iso_c_binding
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocblas_cgeru_strided_batched_orig
      type(c_ptr),value :: handle
      integer(c_int),value :: m
      integer(c_int),value :: n
      complex(c_float_complex) :: alpha
      type(c_ptr),value :: x
      integer(c_int),value :: incx
      integer(c_int64_t),value :: stridex
      type(c_ptr),value :: y
      integer(c_int),value :: incy
      integer(c_int64_t),value :: stridey
      type(c_ptr),value :: A
      integer(c_int),value :: lda
      integer(c_int64_t),value :: strideA
      integer(c_int),value :: batch_count
    end function

#ifdef USE_FPOINTER_INTERFACES
    module procedure rocblas_cgeru_strided_batched_full_rank,rocblas_cgeru_strided_batched_rank_0,rocblas_cgeru_strided_batched_rank_1
#endif

  end interface
  
  interface rocblas_zgeru_strided_batched
    function rocblas_zgeru_strided_batched_orig(handle,m,n,alpha,x,incx,stridex,y,incy,stridey,A,lda,strideA,batch_count) bind(c, name="rocblas_zgeru_strided_batched")
      use iso_c_binding
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocblas_zgeru_strided_batched_orig
      type(c_ptr),value :: handle
      integer(c_int),value :: m
      integer(c_int),value :: n
      complex(c_double_complex) :: alpha
      type(c_ptr),value :: x
      integer(c_int),value :: incx
      integer(c_int64_t),value :: stridex
      type(c_ptr),value :: y
      integer(c_int),value :: incy
      integer(c_int64_t),value :: stridey
      type(c_ptr),value :: A
      integer(c_int),value :: lda
      integer(c_int64_t),value :: strideA
      integer(c_int),value :: batch_count
    end function

#ifdef USE_FPOINTER_INTERFACES
    module procedure rocblas_zgeru_strided_batched_full_rank,rocblas_zgeru_strided_batched_rank_0,rocblas_zgeru_strided_batched_rank_1
#endif

  end interface
  
  interface rocblas_cgerc_strided_batched
    function rocblas_cgerc_strided_batched_orig(handle,m,n,alpha,x,incx,stridex,y,incy,stridey,A,lda,strideA,batch_count) bind(c, name="rocblas_cgerc_strided_batched")
      use iso_c_binding
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocblas_cgerc_strided_batched_orig
      type(c_ptr),value :: handle
      integer(c_int),value :: m
      integer(c_int),value :: n
      complex(c_float_complex) :: alpha
      type(c_ptr),value :: x
      integer(c_int),value :: incx
      integer(c_int64_t),value :: stridex
      type(c_ptr),value :: y
      integer(c_int),value :: incy
      integer(c_int64_t),value :: stridey
      type(c_ptr),value :: A
      integer(c_int),value :: lda
      integer(c_int64_t),value :: strideA
      integer(c_int),value :: batch_count
    end function

#ifdef USE_FPOINTER_INTERFACES
    module procedure rocblas_cgerc_strided_batched_full_rank,rocblas_cgerc_strided_batched_rank_0,rocblas_cgerc_strided_batched_rank_1
#endif

  end interface
  !> ! \brief BLAS Level 2 API
  !> 
  !>     \details
  !>     xGERC,xGERU,xGERC_STRIDED_BATCHED performs the matrix-vector operations
  !> 
  !>         A_i := A_i + alphax_iy_iT, OR
  !>         A_i := A_i + alphax_iy_iH  for xGERC
  !> 
  !>     where (A_i, x_i, y_i) is the i-th instance of the batch.
  !>     alpha is a scalar, x_i and y_i are vectors and A_i is an
  !>     m by n matrix, for i = 1, ..., batch_count.
  !> 
  !>     @param[in]
  !>     handle    [rocblas_handle]
  !>               handle to the rocblas library context queue.
  !>     @param[in]
  !>     m         [rocblas_int]
  !>               the number of rows of each matrix A_i.
  !>     @param[in]
  !>     n         [rocblas_int]
  !>               the number of columns of each matrix A_i.
  !>     @param[in]
  !>     alpha
  !>               device pointer or host pointer to scalar alpha.
  !>     @param[in]
  !>     x         device pointer to the first vector (x_1) in the batch.
  !>     @param[in]
  !>     incx      [rocblas_int]
  !>               specifies the increments for the elements of each vector x_i.
  !>     @param[in]
  !>     stridex   [rocblas_stride]
  !>               stride from the start of one vector (x_i) and the next one (x_i+1).
  !>               There are no restrictions placed on stride_x, however the user should
  !>               take care to ensure that stride_x is of appropriate size, for a typical
  !>               case this means stride_x >= m  incx.
  !>     @param[inout]
  !>     y         device pointer to the first vector (y_1) in the batch.
  !>     @param[in]
  !>     incy      [rocblas_int]
  !>               specifies the increment for the elements of each vector y_i.
  !>     @param[in]
  !>     stridey   [rocblas_stride]
  !>               stride from the start of one vector (y_i) and the next one (y_i+1).
  !>               There are no restrictions placed on stride_y, however the user should
  !>               take care to ensure that stride_y is of appropriate size, for a typical
  !>               case this means stride_y >= n  incy.
  !>     @param[inout]
  !>     A         device pointer to the first matrix (A_1) in the batch.
  !>     @param[in]
  !>     lda       [rocblas_int]
  !>               specifies the leading dimension of each A_i.
  !>     @param[in]
  !>     strideA     [rocblas_stride]
  !>                 stride from the start of one matrix (A_i) and the next one (A_i+1)
  !>     @param[in]
  !>     batch_count [rocblas_int]
  !>                 number of instances in the batch
  !> 
  !>     
  interface rocblas_zgerc_strided_batched
    function rocblas_zgerc_strided_batched_orig(handle,m,n,alpha,x,incx,stridex,y,incy,stridey,A,lda,strideA,batch_count) bind(c, name="rocblas_zgerc_strided_batched")
      use iso_c_binding
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocblas_zgerc_strided_batched_orig
      type(c_ptr),value :: handle
      integer(c_int),value :: m
      integer(c_int),value :: n
      complex(c_double_complex) :: alpha
      type(c_ptr),value :: x
      integer(c_int),value :: incx
      integer(c_int64_t),value :: stridex
      type(c_ptr),value :: y
      integer(c_int),value :: incy
      integer(c_int64_t),value :: stridey
      type(c_ptr),value :: A
      integer(c_int),value :: lda
      integer(c_int64_t),value :: strideA
      integer(c_int),value :: batch_count
    end function

#ifdef USE_FPOINTER_INTERFACES
    module procedure rocblas_zgerc_strided_batched_full_rank,rocblas_zgerc_strided_batched_rank_0,rocblas_zgerc_strided_batched_rank_1
#endif

  end interface
  
  interface rocblas_sspr
    function rocblas_sspr_orig(handle,uplo,n,alpha,x,incx,AP) bind(c, name="rocblas_sspr")
      use iso_c_binding
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocblas_sspr_orig
      type(c_ptr),value :: handle
      integer(kind(rocblas_fill_upper)),value :: uplo
      integer(c_int),value :: n
      real(c_float) :: alpha
      type(c_ptr),value :: x
      integer(c_int),value :: incx
      type(c_ptr),value :: AP
    end function

#ifdef USE_FPOINTER_INTERFACES
    module procedure rocblas_sspr_rank_0,rocblas_sspr_rank_1
#endif

  end interface
  
  interface rocblas_dspr
    function rocblas_dspr_orig(handle,uplo,n,alpha,x,incx,AP) bind(c, name="rocblas_dspr")
      use iso_c_binding
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocblas_dspr_orig
      type(c_ptr),value :: handle
      integer(kind(rocblas_fill_upper)),value :: uplo
      integer(c_int),value :: n
      real(c_double) :: alpha
      type(c_ptr),value :: x
      integer(c_int),value :: incx
      type(c_ptr),value :: AP
    end function

#ifdef USE_FPOINTER_INTERFACES
    module procedure rocblas_dspr_rank_0,rocblas_dspr_rank_1
#endif

  end interface
  
  interface rocblas_cspr
    function rocblas_cspr_orig(handle,uplo,n,alpha,x,incx,AP) bind(c, name="rocblas_cspr")
      use iso_c_binding
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocblas_cspr_orig
      type(c_ptr),value :: handle
      integer(kind(rocblas_fill_upper)),value :: uplo
      integer(c_int),value :: n
      complex(c_float_complex) :: alpha
      type(c_ptr),value :: x
      integer(c_int),value :: incx
      type(c_ptr),value :: AP
    end function

#ifdef USE_FPOINTER_INTERFACES
    module procedure rocblas_cspr_rank_0,rocblas_cspr_rank_1
#endif

  end interface
  !> ! \brief BLAS Level 2 API
  !> 
  !>     \details
  !>     xSPR performs the matrix-vector operations
  !> 
  !>         A := A + alphaxxT
  !> 
  !>     where alpha is a scalar, x is a vector, and A is an
  !>     n by n symmetric matrix, supplied in packed form.
  !> 
  !>     @param[in]
  !>     handle    [rocblas_handle]
  !>               handle to the rocblas library context queue.
  !>     @param[in]
  !>     uplo      [rocblas_fill]
  !>               specifies whether the upper 'rocblas_fill_upper' or lower 'rocblas_fill_lower'
  !>               rocblas_fill_upper: The upper triangular part of A is supplied in AP.
  !>               rocblas_fill_lower: The lower triangular part of A is supplied in AP.
  !>     @param[in]
  !>     n         [rocblas_int]
  !>               the number of rows and columns of matrix A, must be at least 0.
  !>     @param[in]
  !>     alpha
  !>               device pointer or host pointer to scalar alpha.
  !>     @param[in]
  !>     x         device pointer storing vector x.
  !>     @param[in]
  !>     incx      [rocblas_int]
  !>               specifies the increment for the elements of x.
  !>     @param[inout]
  !>     AP        device pointer storing the packed version of the specified triangular portion of
  !>               the symmetric matrix A. Of at least size ((n  (n + 1))  2).
  !>               if uplo == rocblas_fill_upper:
  !>                 The upper triangular portion of the symmetric matrix A is supplied.
  !>                 The matrix is compacted so that AP contains the triangular portion column-by-column
  !>                 so that:
  !>                 AP(0) = A(0,0)
  !>                 AP(1) = A(0,1)
  !>                 AP(2) = A(1,1), etc.
  !>                     Ex: (rocblas_fill_upper; n = 4)
  !>                         1 2 4 7
  !>                         2 3 5 8   -----> [1, 2, 3, 4, 5, 6, 7, 8, 9, 0]
  !>                         4 5 6 9
  !>                         7 8 9 0
  !>             if uplo == rocblas_fill_lower:
  !>                 The lower triangular portion of the symmetric matrix A is supplied.
  !>                 The matrix is compacted so that AP contains the triangular portion column-by-column
  !>                 so that:
  !>                 AP(0) = A(0,0)
  !>                 AP(1) = A(1,0)
  !>                 AP(2) = A(2,1), etc.
  !>                     Ex: (rocblas_fill_lower; n = 4)
  !>                         1 2 3 4
  !>                         2 5 6 7    -----> [1, 2, 3, 4, 5, 6, 7, 8, 9, 0]
  !>                         3 6 8 9
  !>                         4 7 9 0
  !>     
  interface rocblas_zspr
    function rocblas_zspr_orig(handle,uplo,n,alpha,x,incx,AP) bind(c, name="rocblas_zspr")
      use iso_c_binding
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocblas_zspr_orig
      type(c_ptr),value :: handle
      integer(kind(rocblas_fill_upper)),value :: uplo
      integer(c_int),value :: n
      complex(c_double_complex) :: alpha
      type(c_ptr),value :: x
      integer(c_int),value :: incx
      type(c_ptr),value :: AP
    end function

#ifdef USE_FPOINTER_INTERFACES
    module procedure rocblas_zspr_rank_0,rocblas_zspr_rank_1
#endif

  end interface
  
  interface rocblas_sspr_batched
    function rocblas_sspr_batched_orig(handle,uplo,n,alpha,x,incx,AP,batch_count) bind(c, name="rocblas_sspr_batched")
      use iso_c_binding
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocblas_sspr_batched_orig
      type(c_ptr),value :: handle
      integer(kind(rocblas_fill_upper)),value :: uplo
      integer(c_int),value :: n
      real(c_float) :: alpha
      type(c_ptr) :: x
      integer(c_int),value :: incx
      type(c_ptr) :: AP
      integer(c_int),value :: batch_count
    end function

#ifdef USE_FPOINTER_INTERFACES
    module procedure rocblas_sspr_batched_full_rank,rocblas_sspr_batched_rank_0,rocblas_sspr_batched_rank_1
#endif

  end interface
  
  interface rocblas_dspr_batched
    function rocblas_dspr_batched_orig(handle,uplo,n,alpha,x,incx,AP,batch_count) bind(c, name="rocblas_dspr_batched")
      use iso_c_binding
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocblas_dspr_batched_orig
      type(c_ptr),value :: handle
      integer(kind(rocblas_fill_upper)),value :: uplo
      integer(c_int),value :: n
      real(c_double) :: alpha
      type(c_ptr) :: x
      integer(c_int),value :: incx
      type(c_ptr) :: AP
      integer(c_int),value :: batch_count
    end function

#ifdef USE_FPOINTER_INTERFACES
    module procedure rocblas_dspr_batched_full_rank,rocblas_dspr_batched_rank_0,rocblas_dspr_batched_rank_1
#endif

  end interface
  
  interface rocblas_cspr_batched
    function rocblas_cspr_batched_orig(handle,uplo,n,alpha,x,incx,AP,batch_count) bind(c, name="rocblas_cspr_batched")
      use iso_c_binding
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocblas_cspr_batched_orig
      type(c_ptr),value :: handle
      integer(kind(rocblas_fill_upper)),value :: uplo
      integer(c_int),value :: n
      complex(c_float_complex) :: alpha
      type(c_ptr) :: x
      integer(c_int),value :: incx
      type(c_ptr) :: AP
      integer(c_int),value :: batch_count
    end function

#ifdef USE_FPOINTER_INTERFACES
    module procedure rocblas_cspr_batched_full_rank,rocblas_cspr_batched_rank_0,rocblas_cspr_batched_rank_1
#endif

  end interface
  !> ! \brief BLAS Level 2 API
  !> 
  !>     \details
  !>     xSPR_BATCHED performs the matrix-vector operations
  !> 
  !>         A_i := A_i + alphax_ix_iT
  !> 
  !>     where alpha is a scalar, x_i is a vector, and A_i is an
  !>     n by n symmetric matrix, supplied in packed form, for i = 1, ..., batch_count.
  !> 
  !>     @param[in]
  !>     handle    [rocblas_handle]
  !>               handle to the rocblas library context queue.
  !>     @param[in]
  !>     uplo      [rocblas_fill]
  !>               specifies whether the upper 'rocblas_fill_upper' or lower 'rocblas_fill_lower'
  !>               rocblas_fill_upper: The upper triangular part of each A_i is supplied in AP.
  !>               rocblas_fill_lower: The lower triangular part of each A_i is supplied in AP.
  !>     @param[in]
  !>     n         [rocblas_int]
  !>               the number of rows and columns of each matrix A_i, must be at least 0.
  !>     @param[in]
  !>     alpha
  !>               device pointer or host pointer to scalar alpha.
  !>     @param[in]
  !>     x         device array of device pointers storing each vector x_i.
  !>     @param[in]
  !>     incx      [rocblas_int]
  !>               specifies the increment for the elements of each x_i.
  !>     @param[inout]
  !>     AP        device array of device pointers storing the packed version of the specified triangular portion of
  !>               each symmetric matrix A_i of at least size ((n  (n + 1))  2). Array is of at least size batch_count.
  !>               if uplo == rocblas_fill_upper:
  !>                 The upper triangular portion of each symmetric matrix A_i is supplied.
  !>                 The matrix is compacted so that AP contains the triangular portion column-by-column
  !>                 so that:
  !>                 AP(0) = A(0,0)
  !>                 AP(1) = A(0,1)
  !>                 AP(2) = A(1,1), etc.
  !>                     Ex: (rocblas_fill_upper; n = 4)
  !>                         1 2 4 7
  !>                         2 3 5 8   -----> [1, 2, 3, 4, 5, 6, 7, 8, 9, 0]
  !>                         4 5 6 9
  !>                         7 8 9 0
  !>             if uplo == rocblas_fill_lower:
  !>                 The lower triangular portion of each symmetric matrix A_i is supplied.
  !>                 The matrix is compacted so that AP contains the triangular portion column-by-column
  !>                 so that:
  !>                 AP(0) = A(0,0)
  !>                 AP(1) = A(1,0)
  !>                 AP(2) = A(2,1), etc.
  !>                     Ex: (rocblas_fill_lower; n = 4)
  !>                         1 2 3 4
  !>                         2 5 6 7    -----> [1, 2, 3, 4, 5, 6, 7, 8, 9, 0]
  !>                         3 6 8 9
  !>                         4 7 9 0
  !>     @param[in]
  !>     batch_count [rocblas_int]
  !>                 number of instances in the batch.
  !>     
  interface rocblas_zspr_batched
    function rocblas_zspr_batched_orig(handle,uplo,n,alpha,x,incx,AP,batch_count) bind(c, name="rocblas_zspr_batched")
      use iso_c_binding
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocblas_zspr_batched_orig
      type(c_ptr),value :: handle
      integer(kind(rocblas_fill_upper)),value :: uplo
      integer(c_int),value :: n
      complex(c_double_complex) :: alpha
      type(c_ptr) :: x
      integer(c_int),value :: incx
      type(c_ptr) :: AP
      integer(c_int),value :: batch_count
    end function

#ifdef USE_FPOINTER_INTERFACES
    module procedure rocblas_zspr_batched_full_rank,rocblas_zspr_batched_rank_0,rocblas_zspr_batched_rank_1
#endif

  end interface
  
  interface rocblas_sspr_strided_batched
    function rocblas_sspr_strided_batched_orig(handle,uplo,n,alpha,x,incx,stride_x,AP,stride_A,batch_count) bind(c, name="rocblas_sspr_strided_batched")
      use iso_c_binding
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocblas_sspr_strided_batched_orig
      type(c_ptr),value :: handle
      integer(kind(rocblas_fill_upper)),value :: uplo
      integer(c_int),value :: n
      real(c_float) :: alpha
      type(c_ptr),value :: x
      integer(c_int),value :: incx
      integer(c_int64_t),value :: stride_x
      type(c_ptr),value :: AP
      integer(c_int64_t),value :: stride_A
      integer(c_int),value :: batch_count
    end function

#ifdef USE_FPOINTER_INTERFACES
    module procedure rocblas_sspr_strided_batched_rank_0,rocblas_sspr_strided_batched_rank_1
#endif

  end interface
  
  interface rocblas_dspr_strided_batched
    function rocblas_dspr_strided_batched_orig(handle,uplo,n,alpha,x,incx,stride_x,AP,stride_A,batch_count) bind(c, name="rocblas_dspr_strided_batched")
      use iso_c_binding
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocblas_dspr_strided_batched_orig
      type(c_ptr),value :: handle
      integer(kind(rocblas_fill_upper)),value :: uplo
      integer(c_int),value :: n
      real(c_double) :: alpha
      type(c_ptr),value :: x
      integer(c_int),value :: incx
      integer(c_int64_t),value :: stride_x
      type(c_ptr),value :: AP
      integer(c_int64_t),value :: stride_A
      integer(c_int),value :: batch_count
    end function

#ifdef USE_FPOINTER_INTERFACES
    module procedure rocblas_dspr_strided_batched_rank_0,rocblas_dspr_strided_batched_rank_1
#endif

  end interface
  
  interface rocblas_cspr_strided_batched
    function rocblas_cspr_strided_batched_orig(handle,uplo,n,alpha,x,incx,stride_x,AP,stride_A,batch_count) bind(c, name="rocblas_cspr_strided_batched")
      use iso_c_binding
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocblas_cspr_strided_batched_orig
      type(c_ptr),value :: handle
      integer(kind(rocblas_fill_upper)),value :: uplo
      integer(c_int),value :: n
      complex(c_float_complex) :: alpha
      type(c_ptr),value :: x
      integer(c_int),value :: incx
      integer(c_int64_t),value :: stride_x
      type(c_ptr),value :: AP
      integer(c_int64_t),value :: stride_A
      integer(c_int),value :: batch_count
    end function

#ifdef USE_FPOINTER_INTERFACES
    module procedure rocblas_cspr_strided_batched_rank_0,rocblas_cspr_strided_batched_rank_1
#endif

  end interface
  !> ! \brief BLAS Level 2 API
  !> 
  !>     \details
  !>     xSPR_STRIDED_BATCHED performs the matrix-vector operations
  !> 
  !>         A_i := A_i + alphax_ix_iT
  !> 
  !>     where alpha is a scalar, x_i is a vector, and A_i is an
  !>     n by n symmetric matrix, supplied in packed form, for i = 1, ..., batch_count.
  !> 
  !>     @param[in]
  !>     handle    [rocblas_handle]
  !>               handle to the rocblas library context queue.
  !>     @param[in]
  !>     uplo      [rocblas_fill]
  !>               specifies whether the upper 'rocblas_fill_upper' or lower 'rocblas_fill_lower'
  !>               rocblas_fill_upper: The upper triangular part of each A_i is supplied in AP.
  !>               rocblas_fill_lower: The lower triangular part of each A_i is supplied in AP.
  !>     @param[in]
  !>     n         [rocblas_int]
  !>               the number of rows and columns of each matrix A_i, must be at least 0.
  !>     @param[in]
  !>     alpha
  !>               device pointer or host pointer to scalar alpha.
  !>     @param[in]
  !>     x         device pointer pointing to the first vector (x_1).
  !>     @param[in]
  !>     incx      [rocblas_int]
  !>               specifies the increment for the elements of each x_i.
  !>     @param[in]
  !>     stride_x  [rocblas_stride]
  !>               stride from the start of one vector (x_i) and the next one (x_i+1).
  !>     @param[inout]
  !>     AP        device pointer storing the packed version of the specified triangular portion of
  !>               each symmetric matrix A_i. Points to the first A_1.
  !>               if uplo == rocblas_fill_upper:
  !>                 The upper triangular portion of each symmetric matrix A_i is supplied.
  !>                 The matrix is compacted so that AP contains the triangular portion column-by-column
  !>                 so that:
  !>                 AP(0) = A(0,0)
  !>                 AP(1) = A(0,1)
  !>                 AP(2) = A(1,1), etc.
  !>                     Ex: (rocblas_fill_upper; n = 4)
  !>                         1 2 4 7
  !>                         2 3 5 8   -----> [1, 2, 3, 4, 5, 6, 7, 8, 9, 0]
  !>                         4 5 6 9
  !>                         7 8 9 0
  !>             if uplo == rocblas_fill_lower:
  !>                 The lower triangular portion of each symmetric matrix A_i is supplied.
  !>                 The matrix is compacted so that AP contains the triangular portion column-by-column
  !>                 so that:
  !>                 AP(0) = A(0,0)
  !>                 AP(1) = A(1,0)
  !>                 AP(2) = A(2,1), etc.
  !>                     Ex: (rocblas_fill_lower; n = 4)
  !>                         1 2 3 4
  !>                         2 5 6 7    -----> [1, 2, 3, 4, 5, 6, 7, 8, 9, 0]
  !>                         3 6 8 9
  !>                         4 7 9 0
  !>     @param[in]
  !>     stride_A    [rocblas_stride]
  !>                 stride from the start of one (A_i) and the next (A_i+1)
  !>     @param[in]
  !>     batch_count [rocblas_int]
  !>                 number of instances in the batch.
  !>     
  interface rocblas_zspr_strided_batched
    function rocblas_zspr_strided_batched_orig(handle,uplo,n,alpha,x,incx,stride_x,AP,stride_A,batch_count) bind(c, name="rocblas_zspr_strided_batched")
      use iso_c_binding
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocblas_zspr_strided_batched_orig
      type(c_ptr),value :: handle
      integer(kind(rocblas_fill_upper)),value :: uplo
      integer(c_int),value :: n
      complex(c_double_complex) :: alpha
      type(c_ptr),value :: x
      integer(c_int),value :: incx
      integer(c_int64_t),value :: stride_x
      type(c_ptr),value :: AP
      integer(c_int64_t),value :: stride_A
      integer(c_int),value :: batch_count
    end function

#ifdef USE_FPOINTER_INTERFACES
    module procedure rocblas_zspr_strided_batched_rank_0,rocblas_zspr_strided_batched_rank_1
#endif

  end interface
  
  interface rocblas_sspr2
    function rocblas_sspr2_orig(handle,uplo,n,alpha,x,incx,y,incy,AP) bind(c, name="rocblas_sspr2")
      use iso_c_binding
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocblas_sspr2_orig
      type(c_ptr),value :: handle
      integer(kind(rocblas_fill_upper)),value :: uplo
      integer(c_int),value :: n
      real(c_float) :: alpha
      type(c_ptr),value :: x
      integer(c_int),value :: incx
      type(c_ptr),value :: y
      integer(c_int),value :: incy
      type(c_ptr),value :: AP
    end function

#ifdef USE_FPOINTER_INTERFACES
    module procedure rocblas_sspr2_rank_0,rocblas_sspr2_rank_1
#endif

  end interface
  !> ! \brief BLAS Level 2 API
  !> 
  !>     \details
  !>     xSPR2 performs the matrix-vector operation
  !> 
  !>         A := A + alphaxyT + alphayxT
  !> 
  !>     where alpha is a scalar, x and y are vectors, and A is an
  !>     n by n symmetric matrix, supplied in packed form.
  !> 
  !>     @param[in]
  !>     handle    [rocblas_handle]
  !>               handle to the rocblas library context queue.
  !>     @param[in]
  !>     uplo      [rocblas_fill]
  !>               specifies whether the upper 'rocblas_fill_upper' or lower 'rocblas_fill_lower'
  !>               rocblas_fill_upper: The upper triangular part of A is supplied in AP.
  !>               rocblas_fill_lower: The lower triangular part of A is supplied in AP.
  !>     @param[in]
  !>     n         [rocblas_int]
  !>               the number of rows and columns of matrix A, must be at least 0.
  !>     @param[in]
  !>     alpha
  !>               device pointer or host pointer to scalar alpha.
  !>     @param[in]
  !>     x         device pointer storing vector x.
  !>     @param[in]
  !>     incx      [rocblas_int]
  !>               specifies the increment for the elements of x.
  !>     @param[in]
  !>     y         device pointer storing vector y.
  !>     @param[in]
  !>     incy      [rocblas_int]
  !>               specifies the increment for the elements of y.
  !>     @param[inout]
  !>     AP        device pointer storing the packed version of the specified triangular portion of
  !>               the symmetric matrix A. Of at least size ((n  (n + 1))  2).
  !>               if uplo == rocblas_fill_upper:
  !>                 The upper triangular portion of the symmetric matrix A is supplied.
  !>                 The matrix is compacted so that AP contains the triangular portion column-by-column
  !>                 so that:
  !>                 AP(0) = A(0,0)
  !>                 AP(1) = A(0,1)
  !>                 AP(2) = A(1,1), etc.
  !>                     Ex: (rocblas_fill_upper; n = 4)
  !>                         1 2 4 7
  !>                         2 3 5 8   -----> [1, 2, 3, 4, 5, 6, 7, 8, 9, 0]
  !>                         4 5 6 9
  !>                         7 8 9 0
  !>             if uplo == rocblas_fill_lower:
  !>                 The lower triangular portion of the symmetric matrix A is supplied.
  !>                 The matrix is compacted so that AP contains the triangular portion column-by-column
  !>                 so that:
  !>                 AP(0) = A(0,0)
  !>                 AP(1) = A(1,0)
  !>                 AP(n) = A(2,1), etc.
  !>                     Ex: (rocblas_fill_lower; n = 4)
  !>                         1 2 3 4
  !>                         2 5 6 7    -----> [1, 2, 3, 4, 5, 6, 7, 8, 9, 0]
  !>                         3 6 8 9
  !>                         4 7 9 0
  !>     
  interface rocblas_dspr2
    function rocblas_dspr2_orig(handle,uplo,n,alpha,x,incx,y,incy,AP) bind(c, name="rocblas_dspr2")
      use iso_c_binding
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocblas_dspr2_orig
      type(c_ptr),value :: handle
      integer(kind(rocblas_fill_upper)),value :: uplo
      integer(c_int),value :: n
      real(c_double) :: alpha
      type(c_ptr),value :: x
      integer(c_int),value :: incx
      type(c_ptr),value :: y
      integer(c_int),value :: incy
      type(c_ptr),value :: AP
    end function

#ifdef USE_FPOINTER_INTERFACES
    module procedure rocblas_dspr2_rank_0,rocblas_dspr2_rank_1
#endif

  end interface
  
  interface rocblas_sspr2_batched
    function rocblas_sspr2_batched_orig(handle,uplo,n,alpha,x,incx,y,incy,AP,batch_count) bind(c, name="rocblas_sspr2_batched")
      use iso_c_binding
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocblas_sspr2_batched_orig
      type(c_ptr),value :: handle
      integer(kind(rocblas_fill_upper)),value :: uplo
      integer(c_int),value :: n
      real(c_float) :: alpha
      type(c_ptr) :: x
      integer(c_int),value :: incx
      type(c_ptr) :: y
      integer(c_int),value :: incy
      type(c_ptr) :: AP
      integer(c_int),value :: batch_count
    end function

#ifdef USE_FPOINTER_INTERFACES
    module procedure rocblas_sspr2_batched_full_rank,rocblas_sspr2_batched_rank_0,rocblas_sspr2_batched_rank_1
#endif

  end interface
  !> ! \brief BLAS Level 2 API
  !> 
  !>     \details
  !>     xSPR2_BATCHED performs the matrix-vector operation
  !> 
  !>         A_i := A_i + alphax_iy_iT + alphayxT
  !> 
  !>     where alpha is a scalar, x_i is a vector, and A_i is an
  !>     n by n symmetric matrix, supplied in packed form, for i = 1, ..., batch_count.
  !> 
  !>     @param[in]
  !>     handle    [rocblas_handle]
  !>               handle to the rocblas library context queue.
  !>     @param[in]
  !>     uplo      [rocblas_fill]
  !>               specifies whether the upper 'rocblas_fill_upper' or lower 'rocblas_fill_lower'
  !>               rocblas_fill_upper: The upper triangular part of each A_i is supplied in AP.
  !>               rocblas_fill_lower: The lower triangular part of each A_i is supplied in AP.
  !>     @param[in]
  !>     n         [rocblas_int]
  !>               the number of rows and columns of each matrix A_i, must be at least 0.
  !>     @param[in]
  !>     alpha
  !>               device pointer or host pointer to scalar alpha.
  !>     @param[in]
  !>     x         device array of device pointers storing each vector x_i.
  !>     @param[in]
  !>     incx      [rocblas_int]
  !>               specifies the increment for the elements of each x_i.
  !>     @param[in]
  !>     y         device array of device pointers storing each vector y_i.
  !>     @param[in]
  !>     incy      [rocblas_int]
  !>               specifies the increment for the elements of each y_i.
  !>     @param[inout]
  !>     AP        device array of device pointers storing the packed version of the specified triangular portion of
  !>               each symmetric matrix A_i of at least size ((n  (n + 1))  2). Array is of at least size batch_count.
  !>               if uplo == rocblas_fill_upper:
  !>                 The upper triangular portion of each symmetric matrix A_i is supplied.
  !>                 The matrix is compacted so that AP contains the triangular portion column-by-column
  !>                 so that:
  !>                 AP(0) = A(0,0)
  !>                 AP(1) = A(0,1)
  !>                 AP(2) = A(1,1), etc.
  !>                     Ex: (rocblas_fill_upper; n = 4)
  !>                         1 2 4 7
  !>                         2 3 5 8   -----> [1, 2, 3, 4, 5, 6, 7, 8, 9, 0]
  !>                         4 5 6 9
  !>                         7 8 9 0
  !>             if uplo == rocblas_fill_lower:
  !>                 The lower triangular portion of each symmetric matrix A_i is supplied.
  !>                 The matrix is compacted so that AP contains the triangular portion column-by-column
  !>                 so that:
  !>                 AP(0) = A(0,0)
  !>                 AP(1) = A(1,0)
  !>                 AP(n) = A(2,1), etc.
  !>                     Ex: (rocblas_fill_lower; n = 4)
  !>                         1 2 3 4
  !>                         2 5 6 7    -----> [1, 2, 3, 4, 5, 6, 7, 8, 9, 0]
  !>                         3 6 8 9
  !>                         4 7 9 0
  !>     @param[in]
  !>     batch_count [rocblas_int]
  !>                 number of instances in the batch.
  !>     
  interface rocblas_dspr2_batched
    function rocblas_dspr2_batched_orig(handle,uplo,n,alpha,x,incx,y,incy,AP,batch_count) bind(c, name="rocblas_dspr2_batched")
      use iso_c_binding
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocblas_dspr2_batched_orig
      type(c_ptr),value :: handle
      integer(kind(rocblas_fill_upper)),value :: uplo
      integer(c_int),value :: n
      real(c_double) :: alpha
      type(c_ptr) :: x
      integer(c_int),value :: incx
      type(c_ptr) :: y
      integer(c_int),value :: incy
      type(c_ptr) :: AP
      integer(c_int),value :: batch_count
    end function

#ifdef USE_FPOINTER_INTERFACES
    module procedure rocblas_dspr2_batched_full_rank,rocblas_dspr2_batched_rank_0,rocblas_dspr2_batched_rank_1
#endif

  end interface
  
  interface rocblas_sspr2_strided_batched
    function rocblas_sspr2_strided_batched_orig(handle,uplo,n,alpha,x,incx,stride_x,y,incy,stride_y,AP,stride_A,batch_count) bind(c, name="rocblas_sspr2_strided_batched")
      use iso_c_binding
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocblas_sspr2_strided_batched_orig
      type(c_ptr),value :: handle
      integer(kind(rocblas_fill_upper)),value :: uplo
      integer(c_int),value :: n
      real(c_float) :: alpha
      type(c_ptr),value :: x
      integer(c_int),value :: incx
      integer(c_int64_t),value :: stride_x
      type(c_ptr),value :: y
      integer(c_int),value :: incy
      integer(c_int64_t),value :: stride_y
      type(c_ptr),value :: AP
      integer(c_int64_t),value :: stride_A
      integer(c_int),value :: batch_count
    end function

#ifdef USE_FPOINTER_INTERFACES
    module procedure rocblas_sspr2_strided_batched_rank_0,rocblas_sspr2_strided_batched_rank_1
#endif

  end interface
  !> ! \brief BLAS Level 2 API
  !> 
  !>     \details
  !>     xSPR_STRIDED_BATCHED performs the matrix-vector operation
  !> 
  !>         A_i := A_i + alphax_ix_iT
  !> 
  !>     where alpha is a scalar, x_i is a vector, and A_i is an
  !>     n by n symmetric matrix, supplied in packed form, for i = 1, ..., batch_count.
  !> 
  !>     @param[in]
  !>     handle    [rocblas_handle]
  !>               handle to the rocblas library context queue.
  !>     @param[in]
  !>     uplo      [rocblas_fill]
  !>               specifies whether the upper 'rocblas_fill_upper' or lower 'rocblas_fill_lower'
  !>               rocblas_fill_upper: The upper triangular part of each A_i is supplied in AP.
  !>               rocblas_fill_lower: The lower triangular part of each A_i is supplied in AP.
  !>     @param[in]
  !>     n         [rocblas_int]
  !>               the number of rows and columns of each matrix A_i, must be at least 0.
  !>     @param[in]
  !>     alpha
  !>               device pointer or host pointer to scalar alpha.
  !>     @param[in]
  !>     x         device pointer pointing to the first vector (x_1).
  !>     @param[in]
  !>     incx      [rocblas_int]
  !>               specifies the increment for the elements of each x_i.
  !>     @param[in]
  !>     stride_x  [rocblas_stride]
  !>               stride from the start of one vector (x_i) and the next one (x_i+1).
  !>     @param[in]
  !>     y         device pointer pointing to the first vector (y_1).
  !>     @param[in]
  !>     incy      [rocblas_int]
  !>               specifies the increment for the elements of each y_i.
  !>     @param[in]
  !>     stride_y  [rocblas_stride]
  !>               stride from the start of one vector (y_i) and the next one (y_i+1).
  !>     @param[inout]
  !>     AP        device pointer storing the packed version of the specified triangular portion of
  !>               each symmetric matrix A_i. Points to the first A_1.
  !>               if uplo == rocblas_fill_upper:
  !>                 The upper triangular portion of each symmetric matrix A_i is supplied.
  !>                 The matrix is compacted so that AP contains the triangular portion column-by-column
  !>                 so that:
  !>                 AP(0) = A(0,0)
  !>                 AP(1) = A(0,1)
  !>                 AP(2) = A(1,1), etc.
  !>                     Ex: (rocblas_fill_upper; n = 4)
  !>                         1 2 4 7
  !>                         2 3 5 8   -----> [1, 2, 3, 4, 5, 6, 7, 8, 9, 0]
  !>                         4 5 6 9
  !>                         7 8 9 0
  !>             if uplo == rocblas_fill_lower:
  !>                 The lower triangular portion of each symmetric matrix A_i is supplied.
  !>                 The matrix is compacted so that AP contains the triangular portion column-by-column
  !>                 so that:
  !>                 AP(0) = A(0,0)
  !>                 AP(1) = A(1,0)
  !>                 AP(n) = A(2,1), etc.
  !>                     Ex: (rocblas_fill_lower; n = 4)
  !>                         1 2 3 4
  !>                         2 5 6 7    -----> [1, 2, 3, 4, 5, 6, 7, 8, 9, 0]
  !>                         3 6 8 9
  !>                         4 7 9 0
  !>     @param[in]
  !>     stride_A    [rocblas_stride]
  !>                 stride from the start of one (A_i) and the next (A_i+1)
  !>     @param[in]
  !>     batch_count [rocblas_int]
  !>                 number of instances in the batch.
  !>     
  interface rocblas_dspr2_strided_batched
    function rocblas_dspr2_strided_batched_orig(handle,uplo,n,alpha,x,incx,stride_x,y,incy,stride_y,AP,stride_A,batch_count) bind(c, name="rocblas_dspr2_strided_batched")
      use iso_c_binding
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocblas_dspr2_strided_batched_orig
      type(c_ptr),value :: handle
      integer(kind(rocblas_fill_upper)),value :: uplo
      integer(c_int),value :: n
      real(c_double) :: alpha
      type(c_ptr),value :: x
      integer(c_int),value :: incx
      integer(c_int64_t),value :: stride_x
      type(c_ptr),value :: y
      integer(c_int),value :: incy
      integer(c_int64_t),value :: stride_y
      type(c_ptr),value :: AP
      integer(c_int64_t),value :: stride_A
      integer(c_int),value :: batch_count
    end function

#ifdef USE_FPOINTER_INTERFACES
    module procedure rocblas_dspr2_strided_batched_rank_0,rocblas_dspr2_strided_batched_rank_1
#endif

  end interface
  
  interface rocblas_ssyr
    function rocblas_ssyr_orig(handle,uplo,n,alpha,x,incx,A,lda) bind(c, name="rocblas_ssyr")
      use iso_c_binding
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocblas_ssyr_orig
      type(c_ptr),value :: handle
      integer(kind(rocblas_fill_upper)),value :: uplo
      integer(c_int),value :: n
      real(c_float) :: alpha
      type(c_ptr),value :: x
      integer(c_int),value :: incx
      type(c_ptr),value :: A
      integer(c_int),value :: lda
    end function

#ifdef USE_FPOINTER_INTERFACES
    module procedure rocblas_ssyr_full_rank,rocblas_ssyr_rank_0,rocblas_ssyr_rank_1
#endif

  end interface
  
  interface rocblas_dsyr
    function rocblas_dsyr_orig(handle,uplo,n,alpha,x,incx,A,lda) bind(c, name="rocblas_dsyr")
      use iso_c_binding
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocblas_dsyr_orig
      type(c_ptr),value :: handle
      integer(kind(rocblas_fill_upper)),value :: uplo
      integer(c_int),value :: n
      real(c_double) :: alpha
      type(c_ptr),value :: x
      integer(c_int),value :: incx
      type(c_ptr),value :: A
      integer(c_int),value :: lda
    end function

#ifdef USE_FPOINTER_INTERFACES
    module procedure rocblas_dsyr_full_rank,rocblas_dsyr_rank_0,rocblas_dsyr_rank_1
#endif

  end interface
  
  interface rocblas_csyr
    function rocblas_csyr_orig(handle,uplo,n,alpha,x,incx,A,lda) bind(c, name="rocblas_csyr")
      use iso_c_binding
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocblas_csyr_orig
      type(c_ptr),value :: handle
      integer(kind(rocblas_fill_upper)),value :: uplo
      integer(c_int),value :: n
      complex(c_float_complex) :: alpha
      type(c_ptr),value :: x
      integer(c_int),value :: incx
      type(c_ptr),value :: A
      integer(c_int),value :: lda
    end function

#ifdef USE_FPOINTER_INTERFACES
    module procedure rocblas_csyr_full_rank,rocblas_csyr_rank_0,rocblas_csyr_rank_1
#endif

  end interface
  !> ! \brief BLAS Level 2 API
  !> 
  !>     \details
  !>     xSYR performs the matrix-vector operations
  !> 
  !>         A := A + alphaxxT
  !> 
  !>     where alpha is a scalar, x is a vector, and A is an
  !>     n by n symmetric matrix.
  !> 
  !>     @param[in]
  !>     handle    [rocblas_handle]
  !>               handle to the rocblas library context queue.
  !>     @param[in]
  !>     uplo      [rocblas_fill]
  !>               specifies whether the upper 'rocblas_fill_upper' or lower 'rocblas_fill_lower'
  !>               if rocblas_fill_upper, the lower part of A is not referenced
  !>               if rocblas_fill_lower, the upper part of A is not referenced
  !> 
  !>     @param[in]
  !>     n         [rocblas_int]
  !>               the number of rows and columns of matrix A.
  !>     @param[in]
  !>     alpha
  !>               device pointer or host pointer to scalar alpha.
  !>     @param[in]
  !>     x         device pointer storing vector x.
  !>     @param[in]
  !>     incx      [rocblas_int]
  !>               specifies the increment for the elements of x.
  !>     @param[inout]
  !>     A         device pointer storing matrix A.
  !>     @param[in]
  !>     lda       [rocblas_int]
  !>               specifies the leading dimension of A.
  !> 
  !>     
  interface rocblas_zsyr
    function rocblas_zsyr_orig(handle,uplo,n,alpha,x,incx,A,lda) bind(c, name="rocblas_zsyr")
      use iso_c_binding
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocblas_zsyr_orig
      type(c_ptr),value :: handle
      integer(kind(rocblas_fill_upper)),value :: uplo
      integer(c_int),value :: n
      complex(c_double_complex) :: alpha
      type(c_ptr),value :: x
      integer(c_int),value :: incx
      type(c_ptr),value :: A
      integer(c_int),value :: lda
    end function

#ifdef USE_FPOINTER_INTERFACES
    module procedure rocblas_zsyr_full_rank,rocblas_zsyr_rank_0,rocblas_zsyr_rank_1
#endif

  end interface
  
  interface rocblas_ssyr_batched
    function rocblas_ssyr_batched_orig(handle,uplo,n,alpha,x,incx,A,lda,batch_count) bind(c, name="rocblas_ssyr_batched")
      use iso_c_binding
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocblas_ssyr_batched_orig
      type(c_ptr),value :: handle
      integer(kind(rocblas_fill_upper)),value :: uplo
      integer(c_int),value :: n
      real(c_float) :: alpha
      type(c_ptr) :: x
      integer(c_int),value :: incx
      type(c_ptr) :: A
      integer(c_int),value :: lda
      integer(c_int),value :: batch_count
    end function

#ifdef USE_FPOINTER_INTERFACES
    module procedure rocblas_ssyr_batched_full_rank,rocblas_ssyr_batched_rank_0,rocblas_ssyr_batched_rank_1
#endif

  end interface
  
  interface rocblas_dsyr_batched
    function rocblas_dsyr_batched_orig(handle,uplo,n,alpha,x,incx,A,lda,batch_count) bind(c, name="rocblas_dsyr_batched")
      use iso_c_binding
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocblas_dsyr_batched_orig
      type(c_ptr),value :: handle
      integer(kind(rocblas_fill_upper)),value :: uplo
      integer(c_int),value :: n
      real(c_double) :: alpha
      type(c_ptr) :: x
      integer(c_int),value :: incx
      type(c_ptr) :: A
      integer(c_int),value :: lda
      integer(c_int),value :: batch_count
    end function

#ifdef USE_FPOINTER_INTERFACES
    module procedure rocblas_dsyr_batched_full_rank,rocblas_dsyr_batched_rank_0,rocblas_dsyr_batched_rank_1
#endif

  end interface
  
  interface rocblas_csyr_batched
    function rocblas_csyr_batched_orig(handle,uplo,n,alpha,x,incx,A,lda,batch_count) bind(c, name="rocblas_csyr_batched")
      use iso_c_binding
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocblas_csyr_batched_orig
      type(c_ptr),value :: handle
      integer(kind(rocblas_fill_upper)),value :: uplo
      integer(c_int),value :: n
      complex(c_float_complex) :: alpha
      type(c_ptr) :: x
      integer(c_int),value :: incx
      type(c_ptr) :: A
      integer(c_int),value :: lda
      integer(c_int),value :: batch_count
    end function

#ifdef USE_FPOINTER_INTERFACES
    module procedure rocblas_csyr_batched_full_rank,rocblas_csyr_batched_rank_0,rocblas_csyr_batched_rank_1
#endif

  end interface
  !> ! \brief BLAS Level 2 API
  !> 
  !>     \details
  !>     xSYR_batched performs a batch of matrix-vector operations
  !> 
  !>         A[i] := A[i] + alphax[i]x[i]T
  !> 
  !>     where alpha is a scalar, x is an array of vectors, and A is an array of
  !>     n by n symmetric matrices, for i = 1 , ... , batch_count
  !> 
  !>     @param[in]
  !>     handle    [rocblas_handle]
  !>               handle to the rocblas library context queue.
  !>     @param[in]
  !>     uplo      [rocblas_fill]
  !>               specifies whether the upper 'rocblas_fill_upper' or lower 'rocblas_fill_lower'
  !>               if rocblas_fill_upper, the lower part of A is not referenced
  !>               if rocblas_fill_lower, the upper part of A is not referenced
  !>     @param[in]
  !>     n         [rocblas_int]
  !>               the number of rows and columns of matrix A.
  !>     @param[in]
  !>     alpha
  !>               device pointer or host pointer to scalar alpha.
  !>     @param[in]
  !>     x         device array of device pointers storing each vector x_i.
  !>     @param[in]
  !>     incx      [rocblas_int]
  !>               specifies the increment for the elements of each x_i.
  !>     @param[inout]
  !>     A         device array of device pointers storing each matrix A_i.
  !>     @param[in]
  !>     lda       [rocblas_int]
  !>               specifies the leading dimension of each A_i.
  !>     @param[in]
  !>     batch_count [rocblas_int]
  !>                 number of instances in the batch
  !> 
  !>     
  interface rocblas_zsyr_batched
    function rocblas_zsyr_batched_orig(handle,uplo,n,alpha,x,incx,A,lda,batch_count) bind(c, name="rocblas_zsyr_batched")
      use iso_c_binding
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocblas_zsyr_batched_orig
      type(c_ptr),value :: handle
      integer(kind(rocblas_fill_upper)),value :: uplo
      integer(c_int),value :: n
      complex(c_double_complex) :: alpha
      type(c_ptr) :: x
      integer(c_int),value :: incx
      type(c_ptr) :: A
      integer(c_int),value :: lda
      integer(c_int),value :: batch_count
    end function

#ifdef USE_FPOINTER_INTERFACES
    module procedure rocblas_zsyr_batched_full_rank,rocblas_zsyr_batched_rank_0,rocblas_zsyr_batched_rank_1
#endif

  end interface
  
  interface rocblas_ssyr_strided_batched
    function rocblas_ssyr_strided_batched_orig(handle,uplo,n,alpha,x,incx,stridex,A,lda,strideA,batch_count) bind(c, name="rocblas_ssyr_strided_batched")
      use iso_c_binding
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocblas_ssyr_strided_batched_orig
      type(c_ptr),value :: handle
      integer(kind(rocblas_fill_upper)),value :: uplo
      integer(c_int),value :: n
      real(c_float) :: alpha
      type(c_ptr),value :: x
      integer(c_int),value :: incx
      integer(c_int64_t),value :: stridex
      type(c_ptr),value :: A
      integer(c_int),value :: lda
      integer(c_int64_t),value :: strideA
      integer(c_int),value :: batch_count
    end function

#ifdef USE_FPOINTER_INTERFACES
    module procedure rocblas_ssyr_strided_batched_full_rank,rocblas_ssyr_strided_batched_rank_0,rocblas_ssyr_strided_batched_rank_1
#endif

  end interface
  
  interface rocblas_dsyr_strided_batched
    function rocblas_dsyr_strided_batched_orig(handle,uplo,n,alpha,x,incx,stridex,A,lda,strideA,batch_count) bind(c, name="rocblas_dsyr_strided_batched")
      use iso_c_binding
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocblas_dsyr_strided_batched_orig
      type(c_ptr),value :: handle
      integer(kind(rocblas_fill_upper)),value :: uplo
      integer(c_int),value :: n
      real(c_double) :: alpha
      type(c_ptr),value :: x
      integer(c_int),value :: incx
      integer(c_int64_t),value :: stridex
      type(c_ptr),value :: A
      integer(c_int),value :: lda
      integer(c_int64_t),value :: strideA
      integer(c_int),value :: batch_count
    end function

#ifdef USE_FPOINTER_INTERFACES
    module procedure rocblas_dsyr_strided_batched_full_rank,rocblas_dsyr_strided_batched_rank_0,rocblas_dsyr_strided_batched_rank_1
#endif

  end interface
  
  interface rocblas_csyr_strided_batched
    function rocblas_csyr_strided_batched_orig(handle,uplo,n,alpha,x,incx,stridex,A,lda,strideA,batch_count) bind(c, name="rocblas_csyr_strided_batched")
      use iso_c_binding
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocblas_csyr_strided_batched_orig
      type(c_ptr),value :: handle
      integer(kind(rocblas_fill_upper)),value :: uplo
      integer(c_int),value :: n
      complex(c_float_complex) :: alpha
      type(c_ptr),value :: x
      integer(c_int),value :: incx
      integer(c_int64_t),value :: stridex
      type(c_ptr),value :: A
      integer(c_int),value :: lda
      integer(c_int64_t),value :: strideA
      integer(c_int),value :: batch_count
    end function

#ifdef USE_FPOINTER_INTERFACES
    module procedure rocblas_csyr_strided_batched_full_rank,rocblas_csyr_strided_batched_rank_0,rocblas_csyr_strided_batched_rank_1
#endif

  end interface
  !> ! \brief BLAS Level 2 API
  !> 
  !>     \details
  !>     xSYR_strided_batched performs the matrix-vector operations
  !> 
  !>         A[i] := A[i] + alphax[i]x[i]T
  !> 
  !>     where alpha is a scalar, vectors, and A is an array of
  !>     n by n symmetric matrices, for i = 1 , ... , batch_count
  !> 
  !>     @param[in]
  !>     handle    [rocblas_handle]
  !>               handle to the rocblas library context queue.
  !>     @param[in]
  !>     uplo      [rocblas_fill]
  !>               specifies whether the upper 'rocblas_fill_upper' or lower 'rocblas_fill_lower'
  !>               if rocblas_fill_upper, the lower part of A is not referenced
  !>               if rocblas_fill_lower, the upper part of A is not referenced
  !>     @param[in]
  !>     n         [rocblas_int]
  !>               the number of rows and columns of each matrix A.
  !>     @param[in]
  !>     alpha
  !>               device pointer or host pointer to scalar alpha.
  !>     @param[in]
  !>     x         device pointer to the first vector x_1.
  !>     @param[in]
  !>     incx      [rocblas_int]
  !>               specifies the increment for the elements of each x_i.
  !>     @param[in]
  !>     stridex   [rocblas_stride]
  !>               specifies the pointer increment between vectors (x_i) and (x_i+1).
  !>     @param[inout]
  !>     A         device pointer to the first matrix A_1.
  !>     @param[in]
  !>     lda       [rocblas_int]
  !>               specifies the leading dimension of each A_i.
  !>     @param[in]
  !>     strideA   [rocblas_stride]
  !>               stride from the start of one matrix (A_i) and the next one (A_i+1)
  !>     @param[in]
  !>     batch_count [rocblas_int]
  !>               number of instances in the batch
  !> 
  !>     
  interface rocblas_zsyr_strided_batched
    function rocblas_zsyr_strided_batched_orig(handle,uplo,n,alpha,x,incx,stridex,A,lda,strideA,batch_count) bind(c, name="rocblas_zsyr_strided_batched")
      use iso_c_binding
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocblas_zsyr_strided_batched_orig
      type(c_ptr),value :: handle
      integer(kind(rocblas_fill_upper)),value :: uplo
      integer(c_int),value :: n
      complex(c_double_complex) :: alpha
      type(c_ptr),value :: x
      integer(c_int),value :: incx
      integer(c_int64_t),value :: stridex
      type(c_ptr),value :: A
      integer(c_int),value :: lda
      integer(c_int64_t),value :: strideA
      integer(c_int),value :: batch_count
    end function

#ifdef USE_FPOINTER_INTERFACES
    module procedure rocblas_zsyr_strided_batched_full_rank,rocblas_zsyr_strided_batched_rank_0,rocblas_zsyr_strided_batched_rank_1
#endif

  end interface
  
  interface rocblas_ssyr2
    function rocblas_ssyr2_orig(handle,uplo,n,alpha,x,incx,y,incy,A,lda) bind(c, name="rocblas_ssyr2")
      use iso_c_binding
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocblas_ssyr2_orig
      type(c_ptr),value :: handle
      integer(kind(rocblas_fill_upper)),value :: uplo
      integer(c_int),value :: n
      real(c_float) :: alpha
      type(c_ptr),value :: x
      integer(c_int),value :: incx
      type(c_ptr),value :: y
      integer(c_int),value :: incy
      type(c_ptr),value :: A
      integer(c_int),value :: lda
    end function

#ifdef USE_FPOINTER_INTERFACES
    module procedure rocblas_ssyr2_full_rank,rocblas_ssyr2_rank_0,rocblas_ssyr2_rank_1
#endif

  end interface
  
  interface rocblas_dsyr2
    function rocblas_dsyr2_orig(handle,uplo,n,alpha,x,incx,y,incy,A,lda) bind(c, name="rocblas_dsyr2")
      use iso_c_binding
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocblas_dsyr2_orig
      type(c_ptr),value :: handle
      integer(kind(rocblas_fill_upper)),value :: uplo
      integer(c_int),value :: n
      real(c_double) :: alpha
      type(c_ptr),value :: x
      integer(c_int),value :: incx
      type(c_ptr),value :: y
      integer(c_int),value :: incy
      type(c_ptr),value :: A
      integer(c_int),value :: lda
    end function

#ifdef USE_FPOINTER_INTERFACES
    module procedure rocblas_dsyr2_full_rank,rocblas_dsyr2_rank_0,rocblas_dsyr2_rank_1
#endif

  end interface
  
  interface rocblas_csyr2
    function rocblas_csyr2_orig(handle,uplo,n,alpha,x,incx,y,incy,A,lda) bind(c, name="rocblas_csyr2")
      use iso_c_binding
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocblas_csyr2_orig
      type(c_ptr),value :: handle
      integer(kind(rocblas_fill_upper)),value :: uplo
      integer(c_int),value :: n
      complex(c_float_complex) :: alpha
      type(c_ptr),value :: x
      integer(c_int),value :: incx
      type(c_ptr),value :: y
      integer(c_int),value :: incy
      type(c_ptr),value :: A
      integer(c_int),value :: lda
    end function

#ifdef USE_FPOINTER_INTERFACES
    module procedure rocblas_csyr2_full_rank,rocblas_csyr2_rank_0,rocblas_csyr2_rank_1
#endif

  end interface
  !> ! \brief BLAS Level 2 API
  !> 
  !>     \details
  !>     xSYR2 performs the matrix-vector operations
  !> 
  !>         A := A + alphaxyT + alphayxT
  !> 
  !>     where alpha is a scalar, x and y are vectors, and A is an
  !>     n by n symmetric matrix.
  !> 
  !>     @param[in]
  !>     handle    [rocblas_handle]
  !>               handle to the rocblas library context queue.
  !>     @param[in]
  !>     uplo      [rocblas_fill]
  !>               specifies whether the upper 'rocblas_fill_upper' or lower 'rocblas_fill_lower'
  !>               if rocblas_fill_upper, the lower part of A is not referenced
  !>               if rocblas_fill_lower, the upper part of A is not referenced
  !> 
  !>     @param[in]
  !>     n         [rocblas_int]
  !>               the number of rows and columns of matrix A.
  !>     @param[in]
  !>     alpha
  !>               device pointer or host pointer to scalar alpha.
  !>     @param[in]
  !>     x         device pointer storing vector x.
  !>     @param[in]
  !>     incx      [rocblas_int]
  !>               specifies the increment for the elements of x.
  !>     @param[in]
  !>     y         device pointer storing vector y.
  !>     @param[in]
  !>     incy      [rocblas_int]
  !>               specifies the increment for the elements of y.
  !>     @param[inout]
  !>     A         device pointer storing matrix A.
  !>     @param[in]
  !>     lda       [rocblas_int]
  !>               specifies the leading dimension of A.
  !> 
  !>     
  interface rocblas_zsyr2
    function rocblas_zsyr2_orig(handle,uplo,n,alpha,x,incx,y,incy,A,lda) bind(c, name="rocblas_zsyr2")
      use iso_c_binding
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocblas_zsyr2_orig
      type(c_ptr),value :: handle
      integer(kind(rocblas_fill_upper)),value :: uplo
      integer(c_int),value :: n
      complex(c_double_complex) :: alpha
      type(c_ptr),value :: x
      integer(c_int),value :: incx
      type(c_ptr),value :: y
      integer(c_int),value :: incy
      type(c_ptr),value :: A
      integer(c_int),value :: lda
    end function

#ifdef USE_FPOINTER_INTERFACES
    module procedure rocblas_zsyr2_full_rank,rocblas_zsyr2_rank_0,rocblas_zsyr2_rank_1
#endif

  end interface
  
  interface rocblas_ssyr2_batched
    function rocblas_ssyr2_batched_orig(handle,uplo,n,alpha,x,incx,y,incy,A,lda,batch_count) bind(c, name="rocblas_ssyr2_batched")
      use iso_c_binding
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocblas_ssyr2_batched_orig
      type(c_ptr),value :: handle
      integer(kind(rocblas_fill_upper)),value :: uplo
      integer(c_int),value :: n
      real(c_float) :: alpha
      type(c_ptr) :: x
      integer(c_int),value :: incx
      type(c_ptr) :: y
      integer(c_int),value :: incy
      type(c_ptr) :: A
      integer(c_int),value :: lda
      integer(c_int),value :: batch_count
    end function

#ifdef USE_FPOINTER_INTERFACES
    module procedure rocblas_ssyr2_batched_full_rank,rocblas_ssyr2_batched_rank_0,rocblas_ssyr2_batched_rank_1
#endif

  end interface
  
  interface rocblas_dsyr2_batched
    function rocblas_dsyr2_batched_orig(handle,uplo,n,alpha,x,incx,y,incy,A,lda,batch_count) bind(c, name="rocblas_dsyr2_batched")
      use iso_c_binding
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocblas_dsyr2_batched_orig
      type(c_ptr),value :: handle
      integer(kind(rocblas_fill_upper)),value :: uplo
      integer(c_int),value :: n
      real(c_double) :: alpha
      type(c_ptr) :: x
      integer(c_int),value :: incx
      type(c_ptr) :: y
      integer(c_int),value :: incy
      type(c_ptr) :: A
      integer(c_int),value :: lda
      integer(c_int),value :: batch_count
    end function

#ifdef USE_FPOINTER_INTERFACES
    module procedure rocblas_dsyr2_batched_full_rank,rocblas_dsyr2_batched_rank_0,rocblas_dsyr2_batched_rank_1
#endif

  end interface
  
  interface rocblas_csyr2_batched
    function rocblas_csyr2_batched_orig(handle,uplo,n,alpha,x,incx,y,incy,A,lda,batch_count) bind(c, name="rocblas_csyr2_batched")
      use iso_c_binding
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocblas_csyr2_batched_orig
      type(c_ptr),value :: handle
      integer(kind(rocblas_fill_upper)),value :: uplo
      integer(c_int),value :: n
      complex(c_float_complex) :: alpha
      type(c_ptr) :: x
      integer(c_int),value :: incx
      type(c_ptr) :: y
      integer(c_int),value :: incy
      type(c_ptr) :: A
      integer(c_int),value :: lda
      integer(c_int),value :: batch_count
    end function

#ifdef USE_FPOINTER_INTERFACES
    module procedure rocblas_csyr2_batched_full_rank,rocblas_csyr2_batched_rank_0,rocblas_csyr2_batched_rank_1
#endif

  end interface
  !> ! \brief BLAS Level 2 API
  !> 
  !>     \details
  !>     xSYR2_BATCHED performs a batch of matrix-vector operations
  !> 
  !>         A[i] := A[i] + alphax[i]y[i]T + alphay[i]x[i]T
  !> 
  !>     where alpha is a scalar, x[i] and y[i] are vectors, and A[i] is a
  !>     n by n symmetric matrix, for i = 1 , ... , batch_count
  !> 
  !>     @param[in]
  !>     handle    [rocblas_handle]
  !>               handle to the rocblas library context queue.
  !>     @param[in]
  !>     uplo      [rocblas_fill]
  !>               specifies whether the upper 'rocblas_fill_upper' or lower 'rocblas_fill_lower'
  !>               if rocblas_fill_upper, the lower part of A is not referenced
  !>               if rocblas_fill_lower, the upper part of A is not referenced
  !>     @param[in]
  !>     n         [rocblas_int]
  !>               the number of rows and columns of matrix A.
  !>     @param[in]
  !>     alpha
  !>               device pointer or host pointer to scalar alpha.
  !>     @param[in]
  !>     x         device array of device pointers storing each vector x_i.
  !>     @param[in]
  !>     incx      [rocblas_int]
  !>               specifies the increment for the elements of each x_i.
  !>     @param[in]
  !>     y         device array of device pointers storing each vector y_i.
  !>     @param[in]
  !>     incy      [rocblas_int]
  !>               specifies the increment for the elements of each y_i.
  !>     @param[inout]
  !>     A         device array of device pointers storing each matrix A_i.
  !>     @param[in]
  !>     lda       [rocblas_int]
  !>               specifies the leading dimension of each A_i.
  !>     @param[in]
  !>     batch_count [rocblas_int]
  !>                 number of instances in the batch
  !> 
  !>     
  interface rocblas_zsyr2_batched
    function rocblas_zsyr2_batched_orig(handle,uplo,n,alpha,x,incx,y,incy,A,lda,batch_count) bind(c, name="rocblas_zsyr2_batched")
      use iso_c_binding
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocblas_zsyr2_batched_orig
      type(c_ptr),value :: handle
      integer(kind(rocblas_fill_upper)),value :: uplo
      integer(c_int),value :: n
      complex(c_double_complex) :: alpha
      type(c_ptr) :: x
      integer(c_int),value :: incx
      type(c_ptr) :: y
      integer(c_int),value :: incy
      type(c_ptr) :: A
      integer(c_int),value :: lda
      integer(c_int),value :: batch_count
    end function

#ifdef USE_FPOINTER_INTERFACES
    module procedure rocblas_zsyr2_batched_full_rank,rocblas_zsyr2_batched_rank_0,rocblas_zsyr2_batched_rank_1
#endif

  end interface
  
  interface rocblas_ssyr2_strided_batched
    function rocblas_ssyr2_strided_batched_orig(handle,uplo,n,alpha,x,incx,stridex,y,incy,stridey,A,lda,strideA,batch_count) bind(c, name="rocblas_ssyr2_strided_batched")
      use iso_c_binding
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocblas_ssyr2_strided_batched_orig
      type(c_ptr),value :: handle
      integer(kind(rocblas_fill_upper)),value :: uplo
      integer(c_int),value :: n
      real(c_float) :: alpha
      type(c_ptr),value :: x
      integer(c_int),value :: incx
      integer(c_int64_t),value :: stridex
      type(c_ptr),value :: y
      integer(c_int),value :: incy
      integer(c_int64_t),value :: stridey
      type(c_ptr),value :: A
      integer(c_int),value :: lda
      integer(c_int64_t),value :: strideA
      integer(c_int),value :: batch_count
    end function

#ifdef USE_FPOINTER_INTERFACES
    module procedure rocblas_ssyr2_strided_batched_full_rank,rocblas_ssyr2_strided_batched_rank_0,rocblas_ssyr2_strided_batched_rank_1
#endif

  end interface
  
  interface rocblas_dsyr2_strided_batched
    function rocblas_dsyr2_strided_batched_orig(handle,uplo,n,alpha,x,incx,stridex,y,incy,stridey,A,lda,strideA,batch_count) bind(c, name="rocblas_dsyr2_strided_batched")
      use iso_c_binding
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocblas_dsyr2_strided_batched_orig
      type(c_ptr),value :: handle
      integer(kind(rocblas_fill_upper)),value :: uplo
      integer(c_int),value :: n
      real(c_double) :: alpha
      type(c_ptr),value :: x
      integer(c_int),value :: incx
      integer(c_int64_t),value :: stridex
      type(c_ptr),value :: y
      integer(c_int),value :: incy
      integer(c_int64_t),value :: stridey
      type(c_ptr),value :: A
      integer(c_int),value :: lda
      integer(c_int64_t),value :: strideA
      integer(c_int),value :: batch_count
    end function

#ifdef USE_FPOINTER_INTERFACES
    module procedure rocblas_dsyr2_strided_batched_full_rank,rocblas_dsyr2_strided_batched_rank_0,rocblas_dsyr2_strided_batched_rank_1
#endif

  end interface
  
  interface rocblas_csyr2_strided_batched
    function rocblas_csyr2_strided_batched_orig(handle,uplo,n,alpha,x,incx,stridex,y,incy,stridey,A,lda,strideA,batch_count) bind(c, name="rocblas_csyr2_strided_batched")
      use iso_c_binding
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocblas_csyr2_strided_batched_orig
      type(c_ptr),value :: handle
      integer(kind(rocblas_fill_upper)),value :: uplo
      integer(c_int),value :: n
      complex(c_float_complex) :: alpha
      type(c_ptr),value :: x
      integer(c_int),value :: incx
      integer(c_int64_t),value :: stridex
      type(c_ptr),value :: y
      integer(c_int),value :: incy
      integer(c_int64_t),value :: stridey
      type(c_ptr),value :: A
      integer(c_int),value :: lda
      integer(c_int64_t),value :: strideA
      integer(c_int),value :: batch_count
    end function

#ifdef USE_FPOINTER_INTERFACES
    module procedure rocblas_csyr2_strided_batched_full_rank,rocblas_csyr2_strided_batched_rank_0,rocblas_csyr2_strided_batched_rank_1
#endif

  end interface
  !> ! \brief BLAS Level 2 API
  !> 
  !>     \details
  !>     xSYR2_STRIDED_BATCHED the matrix-vector operations
  !> 
  !>         A[i] := A[i] + alphax[i]y[i]T + alphay[i]x[i]T
  !> 
  !>     where alpha is a scalar, x[i] and y[i] are vectors, and A[i] is a
  !>     n by n symmetric matrices, for i = 1 , ... , batch_count
  !> 
  !>     @param[in]
  !>     handle    [rocblas_handle]
  !>               handle to the rocblas library context queue.
  !>     @param[in]
  !>     uplo      [rocblas_fill]
  !>               specifies whether the upper 'rocblas_fill_upper' or lower 'rocblas_fill_lower'
  !>               if rocblas_fill_upper, the lower part of A is not referenced
  !>               if rocblas_fill_lower, the upper part of A is not referenced
  !>     @param[in]
  !>     n         [rocblas_int]
  !>               the number of rows and columns of each matrix A.
  !>     @param[in]
  !>     alpha
  !>               device pointer or host pointer to scalar alpha.
  !>     @param[in]
  !>     x         device pointer to the first vector x_1.
  !>     @param[in]
  !>     incx      [rocblas_int]
  !>               specifies the increment for the elements of each x_i.
  !>     @param[in]
  !>     stridex   [rocblas_stride]
  !>               specifies the pointer increment between vectors (x_i) and (x_i+1).
  !>     @param[in]
  !>     y         device pointer to the first vector y_1.
  !>     @param[in]
  !>     incy      [rocblas_int]
  !>               specifies the increment for the elements of each y_i.
  !>     @param[in]
  !>     stridey   [rocblas_stride]
  !>               specifies the pointer increment between vectors (y_i) and (y_i+1).
  !>     @param[inout]
  !>     A         device pointer to the first matrix A_1.
  !>     @param[in]
  !>     lda       [rocblas_int]
  !>               specifies the leading dimension of each A_i.
  !>     @param[in]
  !>     strideA   [rocblas_stride]
  !>               stride from the start of one matrix (A_i) and the next one (A_i+1)
  !>     @param[in]
  !>     batch_count [rocblas_int]
  !>               number of instances in the batch
  !> 
  !>     
  interface rocblas_zsyr2_strided_batched
    function rocblas_zsyr2_strided_batched_orig(handle,uplo,n,alpha,x,incx,stridex,y,incy,stridey,A,lda,strideA,batch_count) bind(c, name="rocblas_zsyr2_strided_batched")
      use iso_c_binding
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocblas_zsyr2_strided_batched_orig
      type(c_ptr),value :: handle
      integer(kind(rocblas_fill_upper)),value :: uplo
      integer(c_int),value :: n
      complex(c_double_complex) :: alpha
      type(c_ptr),value :: x
      integer(c_int),value :: incx
      integer(c_int64_t),value :: stridex
      type(c_ptr),value :: y
      integer(c_int),value :: incy
      integer(c_int64_t),value :: stridey
      type(c_ptr),value :: A
      integer(c_int),value :: lda
      integer(c_int64_t),value :: strideA
      integer(c_int),value :: batch_count
    end function

#ifdef USE_FPOINTER_INTERFACES
    module procedure rocblas_zsyr2_strided_batched_full_rank,rocblas_zsyr2_strided_batched_rank_0,rocblas_zsyr2_strided_batched_rank_1
#endif

  end interface
  !> 
  !>   ===========================================================================
  !>      level 3 BLAS
  !>   ===========================================================================
  !>  
  interface rocblas_chemm
    function rocblas_chemm_orig(handle,side,uplo,n,k,alpha,A,lda,B,ldb,beta,C,ldc) bind(c, name="rocblas_chemm")
      use iso_c_binding
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocblas_chemm_orig
      type(c_ptr),value :: handle
      integer(kind(rocblas_side_left)),value :: side
      integer(kind(rocblas_fill_upper)),value :: uplo
      integer(c_int),value :: n
      integer(c_int),value :: k
      complex(c_float_complex) :: alpha
      type(c_ptr),value :: A
      integer(c_int),value :: lda
      type(c_ptr),value :: B
      integer(c_int),value :: ldb
      complex(c_float_complex) :: beta
      type(c_ptr),value :: C
      integer(c_int),value :: ldc
    end function

#ifdef USE_FPOINTER_INTERFACES
    module procedure rocblas_chemm_full_rank,rocblas_chemm_rank_0,rocblas_chemm_rank_1
#endif

  end interface
  !> ! \brief BLAS Level 3 API
  !> 
  !>     \details
  !> 
  !>     hemm performs one of the matrix-matrix operations:
  !> 
  !>     C := alphaAB + betaC if side == rocblas_side_left,
  !>     C := alphaBA + betaC if side == rocblas_side_right,
  !> 
  !>     where alpha and beta are scalars, B and C are m by n matrices, and
  !>     A is a Hermitian matrix stored as either upper or lower.
  !> 
  !>     @param[in]
  !>     handle    [rocblas_handle]
  !>               handle to the rocblas library context queue.
  !> 
  !>     @param[in]
  !>     side  [rocblas_side]
  !>             rocblas_side_left:      C := alphaAB + betaC
  !>             rocblas_side_right:     C := alphaBA + betaC
  !> 
  !>     @param[in]
  !>     uplo    [rocblas_fill]
  !>             rocblas_fill_upper:  A is an upper triangular matrix
  !>             rocblas_fill_lower:  A is a  lower triangular matrix
  !> 
  !>     @param[in]
  !>     m       [rocblas_int]
  !>             m specifies the number of rows of B and C. m >= 0.
  !> 
  !>     @param[in]
  !>     n       [rocblas_int]
  !>             n specifies the number of columns of B and C. n >= 0.
  !> 
  !>     @param[in]
  !>     alpha
  !>             alpha specifies the scalar alpha. When alpha is
  !>             zero then A and B are not referenced.
  !> 
  !>     @param[in]
  !>     A       pointer storing matrix A on the GPU.
  !>             A is m by m if side == rocblas_side_left
  !>             A is n by n if side == rocblas_side_right
  !>             Only the upperlower triangular part is accessed.
  !>             The imaginary component of the diagonal elements is not used.
  !> 
  !>     @param[in]
  !>     lda     [rocblas_int]
  !>             lda specifies the first dimension of A.
  !>             if side = rocblas_side_left,  lda >= max( 1, m ),
  !>             otherwise lda >= max( 1, n ).
  !> 
  !>     @param[in]
  !>     B       pointer storing matrix B on the GPU.
  !>             Matrix dimension is m by n
  !> 
  !>     @param[in]
  !>     ldb     [rocblas_int]
  !>             ldb specifies the first dimension of B. ldb >= max( 1, m )
  !> 
  !>     @param[in]
  !>     beta
  !>             beta specifies the scalar beta. When beta is
  !>             zero then C need not be set before entry.
  !> 
  !>     @param[in]
  !>     C       pointer storing matrix C on the GPU.
  !>             Matrix dimension is m by n
  !> 
  !>     @param[in]
  !>     ldc    [rocblas_int]
  !>            ldc specifies the first dimension of C. ldc >= max( 1, m )
  !> 
  !>     
  interface rocblas_zhemm
    function rocblas_zhemm_orig(handle,side,uplo,n,k,alpha,A,lda,B,ldb,beta,C,ldc) bind(c, name="rocblas_zhemm")
      use iso_c_binding
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocblas_zhemm_orig
      type(c_ptr),value :: handle
      integer(kind(rocblas_side_left)),value :: side
      integer(kind(rocblas_fill_upper)),value :: uplo
      integer(c_int),value :: n
      integer(c_int),value :: k
      complex(c_double_complex) :: alpha
      type(c_ptr),value :: A
      integer(c_int),value :: lda
      type(c_ptr),value :: B
      integer(c_int),value :: ldb
      complex(c_double_complex) :: beta
      type(c_ptr),value :: C
      integer(c_int),value :: ldc
    end function

#ifdef USE_FPOINTER_INTERFACES
    module procedure rocblas_zhemm_full_rank,rocblas_zhemm_rank_0,rocblas_zhemm_rank_1
#endif

  end interface
  
  interface rocblas_chemm_batched
    function rocblas_chemm_batched_orig(handle,side,uplo,m,n,alpha,A,lda,B,ldb,beta,C,ldc,batch_count) bind(c, name="rocblas_chemm_batched")
      use iso_c_binding
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocblas_chemm_batched_orig
      type(c_ptr),value :: handle
      integer(kind(rocblas_side_left)),value :: side
      integer(kind(rocblas_fill_upper)),value :: uplo
      integer(c_int),value :: m
      integer(c_int),value :: n
      complex(c_float_complex) :: alpha
      type(c_ptr) :: A
      integer(c_int),value :: lda
      type(c_ptr) :: B
      integer(c_int),value :: ldb
      complex(c_float_complex) :: beta
      type(c_ptr) :: C
      integer(c_int),value :: ldc
      integer(c_int),value :: batch_count
    end function

#ifdef USE_FPOINTER_INTERFACES
    module procedure rocblas_chemm_batched_full_rank,rocblas_chemm_batched_rank_0,rocblas_chemm_batched_rank_1
#endif

  end interface
  !> ! \brief BLAS Level 3 API
  !> 
  !>     \details
  !> 
  !>     hemm_batched performs a batch of the matrix-matrix operations:
  !> 
  !>     C_i := alphaA_iB_i + betaC_i if side == rocblas_side_left,
  !>     C_i := alphaB_iA_i + betaC_i if side == rocblas_side_right,
  !> 
  !>     where alpha and beta are scalars, B_i and C_i are m by n matrices, and
  !>     A_i is a Hermitian matrix stored as either upper or lower.
  !> 
  !>     @param[in]
  !>     handle    [rocblas_handle]
  !>               handle to the rocblas library context queue.
  !> 
  !>     @param[in]
  !>     side  [rocblas_side]
  !>             rocblas_side_left:      C_i := alphaA_iB_i + betaC_i
  !>             rocblas_side_right:     C_i := alphaB_iA_i + betaC_i
  !> 
  !>     @param[in]
  !>     uplo    [rocblas_fill]
  !>             rocblas_fill_upper:  A_i is an upper triangular matrix
  !>             rocblas_fill_lower:  A_i is a  lower triangular matrix
  !> 
  !>     @param[in]
  !>     m       [rocblas_int]
  !>             m specifies the number of rows of B_i and C_i. m >= 0.
  !> 
  !>     @param[in]
  !>     n       [rocblas_int]
  !>             n specifies the number of columns of B_i and C_i. n >= 0.
  !> 
  !>     @param[in]
  !>     alpha
  !>             alpha specifies the scalar alpha. When alpha is
  !>             zero then A_i and B_i are not referenced.
  !> 
  !>     @param[in]
  !>     A       device array of device pointers storing each matrix A_i on the GPU.
  !>             A_i is m by m if side == rocblas_side_left
  !>             A_i is n by n if side == rocblas_side_right
  !>             Only the upperlower triangular part is accessed.
  !>             The imaginary component of the diagonal elements is not used.
  !> 
  !>     @param[in]
  !>     lda     [rocblas_int]
  !>             lda specifies the first dimension of A_i.
  !>             if side = rocblas_side_left,  lda >= max( 1, m ),
  !>             otherwise lda >= max( 1, n ).
  !> 
  !>     @param[in]
  !>     B       device array of device pointers storing each matrix B_i on the GPU.
  !>             Matrix dimension is m by n
  !> 
  !>     @param[in]
  !>     ldb     [rocblas_int]
  !>             ldb specifies the first dimension of B_i. ldb >= max( 1, m )
  !> 
  !>     @param[in]
  !>     beta
  !>             beta specifies the scalar beta. When beta is
  !>             zero then C_i need not be set before entry.
  !> 
  !>     @param[in]
  !>     C       device array of device pointers storing each matrix C_i on the GPU.
  !>             Matrix dimension is m by n
  !> 
  !>     @param[in]
  !>     ldc    [rocblas_int]
  !>            ldc specifies the first dimension of C_i. ldc >= max( 1, m )
  !> 
  !>     @param[in]
  !>     batch_count [rocblas_int]
  !>                 number of instances in the batch.
  !> 
  !>     
  interface rocblas_zhemm_batched
    function rocblas_zhemm_batched_orig(handle,side,uplo,m,n,alpha,A,lda,B,ldb,beta,C,ldc,batch_count) bind(c, name="rocblas_zhemm_batched")
      use iso_c_binding
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocblas_zhemm_batched_orig
      type(c_ptr),value :: handle
      integer(kind(rocblas_side_left)),value :: side
      integer(kind(rocblas_fill_upper)),value :: uplo
      integer(c_int),value :: m
      integer(c_int),value :: n
      complex(c_double_complex) :: alpha
      type(c_ptr) :: A
      integer(c_int),value :: lda
      type(c_ptr) :: B
      integer(c_int),value :: ldb
      complex(c_double_complex) :: beta
      type(c_ptr) :: C
      integer(c_int),value :: ldc
      integer(c_int),value :: batch_count
    end function

#ifdef USE_FPOINTER_INTERFACES
    module procedure rocblas_zhemm_batched_full_rank,rocblas_zhemm_batched_rank_0,rocblas_zhemm_batched_rank_1
#endif

  end interface
  
  interface rocblas_chemm_strided_batched
    function rocblas_chemm_strided_batched_orig(handle,side,uplo,m,n,alpha,A,lda,stride_A,B,ldb,stride_B,beta,C,ldc,stride_C,batch_count) bind(c, name="rocblas_chemm_strided_batched")
      use iso_c_binding
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocblas_chemm_strided_batched_orig
      type(c_ptr),value :: handle
      integer(kind(rocblas_side_left)),value :: side
      integer(kind(rocblas_fill_upper)),value :: uplo
      integer(c_int),value :: m
      integer(c_int),value :: n
      complex(c_float_complex) :: alpha
      type(c_ptr),value :: A
      integer(c_int),value :: lda
      integer(c_int64_t),value :: stride_A
      type(c_ptr),value :: B
      integer(c_int),value :: ldb
      integer(c_int64_t),value :: stride_B
      complex(c_float_complex) :: beta
      type(c_ptr),value :: C
      integer(c_int),value :: ldc
      integer(c_int64_t),value :: stride_C
      integer(c_int),value :: batch_count
    end function

#ifdef USE_FPOINTER_INTERFACES
    module procedure rocblas_chemm_strided_batched_full_rank,rocblas_chemm_strided_batched_rank_0,rocblas_chemm_strided_batched_rank_1
#endif

  end interface
  !> ! \brief BLAS Level 3 API
  !> 
  !>     \details
  !> 
  !>     hemm_strided_batched performs a batch of the matrix-matrix operations:
  !> 
  !>     C_i := alphaA_iB_i + betaC_i if side == rocblas_side_left,
  !>     C_i := alphaB_iA_i + betaC_i if side == rocblas_side_right,
  !> 
  !>     where alpha and beta are scalars, B_i and C_i are m by n matrices, and
  !>     A_i is a Hermitian matrix stored as either upper or lower.
  !> 
  !>     @param[in]
  !>     handle    [rocblas_handle]
  !>               handle to the rocblas library context queue.
  !> 
  !>     @param[in]
  !>     side  [rocblas_side]
  !>             rocblas_side_left:      C_i := alphaA_iB_i + betaC_i
  !>             rocblas_side_right:     C_i := alphaB_iA_i + betaC_i
  !> 
  !>     @param[in]
  !>     uplo    [rocblas_fill]
  !>             rocblas_fill_upper:  A_i is an upper triangular matrix
  !>             rocblas_fill_lower:  A_i is a  lower triangular matrix
  !> 
  !>     @param[in]
  !>     m       [rocblas_int]
  !>             m specifies the number of rows of B_i and C_i. m >= 0.
  !> 
  !>     @param[in]
  !>     n       [rocblas_int]
  !>             n specifies the number of columns of B_i and C_i. n >= 0.
  !> 
  !>     @param[in]
  !>     alpha
  !>             alpha specifies the scalar alpha. When alpha is
  !>             zero then A_i and B_i are not referenced.
  !> 
  !>     @param[in]
  !>     A       device pointer to first matrix A_1
  !>             A_i is m by m if side == rocblas_side_left
  !>             A_i is n by n if side == rocblas_side_right
  !>             Only the upperlower triangular part is accessed.
  !>             The imaginary component of the diagonal elements is not used.
  !> 
  !>     @param[in]
  !>     lda     [rocblas_int]
  !>             lda specifies the first dimension of A_i.
  !>             if side = rocblas_side_left,  lda >= max( 1, m ),
  !>             otherwise lda >= max( 1, n ).
  !> 
  !>     @param[in]
  !>     stride_A  [rocblas_stride]
  !>               stride from the start of one matrix (A_i) and the next one (A_i+1)
  !> 
  !>     @param[in]
  !>     B       device pointer to first matrix B_1 of dimension (ldb, n) on the GPU
  !> 
  !>     @param[in]
  !>     ldb     [rocblas_int]
  !>             ldb specifies the first dimension of B_i.
  !>             if side = rocblas_operation_none,  ldb >= max( 1, m ),
  !>             otherwise ldb >= max( 1, n ).
  !> 
  !>     @param[in]
  !>     stride_B  [rocblas_stride]
  !>               stride from the start of one matrix (B_i) and the next one (B_i+1)
  !> 
  !>     @param[in]
  !>     beta
  !>             beta specifies the scalar beta. When beta is
  !>             zero then C need not be set before entry.
  !> 
  !>     @param[in]
  !>     C        device pointer to first matrix C_1 of dimension (ldc, n) on the GPU.
  !> 
  !>     @param[in]
  !>     ldc    [rocblas_int]
  !>            ldc specifies the first dimension of C. ldc >= max( 1, m )
  !> 
  !>     @param[inout]
  !>     stride_C  [rocblas_stride]
  !>               stride from the start of one matrix (C_i) and the next one (C_i+1)
  !> 
  !>     @param[in]
  !>     batch_count [rocblas_int]
  !>                 number of instances in the batch
  !> 
  !>     
  interface rocblas_zhemm_strided_batched
    function rocblas_zhemm_strided_batched_orig(handle,side,uplo,m,n,alpha,A,lda,stride_A,B,ldb,stride_B,beta,C,ldc,stride_C,batch_count) bind(c, name="rocblas_zhemm_strided_batched")
      use iso_c_binding
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocblas_zhemm_strided_batched_orig
      type(c_ptr),value :: handle
      integer(kind(rocblas_side_left)),value :: side
      integer(kind(rocblas_fill_upper)),value :: uplo
      integer(c_int),value :: m
      integer(c_int),value :: n
      complex(c_double_complex) :: alpha
      type(c_ptr),value :: A
      integer(c_int),value :: lda
      integer(c_int64_t),value :: stride_A
      type(c_ptr),value :: B
      integer(c_int),value :: ldb
      integer(c_int64_t),value :: stride_B
      complex(c_double_complex) :: beta
      type(c_ptr),value :: C
      integer(c_int),value :: ldc
      integer(c_int64_t),value :: stride_C
      integer(c_int),value :: batch_count
    end function

#ifdef USE_FPOINTER_INTERFACES
    module procedure rocblas_zhemm_strided_batched_full_rank,rocblas_zhemm_strided_batched_rank_0,rocblas_zhemm_strided_batched_rank_1
#endif

  end interface
  
  interface rocblas_cherk
    function rocblas_cherk_orig(handle,uplo,transA,n,k,alpha,A,lda,beta,C,ldc) bind(c, name="rocblas_cherk")
      use iso_c_binding
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocblas_cherk_orig
      type(c_ptr),value :: handle
      integer(kind(rocblas_fill_upper)),value :: uplo
      integer(kind(rocblas_operation_none)),value :: transA
      integer(c_int),value :: n
      integer(c_int),value :: k
      real(c_float) :: alpha
      type(c_ptr),value :: A
      integer(c_int),value :: lda
      real(c_float) :: beta
      type(c_ptr),value :: C
      integer(c_int),value :: ldc
    end function

#ifdef USE_FPOINTER_INTERFACES
    module procedure rocblas_cherk_full_rank,rocblas_cherk_rank_0,rocblas_cherk_rank_1
#endif

  end interface
  !> ! \brief BLAS Level 3 API
  !> 
  !>     \details
  !> 
  !>     herk performs one of the matrix-matrix operations for a Hermitian rank-k update
  !> 
  !>     C := alphaop( A )op( A )^H + betaC
  !> 
  !>     where  alpha and beta are scalars, op(A) is an n by k matrix, and
  !>     C is a n x n Hermitian matrix stored as either upper or lower.
  !> 
  !>         op( A ) = A, and A is n by k if transA == rocblas_operation_none
  !>         op( A ) = A^H and A is k by n if transA == rocblas_operation_conjugate_transpose
  !> 
  !>     @param[in]
  !>     handle    [rocblas_handle]
  !>               handle to the rocblas library context queue.
  !> 
  !>     @param[in]
  !>     uplo    [rocblas_fill]
  !>             rocblas_fill_upper:  C is an upper triangular matrix
  !>             rocblas_fill_lower:  C is a  lower triangular matrix
  !> 
  !>     @param[in]
  !>     transA  [rocblas_operation]
  !>             rocblas_operation_conjugate_transpose:  op(A) = A^H
  !>             rocblas_operation_none:                 op(A) = A
  !> 
  !>     @param[in]
  !>     n       [rocblas_int]
  !>             n specifies the number of rows and columns of C. n >= 0.
  !> 
  !>     @param[in]
  !>     k       [rocblas_int]
  !>             k specifies the number of columns of op(A). k >= 0.
  !> 
  !>     @param[in]
  !>     alpha
  !>             alpha specifies the scalar alpha. When alpha is
  !>             zero then A is not referenced and A need not be set before
  !>             entry.
  !> 
  !>     @param[in]
  !>     A       pointer storing matrix A on the GPU.
  !>             Martrix dimension is ( lda, k ) when if transA = rocblas_operation_none, otherwise (lda, n)
  !>             only the upperlower triangular part is accessed.
  !> 
  !>     @param[in]
  !>     lda     [rocblas_int]
  !>             lda specifies the first dimension of A.
  !>             if transA = rocblas_operation_none,  lda >= max( 1, n ),
  !>             otherwise lda >= max( 1, k ).
  !> 
  !>     @param[in]
  !>     beta
  !>             beta specifies the scalar beta. When beta is
  !>             zero then C need not be set before entry.
  !> 
  !>     @param[in]
  !>     C       pointer storing matrix C on the GPU.
  !>             The imaginary component of the diagonal elements are not used but are set to zero unless quick return.
  !> 
  !>     @param[in]
  !>     ldc    [rocblas_int]
  !>            ldc specifies the first dimension of C. ldc >= max( 1, n ).
  !> 
  !>     
  interface rocblas_zherk
    function rocblas_zherk_orig(handle,uplo,transA,n,k,alpha,A,lda,beta,C,ldc) bind(c, name="rocblas_zherk")
      use iso_c_binding
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocblas_zherk_orig
      type(c_ptr),value :: handle
      integer(kind(rocblas_fill_upper)),value :: uplo
      integer(kind(rocblas_operation_none)),value :: transA
      integer(c_int),value :: n
      integer(c_int),value :: k
      real(c_double) :: alpha
      type(c_ptr),value :: A
      integer(c_int),value :: lda
      real(c_double) :: beta
      type(c_ptr),value :: C
      integer(c_int),value :: ldc
    end function

#ifdef USE_FPOINTER_INTERFACES
    module procedure rocblas_zherk_full_rank,rocblas_zherk_rank_0,rocblas_zherk_rank_1
#endif

  end interface
  
  interface rocblas_cherk_batched
    function rocblas_cherk_batched_orig(handle,uplo,transA,n,k,alpha,A,lda,beta,C,ldc,batch_count) bind(c, name="rocblas_cherk_batched")
      use iso_c_binding
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocblas_cherk_batched_orig
      type(c_ptr),value :: handle
      integer(kind(rocblas_fill_upper)),value :: uplo
      integer(kind(rocblas_operation_none)),value :: transA
      integer(c_int),value :: n
      integer(c_int),value :: k
      real(c_float) :: alpha
      type(c_ptr) :: A
      integer(c_int),value :: lda
      real(c_float) :: beta
      type(c_ptr) :: C
      integer(c_int),value :: ldc
      integer(c_int),value :: batch_count
    end function

#ifdef USE_FPOINTER_INTERFACES
    module procedure rocblas_cherk_batched_full_rank,rocblas_cherk_batched_rank_0,rocblas_cherk_batched_rank_1
#endif

  end interface
  !> ! \brief BLAS Level 3 API
  !> 
  !>     \details
  !> 
  !>     herk_batched performs a batch of the matrix-matrix operations for a Hermitian rank-k update
  !> 
  !>     C_i := alphaop( A_i )op( A_i )^H + betaC_i
  !> 
  !>     where  alpha and beta are scalars, op(A) is an n by k matrix, and
  !>     C_i is a n x n Hermitian matrix stored as either upper or lower.
  !> 
  !>         op( A_i ) = A_i, and A_i is n by k if transA == rocblas_operation_none
  !>         op( A_i ) = A_i^H and A_i is k by n if transA == rocblas_operation_conjugate_transpose
  !> 
  !>     @param[in]
  !>     handle    [rocblas_handle]
  !>               handle to the rocblas library context queue.
  !> 
  !>     @param[in]
  !>     uplo    [rocblas_fill]
  !>             rocblas_fill_upper:  C_i is an upper triangular matrix
  !>             rocblas_fill_lower:  C_i is a  lower triangular matrix
  !> 
  !>     @param[in]
  !>     transA  [rocblas_operation]
  !>             rocblas_operation_conjugate_transpose: op(A) = A^H
  !>             rocblas_operation_none:                op(A) = A
  !> 
  !>     @param[in]
  !>     n       [rocblas_int]
  !>             n specifies the number of rows and columns of C_i. n >= 0.
  !> 
  !>     @param[in]
  !>     k       [rocblas_int]
  !>             k specifies the number of columns of op(A). k >= 0.
  !> 
  !>     @param[in]
  !>     alpha
  !>             alpha specifies the scalar alpha. When alpha is
  !>             zero then A is not referenced and A need not be set before
  !>             entry.
  !> 
  !>     @param[in]
  !>     A       device array of device pointers storing each matrix_i A of dimension (lda, k)
  !>             when transA is rocblas_operation_none, otherwise of dimension (lda, n)
  !> 
  !>     @param[in]
  !>     lda     [rocblas_int]
  !>             lda specifies the first dimension of A_i.
  !>             if transA = rocblas_operation_none,  lda >= max( 1, n ),
  !>             otherwise lda >= max( 1, k ).
  !> 
  !>     @param[in]
  !>     beta
  !>             beta specifies the scalar beta. When beta is
  !>             zero then C need not be set before entry.
  !> 
  !>     @param[in]
  !>     C       device array of device pointers storing each matrix C_i on the GPU.
  !>             The imaginary component of the diagonal elements are not used but are set to zero unless quick return.
  !> 
  !>     @param[in]
  !>     ldc    [rocblas_int]
  !>            ldc specifies the first dimension of C. ldc >= max( 1, n ).
  !>     @param[in]
  !>     batch_count [rocblas_int]
  !>                 number of instances in the batch.
  !> 
  !>     
  interface rocblas_zherk_batched
    function rocblas_zherk_batched_orig(handle,uplo,transA,n,k,alpha,A,lda,beta,C,ldc,batch_count) bind(c, name="rocblas_zherk_batched")
      use iso_c_binding
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocblas_zherk_batched_orig
      type(c_ptr),value :: handle
      integer(kind(rocblas_fill_upper)),value :: uplo
      integer(kind(rocblas_operation_none)),value :: transA
      integer(c_int),value :: n
      integer(c_int),value :: k
      real(c_double) :: alpha
      type(c_ptr) :: A
      integer(c_int),value :: lda
      real(c_double) :: beta
      type(c_ptr) :: C
      integer(c_int),value :: ldc
      integer(c_int),value :: batch_count
    end function

#ifdef USE_FPOINTER_INTERFACES
    module procedure rocblas_zherk_batched_full_rank,rocblas_zherk_batched_rank_0,rocblas_zherk_batched_rank_1
#endif

  end interface
  
  interface rocblas_cherk_strided_batched
    function rocblas_cherk_strided_batched_orig(handle,uplo,transA,n,k,alpha,A,lda,stride_A,beta,C,ldc,stride_C,batch_count) bind(c, name="rocblas_cherk_strided_batched")
      use iso_c_binding
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocblas_cherk_strided_batched_orig
      type(c_ptr),value :: handle
      integer(kind(rocblas_fill_upper)),value :: uplo
      integer(kind(rocblas_operation_none)),value :: transA
      integer(c_int),value :: n
      integer(c_int),value :: k
      real(c_float) :: alpha
      type(c_ptr),value :: A
      integer(c_int),value :: lda
      integer(c_int64_t),value :: stride_A
      real(c_float) :: beta
      type(c_ptr),value :: C
      integer(c_int),value :: ldc
      integer(c_int64_t),value :: stride_C
      integer(c_int),value :: batch_count
    end function

#ifdef USE_FPOINTER_INTERFACES
    module procedure rocblas_cherk_strided_batched_full_rank,rocblas_cherk_strided_batched_rank_0,rocblas_cherk_strided_batched_rank_1
#endif

  end interface
  !> ! \brief BLAS Level 3 API
  !> 
  !>     \details
  !> 
  !>     herk_strided_batched performs a batch of the matrix-matrix operations for a Hermitian rank-k update
  !> 
  !>     C_i := alphaop( A_i )op( A_i )^H + betaC_i
  !> 
  !>     where  alpha and beta are scalars, op(A) is an n by k matrix, and
  !>     C_i is a n x n Hermitian matrix stored as either upper or lower.
  !> 
  !>         op( A_i ) = A_i, and A_i is n by k if transA == rocblas_operation_none
  !>         op( A_i ) = A_i^H and A_i is k by n if transA == rocblas_operation_conjugate_transpose
  !> 
  !> 
  !>     @param[in]
  !>     handle    [rocblas_handle]
  !>               handle to the rocblas library context queue.
  !> 
  !>     @param[in]
  !>     uplo    [rocblas_fill]
  !>             rocblas_fill_upper:  C_i is an upper triangular matrix
  !>             rocblas_fill_lower:  C_i is a  lower triangular matrix
  !> 
  !>     @param[in]
  !>     transA  [rocblas_operation]
  !>             rocblas_operation_conjugate_transpose: op(A) = A^H
  !>             rocblas_operation_none:                op(A) = A
  !> 
  !>     @param[in]
  !>     n       [rocblas_int]
  !>             n specifies the number of rows and columns of C_i. n >= 0.
  !> 
  !>     @param[in]
  !>     k       [rocblas_int]
  !>             k specifies the number of columns of op(A). k >= 0.
  !> 
  !>     @param[in]
  !>     alpha
  !>             alpha specifies the scalar alpha. When alpha is
  !>             zero then A is not referenced and A need not be set before
  !>             entry.
  !> 
  !>     @param[in]
  !>     A       Device pointer to the first matrix A_1 on the GPU of dimension (lda, k)
  !>             when transA is rocblas_operation_none, otherwise of dimension (lda, n)
  !> 
  !>     @param[in]
  !>     lda     [rocblas_int]
  !>             lda specifies the first dimension of A_i.
  !>             if transA = rocblas_operation_none,  lda >= max( 1, n ),
  !>             otherwise lda >= max( 1, k ).
  !> 
  !>     @param[in]
  !>     stride_A  [rocblas_stride]
  !>               stride from the start of one matrix (A_i) and the next one (A_i+1)
  !> 
  !>     @param[in]
  !>     beta
  !>             beta specifies the scalar beta. When beta is
  !>             zero then C need not be set before entry.
  !> 
  !>     @param[in]
  !>     C       Device pointer to the first matrix C_1 on the GPU.
  !>             The imaginary component of the diagonal elements are not used but are set to zero unless quick return.
  !> 
  !>     @param[in]
  !>     ldc    [rocblas_int]
  !>            ldc specifies the first dimension of C. ldc >= max( 1, n ).
  !> 
  !>     @param[inout]
  !>     stride_C  [rocblas_stride]
  !>               stride from the start of one matrix (C_i) and the next one (C_i+1)
  !> 
  !>     @param[in]
  !>     batch_count [rocblas_int]
  !>                 number of instances in the batch.
  !> 
  !>     
  interface rocblas_zherk_strided_batched
    function rocblas_zherk_strided_batched_orig(handle,uplo,transA,n,k,alpha,A,lda,stride_A,beta,C,ldc,stride_C,batch_count) bind(c, name="rocblas_zherk_strided_batched")
      use iso_c_binding
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocblas_zherk_strided_batched_orig
      type(c_ptr),value :: handle
      integer(kind(rocblas_fill_upper)),value :: uplo
      integer(kind(rocblas_operation_none)),value :: transA
      integer(c_int),value :: n
      integer(c_int),value :: k
      real(c_double) :: alpha
      type(c_ptr),value :: A
      integer(c_int),value :: lda
      integer(c_int64_t),value :: stride_A
      real(c_double) :: beta
      type(c_ptr),value :: C
      integer(c_int),value :: ldc
      integer(c_int64_t),value :: stride_C
      integer(c_int),value :: batch_count
    end function

#ifdef USE_FPOINTER_INTERFACES
    module procedure rocblas_zherk_strided_batched_full_rank,rocblas_zherk_strided_batched_rank_0,rocblas_zherk_strided_batched_rank_1
#endif

  end interface
  
  interface rocblas_cher2k
    function rocblas_cher2k_orig(handle,uplo,trans,n,k,alpha,A,lda,B,ldb,beta,C,ldc) bind(c, name="rocblas_cher2k")
      use iso_c_binding
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocblas_cher2k_orig
      type(c_ptr),value :: handle
      integer(kind(rocblas_fill_upper)),value :: uplo
      integer(kind(rocblas_operation_none)),value :: trans
      integer(c_int),value :: n
      integer(c_int),value :: k
      complex(c_float_complex) :: alpha
      type(c_ptr),value :: A
      integer(c_int),value :: lda
      type(c_ptr),value :: B
      integer(c_int),value :: ldb
      real(c_float) :: beta
      type(c_ptr),value :: C
      integer(c_int),value :: ldc
    end function

#ifdef USE_FPOINTER_INTERFACES
    module procedure rocblas_cher2k_full_rank,rocblas_cher2k_rank_0,rocblas_cher2k_rank_1
#endif

  end interface
  !> ! \brief BLAS Level 3 API
  !> 
  !>     \details
  !> 
  !>     her2k performs one of the matrix-matrix operations for a Hermitian rank-2k update
  !> 
  !>     C := alphaop( A )op( B )^H + conj(alpha)op( B )op( A )^H + betaC
  !> 
  !>     where  alpha and beta are scalars, op(A) and op(B) are n by k matrices, and
  !>     C is a n x n Hermitian matrix stored as either upper or lower.
  !> 
  !>         op( A ) = A, op( B ) = B, and A and B are n by k if trans == rocblas_operation_none
  !>         op( A ) = A^H, op( B ) = B^H,  and A and B are k by n if trans == rocblas_operation_conjugate_transpose
  !> 
  !>     @param[in]
  !>     handle    [rocblas_handle]
  !>               handle to the rocblas library context queue.
  !> 
  !>     @param[in]
  !>     uplo    [rocblas_fill]
  !>             rocblas_fill_upper:  C is an upper triangular matrix
  !>             rocblas_fill_lower:  C is a  lower triangular matrix
  !> 
  !>     @param[in]
  !>     trans  [rocblas_operation]
  !>             rocblas_operation_conjugate_transpose:  op( A ) = A^H, op( B ) = B^H
  !>             rocblas_operation_none:                 op( A ) = A, op( B ) = B
  !> 
  !>     @param[in]
  !>     n       [rocblas_int]
  !>             n specifies the number of rows and columns of C. n >= 0.
  !> 
  !>     @param[in]
  !>     k       [rocblas_int]
  !>             k specifies the number of columns of op(A). k >= 0.
  !> 
  !>     @param[in]
  !>     alpha
  !>             alpha specifies the scalar alpha. When alpha is
  !>             zero then A is not referenced and A need not be set before
  !>             entry.
  !> 
  !>     @param[in]
  !>     A       pointer storing matrix A on the GPU.
  !>             Martrix dimension is ( lda, k ) when if trans = rocblas_operation_none, otherwise (lda, n)
  !>             only the upperlower triangular part is accessed.
  !> 
  !>     @param[in]
  !>     lda     [rocblas_int]
  !>             lda specifies the first dimension of A.
  !>             if trans = rocblas_operation_none,  lda >= max( 1, n ),
  !>             otherwise lda >= max( 1, k ).
  !>     @param[in]
  !>     B       pointer storing matrix B on the GPU.
  !>             Martrix dimension is ( ldb, k ) when if trans = rocblas_operation_none, otherwise (ldb, n)
  !>             only the upperlower triangular part is accessed.
  !> 
  !>     @param[in]
  !>     ldb     [rocblas_int]
  !>             ldb specifies the first dimension of B.
  !>             if trans = rocblas_operation_none,  ldb >= max( 1, n ),
  !>             otherwise ldb >= max( 1, k ).
  !>     @param[in]
  !>     beta
  !>             beta specifies the scalar beta. When beta is
  !>             zero then C need not be set before entry.
  !> 
  !>     @param[in]
  !>     C       pointer storing matrix C on the GPU.
  !>             The imaginary component of the diagonal elements are not used but are set to zero unless quick return.
  !> 
  !>     @param[in]
  !>     ldc    [rocblas_int]
  !>            ldc specifies the first dimension of C. ldc >= max( 1, n ).
  !> 
  !>     
  interface rocblas_zher2k
    function rocblas_zher2k_orig(handle,uplo,trans,n,k,alpha,A,lda,B,ldb,beta,C,ldc) bind(c, name="rocblas_zher2k")
      use iso_c_binding
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocblas_zher2k_orig
      type(c_ptr),value :: handle
      integer(kind(rocblas_fill_upper)),value :: uplo
      integer(kind(rocblas_operation_none)),value :: trans
      integer(c_int),value :: n
      integer(c_int),value :: k
      complex(c_double_complex) :: alpha
      type(c_ptr),value :: A
      integer(c_int),value :: lda
      type(c_ptr),value :: B
      integer(c_int),value :: ldb
      real(c_double) :: beta
      type(c_ptr),value :: C
      integer(c_int),value :: ldc
    end function

#ifdef USE_FPOINTER_INTERFACES
    module procedure rocblas_zher2k_full_rank,rocblas_zher2k_rank_0,rocblas_zher2k_rank_1
#endif

  end interface
  
  interface rocblas_cher2k_batched
    function rocblas_cher2k_batched_orig(handle,uplo,trans,n,k,alpha,A,lda,B,ldb,beta,C,ldc,batch_count) bind(c, name="rocblas_cher2k_batched")
      use iso_c_binding
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocblas_cher2k_batched_orig
      type(c_ptr),value :: handle
      integer(kind(rocblas_fill_upper)),value :: uplo
      integer(kind(rocblas_operation_none)),value :: trans
      integer(c_int),value :: n
      integer(c_int),value :: k
      complex(c_float_complex) :: alpha
      type(c_ptr) :: A
      integer(c_int),value :: lda
      type(c_ptr) :: B
      integer(c_int),value :: ldb
      real(c_float) :: beta
      type(c_ptr) :: C
      integer(c_int),value :: ldc
      integer(c_int),value :: batch_count
    end function

#ifdef USE_FPOINTER_INTERFACES
    module procedure rocblas_cher2k_batched_full_rank,rocblas_cher2k_batched_rank_0,rocblas_cher2k_batched_rank_1
#endif

  end interface
  !> ! \brief BLAS Level 3 API
  !> 
  !>     \details
  !> 
  !>     her2k_batched performs a batch of the matrix-matrix operations for a Hermitian rank-2k update
  !> 
  !>     C_i := alphaop( A_i )op( B_i )^H + conj(alpha)op( B_i )op( A_i )^H + betaC_i
  !> 
  !>     where  alpha and beta are scalars, op(A_i) and op(B_i) are n by k matrices, and
  !>     C_i is a n x n Hermitian matrix stored as either upper or lower.
  !> 
  !>         op( A_i ) = A_i, op( B_i ) = B_i, and A_i and B_i are n by k if trans == rocblas_operation_none
  !>         op( A_i ) = A_i^H, op( B_i ) = B_i^H,  and A_i and B_i are k by n if trans == rocblas_operation_conjugate_transpose
  !> 
  !>     @param[in]
  !>     handle    [rocblas_handle]
  !>               handle to the rocblas library context queue.
  !> 
  !>     @param[in]
  !>     uplo    [rocblas_fill]
  !>             rocblas_fill_upper:  C_i is an upper triangular matrix
  !>             rocblas_fill_lower:  C_i is a  lower triangular matrix
  !> 
  !>     @param[in]
  !>     trans  [rocblas_operation]
  !>             rocblas_operation_conjugate_transpose: op(A) = A^H
  !>             rocblas_operation_none:                op(A) = A
  !> 
  !>     @param[in]
  !>     n       [rocblas_int]
  !>             n specifies the number of rows and columns of C_i. n >= 0.
  !> 
  !>     @param[in]
  !>     k       [rocblas_int]
  !>             k specifies the number of columns of op(A). k >= 0.
  !> 
  !>     @param[in]
  !>     alpha
  !>             alpha specifies the scalar alpha. When alpha is
  !>             zero then A is not referenced and A need not be set before
  !>             entry.
  !> 
  !>     @param[in]
  !>     A       device array of device pointers storing each matrix_i A of dimension (lda, k)
  !>             when trans is rocblas_operation_none, otherwise of dimension (lda, n)
  !> 
  !>     @param[in]
  !>     lda     [rocblas_int]
  !>             lda specifies the first dimension of A_i.
  !>             if trans = rocblas_operation_none,  lda >= max( 1, n ),
  !>             otherwise lda >= max( 1, k ).
  !>     @param[in]
  !>     B       device array of device pointers storing each matrix_i B of dimension (ldb, k)
  !>             when trans is rocblas_operation_none, otherwise of dimension (ldb, n)
  !> 
  !>     @param[in]
  !>     ldb     [rocblas_int]
  !>             ldb specifies the first dimension of B_i.
  !>             if trans = rocblas_operation_none,  ldb >= max( 1, n ),
  !>             otherwise ldb >= max( 1, k ).
  !>     @param[in]
  !>     beta
  !>             beta specifies the scalar beta. When beta is
  !>             zero then C need not be set before entry.
  !> 
  !>     @param[in]
  !>     C       device array of device pointers storing each matrix C_i on the GPU.
  !>             The imaginary component of the diagonal elements are not used but are set to zero unless quick return.
  !> 
  !>     @param[in]
  !>     ldc    [rocblas_int]
  !>            ldc specifies the first dimension of C. ldc >= max( 1, n ).
  !>     @param[in]
  !>     batch_count [rocblas_int]
  !>                 number of instances in the batch.
  !> 
  !>     
  interface rocblas_zher2k_batched
    function rocblas_zher2k_batched_orig(handle,uplo,trans,n,k,alpha,A,lda,B,ldb,beta,C,ldc,batch_count) bind(c, name="rocblas_zher2k_batched")
      use iso_c_binding
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocblas_zher2k_batched_orig
      type(c_ptr),value :: handle
      integer(kind(rocblas_fill_upper)),value :: uplo
      integer(kind(rocblas_operation_none)),value :: trans
      integer(c_int),value :: n
      integer(c_int),value :: k
      complex(c_double_complex) :: alpha
      type(c_ptr) :: A
      integer(c_int),value :: lda
      type(c_ptr) :: B
      integer(c_int),value :: ldb
      real(c_double) :: beta
      type(c_ptr) :: C
      integer(c_int),value :: ldc
      integer(c_int),value :: batch_count
    end function

#ifdef USE_FPOINTER_INTERFACES
    module procedure rocblas_zher2k_batched_full_rank,rocblas_zher2k_batched_rank_0,rocblas_zher2k_batched_rank_1
#endif

  end interface
  
  interface rocblas_cher2k_strided_batched
    function rocblas_cher2k_strided_batched_orig(handle,uplo,trans,n,k,alpha,A,lda,stride_A,B,ldb,stride_B,beta,C,ldc,stride_C,batch_count) bind(c, name="rocblas_cher2k_strided_batched")
      use iso_c_binding
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocblas_cher2k_strided_batched_orig
      type(c_ptr),value :: handle
      integer(kind(rocblas_fill_upper)),value :: uplo
      integer(kind(rocblas_operation_none)),value :: trans
      integer(c_int),value :: n
      integer(c_int),value :: k
      complex(c_float_complex) :: alpha
      type(c_ptr),value :: A
      integer(c_int),value :: lda
      integer(c_int64_t),value :: stride_A
      type(c_ptr),value :: B
      integer(c_int),value :: ldb
      integer(c_int64_t),value :: stride_B
      real(c_float) :: beta
      type(c_ptr),value :: C
      integer(c_int),value :: ldc
      integer(c_int64_t),value :: stride_C
      integer(c_int),value :: batch_count
    end function

#ifdef USE_FPOINTER_INTERFACES
    module procedure rocblas_cher2k_strided_batched_full_rank,rocblas_cher2k_strided_batched_rank_0,rocblas_cher2k_strided_batched_rank_1
#endif

  end interface
  !> ! \brief BLAS Level 3 API
  !> 
  !>     \details
  !> 
  !>     her2k_strided_batched performs a batch of the matrix-matrix operations for a Hermitian rank-2k update
  !> 
  !>     C_i := alphaop( A_i )op( B_i )^H + conj(alpha)op( B_i )op( A_i )^H + betaC_i
  !> 
  !>     where  alpha and beta are scalars, op(A_i) and op(B_i) are n by k matrices, and
  !>     C_i is a n x n Hermitian matrix stored as either upper or lower.
  !> 
  !>         op( A_i ) = A_i, op( B_i ) = B_i, and A_i and B_i are n by k if trans == rocblas_operation_none
  !>         op( A_i ) = A_i^H, op( B_i ) = B_i^H,  and A_i and B_i are k by n if trans == rocblas_operation_conjugate_transpose
  !> 
  !>     @param[in]
  !>     handle    [rocblas_handle]
  !>               handle to the rocblas library context queue.
  !> 
  !>     @param[in]
  !>     uplo    [rocblas_fill]
  !>             rocblas_fill_upper:  C_i is an upper triangular matrix
  !>             rocblas_fill_lower:  C_i is a  lower triangular matrix
  !> 
  !>     @param[in]
  !>     trans  [rocblas_operation]
  !>             rocblas_operation_conjugate_transpose: op( A_i ) = A_i^H, op( B_i ) = B_i^H
  !>             rocblas_operation_none:                op( A_i ) = A_i, op( B_i ) = B_i
  !> 
  !>     @param[in]
  !>     n       [rocblas_int]
  !>             n specifies the number of rows and columns of C_i. n >= 0.
  !> 
  !>     @param[in]
  !>     k       [rocblas_int]
  !>             k specifies the number of columns of op(A). k >= 0.
  !> 
  !>     @param[in]
  !>     alpha
  !>             alpha specifies the scalar alpha. When alpha is
  !>             zero then A is not referenced and A need not be set before
  !>             entry.
  !> 
  !>     @param[in]
  !>     A       Device pointer to the first matrix A_1 on the GPU of dimension (lda, k)
  !>             when trans is rocblas_operation_none, otherwise of dimension (lda, n)
  !> 
  !>     @param[in]
  !>     lda     [rocblas_int]
  !>             lda specifies the first dimension of A_i.
  !>             if trans = rocblas_operation_none,  lda >= max( 1, n ),
  !>             otherwise lda >= max( 1, k ).
  !> 
  !>     @param[in]
  !>     stride_A  [rocblas_stride]
  !>               stride from the start of one matrix (A_i) and the next one (A_i+1)
  !> 
  !>     @param[in]
  !>     B       Device pointer to the first matrix B_1 on the GPU of dimension (ldb, k)
  !>             when trans is rocblas_operation_none, otherwise of dimension (ldb, n)
  !> 
  !>     @param[in]
  !>     ldb     [rocblas_int]
  !>             ldb specifies the first dimension of B_i.
  !>             if trans = rocblas_operation_none,  ldb >= max( 1, n ),
  !>             otherwise ldb >= max( 1, k ).
  !> 
  !>     @param[in]
  !>     stride_B  [rocblas_stride]
  !>               stride from the start of one matrix (B_i) and the next one (B_i+1)
  !> 
  !>     @param[in]
  !>     beta
  !>             beta specifies the scalar beta. When beta is
  !>             zero then C need not be set before entry.
  !> 
  !>     @param[in]
  !>     C       Device pointer to the first matrix C_1 on the GPU.
  !>             The imaginary component of the diagonal elements are not used but are set to zero unless quick return.
  !> 
  !>     @param[in]
  !>     ldc    [rocblas_int]
  !>            ldc specifies the first dimension of C. ldc >= max( 1, n ).
  !> 
  !>     @param[inout]
  !>     stride_C  [rocblas_stride]
  !>               stride from the start of one matrix (C_i) and the next one (C_i+1)
  !> 
  !>     @param[in]
  !>     batch_count [rocblas_int]
  !>                 number of instances in the batch.
  !> 
  !>     
  interface rocblas_zher2k_strided_batched
    function rocblas_zher2k_strided_batched_orig(handle,uplo,trans,n,k,alpha,A,lda,stride_A,B,ldb,stride_B,beta,C,ldc,stride_C,batch_count) bind(c, name="rocblas_zher2k_strided_batched")
      use iso_c_binding
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocblas_zher2k_strided_batched_orig
      type(c_ptr),value :: handle
      integer(kind(rocblas_fill_upper)),value :: uplo
      integer(kind(rocblas_operation_none)),value :: trans
      integer(c_int),value :: n
      integer(c_int),value :: k
      complex(c_double_complex) :: alpha
      type(c_ptr),value :: A
      integer(c_int),value :: lda
      integer(c_int64_t),value :: stride_A
      type(c_ptr),value :: B
      integer(c_int),value :: ldb
      integer(c_int64_t),value :: stride_B
      real(c_double) :: beta
      type(c_ptr),value :: C
      integer(c_int),value :: ldc
      integer(c_int64_t),value :: stride_C
      integer(c_int),value :: batch_count
    end function

#ifdef USE_FPOINTER_INTERFACES
    module procedure rocblas_zher2k_strided_batched_full_rank,rocblas_zher2k_strided_batched_rank_0,rocblas_zher2k_strided_batched_rank_1
#endif

  end interface
  
  interface rocblas_cherkx
    function rocblas_cherkx_orig(handle,uplo,trans,n,k,alpha,A,lda,B,ldb,beta,C,ldc) bind(c, name="rocblas_cherkx")
      use iso_c_binding
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocblas_cherkx_orig
      type(c_ptr),value :: handle
      integer(kind(rocblas_fill_upper)),value :: uplo
      integer(kind(rocblas_operation_none)),value :: trans
      integer(c_int),value :: n
      integer(c_int),value :: k
      complex(c_float_complex) :: alpha
      type(c_ptr),value :: A
      integer(c_int),value :: lda
      type(c_ptr),value :: B
      integer(c_int),value :: ldb
      real(c_float) :: beta
      type(c_ptr),value :: C
      integer(c_int),value :: ldc
    end function

#ifdef USE_FPOINTER_INTERFACES
    module procedure rocblas_cherkx_full_rank,rocblas_cherkx_rank_0,rocblas_cherkx_rank_1
#endif

  end interface
  !> ! \brief BLAS Level 3 API
  !> 
  !>     \details
  !> 
  !>     herkx performs one of the matrix-matrix operations for a Hermitian rank-k update
  !> 
  !>     C := alphaop( A )op( B )^H + betaC
  !> 
  !>     where  alpha and beta are scalars, op(A) and op(B) are n by k matrices, and
  !>     C is a n x n Hermitian matrix stored as either upper or lower.
  !>     This routine should only be used when the caller can guarantee that the result of op( A )op( B )^T will be Hermitian.
  !> 
  !> 
  !>         op( A ) = A, op( B ) = B, and A and B are n by k if trans == rocblas_operation_none
  !>         op( A ) = A^H, op( B ) = B^H,  and A and B are k by n if trans == rocblas_operation_conjugate_transpose
  !> 
  !>     @param[in]
  !>     handle    [rocblas_handle]
  !>               handle to the rocblas library context queue.
  !> 
  !>     @param[in]
  !>     uplo    [rocblas_fill]
  !>             rocblas_fill_upper:  C is an upper triangular matrix
  !>             rocblas_fill_lower:  C is a  lower triangular matrix
  !> 
  !>     @param[in]
  !>     trans  [rocblas_operation]
  !>             rocblas_operation_conjugate_transpose:  op( A ) = A^H, op( B ) = B^H
  !>             rocblas_operation_none:                 op( A ) = A, op( B ) = B
  !> 
  !>     @param[in]
  !>     n       [rocblas_int]
  !>             n specifies the number of rows and columns of C. n >= 0.
  !> 
  !>     @param[in]
  !>     k       [rocblas_int]
  !>             k specifies the number of columns of op(A). k >= 0.
  !> 
  !>     @param[in]
  !>     alpha
  !>             alpha specifies the scalar alpha. When alpha is
  !>             zero then A is not referenced and A need not be set before
  !>             entry.
  !> 
  !>     @param[in]
  !>     A       pointer storing matrix A on the GPU.
  !>             Martrix dimension is ( lda, k ) when if trans = rocblas_operation_none, otherwise (lda, n)
  !>             only the upperlower triangular part is accessed.
  !> 
  !>     @param[in]
  !>     lda     [rocblas_int]
  !>             lda specifies the first dimension of A.
  !>             if trans = rocblas_operation_none,  lda >= max( 1, n ),
  !>             otherwise lda >= max( 1, k ).
  !>     @param[in]
  !>     B       pointer storing matrix B on the GPU.
  !>             Martrix dimension is ( ldb, k ) when if trans = rocblas_operation_none, otherwise (ldb, n)
  !>             only the upperlower triangular part is accessed.
  !> 
  !>     @param[in]
  !>     ldb     [rocblas_int]
  !>             ldb specifies the first dimension of B.
  !>             if trans = rocblas_operation_none,  ldb >= max( 1, n ),
  !>             otherwise ldb >= max( 1, k ).
  !>     @param[in]
  !>     beta
  !>             beta specifies the scalar beta. When beta is
  !>             zero then C need not be set before entry.
  !> 
  !>     @param[in]
  !>     C       pointer storing matrix C on the GPU.
  !>             The imaginary component of the diagonal elements are not used but are set to zero unless quick return.
  !> 
  !>     @param[in]
  !>     ldc    [rocblas_int]
  !>            ldc specifies the first dimension of C. ldc >= max( 1, n ).
  !> 
  !>     
  interface rocblas_zherkx
    function rocblas_zherkx_orig(handle,uplo,trans,n,k,alpha,A,lda,B,ldb,beta,C,ldc) bind(c, name="rocblas_zherkx")
      use iso_c_binding
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocblas_zherkx_orig
      type(c_ptr),value :: handle
      integer(kind(rocblas_fill_upper)),value :: uplo
      integer(kind(rocblas_operation_none)),value :: trans
      integer(c_int),value :: n
      integer(c_int),value :: k
      complex(c_double_complex) :: alpha
      type(c_ptr),value :: A
      integer(c_int),value :: lda
      type(c_ptr),value :: B
      integer(c_int),value :: ldb
      real(c_double) :: beta
      type(c_ptr),value :: C
      integer(c_int),value :: ldc
    end function

#ifdef USE_FPOINTER_INTERFACES
    module procedure rocblas_zherkx_full_rank,rocblas_zherkx_rank_0,rocblas_zherkx_rank_1
#endif

  end interface
  
  interface rocblas_cherkx_batched
    function rocblas_cherkx_batched_orig(handle,uplo,trans,n,k,alpha,A,lda,B,ldb,beta,C,ldc,batch_count) bind(c, name="rocblas_cherkx_batched")
      use iso_c_binding
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocblas_cherkx_batched_orig
      type(c_ptr),value :: handle
      integer(kind(rocblas_fill_upper)),value :: uplo
      integer(kind(rocblas_operation_none)),value :: trans
      integer(c_int),value :: n
      integer(c_int),value :: k
      complex(c_float_complex) :: alpha
      type(c_ptr) :: A
      integer(c_int),value :: lda
      type(c_ptr) :: B
      integer(c_int),value :: ldb
      real(c_float) :: beta
      type(c_ptr) :: C
      integer(c_int),value :: ldc
      integer(c_int),value :: batch_count
    end function

#ifdef USE_FPOINTER_INTERFACES
    module procedure rocblas_cherkx_batched_full_rank,rocblas_cherkx_batched_rank_0,rocblas_cherkx_batched_rank_1
#endif

  end interface
  !> ! \brief BLAS Level 3 API
  !> 
  !>     \details
  !> 
  !>     herkx_batched performs a batch of the matrix-matrix operations for a Hermitian rank-k update
  !> 
  !>     C_i := alphaop( A_i )op( B_i )^H + betaC_i
  !> 
  !>     where  alpha and beta are scalars, op(A_i) and op(B_i) are n by k matrices, and
  !>     C_i is a n x n Hermitian matrix stored as either upper or lower.
  !>     This routine should only be used when the caller can guarantee that the result of op( A )op( B )^T will be Hermitian.
  !> 
  !>         op( A_i ) = A_i, op( B_i ) = B_i, and A_i and B_i are n by k if trans == rocblas_operation_none
  !>         op( A_i ) = A_i^H, op( B_i ) = B_i^H,  and A_i and B_i are k by n if trans == rocblas_operation_conjugate_transpose
  !> 
  !>     @param[in]
  !>     handle    [rocblas_handle]
  !>               handle to the rocblas library context queue.
  !> 
  !>     @param[in]
  !>     uplo    [rocblas_fill]
  !>             rocblas_fill_upper:  C_i is an upper triangular matrix
  !>             rocblas_fill_lower:  C_i is a  lower triangular matrix
  !> 
  !>     @param[in]
  !>     trans  [rocblas_operation]
  !>             rocblas_operation_conjugate_transpose: op(A) = A^H
  !>             rocblas_operation_none:                op(A) = A
  !> 
  !>     @param[in]
  !>     n       [rocblas_int]
  !>             n specifies the number of rows and columns of C_i. n >= 0.
  !> 
  !>     @param[in]
  !>     k       [rocblas_int]
  !>             k specifies the number of columns of op(A). k >= 0.
  !> 
  !>     @param[in]
  !>     alpha
  !>             alpha specifies the scalar alpha. When alpha is
  !>             zero then A is not referenced and A need not be set before
  !>             entry.
  !> 
  !>     @param[in]
  !>     A       device array of device pointers storing each matrix_i A of dimension (lda, k)
  !>             when trans is rocblas_operation_none, otherwise of dimension (lda, n)
  !> 
  !>     @param[in]
  !>     lda     [rocblas_int]
  !>             lda specifies the first dimension of A_i.
  !>             if trans = rocblas_operation_none,  lda >= max( 1, n ),
  !>             otherwise lda >= max( 1, k ).
  !> 
  !>     @param[in]
  !>     B       device array of device pointers storing each matrix_i B of dimension (ldb, k)
  !>             when trans is rocblas_operation_none, otherwise of dimension (ldb, n)
  !> 
  !>     @param[in]
  !>     ldb     [rocblas_int]
  !>             ldb specifies the first dimension of B_i.
  !>             if trans = rocblas_operation_none,  ldb >= max( 1, n ),
  !>             otherwise ldb >= max( 1, k ).
  !> 
  !>     @param[in]
  !>     beta
  !>             beta specifies the scalar beta. When beta is
  !>             zero then C need not be set before entry.
  !> 
  !>     @param[in]
  !>     C       device array of device pointers storing each matrix C_i on the GPU.
  !>             The imaginary component of the diagonal elements are not used but are set to zero unless quick return.
  !> 
  !>     @param[in]
  !>     ldc    [rocblas_int]
  !>            ldc specifies the first dimension of C. ldc >= max( 1, n ).
  !> 
  !>     @param[in]
  !>     batch_count [rocblas_int]
  !>                 number of instances in the batch.
  !> 
  !>     
  interface rocblas_zherkx_batched
    function rocblas_zherkx_batched_orig(handle,uplo,trans,n,k,alpha,A,lda,B,ldb,beta,C,ldc,batch_count) bind(c, name="rocblas_zherkx_batched")
      use iso_c_binding
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocblas_zherkx_batched_orig
      type(c_ptr),value :: handle
      integer(kind(rocblas_fill_upper)),value :: uplo
      integer(kind(rocblas_operation_none)),value :: trans
      integer(c_int),value :: n
      integer(c_int),value :: k
      complex(c_double_complex) :: alpha
      type(c_ptr) :: A
      integer(c_int),value :: lda
      type(c_ptr) :: B
      integer(c_int),value :: ldb
      real(c_double) :: beta
      type(c_ptr) :: C
      integer(c_int),value :: ldc
      integer(c_int),value :: batch_count
    end function

#ifdef USE_FPOINTER_INTERFACES
    module procedure rocblas_zherkx_batched_full_rank,rocblas_zherkx_batched_rank_0,rocblas_zherkx_batched_rank_1
#endif

  end interface
  
  interface rocblas_cherkx_strided_batched
    function rocblas_cherkx_strided_batched_orig(handle,uplo,trans,n,k,alpha,A,lda,stride_A,B,ldb,stride_B,beta,C,ldc,stride_C,batch_count) bind(c, name="rocblas_cherkx_strided_batched")
      use iso_c_binding
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocblas_cherkx_strided_batched_orig
      type(c_ptr),value :: handle
      integer(kind(rocblas_fill_upper)),value :: uplo
      integer(kind(rocblas_operation_none)),value :: trans
      integer(c_int),value :: n
      integer(c_int),value :: k
      complex(c_float_complex) :: alpha
      type(c_ptr),value :: A
      integer(c_int),value :: lda
      integer(c_int64_t),value :: stride_A
      type(c_ptr),value :: B
      integer(c_int),value :: ldb
      integer(c_int64_t),value :: stride_B
      real(c_float) :: beta
      type(c_ptr),value :: C
      integer(c_int),value :: ldc
      integer(c_int64_t),value :: stride_C
      integer(c_int),value :: batch_count
    end function

#ifdef USE_FPOINTER_INTERFACES
    module procedure rocblas_cherkx_strided_batched_full_rank,rocblas_cherkx_strided_batched_rank_0,rocblas_cherkx_strided_batched_rank_1
#endif

  end interface
  !> ! \brief BLAS Level 3 API
  !> 
  !>     \details
  !> 
  !>     herkx_strided_batched performs a batch of the matrix-matrix operations for a Hermitian rank-k update
  !> 
  !>     C_i := alphaop( A_i )op( B_i )^H + betaC_i
  !> 
  !>     where  alpha and beta are scalars, op(A_i) and op(B_i) are n by k matrices, and
  !>     C_i is a n x n Hermitian matrix stored as either upper or lower.
  !>     This routine should only be used when the caller can guarantee that the result of op( A )op( B )^T will be Hermitian.
  !> 
  !>         op( A_i ) = A_i, op( B_i ) = B_i, and A_i and B_i are n by k if trans == rocblas_operation_none
  !>         op( A_i ) = A_i^H, op( B_i ) = B_i^H,  and A_i and B_i are k by n if trans == rocblas_operation_conjugate_transpose
  !> 
  !>     @param[in]
  !>     handle    [rocblas_handle]
  !>               handle to the rocblas library context queue.
  !> 
  !>     @param[in]
  !>     uplo    [rocblas_fill]
  !>             rocblas_fill_upper:  C_i is an upper triangular matrix
  !>             rocblas_fill_lower:  C_i is a  lower triangular matrix
  !> 
  !>     @param[in]
  !>     trans  [rocblas_operation]
  !>             rocblas_operation_conjugate_transpose: op( A_i ) = A_i^H, op( B_i ) = B_i^H
  !>             rocblas_operation_none:                op( A_i ) = A_i, op( B_i ) = B_i
  !> 
  !>     @param[in]
  !>     n       [rocblas_int]
  !>             n specifies the number of rows and columns of C_i. n >= 0.
  !> 
  !>     @param[in]
  !>     k       [rocblas_int]
  !>             k specifies the number of columns of op(A). k >= 0.
  !> 
  !>     @param[in]
  !>     alpha
  !>             alpha specifies the scalar alpha. When alpha is
  !>             zero then A is not referenced and A need not be set before
  !>             entry.
  !> 
  !>     @param[in]
  !>     A       Device pointer to the first matrix A_1 on the GPU of dimension (lda, k)
  !>             when trans is rocblas_operation_none, otherwise of dimension (lda, n)
  !> 
  !>     @param[in]
  !>     lda     [rocblas_int]
  !>             lda specifies the first dimension of A_i.
  !>             if trans = rocblas_operation_none,  lda >= max( 1, n ),
  !>             otherwise lda >= max( 1, k ).
  !> 
  !>     @param[in]
  !>     stride_A  [rocblas_stride]
  !>               stride from the start of one matrix (A_i) and the next one (A_i+1)
  !> 
  !>     @param[in]
  !>     B       Device pointer to the first matrix B_1 on the GPU of dimension (ldb, k)
  !>             when trans is rocblas_operation_none, otherwise of dimension (ldb, n)
  !> 
  !>     @param[in]
  !>     ldb     [rocblas_int]
  !>             ldb specifies the first dimension of B_i.
  !>             if trans = rocblas_operation_none,  ldb >= max( 1, n ),
  !>             otherwise ldb >= max( 1, k ).
  !> 
  !>     @param[in]
  !>     stride_B  [rocblas_stride]
  !>               stride from the start of one matrix (B_i) and the next one (B_i+1)
  !> 
  !>     @param[in]
  !>     beta
  !>             beta specifies the scalar beta. When beta is
  !>             zero then C need not be set before entry.
  !> 
  !>     @param[in]
  !>     C       Device pointer to the first matrix C_1 on the GPU.
  !>             The imaginary component of the diagonal elements are not used but are set to zero unless quick return.
  !> 
  !>     @param[in]
  !>     ldc    [rocblas_int]
  !>            ldc specifies the first dimension of C. ldc >= max( 1, n ).
  !> 
  !>     @param[inout]
  !>     stride_C  [rocblas_stride]
  !>               stride from the start of one matrix (C_i) and the next one (C_i+1)
  !> 
  !>     @param[in]
  !>     batch_count [rocblas_int]
  !>                 number of instances in the batch.
  !> 
  !>     
  interface rocblas_zherkx_strided_batched
    function rocblas_zherkx_strided_batched_orig(handle,uplo,trans,n,k,alpha,A,lda,stride_A,B,ldb,stride_B,beta,C,ldc,stride_C,batch_count) bind(c, name="rocblas_zherkx_strided_batched")
      use iso_c_binding
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocblas_zherkx_strided_batched_orig
      type(c_ptr),value :: handle
      integer(kind(rocblas_fill_upper)),value :: uplo
      integer(kind(rocblas_operation_none)),value :: trans
      integer(c_int),value :: n
      integer(c_int),value :: k
      complex(c_double_complex) :: alpha
      type(c_ptr),value :: A
      integer(c_int),value :: lda
      integer(c_int64_t),value :: stride_A
      type(c_ptr),value :: B
      integer(c_int),value :: ldb
      integer(c_int64_t),value :: stride_B
      real(c_double) :: beta
      type(c_ptr),value :: C
      integer(c_int),value :: ldc
      integer(c_int64_t),value :: stride_C
      integer(c_int),value :: batch_count
    end function

#ifdef USE_FPOINTER_INTERFACES
    module procedure rocblas_zherkx_strided_batched_full_rank,rocblas_zherkx_strided_batched_rank_0,rocblas_zherkx_strided_batched_rank_1
#endif

  end interface
  
  interface rocblas_ssymm
    function rocblas_ssymm_orig(handle,side,uplo,m,n,alpha,A,lda,B,ldb,beta,C,ldc) bind(c, name="rocblas_ssymm")
      use iso_c_binding
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocblas_ssymm_orig
      type(c_ptr),value :: handle
      integer(kind(rocblas_side_left)),value :: side
      integer(kind(rocblas_fill_upper)),value :: uplo
      integer(c_int),value :: m
      integer(c_int),value :: n
      real(c_float) :: alpha
      type(c_ptr),value :: A
      integer(c_int),value :: lda
      type(c_ptr),value :: B
      integer(c_int),value :: ldb
      real(c_float) :: beta
      type(c_ptr),value :: C
      integer(c_int),value :: ldc
    end function

#ifdef USE_FPOINTER_INTERFACES
    module procedure rocblas_ssymm_full_rank,rocblas_ssymm_rank_0,rocblas_ssymm_rank_1
#endif

  end interface
  
  interface rocblas_dsymm
    function rocblas_dsymm_orig(handle,side,uplo,m,n,alpha,A,lda,B,ldb,beta,C,ldc) bind(c, name="rocblas_dsymm")
      use iso_c_binding
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocblas_dsymm_orig
      type(c_ptr),value :: handle
      integer(kind(rocblas_side_left)),value :: side
      integer(kind(rocblas_fill_upper)),value :: uplo
      integer(c_int),value :: m
      integer(c_int),value :: n
      real(c_double) :: alpha
      type(c_ptr),value :: A
      integer(c_int),value :: lda
      type(c_ptr),value :: B
      integer(c_int),value :: ldb
      real(c_double) :: beta
      type(c_ptr),value :: C
      integer(c_int),value :: ldc
    end function

#ifdef USE_FPOINTER_INTERFACES
    module procedure rocblas_dsymm_full_rank,rocblas_dsymm_rank_0,rocblas_dsymm_rank_1
#endif

  end interface
  
  interface rocblas_csymm
    function rocblas_csymm_orig(handle,side,uplo,m,n,alpha,A,lda,B,ldb,beta,C,ldc) bind(c, name="rocblas_csymm")
      use iso_c_binding
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocblas_csymm_orig
      type(c_ptr),value :: handle
      integer(kind(rocblas_side_left)),value :: side
      integer(kind(rocblas_fill_upper)),value :: uplo
      integer(c_int),value :: m
      integer(c_int),value :: n
      complex(c_float_complex) :: alpha
      type(c_ptr),value :: A
      integer(c_int),value :: lda
      type(c_ptr),value :: B
      integer(c_int),value :: ldb
      complex(c_float_complex) :: beta
      type(c_ptr),value :: C
      integer(c_int),value :: ldc
    end function

#ifdef USE_FPOINTER_INTERFACES
    module procedure rocblas_csymm_full_rank,rocblas_csymm_rank_0,rocblas_csymm_rank_1
#endif

  end interface
  !> ! \brief BLAS Level 3 API
  !> 
  !>     \details
  !> 
  !>     symm performs one of the matrix-matrix operations:
  !> 
  !>     C := alphaAB + betaC if side == rocblas_side_left,
  !>     C := alphaBA + betaC if side == rocblas_side_right,
  !> 
  !>     where alpha and beta are scalars, B and C are m by n matrices, and
  !>     A is a symmetric matrix stored as either upper or lower.
  !> 
  !>     @param[in]
  !>     handle    [rocblas_handle]
  !>               handle to the rocblas library context queue.
  !> 
  !>     @param[in]
  !>     side  [rocblas_side]
  !>             rocblas_side_left:      C := alphaAB + betaC
  !>             rocblas_side_right:     C := alphaBA + betaC
  !> 
  !>     @param[in]
  !>     uplo    [rocblas_fill]
  !>             rocblas_fill_upper:  A is an upper triangular matrix
  !>             rocblas_fill_lower:  A is a  lower triangular matrix
  !> 
  !>     @param[in]
  !>     m       [rocblas_int]
  !>             m specifies the number of rows of B and C. m >= 0.
  !> 
  !>     @param[in]
  !>     n       [rocblas_int]
  !>             n specifies the number of columns of B and C. n >= 0.
  !> 
  !>     @param[in]
  !>     alpha
  !>             alpha specifies the scalar alpha. When alpha is
  !>             zero then A and B are not referenced.
  !> 
  !>     @param[in]
  !>     A       pointer storing matrix A on the GPU.
  !>             A is m by m if side == rocblas_side_left
  !>             A is n by n if side == rocblas_side_right
  !>             only the upperlower triangular part is accessed.
  !> 
  !>     @param[in]
  !>     lda     [rocblas_int]
  !>             lda specifies the first dimension of A.
  !>             if side = rocblas_side_left,  lda >= max( 1, m ),
  !>             otherwise lda >= max( 1, n ).
  !> 
  !>     @param[in]
  !>     B       pointer storing matrix B on the GPU.
  !>             Matrix dimension is m by n
  !> 
  !>     @param[in]
  !>     ldb     [rocblas_int]
  !>             ldb specifies the first dimension of B. ldb >= max( 1, m )
  !> 
  !>     @param[in]
  !>     beta
  !>             beta specifies the scalar beta. When beta is
  !>             zero then C need not be set before entry.
  !> 
  !>     @param[in]
  !>     C       pointer storing matrix C on the GPU.
  !>             Matrix dimension is m by n
  !> 
  !>     @param[in]
  !>     ldc    [rocblas_int]
  !>            ldc specifies the first dimension of C. ldc >= max( 1, m )
  !> 
  !>     
  interface rocblas_zsymm
    function rocblas_zsymm_orig(handle,side,uplo,m,n,alpha,A,lda,B,ldb,beta,C,ldc) bind(c, name="rocblas_zsymm")
      use iso_c_binding
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocblas_zsymm_orig
      type(c_ptr),value :: handle
      integer(kind(rocblas_side_left)),value :: side
      integer(kind(rocblas_fill_upper)),value :: uplo
      integer(c_int),value :: m
      integer(c_int),value :: n
      complex(c_double_complex) :: alpha
      type(c_ptr),value :: A
      integer(c_int),value :: lda
      type(c_ptr),value :: B
      integer(c_int),value :: ldb
      complex(c_double_complex) :: beta
      type(c_ptr),value :: C
      integer(c_int),value :: ldc
    end function

#ifdef USE_FPOINTER_INTERFACES
    module procedure rocblas_zsymm_full_rank,rocblas_zsymm_rank_0,rocblas_zsymm_rank_1
#endif

  end interface
  
  interface rocblas_ssymm_batched
    function rocblas_ssymm_batched_orig(handle,side,uplo,m,n,alpha,A,lda,B,ldb,beta,C,ldc,batch_count) bind(c, name="rocblas_ssymm_batched")
      use iso_c_binding
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocblas_ssymm_batched_orig
      type(c_ptr),value :: handle
      integer(kind(rocblas_side_left)),value :: side
      integer(kind(rocblas_fill_upper)),value :: uplo
      integer(c_int),value :: m
      integer(c_int),value :: n
      real(c_float) :: alpha
      type(c_ptr) :: A
      integer(c_int),value :: lda
      type(c_ptr) :: B
      integer(c_int),value :: ldb
      real(c_float) :: beta
      type(c_ptr) :: C
      integer(c_int),value :: ldc
      integer(c_int),value :: batch_count
    end function

#ifdef USE_FPOINTER_INTERFACES
    module procedure rocblas_ssymm_batched_full_rank,rocblas_ssymm_batched_rank_0,rocblas_ssymm_batched_rank_1
#endif

  end interface
  
  interface rocblas_dsymm_batched
    function rocblas_dsymm_batched_orig(handle,side,uplo,m,n,alpha,A,lda,B,ldb,beta,C,ldc,batch_count) bind(c, name="rocblas_dsymm_batched")
      use iso_c_binding
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocblas_dsymm_batched_orig
      type(c_ptr),value :: handle
      integer(kind(rocblas_side_left)),value :: side
      integer(kind(rocblas_fill_upper)),value :: uplo
      integer(c_int),value :: m
      integer(c_int),value :: n
      real(c_double) :: alpha
      type(c_ptr) :: A
      integer(c_int),value :: lda
      type(c_ptr) :: B
      integer(c_int),value :: ldb
      real(c_double) :: beta
      type(c_ptr) :: C
      integer(c_int),value :: ldc
      integer(c_int),value :: batch_count
    end function

#ifdef USE_FPOINTER_INTERFACES
    module procedure rocblas_dsymm_batched_full_rank,rocblas_dsymm_batched_rank_0,rocblas_dsymm_batched_rank_1
#endif

  end interface
  
  interface rocblas_csymm_batched
    function rocblas_csymm_batched_orig(handle,side,uplo,m,n,alpha,A,lda,B,ldb,beta,C,ldc,batch_count) bind(c, name="rocblas_csymm_batched")
      use iso_c_binding
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocblas_csymm_batched_orig
      type(c_ptr),value :: handle
      integer(kind(rocblas_side_left)),value :: side
      integer(kind(rocblas_fill_upper)),value :: uplo
      integer(c_int),value :: m
      integer(c_int),value :: n
      complex(c_float_complex) :: alpha
      type(c_ptr) :: A
      integer(c_int),value :: lda
      type(c_ptr) :: B
      integer(c_int),value :: ldb
      complex(c_float_complex) :: beta
      type(c_ptr) :: C
      integer(c_int),value :: ldc
      integer(c_int),value :: batch_count
    end function

#ifdef USE_FPOINTER_INTERFACES
    module procedure rocblas_csymm_batched_full_rank,rocblas_csymm_batched_rank_0,rocblas_csymm_batched_rank_1
#endif

  end interface
  !> ! \brief BLAS Level 3 API
  !> 
  !>     \details
  !> 
  !>     symm_batched performs a batch of the matrix-matrix operations:
  !> 
  !>     C_i := alphaA_iB_i + betaC_i if side == rocblas_side_left,
  !>     C_i := alphaB_iA_i + betaC_i if side == rocblas_side_right,
  !> 
  !>     where alpha and beta are scalars, B_i and C_i are m by n matrices, and
  !>     A_i is a symmetric matrix stored as either upper or lower.
  !> 
  !>     @param[in]
  !>     handle    [rocblas_handle]
  !>               handle to the rocblas library context queue.
  !> 
  !>     @param[in]
  !>     side  [rocblas_side]
  !>             rocblas_side_left:      C_i := alphaA_iB_i + betaC_i
  !>             rocblas_side_right:     C_i := alphaB_iA_i + betaC_i
  !> 
  !>     @param[in]
  !>     uplo    [rocblas_fill]
  !>             rocblas_fill_upper:  A_i is an upper triangular matrix
  !>             rocblas_fill_lower:  A_i is a  lower triangular matrix
  !> 
  !>     @param[in]
  !>     m       [rocblas_int]
  !>             m specifies the number of rows of B_i and C_i. m >= 0.
  !> 
  !>     @param[in]
  !>     n       [rocblas_int]
  !>             n specifies the number of columns of B_i and C_i. n >= 0.
  !> 
  !>     @param[in]
  !>     alpha
  !>             alpha specifies the scalar alpha. When alpha is
  !>             zero then A_i and B_i are not referenced.
  !> 
  !>     @param[in]
  !>     A       device array of device pointers storing each matrix A_i on the GPU.
  !>             A_i is m by m if side == rocblas_side_left
  !>             A_i is n by n if side == rocblas_side_right
  !>             only the upperlower triangular part is accessed.
  !> 
  !>     @param[in]
  !>     lda     [rocblas_int]
  !>             lda specifies the first dimension of A_i.
  !>             if side = rocblas_side_left,  lda >= max( 1, m ),
  !>             otherwise lda >= max( 1, n ).
  !> 
  !>     @param[in]
  !>     B       device array of device pointers storing each matrix B_i on the GPU.
  !>             Matrix dimension is m by n
  !> 
  !>     @param[in]
  !>     ldb     [rocblas_int]
  !>             ldb specifies the first dimension of B_i. ldb >= max( 1, m )
  !> 
  !>     @param[in]
  !>     beta
  !>             beta specifies the scalar beta. When beta is
  !>             zero then C_i need not be set before entry.
  !> 
  !>     @param[in]
  !>     C       device array of device pointers storing each matrix C_i on the GPU.
  !>             Matrix dimension is m by n
  !> 
  !>     @param[in]
  !>     ldc    [rocblas_int]
  !>            ldc specifies the first dimension of C_i. ldc >= max( 1, m )
  !> 
  !>     @param[in]
  !>     batch_count [rocblas_int]
  !>                 number of instances in the batch.
  !> 
  !>     
  interface rocblas_zsymm_batched
    function rocblas_zsymm_batched_orig(handle,side,uplo,m,n,alpha,A,lda,B,ldb,beta,C,ldc,batch_count) bind(c, name="rocblas_zsymm_batched")
      use iso_c_binding
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocblas_zsymm_batched_orig
      type(c_ptr),value :: handle
      integer(kind(rocblas_side_left)),value :: side
      integer(kind(rocblas_fill_upper)),value :: uplo
      integer(c_int),value :: m
      integer(c_int),value :: n
      complex(c_double_complex) :: alpha
      type(c_ptr) :: A
      integer(c_int),value :: lda
      type(c_ptr) :: B
      integer(c_int),value :: ldb
      complex(c_double_complex) :: beta
      type(c_ptr) :: C
      integer(c_int),value :: ldc
      integer(c_int),value :: batch_count
    end function

#ifdef USE_FPOINTER_INTERFACES
    module procedure rocblas_zsymm_batched_full_rank,rocblas_zsymm_batched_rank_0,rocblas_zsymm_batched_rank_1
#endif

  end interface
  
  interface rocblas_ssymm_strided_batched
    function rocblas_ssymm_strided_batched_orig(handle,side,uplo,m,n,alpha,A,lda,stride_A,B,ldb,stride_B,beta,C,ldc,stride_C,batch_count) bind(c, name="rocblas_ssymm_strided_batched")
      use iso_c_binding
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocblas_ssymm_strided_batched_orig
      type(c_ptr),value :: handle
      integer(kind(rocblas_side_left)),value :: side
      integer(kind(rocblas_fill_upper)),value :: uplo
      integer(c_int),value :: m
      integer(c_int),value :: n
      real(c_float) :: alpha
      type(c_ptr),value :: A
      integer(c_int),value :: lda
      integer(c_int64_t),value :: stride_A
      type(c_ptr),value :: B
      integer(c_int),value :: ldb
      integer(c_int64_t),value :: stride_B
      real(c_float) :: beta
      type(c_ptr),value :: C
      integer(c_int),value :: ldc
      integer(c_int64_t),value :: stride_C
      integer(c_int),value :: batch_count
    end function

#ifdef USE_FPOINTER_INTERFACES
    module procedure rocblas_ssymm_strided_batched_full_rank,rocblas_ssymm_strided_batched_rank_0,rocblas_ssymm_strided_batched_rank_1
#endif

  end interface
  
  interface rocblas_dsymm_strided_batched
    function rocblas_dsymm_strided_batched_orig(handle,side,uplo,m,n,alpha,A,lda,stride_A,B,ldb,stride_B,beta,C,ldc,stride_C,batch_count) bind(c, name="rocblas_dsymm_strided_batched")
      use iso_c_binding
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocblas_dsymm_strided_batched_orig
      type(c_ptr),value :: handle
      integer(kind(rocblas_side_left)),value :: side
      integer(kind(rocblas_fill_upper)),value :: uplo
      integer(c_int),value :: m
      integer(c_int),value :: n
      real(c_double) :: alpha
      type(c_ptr),value :: A
      integer(c_int),value :: lda
      integer(c_int64_t),value :: stride_A
      type(c_ptr),value :: B
      integer(c_int),value :: ldb
      integer(c_int64_t),value :: stride_B
      real(c_double) :: beta
      type(c_ptr),value :: C
      integer(c_int),value :: ldc
      integer(c_int64_t),value :: stride_C
      integer(c_int),value :: batch_count
    end function

#ifdef USE_FPOINTER_INTERFACES
    module procedure rocblas_dsymm_strided_batched_full_rank,rocblas_dsymm_strided_batched_rank_0,rocblas_dsymm_strided_batched_rank_1
#endif

  end interface
  
  interface rocblas_csymm_strided_batched
    function rocblas_csymm_strided_batched_orig(handle,side,uplo,m,n,alpha,A,lda,stride_A,B,ldb,stride_B,beta,C,ldc,stride_C,batch_count) bind(c, name="rocblas_csymm_strided_batched")
      use iso_c_binding
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocblas_csymm_strided_batched_orig
      type(c_ptr),value :: handle
      integer(kind(rocblas_side_left)),value :: side
      integer(kind(rocblas_fill_upper)),value :: uplo
      integer(c_int),value :: m
      integer(c_int),value :: n
      complex(c_float_complex) :: alpha
      type(c_ptr),value :: A
      integer(c_int),value :: lda
      integer(c_int64_t),value :: stride_A
      type(c_ptr),value :: B
      integer(c_int),value :: ldb
      integer(c_int64_t),value :: stride_B
      complex(c_float_complex) :: beta
      type(c_ptr),value :: C
      integer(c_int),value :: ldc
      integer(c_int64_t),value :: stride_C
      integer(c_int),value :: batch_count
    end function

#ifdef USE_FPOINTER_INTERFACES
    module procedure rocblas_csymm_strided_batched_full_rank,rocblas_csymm_strided_batched_rank_0,rocblas_csymm_strided_batched_rank_1
#endif

  end interface
  !> ! \brief BLAS Level 3 API
  !> 
  !>     \details
  !> 
  !>     symm_strided_batched performs a batch of the matrix-matrix operations:
  !> 
  !>     C_i := alphaA_iB_i + betaC_i if side == rocblas_side_left,
  !>     C_i := alphaB_iA_i + betaC_i if side == rocblas_side_right,
  !> 
  !>     where alpha and beta are scalars, B_i and C_i are m by n matrices, and
  !>     A_i is a symmetric matrix stored as either upper or lower.
  !> 
  !>     @param[in]
  !>     handle    [rocblas_handle]
  !>               handle to the rocblas library context queue.
  !> 
  !>     @param[in]
  !>     side  [rocblas_side]
  !>             rocblas_side_left:      C_i := alphaA_iB_i + betaC_i
  !>             rocblas_side_right:     C_i := alphaB_iA_i + betaC_i
  !> 
  !>     @param[in]
  !>     uplo    [rocblas_fill]
  !>             rocblas_fill_upper:  A_i is an upper triangular matrix
  !>             rocblas_fill_lower:  A_i is a  lower triangular matrix
  !> 
  !>     @param[in]
  !>     m       [rocblas_int]
  !>             m specifies the number of rows of B_i and C_i. m >= 0.
  !> 
  !>     @param[in]
  !>     n       [rocblas_int]
  !>             n specifies the number of columns of B_i and C_i. n >= 0.
  !> 
  !>     @param[in]
  !>     alpha
  !>             alpha specifies the scalar alpha. When alpha is
  !>             zero then A_i and B_i are not referenced.
  !> 
  !>     @param[in]
  !>     A       device pointer to first matrix A_1
  !>             A_i is m by m if side == rocblas_side_left
  !>             A_i is n by n if side == rocblas_side_right
  !>             only the upperlower triangular part is accessed.
  !> 
  !>     @param[in]
  !>     lda     [rocblas_int]
  !>             lda specifies the first dimension of A_i.
  !>             if side = rocblas_side_left,  lda >= max( 1, m ),
  !>             otherwise lda >= max( 1, n ).
  !> 
  !>     @param[in]
  !>     stride_A  [rocblas_stride]
  !>               stride from the start of one matrix (A_i) and the next one (A_i+1)
  !> 
  !>     @param[in]
  !>     B       device pointer to first matrix B_1 of dimension (ldb, n) on the GPU.
  !> 
  !>     @param[in]
  !>     ldb     [rocblas_int]
  !>             ldb specifies the first dimension of B_i. ldb >= max( 1, m )
  !> 
  !>     @param[in]
  !>     stride_B  [rocblas_stride]
  !>               stride from the start of one matrix (B_i) and the next one (B_i+1)
  !>     @param[in]
  !>     beta
  !>             beta specifies the scalar beta. When beta is
  !>             zero then C need not be set before entry.
  !> 
  !>     @param[in]
  !>     C        device pointer to first matrix C_1 of dimension (ldc, n) on the GPU.
  !> 
  !>     @param[in]
  !>     ldc    [rocblas_int]
  !>            ldc specifies the first dimension of C. ldc >= max( 1, m ).
  !> 
  !>     @param[inout]
  !>     stride_C  [rocblas_stride]
  !>               stride from the start of one matrix (C_i) and the next one (C_i+1)
  !> 
  !>     @param[in]
  !>     batch_count [rocblas_int]
  !>                 number of instances in the batch.
  !> 
  !>     
  interface rocblas_zsymm_strided_batched
    function rocblas_zsymm_strided_batched_orig(handle,side,uplo,m,n,alpha,A,lda,stride_A,B,ldb,stride_B,beta,C,ldc,stride_C,batch_count) bind(c, name="rocblas_zsymm_strided_batched")
      use iso_c_binding
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocblas_zsymm_strided_batched_orig
      type(c_ptr),value :: handle
      integer(kind(rocblas_side_left)),value :: side
      integer(kind(rocblas_fill_upper)),value :: uplo
      integer(c_int),value :: m
      integer(c_int),value :: n
      complex(c_double_complex) :: alpha
      type(c_ptr),value :: A
      integer(c_int),value :: lda
      integer(c_int64_t),value :: stride_A
      type(c_ptr),value :: B
      integer(c_int),value :: ldb
      integer(c_int64_t),value :: stride_B
      complex(c_double_complex) :: beta
      type(c_ptr),value :: C
      integer(c_int),value :: ldc
      integer(c_int64_t),value :: stride_C
      integer(c_int),value :: batch_count
    end function

#ifdef USE_FPOINTER_INTERFACES
    module procedure rocblas_zsymm_strided_batched_full_rank,rocblas_zsymm_strided_batched_rank_0,rocblas_zsymm_strided_batched_rank_1
#endif

  end interface
  
  interface rocblas_ssyrk
    function rocblas_ssyrk_orig(handle,uplo,transA,n,k,alpha,A,lda,beta,C,ldc) bind(c, name="rocblas_ssyrk")
      use iso_c_binding
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocblas_ssyrk_orig
      type(c_ptr),value :: handle
      integer(kind(rocblas_fill_upper)),value :: uplo
      integer(kind(rocblas_operation_none)),value :: transA
      integer(c_int),value :: n
      integer(c_int),value :: k
      real(c_float) :: alpha
      type(c_ptr),value :: A
      integer(c_int),value :: lda
      real(c_float) :: beta
      type(c_ptr),value :: C
      integer(c_int),value :: ldc
    end function

#ifdef USE_FPOINTER_INTERFACES
    module procedure rocblas_ssyrk_full_rank,rocblas_ssyrk_rank_0,rocblas_ssyrk_rank_1
#endif

  end interface
  
  interface rocblas_dsyrk
    function rocblas_dsyrk_orig(handle,uplo,transA,n,k,alpha,A,lda,beta,C,ldc) bind(c, name="rocblas_dsyrk")
      use iso_c_binding
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocblas_dsyrk_orig
      type(c_ptr),value :: handle
      integer(kind(rocblas_fill_upper)),value :: uplo
      integer(kind(rocblas_operation_none)),value :: transA
      integer(c_int),value :: n
      integer(c_int),value :: k
      real(c_double) :: alpha
      type(c_ptr),value :: A
      integer(c_int),value :: lda
      real(c_double) :: beta
      type(c_ptr),value :: C
      integer(c_int),value :: ldc
    end function

#ifdef USE_FPOINTER_INTERFACES
    module procedure rocblas_dsyrk_full_rank,rocblas_dsyrk_rank_0,rocblas_dsyrk_rank_1
#endif

  end interface
  
  interface rocblas_csyrk
    function rocblas_csyrk_orig(handle,uplo,transA,n,k,alpha,A,lda,beta,C,ldc) bind(c, name="rocblas_csyrk")
      use iso_c_binding
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocblas_csyrk_orig
      type(c_ptr),value :: handle
      integer(kind(rocblas_fill_upper)),value :: uplo
      integer(kind(rocblas_operation_none)),value :: transA
      integer(c_int),value :: n
      integer(c_int),value :: k
      complex(c_float_complex) :: alpha
      type(c_ptr),value :: A
      integer(c_int),value :: lda
      complex(c_float_complex) :: beta
      type(c_ptr),value :: C
      integer(c_int),value :: ldc
    end function

#ifdef USE_FPOINTER_INTERFACES
    module procedure rocblas_csyrk_full_rank,rocblas_csyrk_rank_0,rocblas_csyrk_rank_1
#endif

  end interface
  !> ! \brief BLAS Level 3 API
  !> 
  !>     \details
  !> 
  !>     syrk performs one of the matrix-matrix operations for a symmetric rank-k update
  !> 
  !>     C := alphaop( A )op( A )^T + betaC
  !> 
  !>     where  alpha and beta are scalars, op(A) is an n by k matrix, and
  !>     C is a symmetric n x n matrix stored as either upper or lower.
  !> 
  !>         op( A ) = A, and A is n by k if transA == rocblas_operation_none
  !>         op( A ) = A^T and A is k by n if transA == rocblas_operation_transpose
  !> 
  !>     @param[in]
  !>     handle    [rocblas_handle]
  !>               handle to the rocblas library context queue.
  !> 
  !>     @param[in]
  !>     uplo    [rocblas_fill]
  !>             rocblas_fill_upper:  C is an upper triangular matrix
  !>             rocblas_fill_lower:  C is a  lower triangular matrix
  !> 
  !>     @param[in]
  !>     transA  [rocblas_operation]
  !>             rocblas_operation_transpose:      op(A) = A^T
  !>             rocblas_operation_none:           op(A) = A
  !> 
  !>     @param[in]
  !>     n       [rocblas_int]
  !>             n specifies the number of rows and columns of C. n >= 0.
  !> 
  !>     @param[in]
  !>     k       [rocblas_int]
  !>             k specifies the number of columns of op(A). k >= 0.
  !> 
  !>     @param[in]
  !>     alpha
  !>             alpha specifies the scalar alpha. When alpha is
  !>             zero then A is not referenced and A need not be set before
  !>             entry.
  !> 
  !>     @param[in]
  !>     A       pointer storing matrix A on the GPU.
  !>             Martrix dimension is ( lda, k ) when if transA = rocblas_operation_none, otherwise (lda, n)
  !>             only the upperlower triangular part is accessed.
  !> 
  !>     @param[in]
  !>     lda     [rocblas_int]
  !>             lda specifies the first dimension of A.
  !>             if transA = rocblas_operation_none,  lda >= max( 1, n ),
  !>             otherwise lda >= max( 1, k ).
  !> 
  !>     @param[in]
  !>     beta
  !>             beta specifies the scalar beta. When beta is
  !>             zero then C need not be set before entry.
  !> 
  !>     @param[in]
  !>     C       pointer storing matrix C on the GPU.
  !> 
  !>     @param[in]
  !>     ldc    [rocblas_int]
  !>            ldc specifies the first dimension of C. ldc >= max( 1, n ).
  !> 
  !>     
  interface rocblas_zsyrk
    function rocblas_zsyrk_orig(handle,uplo,transA,n,k,alpha,A,lda,beta,C,ldc) bind(c, name="rocblas_zsyrk")
      use iso_c_binding
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocblas_zsyrk_orig
      type(c_ptr),value :: handle
      integer(kind(rocblas_fill_upper)),value :: uplo
      integer(kind(rocblas_operation_none)),value :: transA
      integer(c_int),value :: n
      integer(c_int),value :: k
      complex(c_double_complex) :: alpha
      type(c_ptr),value :: A
      integer(c_int),value :: lda
      complex(c_double_complex) :: beta
      type(c_ptr),value :: C
      integer(c_int),value :: ldc
    end function

#ifdef USE_FPOINTER_INTERFACES
    module procedure rocblas_zsyrk_full_rank,rocblas_zsyrk_rank_0,rocblas_zsyrk_rank_1
#endif

  end interface
  
  interface rocblas_ssyrk_batched
    function rocblas_ssyrk_batched_orig(handle,uplo,transA,n,k,alpha,A,lda,beta,C,ldc,batch_count) bind(c, name="rocblas_ssyrk_batched")
      use iso_c_binding
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocblas_ssyrk_batched_orig
      type(c_ptr),value :: handle
      integer(kind(rocblas_fill_upper)),value :: uplo
      integer(kind(rocblas_operation_none)),value :: transA
      integer(c_int),value :: n
      integer(c_int),value :: k
      real(c_float) :: alpha
      type(c_ptr) :: A
      integer(c_int),value :: lda
      real(c_float) :: beta
      type(c_ptr) :: C
      integer(c_int),value :: ldc
      integer(c_int),value :: batch_count
    end function

#ifdef USE_FPOINTER_INTERFACES
    module procedure rocblas_ssyrk_batched_full_rank,rocblas_ssyrk_batched_rank_0,rocblas_ssyrk_batched_rank_1
#endif

  end interface
  
  interface rocblas_dsyrk_batched
    function rocblas_dsyrk_batched_orig(handle,uplo,transA,n,k,alpha,A,lda,beta,C,ldc,batch_count) bind(c, name="rocblas_dsyrk_batched")
      use iso_c_binding
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocblas_dsyrk_batched_orig
      type(c_ptr),value :: handle
      integer(kind(rocblas_fill_upper)),value :: uplo
      integer(kind(rocblas_operation_none)),value :: transA
      integer(c_int),value :: n
      integer(c_int),value :: k
      real(c_double) :: alpha
      type(c_ptr) :: A
      integer(c_int),value :: lda
      real(c_double) :: beta
      type(c_ptr) :: C
      integer(c_int),value :: ldc
      integer(c_int),value :: batch_count
    end function

#ifdef USE_FPOINTER_INTERFACES
    module procedure rocblas_dsyrk_batched_full_rank,rocblas_dsyrk_batched_rank_0,rocblas_dsyrk_batched_rank_1
#endif

  end interface
  
  interface rocblas_csyrk_batched
    function rocblas_csyrk_batched_orig(handle,uplo,transA,n,k,alpha,A,lda,beta,C,ldc,batch_count) bind(c, name="rocblas_csyrk_batched")
      use iso_c_binding
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocblas_csyrk_batched_orig
      type(c_ptr),value :: handle
      integer(kind(rocblas_fill_upper)),value :: uplo
      integer(kind(rocblas_operation_none)),value :: transA
      integer(c_int),value :: n
      integer(c_int),value :: k
      complex(c_float_complex) :: alpha
      type(c_ptr) :: A
      integer(c_int),value :: lda
      complex(c_float_complex) :: beta
      type(c_ptr) :: C
      integer(c_int),value :: ldc
      integer(c_int),value :: batch_count
    end function

#ifdef USE_FPOINTER_INTERFACES
    module procedure rocblas_csyrk_batched_full_rank,rocblas_csyrk_batched_rank_0,rocblas_csyrk_batched_rank_1
#endif

  end interface
  !> ! \brief BLAS Level 3 API
  !> 
  !>     \details
  !> 
  !>     syrk_batched performs a batch of the matrix-matrix operations for a symmetric rank-k update
  !> 
  !>     C_i := alphaop( A_i )op( A_i )^T + betaC_i
  !> 
  !>     where  alpha and beta are scalars, op(A_i) is an n by k matrix, and
  !>     C_i is a symmetric n x n matrix stored as either upper or lower.
  !> 
  !>         op( A_i ) = A_i, and A_i is n by k if transA == rocblas_operation_none
  !>         op( A_i ) = A^T and A_i is k by n if transA == rocblas_operation_transpose
  !> 
  !>     @param[in]
  !>     handle    [rocblas_handle]
  !>               handle to the rocblas library context queue.
  !> 
  !>     @param[in]
  !>     uplo    [rocblas_fill]
  !>             rocblas_fill_upper:  C_i is an upper triangular matrix
  !>             rocblas_fill_lower:  C_i is a  lower triangular matrix
  !> 
  !>     @param[in]
  !>     transA  [rocblas_operation]
  !>             rocblas_operation_transpose:      op(A) = A^T
  !>             rocblas_operation_none:           op(A) = A
  !> 
  !>     @param[in]
  !>     n       [rocblas_int]
  !>             n specifies the number of rows and columns of C_i. n >= 0.
  !> 
  !>     @param[in]
  !>     k       [rocblas_int]
  !>             k specifies the number of columns of op(A). k >= 0.
  !> 
  !>     @param[in]
  !>     alpha
  !>             alpha specifies the scalar alpha. When alpha is
  !>             zero then A is not referenced and A need not be set before
  !>             entry.
  !> 
  !>     @param[in]
  !>     A       device array of device pointers storing each matrix_i A of dimension (lda, k)
  !>             when transA is rocblas_operation_none, otherwise of dimension (lda, n)
  !> 
  !>     @param[in]
  !>     lda     [rocblas_int]
  !>             lda specifies the first dimension of A_i.
  !>             if transA = rocblas_operation_none,  lda >= max( 1, n ),
  !>             otherwise lda >= max( 1, k ).
  !> 
  !>     @param[in]
  !>     beta
  !>             beta specifies the scalar beta. When beta is
  !>             zero then C need not be set before entry.
  !> 
  !>     @param[in]
  !>     C       device array of device pointers storing each matrix C_i on the GPU.
  !> 
  !>     @param[in]
  !>     ldc    [rocblas_int]
  !>            ldc specifies the first dimension of C. ldc >= max( 1, n ).
  !>     @param[in]
  !>     batch_count [rocblas_int]
  !>                 number of instances in the batch.
  !> 
  !>     
  interface rocblas_zsyrk_batched
    function rocblas_zsyrk_batched_orig(handle,uplo,transA,n,k,alpha,A,lda,beta,C,ldc,batch_count) bind(c, name="rocblas_zsyrk_batched")
      use iso_c_binding
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocblas_zsyrk_batched_orig
      type(c_ptr),value :: handle
      integer(kind(rocblas_fill_upper)),value :: uplo
      integer(kind(rocblas_operation_none)),value :: transA
      integer(c_int),value :: n
      integer(c_int),value :: k
      complex(c_double_complex) :: alpha
      type(c_ptr) :: A
      integer(c_int),value :: lda
      complex(c_double_complex) :: beta
      type(c_ptr) :: C
      integer(c_int),value :: ldc
      integer(c_int),value :: batch_count
    end function

#ifdef USE_FPOINTER_INTERFACES
    module procedure rocblas_zsyrk_batched_full_rank,rocblas_zsyrk_batched_rank_0,rocblas_zsyrk_batched_rank_1
#endif

  end interface
  
  interface rocblas_ssyrk_strided_batched
    function rocblas_ssyrk_strided_batched_orig(handle,uplo,transA,n,k,alpha,A,lda,stride_A,beta,C,ldc,stride_C,batch_count) bind(c, name="rocblas_ssyrk_strided_batched")
      use iso_c_binding
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocblas_ssyrk_strided_batched_orig
      type(c_ptr),value :: handle
      integer(kind(rocblas_fill_upper)),value :: uplo
      integer(kind(rocblas_operation_none)),value :: transA
      integer(c_int),value :: n
      integer(c_int),value :: k
      real(c_float) :: alpha
      type(c_ptr),value :: A
      integer(c_int),value :: lda
      integer(c_int64_t),value :: stride_A
      real(c_float) :: beta
      type(c_ptr),value :: C
      integer(c_int),value :: ldc
      integer(c_int64_t),value :: stride_C
      integer(c_int),value :: batch_count
    end function

#ifdef USE_FPOINTER_INTERFACES
    module procedure rocblas_ssyrk_strided_batched_full_rank,rocblas_ssyrk_strided_batched_rank_0,rocblas_ssyrk_strided_batched_rank_1
#endif

  end interface
  
  interface rocblas_dsyrk_strided_batched
    function rocblas_dsyrk_strided_batched_orig(handle,uplo,transA,n,k,alpha,A,lda,stride_A,beta,C,ldc,stride_C,batch_count) bind(c, name="rocblas_dsyrk_strided_batched")
      use iso_c_binding
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocblas_dsyrk_strided_batched_orig
      type(c_ptr),value :: handle
      integer(kind(rocblas_fill_upper)),value :: uplo
      integer(kind(rocblas_operation_none)),value :: transA
      integer(c_int),value :: n
      integer(c_int),value :: k
      real(c_double) :: alpha
      type(c_ptr),value :: A
      integer(c_int),value :: lda
      integer(c_int64_t),value :: stride_A
      real(c_double) :: beta
      type(c_ptr),value :: C
      integer(c_int),value :: ldc
      integer(c_int64_t),value :: stride_C
      integer(c_int),value :: batch_count
    end function

#ifdef USE_FPOINTER_INTERFACES
    module procedure rocblas_dsyrk_strided_batched_full_rank,rocblas_dsyrk_strided_batched_rank_0,rocblas_dsyrk_strided_batched_rank_1
#endif

  end interface
  
  interface rocblas_csyrk_strided_batched
    function rocblas_csyrk_strided_batched_orig(handle,uplo,transA,n,k,alpha,A,lda,stride_A,beta,C,ldc,stride_C,batch_count) bind(c, name="rocblas_csyrk_strided_batched")
      use iso_c_binding
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocblas_csyrk_strided_batched_orig
      type(c_ptr),value :: handle
      integer(kind(rocblas_fill_upper)),value :: uplo
      integer(kind(rocblas_operation_none)),value :: transA
      integer(c_int),value :: n
      integer(c_int),value :: k
      complex(c_float_complex) :: alpha
      type(c_ptr),value :: A
      integer(c_int),value :: lda
      integer(c_int64_t),value :: stride_A
      complex(c_float_complex) :: beta
      type(c_ptr),value :: C
      integer(c_int),value :: ldc
      integer(c_int64_t),value :: stride_C
      integer(c_int),value :: batch_count
    end function

#ifdef USE_FPOINTER_INTERFACES
    module procedure rocblas_csyrk_strided_batched_full_rank,rocblas_csyrk_strided_batched_rank_0,rocblas_csyrk_strided_batched_rank_1
#endif

  end interface
  !> ! \brief BLAS Level 3 API
  !> 
  !>     \details
  !> 
  !>     syrk_strided_batched performs a batch of the matrix-matrix operations for a symmetric rank-k update
  !> 
  !>     C_i := alphaop( A_i )op( A_i )^T + betaC_i
  !> 
  !>     where  alpha and beta are scalars, op(A_i) is an n by k matrix, and
  !>     C_i is a symmetric n x n matrix stored as either upper or lower.
  !> 
  !>         op( A_i ) = A_i, and A_i is n by k if transA == rocblas_operation_none
  !>         op( A_i ) = A^T and A_i is k by n if transA == rocblas_operation_transpose
  !> 
  !>     @param[in]
  !>     handle    [rocblas_handle]
  !>               handle to the rocblas library context queue.
  !> 
  !>     @param[in]
  !>     uplo    [rocblas_fill]
  !>             rocblas_fill_upper:  C_i is an upper triangular matrix
  !>             rocblas_fill_lower:  C_i is a  lower triangular matrix
  !> 
  !>     @param[in]
  !>     transA  [rocblas_operation]
  !>             rocblas_operation_transpose:      op(A) = A^T
  !>             rocblas_operation_none:           op(A) = A
  !> 
  !>     @param[in]
  !>     n       [rocblas_int]
  !>             n specifies the number of rows and columns of C_i. n >= 0.
  !> 
  !>     @param[in]
  !>     k       [rocblas_int]
  !>             k specifies the number of columns of op(A). k >= 0.
  !> 
  !>     @param[in]
  !>     alpha
  !>             alpha specifies the scalar alpha. When alpha is
  !>             zero then A is not referenced and A need not be set before
  !>             entry.
  !> 
  !>     @param[in]
  !>     A       Device pointer to the first matrix A_1 on the GPU of dimension (lda, k)
  !>             when transA is rocblas_operation_none, otherwise of dimension (lda, n)
  !> 
  !>     @param[in]
  !>     lda     [rocblas_int]
  !>             lda specifies the first dimension of A_i.
  !>             if transA = rocblas_operation_none,  lda >= max( 1, n ),
  !>             otherwise lda >= max( 1, k ).
  !> 
  !>     @param[in]
  !>     stride_A  [rocblas_stride]
  !>               stride from the start of one matrix (A_i) and the next one (A_i+1)
  !> 
  !>     @param[in]
  !>     beta
  !>             beta specifies the scalar beta. When beta is
  !>             zero then C need not be set before entry.
  !> 
  !>     @param[in]
  !>     C       Device pointer to the first matrix C_1 on the GPU. on the GPU.
  !> 
  !>     @param[in]
  !>     ldc    [rocblas_int]
  !>            ldc specifies the first dimension of C. ldc >= max( 1, n ).
  !> 
  !>     @param[inout]
  !>     stride_C  [rocblas_stride]
  !>               stride from the start of one matrix (C_i) and the next one (C_i+1)
  !> 
  !>     @param[in]
  !>     batch_count [rocblas_int]
  !>                 number of instances in the batch.
  !> 
  !>     
  interface rocblas_zsyrk_strided_batched
    function rocblas_zsyrk_strided_batched_orig(handle,uplo,transA,n,k,alpha,A,lda,stride_A,beta,C,ldc,stride_C,batch_count) bind(c, name="rocblas_zsyrk_strided_batched")
      use iso_c_binding
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocblas_zsyrk_strided_batched_orig
      type(c_ptr),value :: handle
      integer(kind(rocblas_fill_upper)),value :: uplo
      integer(kind(rocblas_operation_none)),value :: transA
      integer(c_int),value :: n
      integer(c_int),value :: k
      complex(c_double_complex) :: alpha
      type(c_ptr),value :: A
      integer(c_int),value :: lda
      integer(c_int64_t),value :: stride_A
      complex(c_double_complex) :: beta
      type(c_ptr),value :: C
      integer(c_int),value :: ldc
      integer(c_int64_t),value :: stride_C
      integer(c_int),value :: batch_count
    end function

#ifdef USE_FPOINTER_INTERFACES
    module procedure rocblas_zsyrk_strided_batched_full_rank,rocblas_zsyrk_strided_batched_rank_0,rocblas_zsyrk_strided_batched_rank_1
#endif

  end interface
  
  interface rocblas_ssyr2k
    function rocblas_ssyr2k_orig(handle,uplo,trans,n,k,alpha,A,lda,B,ldb,beta,C,ldc) bind(c, name="rocblas_ssyr2k")
      use iso_c_binding
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocblas_ssyr2k_orig
      type(c_ptr),value :: handle
      integer(kind(rocblas_fill_upper)),value :: uplo
      integer(kind(rocblas_operation_none)),value :: trans
      integer(c_int),value :: n
      integer(c_int),value :: k
      real(c_float) :: alpha
      type(c_ptr),value :: A
      integer(c_int),value :: lda
      type(c_ptr),value :: B
      integer(c_int),value :: ldb
      real(c_float) :: beta
      type(c_ptr),value :: C
      integer(c_int),value :: ldc
    end function

#ifdef USE_FPOINTER_INTERFACES
    module procedure rocblas_ssyr2k_full_rank,rocblas_ssyr2k_rank_0,rocblas_ssyr2k_rank_1
#endif

  end interface
  
  interface rocblas_dsyr2k
    function rocblas_dsyr2k_orig(handle,uplo,trans,n,k,alpha,A,lda,B,ldb,beta,C,ldc) bind(c, name="rocblas_dsyr2k")
      use iso_c_binding
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocblas_dsyr2k_orig
      type(c_ptr),value :: handle
      integer(kind(rocblas_fill_upper)),value :: uplo
      integer(kind(rocblas_operation_none)),value :: trans
      integer(c_int),value :: n
      integer(c_int),value :: k
      real(c_double) :: alpha
      type(c_ptr),value :: A
      integer(c_int),value :: lda
      type(c_ptr),value :: B
      integer(c_int),value :: ldb
      real(c_double) :: beta
      type(c_ptr),value :: C
      integer(c_int),value :: ldc
    end function

#ifdef USE_FPOINTER_INTERFACES
    module procedure rocblas_dsyr2k_full_rank,rocblas_dsyr2k_rank_0,rocblas_dsyr2k_rank_1
#endif

  end interface
  
  interface rocblas_csyr2k
    function rocblas_csyr2k_orig(handle,uplo,trans,n,k,alpha,A,lda,B,ldb,beta,C,ldc) bind(c, name="rocblas_csyr2k")
      use iso_c_binding
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocblas_csyr2k_orig
      type(c_ptr),value :: handle
      integer(kind(rocblas_fill_upper)),value :: uplo
      integer(kind(rocblas_operation_none)),value :: trans
      integer(c_int),value :: n
      integer(c_int),value :: k
      complex(c_float_complex) :: alpha
      type(c_ptr),value :: A
      integer(c_int),value :: lda
      type(c_ptr),value :: B
      integer(c_int),value :: ldb
      complex(c_float_complex) :: beta
      type(c_ptr),value :: C
      integer(c_int),value :: ldc
    end function

#ifdef USE_FPOINTER_INTERFACES
    module procedure rocblas_csyr2k_full_rank,rocblas_csyr2k_rank_0,rocblas_csyr2k_rank_1
#endif

  end interface
  !> ! \brief BLAS Level 3 API
  !> 
  !>     \details
  !> 
  !>     syr2k performs one of the matrix-matrix operations for a symmetric rank-2k update
  !> 
  !>     C := alpha(op( A )op( B )^T + op( B )op( A )^T) + betaC
  !> 
  !>     where  alpha and beta are scalars, op(A) and op(B) are n by k matrix, and
  !>     C is a symmetric n x n matrix stored as either upper or lower.
  !> 
  !>         op( A ) = A, op( B ) = B, and A and B are n by k if trans == rocblas_operation_none
  !>         op( A ) = A^T, op( B ) = B^T,  and A and B are k by n if trans == rocblas_operation_transpose
  !> 
  !>     @param[in]
  !>     handle    [rocblas_handle]
  !>               handle to the rocblas library context queue.
  !> 
  !>     @param[in]
  !>     uplo    [rocblas_fill]
  !>             rocblas_fill_upper:  C is an upper triangular matrix
  !>             rocblas_fill_lower:  C is a  lower triangular matrix
  !> 
  !>     @param[in]
  !>     trans  [rocblas_operation]
  !>             rocblas_operation_transpose:      op( A ) = A^T, op( B ) = B^T
  !>             rocblas_operation_none:           op( A ) = A, op( B ) = B
  !> 
  !>     @param[in]
  !>     n       [rocblas_int]
  !>             n specifies the number of rows and columns of C. n >= 0.
  !> 
  !>     @param[in]
  !>     k       [rocblas_int]
  !>             k specifies the number of columns of op(A) and op(B). k >= 0.
  !> 
  !>     @param[in]
  !>     alpha
  !>             alpha specifies the scalar alpha. When alpha is
  !>             zero then A is not referenced and A need not be set before
  !>             entry.
  !> 
  !>     @param[in]
  !>     A       pointer storing matrix A on the GPU.
  !>             Martrix dimension is ( lda, k ) when if trans = rocblas_operation_none, otherwise (lda, n)
  !>             only the upperlower triangular part is accessed.
  !> 
  !>     @param[in]
  !>     lda     [rocblas_int]
  !>             lda specifies the first dimension of A.
  !>             if trans = rocblas_operation_none,  lda >= max( 1, n ),
  !>             otherwise lda >= max( 1, k ).
  !>     @param[in]
  !>     B       pointer storing matrix B on the GPU.
  !>             Martrix dimension is ( ldb, k ) when if trans = rocblas_operation_none, otherwise (ldb, n)
  !>             only the upperlower triangular part is accessed.
  !> 
  !>     @param[in]
  !>     ldb     [rocblas_int]
  !>             ldb specifies the first dimension of B.
  !>             if trans = rocblas_operation_none,  ldb >= max( 1, n ),
  !>             otherwise ldb >= max( 1, k ).
  !>     @param[in]
  !>     beta
  !>             beta specifies the scalar beta. When beta is
  !>             zero then C need not be set before entry.
  !> 
  !>     @param[in]
  !>     C       pointer storing matrix C on the GPU.
  !> 
  !>     @param[in]
  !>     ldc    [rocblas_int]
  !>            ldc specifies the first dimension of C. ldc >= max( 1, n ).
  !> 
  !>     
  interface rocblas_zsyr2k
    function rocblas_zsyr2k_orig(handle,uplo,trans,n,k,alpha,A,lda,B,ldb,beta,C,ldc) bind(c, name="rocblas_zsyr2k")
      use iso_c_binding
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocblas_zsyr2k_orig
      type(c_ptr),value :: handle
      integer(kind(rocblas_fill_upper)),value :: uplo
      integer(kind(rocblas_operation_none)),value :: trans
      integer(c_int),value :: n
      integer(c_int),value :: k
      complex(c_double_complex) :: alpha
      type(c_ptr),value :: A
      integer(c_int),value :: lda
      type(c_ptr),value :: B
      integer(c_int),value :: ldb
      complex(c_double_complex) :: beta
      type(c_ptr),value :: C
      integer(c_int),value :: ldc
    end function

#ifdef USE_FPOINTER_INTERFACES
    module procedure rocblas_zsyr2k_full_rank,rocblas_zsyr2k_rank_0,rocblas_zsyr2k_rank_1
#endif

  end interface
  
  interface rocblas_ssyr2k_batched
    function rocblas_ssyr2k_batched_orig(handle,uplo,trans,n,k,alpha,A,lda,B,ldb,beta,C,ldc,batch_count) bind(c, name="rocblas_ssyr2k_batched")
      use iso_c_binding
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocblas_ssyr2k_batched_orig
      type(c_ptr),value :: handle
      integer(kind(rocblas_fill_upper)),value :: uplo
      integer(kind(rocblas_operation_none)),value :: trans
      integer(c_int),value :: n
      integer(c_int),value :: k
      real(c_float) :: alpha
      type(c_ptr) :: A
      integer(c_int),value :: lda
      type(c_ptr) :: B
      integer(c_int),value :: ldb
      real(c_float) :: beta
      type(c_ptr) :: C
      integer(c_int),value :: ldc
      integer(c_int),value :: batch_count
    end function

#ifdef USE_FPOINTER_INTERFACES
    module procedure rocblas_ssyr2k_batched_full_rank,rocblas_ssyr2k_batched_rank_0,rocblas_ssyr2k_batched_rank_1
#endif

  end interface
  
  interface rocblas_dsyr2k_batched
    function rocblas_dsyr2k_batched_orig(handle,uplo,trans,n,k,alpha,A,lda,B,ldb,beta,C,ldc,batch_count) bind(c, name="rocblas_dsyr2k_batched")
      use iso_c_binding
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocblas_dsyr2k_batched_orig
      type(c_ptr),value :: handle
      integer(kind(rocblas_fill_upper)),value :: uplo
      integer(kind(rocblas_operation_none)),value :: trans
      integer(c_int),value :: n
      integer(c_int),value :: k
      real(c_double) :: alpha
      type(c_ptr) :: A
      integer(c_int),value :: lda
      type(c_ptr) :: B
      integer(c_int),value :: ldb
      real(c_double) :: beta
      type(c_ptr) :: C
      integer(c_int),value :: ldc
      integer(c_int),value :: batch_count
    end function

#ifdef USE_FPOINTER_INTERFACES
    module procedure rocblas_dsyr2k_batched_full_rank,rocblas_dsyr2k_batched_rank_0,rocblas_dsyr2k_batched_rank_1
#endif

  end interface
  
  interface rocblas_csyr2k_batched
    function rocblas_csyr2k_batched_orig(handle,uplo,trans,n,k,alpha,A,lda,B,ldb,beta,C,ldc,batch_count) bind(c, name="rocblas_csyr2k_batched")
      use iso_c_binding
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocblas_csyr2k_batched_orig
      type(c_ptr),value :: handle
      integer(kind(rocblas_fill_upper)),value :: uplo
      integer(kind(rocblas_operation_none)),value :: trans
      integer(c_int),value :: n
      integer(c_int),value :: k
      complex(c_float_complex) :: alpha
      type(c_ptr) :: A
      integer(c_int),value :: lda
      type(c_ptr) :: B
      integer(c_int),value :: ldb
      complex(c_float_complex) :: beta
      type(c_ptr) :: C
      integer(c_int),value :: ldc
      integer(c_int),value :: batch_count
    end function

#ifdef USE_FPOINTER_INTERFACES
    module procedure rocblas_csyr2k_batched_full_rank,rocblas_csyr2k_batched_rank_0,rocblas_csyr2k_batched_rank_1
#endif

  end interface
  !> ! \brief BLAS Level 3 API
  !> 
  !>     \details
  !> 
  !>     syr2k_batched performs a batch of the matrix-matrix operations for a symmetric rank-2k update
  !> 
  !>     C_i := alpha(op( A_i )op( B_i )^T + op( B_i )op( A_i )^T) + betaC_i
  !> 
  !>     where  alpha and beta are scalars, op(A_i) and op(B_i) are n by k matrix, and
  !>     C_i is a symmetric n x n matrix stored as either upper or lower.
  !> 
  !>         op( A_i ) = A_i, op( B_i ) = B_i, and A_i and B_i are n by k if trans == rocblas_operation_none
  !>         op( A_i ) = A_i^T, op( B_i ) = B_i^T,  and A_i and B_i are k by n if trans == rocblas_operation_transpose
  !> 
  !>     @param[in]
  !>     handle    [rocblas_handle]
  !>               handle to the rocblas library context queue.
  !> 
  !>     @param[in]
  !>     uplo    [rocblas_fill]
  !>             rocblas_fill_upper:  C_i is an upper triangular matrix
  !>             rocblas_fill_lower:  C_i is a  lower triangular matrix
  !> 
  !>     @param[in]
  !>     trans  [rocblas_operation]
  !>             rocblas_operation_transpose:      op( A_i ) = A_i^T, op( B_i ) = B_i^T
  !>             rocblas_operation_none:           op( A_i ) = A_i, op( B_i ) = B_i
  !> 
  !>     @param[in]
  !>     n       [rocblas_int]
  !>             n specifies the number of rows and columns of C_i. n >= 0.
  !> 
  !>     @param[in]
  !>     k       [rocblas_int]
  !>             k specifies the number of columns of op(A). k >= 0.
  !> 
  !>     @param[in]
  !>     alpha
  !>             alpha specifies the scalar alpha. When alpha is
  !>             zero then A is not referenced and A need not be set before
  !>             entry.
  !> 
  !>     @param[in]
  !>     A       device array of device pointers storing each matrix_i A of dimension (lda, k)
  !>             when trans is rocblas_operation_none, otherwise of dimension (lda, n)
  !> 
  !>     @param[in]
  !>     lda     [rocblas_int]
  !>             lda specifies the first dimension of A_i.
  !>             if trans = rocblas_operation_none,  lda >= max( 1, n ),
  !>             otherwise lda >= max( 1, k ).
  !>     @param[in]
  !>     B       device array of device pointers storing each matrix_i B of dimension (ldb, k)
  !>             when trans is rocblas_operation_none, otherwise of dimension (ldb, n)
  !>     @param[in]
  !>     ldb     [rocblas_int]
  !>             ldb specifies the first dimension of B.
  !>             if trans = rocblas_operation_none,  ldb >= max( 1, n ),
  !>             otherwise ldb >= max( 1, k ).
  !>     @param[in]
  !>     beta
  !>             beta specifies the scalar beta. When beta is
  !>             zero then C need not be set before entry.
  !> 
  !>     @param[in]
  !>     C       device array of device pointers storing each matrix C_i on the GPU.
  !> 
  !>     @param[in]
  !>     ldc    [rocblas_int]
  !>            ldc specifies the first dimension of C. ldc >= max( 1, n ).
  !>     @param[in]
  !>     batch_count [rocblas_int]
  !>                 number of instances in the batch.
  !> 
  !>     
  interface rocblas_zsyr2k_batched
    function rocblas_zsyr2k_batched_orig(handle,uplo,trans,n,k,alpha,A,lda,B,ldb,beta,C,ldc,batch_count) bind(c, name="rocblas_zsyr2k_batched")
      use iso_c_binding
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocblas_zsyr2k_batched_orig
      type(c_ptr),value :: handle
      integer(kind(rocblas_fill_upper)),value :: uplo
      integer(kind(rocblas_operation_none)),value :: trans
      integer(c_int),value :: n
      integer(c_int),value :: k
      complex(c_double_complex) :: alpha
      type(c_ptr) :: A
      integer(c_int),value :: lda
      type(c_ptr) :: B
      integer(c_int),value :: ldb
      complex(c_double_complex) :: beta
      type(c_ptr) :: C
      integer(c_int),value :: ldc
      integer(c_int),value :: batch_count
    end function

#ifdef USE_FPOINTER_INTERFACES
    module procedure rocblas_zsyr2k_batched_full_rank,rocblas_zsyr2k_batched_rank_0,rocblas_zsyr2k_batched_rank_1
#endif

  end interface
  
  interface rocblas_ssyr2k_strided_batched
    function rocblas_ssyr2k_strided_batched_orig(handle,uplo,trans,n,k,alpha,A,lda,stride_A,B,ldb,stride_B,beta,C,ldc,stride_C,batch_count) bind(c, name="rocblas_ssyr2k_strided_batched")
      use iso_c_binding
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocblas_ssyr2k_strided_batched_orig
      type(c_ptr),value :: handle
      integer(kind(rocblas_fill_upper)),value :: uplo
      integer(kind(rocblas_operation_none)),value :: trans
      integer(c_int),value :: n
      integer(c_int),value :: k
      real(c_float) :: alpha
      type(c_ptr),value :: A
      integer(c_int),value :: lda
      integer(c_int64_t),value :: stride_A
      type(c_ptr),value :: B
      integer(c_int),value :: ldb
      integer(c_int64_t),value :: stride_B
      real(c_float) :: beta
      type(c_ptr),value :: C
      integer(c_int),value :: ldc
      integer(c_int64_t),value :: stride_C
      integer(c_int),value :: batch_count
    end function

#ifdef USE_FPOINTER_INTERFACES
    module procedure rocblas_ssyr2k_strided_batched_full_rank,rocblas_ssyr2k_strided_batched_rank_0,rocblas_ssyr2k_strided_batched_rank_1
#endif

  end interface
  
  interface rocblas_dsyr2k_strided_batched
    function rocblas_dsyr2k_strided_batched_orig(handle,uplo,trans,n,k,alpha,A,lda,stride_A,B,ldb,stride_B,beta,C,ldc,stride_C,batch_count) bind(c, name="rocblas_dsyr2k_strided_batched")
      use iso_c_binding
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocblas_dsyr2k_strided_batched_orig
      type(c_ptr),value :: handle
      integer(kind(rocblas_fill_upper)),value :: uplo
      integer(kind(rocblas_operation_none)),value :: trans
      integer(c_int),value :: n
      integer(c_int),value :: k
      real(c_double) :: alpha
      type(c_ptr),value :: A
      integer(c_int),value :: lda
      integer(c_int64_t),value :: stride_A
      type(c_ptr),value :: B
      integer(c_int),value :: ldb
      integer(c_int64_t),value :: stride_B
      real(c_double) :: beta
      type(c_ptr),value :: C
      integer(c_int),value :: ldc
      integer(c_int64_t),value :: stride_C
      integer(c_int),value :: batch_count
    end function

#ifdef USE_FPOINTER_INTERFACES
    module procedure rocblas_dsyr2k_strided_batched_full_rank,rocblas_dsyr2k_strided_batched_rank_0,rocblas_dsyr2k_strided_batched_rank_1
#endif

  end interface
  
  interface rocblas_csyr2k_strided_batched
    function rocblas_csyr2k_strided_batched_orig(handle,uplo,trans,n,k,alpha,A,lda,stride_A,B,ldb,stride_B,beta,C,ldc,stride_C,batch_count) bind(c, name="rocblas_csyr2k_strided_batched")
      use iso_c_binding
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocblas_csyr2k_strided_batched_orig
      type(c_ptr),value :: handle
      integer(kind(rocblas_fill_upper)),value :: uplo
      integer(kind(rocblas_operation_none)),value :: trans
      integer(c_int),value :: n
      integer(c_int),value :: k
      complex(c_float_complex) :: alpha
      type(c_ptr),value :: A
      integer(c_int),value :: lda
      integer(c_int64_t),value :: stride_A
      type(c_ptr),value :: B
      integer(c_int),value :: ldb
      integer(c_int64_t),value :: stride_B
      complex(c_float_complex) :: beta
      type(c_ptr),value :: C
      integer(c_int),value :: ldc
      integer(c_int64_t),value :: stride_C
      integer(c_int),value :: batch_count
    end function

#ifdef USE_FPOINTER_INTERFACES
    module procedure rocblas_csyr2k_strided_batched_full_rank,rocblas_csyr2k_strided_batched_rank_0,rocblas_csyr2k_strided_batched_rank_1
#endif

  end interface
  !> ! \brief BLAS Level 3 API
  !> 
  !>     \details
  !> 
  !>     syr2k_strided_batched performs a batch of the matrix-matrix operations for a symmetric rank-2k update
  !> 
  !>     C_i := alpha(op( A_i )op( B_i )^T + op( B_i )op( A_i )^T) + betaC_i
  !> 
  !>     where  alpha and beta are scalars, op(A_i) and op(B_i) are n by k matrix, and
  !>     C_i is a symmetric n x n matrix stored as either upper or lower.
  !> 
  !>         op( A_i ) = A_i, op( B_i ) = B_i, and A_i and B_i are n by k if trans == rocblas_operation_none
  !>         op( A_i ) = A_i^T, op( B_i ) = B_i^T,  and A_i and B_i are k by n if trans == rocblas_operation_transpose
  !> 
  !>     @param[in]
  !>     handle    [rocblas_handle]
  !>               handle to the rocblas library context queue.
  !> 
  !>     @param[in]
  !>     uplo    [rocblas_fill]
  !>             rocblas_fill_upper:  C_i is an upper triangular matrix
  !>             rocblas_fill_lower:  C_i is a  lower triangular matrix
  !> 
  !>     @param[in]
  !>     trans  [rocblas_operation]
  !>             rocblas_operation_transpose:      op( A_i ) = A_i^T, op( B_i ) = B_i^T
  !>             rocblas_operation_none:           op( A_i ) = A_i, op( B_i ) = B_i
  !> 
  !>     @param[in]
  !>     n       [rocblas_int]
  !>             n specifies the number of rows and columns of C_i. n >= 0.
  !> 
  !>     @param[in]
  !>     k       [rocblas_int]
  !>             k specifies the number of columns of op(A). k >= 0.
  !> 
  !>     @param[in]
  !>     alpha
  !>             alpha specifies the scalar alpha. When alpha is
  !>             zero then A is not referenced and A need not be set before
  !>             entry.
  !> 
  !>     @param[in]
  !>     A       Device pointer to the first matrix A_1 on the GPU of dimension (lda, k)
  !>             when trans is rocblas_operation_none, otherwise of dimension (lda, n)
  !> 
  !>     @param[in]
  !>     lda     [rocblas_int]
  !>             lda specifies the first dimension of A_i.
  !>             if trans = rocblas_operation_none,  lda >= max( 1, n ),
  !>             otherwise lda >= max( 1, k ).
  !> 
  !>     @param[in]
  !>     stride_A  [rocblas_stride]
  !>               stride from the start of one matrix (A_i) and the next one (A_i+1)
  !> 
  !>     @param[in]
  !>     B       Device pointer to the first matrix B_1 on the GPU of dimension (ldb, k)
  !>             when trans is rocblas_operation_none, otherwise of dimension (ldb, n)
  !> 
  !>     @param[in]
  !>     ldb     [rocblas_int]
  !>             ldb specifies the first dimension of B_i.
  !>             if trans = rocblas_operation_none,  ldb >= max( 1, n ),
  !>             otherwise ldb >= max( 1, k ).
  !> 
  !>     @param[in]
  !>     stride_B  [rocblas_stride]
  !>               stride from the start of one matrix (B_i) and the next one (B_i+1)
  !> 
  !>     @param[in]
  !>     beta
  !>             beta specifies the scalar beta. When beta is
  !>             zero then C need not be set before entry.
  !> 
  !>     @param[in]
  !>     C       Device pointer to the first matrix C_1 on the GPU.
  !> 
  !>     @param[in]
  !>     ldc    [rocblas_int]
  !>            ldc specifies the first dimension of C. ldc >= max( 1, n ).
  !> 
  !>     @param[inout]
  !>     stride_C  [rocblas_stride]
  !>               stride from the start of one matrix (C_i) and the next one (C_i+1)
  !> 
  !>     @param[in]
  !>     batch_count [rocblas_int]
  !>                 number of instances in the batch.
  !> 
  !>     
  interface rocblas_zsyr2k_strided_batched
    function rocblas_zsyr2k_strided_batched_orig(handle,uplo,trans,n,k,alpha,A,lda,stride_A,B,ldb,stride_B,beta,C,ldc,stride_C,batch_count) bind(c, name="rocblas_zsyr2k_strided_batched")
      use iso_c_binding
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocblas_zsyr2k_strided_batched_orig
      type(c_ptr),value :: handle
      integer(kind(rocblas_fill_upper)),value :: uplo
      integer(kind(rocblas_operation_none)),value :: trans
      integer(c_int),value :: n
      integer(c_int),value :: k
      complex(c_double_complex) :: alpha
      type(c_ptr),value :: A
      integer(c_int),value :: lda
      integer(c_int64_t),value :: stride_A
      type(c_ptr),value :: B
      integer(c_int),value :: ldb
      integer(c_int64_t),value :: stride_B
      complex(c_double_complex) :: beta
      type(c_ptr),value :: C
      integer(c_int),value :: ldc
      integer(c_int64_t),value :: stride_C
      integer(c_int),value :: batch_count
    end function

#ifdef USE_FPOINTER_INTERFACES
    module procedure rocblas_zsyr2k_strided_batched_full_rank,rocblas_zsyr2k_strided_batched_rank_0,rocblas_zsyr2k_strided_batched_rank_1
#endif

  end interface
  
  interface rocblas_ssyrkx
    function rocblas_ssyrkx_orig(handle,uplo,trans,n,k,alpha,A,lda,B,ldb,beta,C,ldc) bind(c, name="rocblas_ssyrkx")
      use iso_c_binding
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocblas_ssyrkx_orig
      type(c_ptr),value :: handle
      integer(kind(rocblas_fill_upper)),value :: uplo
      integer(kind(rocblas_operation_none)),value :: trans
      integer(c_int),value :: n
      integer(c_int),value :: k
      real(c_float) :: alpha
      type(c_ptr),value :: A
      integer(c_int),value :: lda
      type(c_ptr),value :: B
      integer(c_int),value :: ldb
      real(c_float) :: beta
      type(c_ptr),value :: C
      integer(c_int),value :: ldc
    end function

#ifdef USE_FPOINTER_INTERFACES
    module procedure rocblas_ssyrkx_full_rank,rocblas_ssyrkx_rank_0,rocblas_ssyrkx_rank_1
#endif

  end interface
  
  interface rocblas_dsyrkx
    function rocblas_dsyrkx_orig(handle,uplo,trans,n,k,alpha,A,lda,B,ldb,beta,C,ldc) bind(c, name="rocblas_dsyrkx")
      use iso_c_binding
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocblas_dsyrkx_orig
      type(c_ptr),value :: handle
      integer(kind(rocblas_fill_upper)),value :: uplo
      integer(kind(rocblas_operation_none)),value :: trans
      integer(c_int),value :: n
      integer(c_int),value :: k
      real(c_double) :: alpha
      type(c_ptr),value :: A
      integer(c_int),value :: lda
      type(c_ptr),value :: B
      integer(c_int),value :: ldb
      real(c_double) :: beta
      type(c_ptr),value :: C
      integer(c_int),value :: ldc
    end function

#ifdef USE_FPOINTER_INTERFACES
    module procedure rocblas_dsyrkx_full_rank,rocblas_dsyrkx_rank_0,rocblas_dsyrkx_rank_1
#endif

  end interface
  
  interface rocblas_csyrkx
    function rocblas_csyrkx_orig(handle,uplo,trans,n,k,alpha,A,lda,B,ldb,beta,C,ldc) bind(c, name="rocblas_csyrkx")
      use iso_c_binding
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocblas_csyrkx_orig
      type(c_ptr),value :: handle
      integer(kind(rocblas_fill_upper)),value :: uplo
      integer(kind(rocblas_operation_none)),value :: trans
      integer(c_int),value :: n
      integer(c_int),value :: k
      complex(c_float_complex) :: alpha
      type(c_ptr),value :: A
      integer(c_int),value :: lda
      type(c_ptr),value :: B
      integer(c_int),value :: ldb
      complex(c_float_complex) :: beta
      type(c_ptr),value :: C
      integer(c_int),value :: ldc
    end function

#ifdef USE_FPOINTER_INTERFACES
    module procedure rocblas_csyrkx_full_rank,rocblas_csyrkx_rank_0,rocblas_csyrkx_rank_1
#endif

  end interface
  !> ! \brief BLAS Level 3 API
  !> 
  !>     \details
  !> 
  !>     syrkx performs one of the matrix-matrix operations for a symmetric rank-k update
  !> 
  !>     C := alphaop( A )op( B )^T + betaC
  !> 
  !>     where  alpha and beta are scalars, op(A) and op(B) are n by k matrix, and
  !>     C is a symmetric n x n matrix stored as either upper or lower.
  !>     This routine should only be used when the caller can guarantee that the result of op( A )op( B )^T will be symmetric.
  !> 
  !>         op( A ) = A, op( B ) = B, and A and B are n by k if trans == rocblas_operation_none
  !>         op( A ) = A^T, op( B ) = B^T,  and A and B are k by n if trans == rocblas_operation_transpose
  !> 
  !>     @param[in]
  !>     handle    [rocblas_handle]
  !>               handle to the rocblas library context queue.
  !> 
  !>     @param[in]
  !>     uplo    [rocblas_fill]
  !>             rocblas_fill_upper:  C is an upper triangular matrix
  !>             rocblas_fill_lower:  C is a  lower triangular matrix
  !> 
  !>     @param[in]
  !>     trans  [rocblas_operation]
  !>             rocblas_operation_transpose:      op( A ) = A^T, op( B ) = B^T
  !>             rocblas_operation_none:           op( A ) = A, op( B ) = B
  !> 
  !>     @param[in]
  !>     n       [rocblas_int]
  !>             n specifies the number of rows and columns of C. n >= 0.
  !> 
  !>     @param[in]
  !>     k       [rocblas_int]
  !>             k specifies the number of columns of op(A) and op(B). k >= 0.
  !> 
  !>     @param[in]
  !>     alpha
  !>             alpha specifies the scalar alpha. When alpha is
  !>             zero then A is not referenced and A need not be set before
  !>             entry.
  !> 
  !>     @param[in]
  !>     A       pointer storing matrix A on the GPU.
  !>             Martrix dimension is ( lda, k ) when if trans = rocblas_operation_none, otherwise (lda, n)
  !>             only the upperlower triangular part is accessed.
  !> 
  !>     @param[in]
  !>     lda     [rocblas_int]
  !>             lda specifies the first dimension of A.
  !>             if trans = rocblas_operation_none,  lda >= max( 1, n ),
  !>             otherwise lda >= max( 1, k ).
  !> 
  !>     @param[in]
  !>     B       pointer storing matrix B on the GPU.
  !>             Martrix dimension is ( ldb, k ) when if trans = rocblas_operation_none, otherwise (ldb, n)
  !>             only the upperlower triangular part is accessed.
  !> 
  !>     @param[in]
  !>     ldb     [rocblas_int]
  !>             ldb specifies the first dimension of B.
  !>             if trans = rocblas_operation_none,  ldb >= max( 1, n ),
  !>             otherwise ldb >= max( 1, k ).
  !> 
  !>     @param[in]
  !>     beta
  !>             beta specifies the scalar beta. When beta is
  !>             zero then C need not be set before entry.
  !> 
  !>     @param[in]
  !>     C       pointer storing matrix C on the GPU.
  !> 
  !>     @param[in]
  !>     ldc    [rocblas_int]
  !>            ldc specifies the first dimension of C. ldc >= max( 1, n ).
  !> 
  !>     
  interface rocblas_zsyrkx
    function rocblas_zsyrkx_orig(handle,uplo,trans,n,k,alpha,A,lda,B,ldb,beta,C,ldc) bind(c, name="rocblas_zsyrkx")
      use iso_c_binding
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocblas_zsyrkx_orig
      type(c_ptr),value :: handle
      integer(kind(rocblas_fill_upper)),value :: uplo
      integer(kind(rocblas_operation_none)),value :: trans
      integer(c_int),value :: n
      integer(c_int),value :: k
      complex(c_double_complex) :: alpha
      type(c_ptr),value :: A
      integer(c_int),value :: lda
      type(c_ptr),value :: B
      integer(c_int),value :: ldb
      complex(c_double_complex) :: beta
      type(c_ptr),value :: C
      integer(c_int),value :: ldc
    end function

#ifdef USE_FPOINTER_INTERFACES
    module procedure rocblas_zsyrkx_full_rank,rocblas_zsyrkx_rank_0,rocblas_zsyrkx_rank_1
#endif

  end interface
  
  interface rocblas_ssyrkx_batched
    function rocblas_ssyrkx_batched_orig(handle,uplo,trans,n,k,alpha,A,lda,B,ldb,beta,C,ldc,batch_count) bind(c, name="rocblas_ssyrkx_batched")
      use iso_c_binding
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocblas_ssyrkx_batched_orig
      type(c_ptr),value :: handle
      integer(kind(rocblas_fill_upper)),value :: uplo
      integer(kind(rocblas_operation_none)),value :: trans
      integer(c_int),value :: n
      integer(c_int),value :: k
      real(c_float) :: alpha
      type(c_ptr) :: A
      integer(c_int),value :: lda
      type(c_ptr) :: B
      integer(c_int),value :: ldb
      real(c_float) :: beta
      type(c_ptr) :: C
      integer(c_int),value :: ldc
      integer(c_int),value :: batch_count
    end function

#ifdef USE_FPOINTER_INTERFACES
    module procedure rocblas_ssyrkx_batched_full_rank,rocblas_ssyrkx_batched_rank_0,rocblas_ssyrkx_batched_rank_1
#endif

  end interface
  
  interface rocblas_dsyrkx_batched
    function rocblas_dsyrkx_batched_orig(handle,uplo,trans,n,k,alpha,A,lda,B,ldb,beta,C,ldc,batch_count) bind(c, name="rocblas_dsyrkx_batched")
      use iso_c_binding
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocblas_dsyrkx_batched_orig
      type(c_ptr),value :: handle
      integer(kind(rocblas_fill_upper)),value :: uplo
      integer(kind(rocblas_operation_none)),value :: trans
      integer(c_int),value :: n
      integer(c_int),value :: k
      real(c_double) :: alpha
      type(c_ptr) :: A
      integer(c_int),value :: lda
      type(c_ptr) :: B
      integer(c_int),value :: ldb
      real(c_double) :: beta
      type(c_ptr) :: C
      integer(c_int),value :: ldc
      integer(c_int),value :: batch_count
    end function

#ifdef USE_FPOINTER_INTERFACES
    module procedure rocblas_dsyrkx_batched_full_rank,rocblas_dsyrkx_batched_rank_0,rocblas_dsyrkx_batched_rank_1
#endif

  end interface
  
  interface rocblas_csyrkx_batched
    function rocblas_csyrkx_batched_orig(handle,uplo,trans,n,k,alpha,A,lda,B,ldb,beta,C,ldc,batch_count) bind(c, name="rocblas_csyrkx_batched")
      use iso_c_binding
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocblas_csyrkx_batched_orig
      type(c_ptr),value :: handle
      integer(kind(rocblas_fill_upper)),value :: uplo
      integer(kind(rocblas_operation_none)),value :: trans
      integer(c_int),value :: n
      integer(c_int),value :: k
      complex(c_float_complex) :: alpha
      type(c_ptr) :: A
      integer(c_int),value :: lda
      type(c_ptr) :: B
      integer(c_int),value :: ldb
      complex(c_float_complex) :: beta
      type(c_ptr) :: C
      integer(c_int),value :: ldc
      integer(c_int),value :: batch_count
    end function

#ifdef USE_FPOINTER_INTERFACES
    module procedure rocblas_csyrkx_batched_full_rank,rocblas_csyrkx_batched_rank_0,rocblas_csyrkx_batched_rank_1
#endif

  end interface
  !> ! \brief BLAS Level 3 API
  !> 
  !>     \details
  !> 
  !>     syrkx_batched performs a batch of the matrix-matrix operations for a symmetric rank-k update
  !> 
  !>     C_i := alphaop( A_i )op( B_i )^T + betaC_i
  !> 
  !>     where  alpha and beta are scalars, op(A_i) and op(B_i) are n by k matrix, and
  !>     C_i is a symmetric n x n matrix stored as either upper or lower.
  !>     This routine should only be used when the caller can guarantee that the result of op( A_i )op( B_i )^T will be symmetric.
  !> 
  !>         op( A_i ) = A_i, op( B_i ) = B_i, and A_i and B_i are n by k if trans == rocblas_operation_none
  !>         op( A_i ) = A_i^T, op( B_i ) = B_i^T,  and A_i and B_i are k by n if trans == rocblas_operation_transpose
  !> 
  !>     @param[in]
  !>     handle    [rocblas_handle]
  !>               handle to the rocblas library context queue.
  !> 
  !>     @param[in]
  !>     uplo    [rocblas_fill]
  !>             rocblas_fill_upper:  C_i is an upper triangular matrix
  !>             rocblas_fill_lower:  C_i is a  lower triangular matrix
  !> 
  !>     @param[in]
  !>     trans  [rocblas_operation]
  !>             rocblas_operation_transpose:      op( A_i ) = A_i^T, op( B_i ) = B_i^T
  !>             rocblas_operation_none:           op( A_i ) = A_i, op( B_i ) = B_i
  !> 
  !>     @param[in]
  !>     n       [rocblas_int]
  !>             n specifies the number of rows and columns of C_i. n >= 0.
  !> 
  !>     @param[in]
  !>     k       [rocblas_int]
  !>             k specifies the number of columns of op(A). k >= 0.
  !> 
  !>     @param[in]
  !>     alpha
  !>             alpha specifies the scalar alpha. When alpha is
  !>             zero then A is not referenced and A need not be set before
  !>             entry.
  !> 
  !>     @param[in]
  !>     A       device array of device pointers storing each matrix_i A of dimension (lda, k)
  !>             when trans is rocblas_operation_none, otherwise of dimension (lda, n)
  !> 
  !>     @param[in]
  !>     lda     [rocblas_int]
  !>             lda specifies the first dimension of A_i.
  !>             if trans = rocblas_operation_none,  lda >= max( 1, n ),
  !>             otherwise lda >= max( 1, k ).
  !> 
  !>     @param[in]
  !>     B       device array of device pointers storing each matrix_i B of dimension (ldb, k)
  !>             when trans is rocblas_operation_none, otherwise of dimension (ldb, n)
  !> 
  !>     @param[in]
  !>     ldb     [rocblas_int]
  !>             ldb specifies the first dimension of B.
  !>             if trans = rocblas_operation_none,  ldb >= max( 1, n ),
  !>             otherwise ldb >= max( 1, k ).
  !> 
  !>     @param[in]
  !>     beta
  !>             beta specifies the scalar beta. When beta is
  !>             zero then C need not be set before entry.
  !> 
  !>     @param[in]
  !>     C       device array of device pointers storing each matrix C_i on the GPU.
  !> 
  !>     @param[in]
  !>     ldc    [rocblas_int]
  !>            ldc specifies the first dimension of C. ldc >= max( 1, n ).
  !> 
  !>     @param[in]
  !>     batch_count [rocblas_int]
  !>             number of instances in the batch.
  !> 
  !>     
  interface rocblas_zsyrkx_batched
    function rocblas_zsyrkx_batched_orig(handle,uplo,trans,n,k,alpha,A,lda,B,ldb,beta,C,ldc,batch_count) bind(c, name="rocblas_zsyrkx_batched")
      use iso_c_binding
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocblas_zsyrkx_batched_orig
      type(c_ptr),value :: handle
      integer(kind(rocblas_fill_upper)),value :: uplo
      integer(kind(rocblas_operation_none)),value :: trans
      integer(c_int),value :: n
      integer(c_int),value :: k
      complex(c_double_complex) :: alpha
      type(c_ptr) :: A
      integer(c_int),value :: lda
      type(c_ptr) :: B
      integer(c_int),value :: ldb
      complex(c_double_complex) :: beta
      type(c_ptr) :: C
      integer(c_int),value :: ldc
      integer(c_int),value :: batch_count
    end function

#ifdef USE_FPOINTER_INTERFACES
    module procedure rocblas_zsyrkx_batched_full_rank,rocblas_zsyrkx_batched_rank_0,rocblas_zsyrkx_batched_rank_1
#endif

  end interface
  
  interface rocblas_ssyrkx_strided_batched
    function rocblas_ssyrkx_strided_batched_orig(handle,uplo,trans,n,k,alpha,A,lda,stride_A,B,ldb,stride_B,beta,C,ldc,stride_C,batch_count) bind(c, name="rocblas_ssyrkx_strided_batched")
      use iso_c_binding
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocblas_ssyrkx_strided_batched_orig
      type(c_ptr),value :: handle
      integer(kind(rocblas_fill_upper)),value :: uplo
      integer(kind(rocblas_operation_none)),value :: trans
      integer(c_int),value :: n
      integer(c_int),value :: k
      real(c_float) :: alpha
      type(c_ptr),value :: A
      integer(c_int),value :: lda
      integer(c_int64_t),value :: stride_A
      type(c_ptr),value :: B
      integer(c_int),value :: ldb
      integer(c_int64_t),value :: stride_B
      real(c_float) :: beta
      type(c_ptr),value :: C
      integer(c_int),value :: ldc
      integer(c_int64_t),value :: stride_C
      integer(c_int),value :: batch_count
    end function

#ifdef USE_FPOINTER_INTERFACES
    module procedure rocblas_ssyrkx_strided_batched_full_rank,rocblas_ssyrkx_strided_batched_rank_0,rocblas_ssyrkx_strided_batched_rank_1
#endif

  end interface
  
  interface rocblas_dsyrkx_strided_batched
    function rocblas_dsyrkx_strided_batched_orig(handle,uplo,trans,n,k,alpha,A,lda,stride_A,B,ldb,stride_B,beta,C,ldc,stride_C,batch_count) bind(c, name="rocblas_dsyrkx_strided_batched")
      use iso_c_binding
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocblas_dsyrkx_strided_batched_orig
      type(c_ptr),value :: handle
      integer(kind(rocblas_fill_upper)),value :: uplo
      integer(kind(rocblas_operation_none)),value :: trans
      integer(c_int),value :: n
      integer(c_int),value :: k
      real(c_double) :: alpha
      type(c_ptr),value :: A
      integer(c_int),value :: lda
      integer(c_int64_t),value :: stride_A
      type(c_ptr),value :: B
      integer(c_int),value :: ldb
      integer(c_int64_t),value :: stride_B
      real(c_double) :: beta
      type(c_ptr),value :: C
      integer(c_int),value :: ldc
      integer(c_int64_t),value :: stride_C
      integer(c_int),value :: batch_count
    end function

#ifdef USE_FPOINTER_INTERFACES
    module procedure rocblas_dsyrkx_strided_batched_full_rank,rocblas_dsyrkx_strided_batched_rank_0,rocblas_dsyrkx_strided_batched_rank_1
#endif

  end interface
  
  interface rocblas_csyrkx_strided_batched
    function rocblas_csyrkx_strided_batched_orig(handle,uplo,trans,n,k,alpha,A,lda,stride_A,B,ldb,stride_B,beta,C,ldc,stride_C,batch_count) bind(c, name="rocblas_csyrkx_strided_batched")
      use iso_c_binding
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocblas_csyrkx_strided_batched_orig
      type(c_ptr),value :: handle
      integer(kind(rocblas_fill_upper)),value :: uplo
      integer(kind(rocblas_operation_none)),value :: trans
      integer(c_int),value :: n
      integer(c_int),value :: k
      complex(c_float_complex) :: alpha
      type(c_ptr),value :: A
      integer(c_int),value :: lda
      integer(c_int64_t),value :: stride_A
      type(c_ptr),value :: B
      integer(c_int),value :: ldb
      integer(c_int64_t),value :: stride_B
      complex(c_float_complex) :: beta
      type(c_ptr),value :: C
      integer(c_int),value :: ldc
      integer(c_int64_t),value :: stride_C
      integer(c_int),value :: batch_count
    end function

#ifdef USE_FPOINTER_INTERFACES
    module procedure rocblas_csyrkx_strided_batched_full_rank,rocblas_csyrkx_strided_batched_rank_0,rocblas_csyrkx_strided_batched_rank_1
#endif

  end interface
  !> ! \brief BLAS Level 3 API
  !> 
  !>     \details
  !> 
  !>     syrkx_strided_batched performs a batch of the matrix-matrix operations for a symmetric rank-k update
  !> 
  !>     C_i := alphaop( A_i )op( B_i )^T + betaC_i
  !> 
  !>     where  alpha and beta are scalars, op(A_i) and op(B_i) are n by k matrix, and
  !>     C_i is a symmetric n x n matrix stored as either upper or lower.
  !>     This routine should only be used when the caller can guarantee that the result of op( A_i )op( B_i )^T will be symmetric.
  !> 
  !>         op( A_i ) = A_i, op( B_i ) = B_i, and A_i and B_i are n by k if trans == rocblas_operation_none
  !>         op( A_i ) = A_i^T, op( B_i ) = B_i^T,  and A_i and B_i are k by n if trans == rocblas_operation_transpose
  !> 
  !>     @param[in]
  !>     handle    [rocblas_handle]
  !>               handle to the rocblas library context queue.
  !> 
  !>     @param[in]
  !>     uplo    [rocblas_fill]
  !>             rocblas_fill_upper:  C_i is an upper triangular matrix
  !>             rocblas_fill_lower:  C_i is a  lower triangular matrix
  !> 
  !>     @param[in]
  !>     trans  [rocblas_operation]
  !>             rocblas_operation_transpose:      op( A_i ) = A_i^T, op( B_i ) = B_i^T
  !>             rocblas_operation_none:           op( A_i ) = A_i, op( B_i ) = B_i
  !> 
  !>     @param[in]
  !>     n       [rocblas_int]
  !>             n specifies the number of rows and columns of C_i. n >= 0.
  !> 
  !>     @param[in]
  !>     k       [rocblas_int]
  !>             k specifies the number of columns of op(A). k >= 0.
  !> 
  !>     @param[in]
  !>     alpha
  !>             alpha specifies the scalar alpha. When alpha is
  !>             zero then A is not referenced and A need not be set before
  !>             entry.
  !> 
  !>     @param[in]
  !>     A       Device pointer to the first matrix A_1 on the GPU of dimension (lda, k)
  !>             when trans is rocblas_operation_none, otherwise of dimension (lda, n)
  !> 
  !>     @param[in]
  !>     lda     [rocblas_int]
  !>             lda specifies the first dimension of A_i.
  !>             if trans = rocblas_operation_none,  lda >= max( 1, n ),
  !>             otherwise lda >= max( 1, k ).
  !> 
  !>     @param[in]
  !>     stride_A  [rocblas_stride]
  !>               stride from the start of one matrix (A_i) and the next one (A_i+1)
  !> 
  !>     @param[in]
  !>     B       Device pointer to the first matrix B_1 on the GPU of dimension (ldb, k)
  !>             when trans is rocblas_operation_none, otherwise of dimension (ldb, n)
  !> 
  !>     @param[in]
  !>     ldb     [rocblas_int]
  !>             ldb specifies the first dimension of B_i.
  !>             if trans = rocblas_operation_none,  ldb >= max( 1, n ),
  !>             otherwise ldb >= max( 1, k ).
  !> 
  !>     @param[in]
  !>     stride_B  [rocblas_stride]
  !>               stride from the start of one matrix (B_i) and the next one (B_i+1)
  !> 
  !>     @param[in]
  !>     beta
  !>             beta specifies the scalar beta. When beta is
  !>             zero then C need not be set before entry.
  !> 
  !>     @param[in]
  !>     C       Device pointer to the first matrix C_1 on the GPU.
  !> 
  !>     @param[in]
  !>     ldc    [rocblas_int]
  !>            ldc specifies the first dimension of C. ldc >= max( 1, n ).
  !> 
  !>     @param[inout]
  !>     stride_C  [rocblas_stride]
  !>               stride from the start of one matrix (C_i) and the next one (C_i+1)
  !> 
  !>     @param[in]
  !>     batch_count [rocblas_int]
  !>                 number of instances in the batch.
  !> 
  !>     
  interface rocblas_zsyrkx_strided_batched
    function rocblas_zsyrkx_strided_batched_orig(handle,uplo,trans,n,k,alpha,A,lda,stride_A,B,ldb,stride_B,beta,C,ldc,stride_C,batch_count) bind(c, name="rocblas_zsyrkx_strided_batched")
      use iso_c_binding
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocblas_zsyrkx_strided_batched_orig
      type(c_ptr),value :: handle
      integer(kind(rocblas_fill_upper)),value :: uplo
      integer(kind(rocblas_operation_none)),value :: trans
      integer(c_int),value :: n
      integer(c_int),value :: k
      complex(c_double_complex) :: alpha
      type(c_ptr),value :: A
      integer(c_int),value :: lda
      integer(c_int64_t),value :: stride_A
      type(c_ptr),value :: B
      integer(c_int),value :: ldb
      integer(c_int64_t),value :: stride_B
      complex(c_double_complex) :: beta
      type(c_ptr),value :: C
      integer(c_int),value :: ldc
      integer(c_int64_t),value :: stride_C
      integer(c_int),value :: batch_count
    end function

#ifdef USE_FPOINTER_INTERFACES
    module procedure rocblas_zsyrkx_strided_batched_full_rank,rocblas_zsyrkx_strided_batched_rank_0,rocblas_zsyrkx_strided_batched_rank_1
#endif

  end interface
  
  interface rocblas_strmm
    function rocblas_strmm_orig(handle,side,uplo,transA,diag,m,n,alpha,A,lda,B,ldb) bind(c, name="rocblas_strmm")
      use iso_c_binding
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocblas_strmm_orig
      type(c_ptr),value :: handle
      integer(kind(rocblas_side_left)),value :: side
      integer(kind(rocblas_fill_upper)),value :: uplo
      integer(kind(rocblas_operation_none)),value :: transA
      integer(kind(rocblas_diagonal_non_unit)),value :: diag
      integer(c_int),value :: m
      integer(c_int),value :: n
      real(c_float) :: alpha
      type(c_ptr),value :: A
      integer(c_int),value :: lda
      type(c_ptr),value :: B
      integer(c_int),value :: ldb
    end function

#ifdef USE_FPOINTER_INTERFACES
    module procedure rocblas_strmm_full_rank,rocblas_strmm_rank_0,rocblas_strmm_rank_1
#endif

  end interface
  
  interface rocblas_dtrmm
    function rocblas_dtrmm_orig(handle,side,uplo,transA,diag,m,n,alpha,A,lda,B,ldb) bind(c, name="rocblas_dtrmm")
      use iso_c_binding
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocblas_dtrmm_orig
      type(c_ptr),value :: handle
      integer(kind(rocblas_side_left)),value :: side
      integer(kind(rocblas_fill_upper)),value :: uplo
      integer(kind(rocblas_operation_none)),value :: transA
      integer(kind(rocblas_diagonal_non_unit)),value :: diag
      integer(c_int),value :: m
      integer(c_int),value :: n
      real(c_double) :: alpha
      type(c_ptr),value :: A
      integer(c_int),value :: lda
      type(c_ptr),value :: B
      integer(c_int),value :: ldb
    end function

#ifdef USE_FPOINTER_INTERFACES
    module procedure rocblas_dtrmm_full_rank,rocblas_dtrmm_rank_0,rocblas_dtrmm_rank_1
#endif

  end interface
  
  interface rocblas_ctrmm
    function rocblas_ctrmm_orig(handle,side,uplo,transA,diag,m,n,alpha,A,lda,B,ldb) bind(c, name="rocblas_ctrmm")
      use iso_c_binding
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocblas_ctrmm_orig
      type(c_ptr),value :: handle
      integer(kind(rocblas_side_left)),value :: side
      integer(kind(rocblas_fill_upper)),value :: uplo
      integer(kind(rocblas_operation_none)),value :: transA
      integer(kind(rocblas_diagonal_non_unit)),value :: diag
      integer(c_int),value :: m
      integer(c_int),value :: n
      complex(c_float_complex) :: alpha
      type(c_ptr),value :: A
      integer(c_int),value :: lda
      type(c_ptr),value :: B
      integer(c_int),value :: ldb
    end function

#ifdef USE_FPOINTER_INTERFACES
    module procedure rocblas_ctrmm_full_rank,rocblas_ctrmm_rank_0,rocblas_ctrmm_rank_1
#endif

  end interface
  !> ! \brief BLAS Level 3 API
  !> 
  !>     \details
  !> 
  !>     trmm performs one of the matrix-matrix operations
  !> 
  !>     B := alphaop( A )B,   or   B := alphaBop( A )
  !> 
  !>     where  alpha  is a scalar,  B  is an m by n matrix,  A  is a unit, or
  !>     non-unit,  upper or lower triangular matrix  and  op( A )  is one  of
  !> 
  !>         op( A ) = A   or   op( A ) = A^T   or   op( A ) = A^H.
  !> 
  !>     @param[in]
  !>     handle    [rocblas_handle]
  !>               handle to the rocblas library context queue.
  !> 
  !>     @param[in]
  !>     side    [rocblas_side]
  !>             Specifies whether op(A) multiplies B from the left or right as follows:
  !>             rocblas_side_left:       B := alphaop( A )B.
  !>             rocblas_side_right:      B := alphaBop( A ).
  !> 
  !>     @param[in]
  !>     uplo    [rocblas_fill]
  !>             Specifies whether the matrix A is an uppoer or lower triangular matrix as follows:
  !>             rocblas_fill_upper:  A is an upper triangular matrix.
  !>             rocblas_fill_lower:  A is a  lower triangular matrix.
  !> 
  !>     @param[in]
  !>     transA  [rocblas_operation]
  !>             Specifies the form of op(A) to be used in the matrix multiplication as follows:
  !>             rocblas_operation_none:    op(A) = A.
  !>             rocblas_operation_transpose:      op(A) = A^T.
  !>             rocblas_operation_conjugate_transpose:  op(A) = A^H.
  !> 
  !>     @param[in]
  !>     diag    [rocblas_diagonal]
  !>             Specifies whether or not A is unit triangular as follows:
  !>             rocblas_diagonal_unit:      A is assumed to be unit triangular.
  !>             rocblas_diagonal_non_unit:  A is not assumed to be unit triangular.
  !> 
  !>     @param[in]
  !>     m       [rocblas_int]
  !>             m specifies the number of rows of B. m >= 0.
  !> 
  !>     @param[in]
  !>     n       [rocblas_int]
  !>             n specifies the number of columns of B. n >= 0.
  !> 
  !>     @param[in]
  !>     alpha
  !>             alpha specifies the scalar alpha. When alpha is
  !>             zero then A is not referenced and B need not be set before
  !>             entry.
  !> 
  !>     @param[in]
  !>     A       Device pointer to matrix A on the GPU.
  !>             A has dimension ( lda, k ), where k is m
  !>             when  side == rocblas_side_left  and
  !>             is  n  when  side == rocblas_side_right.
  !> 
  !>         When uplo == rocblas_fill_upper the  leading  k by k
  !>         upper triangular part of the array  A must contain the upper
  !>         triangular matrix  and the strictly lower triangular part of
  !>         A is not referenced.
  !> 
  !>         When uplo == rocblas_fill_lower the  leading  k by k
  !>         lower triangular part of the array  A must contain the lower
  !>         triangular matrix  and the strictly upper triangular part of
  !>         A is not referenced.
  !> 
  !>         Note that when  diag == rocblas_diagonal_unit  the diagonal elements of
  !>         A  are not referenced either,  but are assumed to be  unity.
  !> 
  !>     @param[in]
  !>     lda     [rocblas_int]
  !>             lda specifies the first dimension of A.
  !>             if side == rocblas_side_left,  lda >= max( 1, m ),
  !>             if side == rocblas_side_right, lda >= max( 1, n ).
  !> 
  !>     @param[in]
  !>     B       Device pointer to the first matrix B_0 on the GPU.
  !>             On entry,  the leading  m by n part of the array  B must
  !>            contain the matrix  B,  and  on exit  is overwritten  by the
  !>            transformed matrix.
  !> 
  !>     @param[in]
  !>     ldb    [rocblas_int]
  !>            ldb specifies the first dimension of B. ldb >= max( 1, m ).
  !> 
  !>     
  interface rocblas_ztrmm
    function rocblas_ztrmm_orig(handle,side,uplo,transA,diag,m,n,alpha,A,lda,B,ldb) bind(c, name="rocblas_ztrmm")
      use iso_c_binding
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocblas_ztrmm_orig
      type(c_ptr),value :: handle
      integer(kind(rocblas_side_left)),value :: side
      integer(kind(rocblas_fill_upper)),value :: uplo
      integer(kind(rocblas_operation_none)),value :: transA
      integer(kind(rocblas_diagonal_non_unit)),value :: diag
      integer(c_int),value :: m
      integer(c_int),value :: n
      complex(c_double_complex) :: alpha
      type(c_ptr),value :: A
      integer(c_int),value :: lda
      type(c_ptr),value :: B
      integer(c_int),value :: ldb
    end function

#ifdef USE_FPOINTER_INTERFACES
    module procedure rocblas_ztrmm_full_rank,rocblas_ztrmm_rank_0,rocblas_ztrmm_rank_1
#endif

  end interface
  
  interface rocblas_strmm_batched
    function rocblas_strmm_batched_orig(handle,side,uplo,transa,diag,m,n,alpha,a,lda,c,ldc,batch_count) bind(c, name="rocblas_strmm_batched")
      use iso_c_binding
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocblas_strmm_batched_orig
      type(c_ptr),value :: handle
      integer(kind(rocblas_side_left)),value :: side
      integer(kind(rocblas_fill_upper)),value :: uplo
      integer(kind(rocblas_operation_none)),value :: transa
      integer(kind(rocblas_diagonal_non_unit)),value :: diag
      integer(c_int),value :: m
      integer(c_int),value :: n
      real(c_float) :: alpha
      type(c_ptr) :: a
      integer(c_int),value :: lda
      type(c_ptr) :: c
      integer(c_int),value :: ldc
      integer(c_int),value :: batch_count
    end function


  end interface
  
  interface rocblas_dtrmm_batched
    function rocblas_dtrmm_batched_orig(handle,side,uplo,transa,diag,m,n,alpha,a,lda,c,ldc,batch_count) bind(c, name="rocblas_dtrmm_batched")
      use iso_c_binding
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocblas_dtrmm_batched_orig
      type(c_ptr),value :: handle
      integer(kind(rocblas_side_left)),value :: side
      integer(kind(rocblas_fill_upper)),value :: uplo
      integer(kind(rocblas_operation_none)),value :: transa
      integer(kind(rocblas_diagonal_non_unit)),value :: diag
      integer(c_int),value :: m
      integer(c_int),value :: n
      real(c_double) :: alpha
      type(c_ptr) :: a
      integer(c_int),value :: lda
      type(c_ptr) :: c
      integer(c_int),value :: ldc
      integer(c_int),value :: batch_count
    end function


  end interface
  
  interface rocblas_ctrmm_batched
    function rocblas_ctrmm_batched_orig(handle,side,uplo,transa,diag,m,n,alpha,a,lda,c,ldc,batch_count) bind(c, name="rocblas_ctrmm_batched")
      use iso_c_binding
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocblas_ctrmm_batched_orig
      type(c_ptr),value :: handle
      integer(kind(rocblas_side_left)),value :: side
      integer(kind(rocblas_fill_upper)),value :: uplo
      integer(kind(rocblas_operation_none)),value :: transa
      integer(kind(rocblas_diagonal_non_unit)),value :: diag
      integer(c_int),value :: m
      integer(c_int),value :: n
      complex(c_float_complex) :: alpha
      type(c_ptr) :: a
      integer(c_int),value :: lda
      type(c_ptr) :: c
      integer(c_int),value :: ldc
      integer(c_int),value :: batch_count
    end function


  end interface
  !> ! \brief BLAS Level 3 API
  !> 
  !>     \details
  !> 
  !>     trmm_batched performs one of the batched matrix-matrix operations
  !> 
  !>     B_i := alphaop( A_i )B_i,   or   B_i := alphaB_iop( A_i )  for i = 0, 1, ... batch_count -1
  !> 
  !>     where  alpha  is a scalar,  B_i  is an m by n matrix,  A_i  is a unit, or
  !>     non-unit,  upper or lower triangular matrix  and  op( A_i )  is one  of
  !> 
  !>         op( A_i ) = A_i   or   op( A_i ) = A_i^T   or   op( A_i ) = A_i^H.
  !> 
  !>     @param[in]
  !>     handle    [rocblas_handle]
  !>               handle to the rocblas library context queue.
  !> 
  !>     @param[in]
  !>     side    [rocblas_side]
  !>             Specifies whether op(A_i) multiplies B_i from the left or right as follows:
  !>             rocblas_side_left:       B_i := alphaop( A_i )B_i.
  !>             rocblas_side_right:      B_i := alphaB_iop( A_i ).
  !> 
  !>     @param[in]
  !>     uplo    [rocblas_fill]
  !>             Specifies whether the matrix A is an uppoer or lower triangular matrix as follows:
  !>             rocblas_fill_upper:  A is an upper triangular matrix.
  !>             rocblas_fill_lower:  A is a  lower triangular matrix.
  !> 
  !>     @param[in]
  !>     transA  [rocblas_operation]
  !>             Specifies the form of op(A_i) to be used in the matrix multiplication as follows:
  !>             rocblas_operation_none:    op(A_i) = A_i.
  !>             rocblas_operation_transpose:      op(A_i) = A_i^T.
  !>             rocblas_operation_conjugate_transpose:  op(A_i) = A_i^H.
  !> 
  !>     @param[in]
  !>     diag    [rocblas_diagonal]
  !>             Specifies whether or not A_i is unit triangular as follows:
  !>             rocblas_diagonal_unit:      A_i is assumed to be unit triangular.
  !>             rocblas_diagonal_non_unit:  A_i is not assumed to be unit triangular.
  !> 
  !>     @param[in]
  !>     m       [rocblas_int]
  !>             m specifies the number of rows of B_i. m >= 0.
  !> 
  !>     @param[in]
  !>     n       [rocblas_int]
  !>             n specifies the number of columns of B_i. n >= 0.
  !> 
  !>     @param[in]
  !>     alpha
  !>             alpha specifies the scalar alpha. When alpha is
  !>             zero then A_i is not referenced and B_i need not be set before
  !>             entry.
  !> 
  !>     @param[in]
  !>     A       Device array of device pointers storing each matrix A_i on the GPU.
  !>             Each A_i is of dimension ( lda, k ), where k is m
  !>             when  side == rocblas_side_left  and
  !>             is  n  when  side == rocblas_side_right.
  !> 
  !>         When uplo == rocblas_fill_upper the  leading  k by k
  !>         upper triangular part of the array  A must contain the upper
  !>         triangular matrix  and the strictly lower triangular part of
  !>         A is not referenced.
  !> 
  !>         When uplo == rocblas_fill_lower the  leading  k by k
  !>         lower triangular part of the array  A must contain the lower
  !>         triangular matrix  and the strictly upper triangular part of
  !>         A is not referenced.
  !> 
  !>         Note that when  diag == rocblas_diagonal_unit  the diagonal elements of
  !>         A_i  are not referenced either,  but are assumed to be  unity.
  !> 
  !>     @param[in]
  !>     lda     [rocblas_int]
  !>             lda specifies the first dimension of A.
  !>             if side == rocblas_side_left,  lda >= max( 1, m ),
  !>             if side == rocblas_side_right, lda >= max( 1, n ).
  !> 
  !>     @param[in]
  !>     B       device array of device pointers storing each matrix B_i on the GPU.
  !>             On entry,  the leading  m by n part of the array  B_i must
  !>            contain the matrix  B_i,  and  on exit  is overwritten  by the
  !>            transformed matrix.
  !> 
  !>     @param[in]
  !>     ldb    [rocblas_int]
  !>            ldb specifies the first dimension of B_i. ldb >= max( 1, m ).
  !> 
  !>     @param[in]
  !>     batch_count [rocblas_int]
  !>                 number of instances i in the batch.
  !>     
  interface rocblas_ztrmm_batched
    function rocblas_ztrmm_batched_orig(handle,side,uplo,transa,diag,m,n,alpha,a,lda,c,ldc,batch_count) bind(c, name="rocblas_ztrmm_batched")
      use iso_c_binding
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocblas_ztrmm_batched_orig
      type(c_ptr),value :: handle
      integer(kind(rocblas_side_left)),value :: side
      integer(kind(rocblas_fill_upper)),value :: uplo
      integer(kind(rocblas_operation_none)),value :: transa
      integer(kind(rocblas_diagonal_non_unit)),value :: diag
      integer(c_int),value :: m
      integer(c_int),value :: n
      complex(c_double_complex) :: alpha
      type(c_ptr) :: a
      integer(c_int),value :: lda
      type(c_ptr) :: c
      integer(c_int),value :: ldc
      integer(c_int),value :: batch_count
    end function


  end interface
  
  interface rocblas_strmm_strided_batched
    function rocblas_strmm_strided_batched_orig(handle,side,uplo,transa,diag,m,n,alpha,a,lda,stride_a,c,ldc,stride_c,batch_count) bind(c, name="rocblas_strmm_strided_batched")
      use iso_c_binding
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocblas_strmm_strided_batched_orig
      type(c_ptr),value :: handle
      integer(kind(rocblas_side_left)),value :: side
      integer(kind(rocblas_fill_upper)),value :: uplo
      integer(kind(rocblas_operation_none)),value :: transa
      integer(kind(rocblas_diagonal_non_unit)),value :: diag
      integer(c_int),value :: m
      integer(c_int),value :: n
      real(c_float) :: alpha
      type(c_ptr),value :: a
      integer(c_int),value :: lda
      integer(c_int64_t),value :: stride_a
      type(c_ptr),value :: c
      integer(c_int),value :: ldc
      integer(c_int64_t),value :: stride_c
      integer(c_int),value :: batch_count
    end function


  end interface
  
  interface rocblas_dtrmm_strided_batched
    function rocblas_dtrmm_strided_batched_orig(handle,side,uplo,transa,diag,m,n,alpha,a,lda,stride_a,c,ldc,stride_c,batch_count) bind(c, name="rocblas_dtrmm_strided_batched")
      use iso_c_binding
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocblas_dtrmm_strided_batched_orig
      type(c_ptr),value :: handle
      integer(kind(rocblas_side_left)),value :: side
      integer(kind(rocblas_fill_upper)),value :: uplo
      integer(kind(rocblas_operation_none)),value :: transa
      integer(kind(rocblas_diagonal_non_unit)),value :: diag
      integer(c_int),value :: m
      integer(c_int),value :: n
      real(c_double) :: alpha
      type(c_ptr),value :: a
      integer(c_int),value :: lda
      integer(c_int64_t),value :: stride_a
      type(c_ptr),value :: c
      integer(c_int),value :: ldc
      integer(c_int64_t),value :: stride_c
      integer(c_int),value :: batch_count
    end function


  end interface
  
  interface rocblas_ctrmm_strided_batched
    function rocblas_ctrmm_strided_batched_orig(handle,side,uplo,transa,diag,m,n,alpha,a,lda,stride_a,c,ldc,stride_c,batch_count) bind(c, name="rocblas_ctrmm_strided_batched")
      use iso_c_binding
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocblas_ctrmm_strided_batched_orig
      type(c_ptr),value :: handle
      integer(kind(rocblas_side_left)),value :: side
      integer(kind(rocblas_fill_upper)),value :: uplo
      integer(kind(rocblas_operation_none)),value :: transa
      integer(kind(rocblas_diagonal_non_unit)),value :: diag
      integer(c_int),value :: m
      integer(c_int),value :: n
      complex(c_float_complex) :: alpha
      type(c_ptr),value :: a
      integer(c_int),value :: lda
      integer(c_int64_t),value :: stride_a
      type(c_ptr),value :: c
      integer(c_int),value :: ldc
      integer(c_int64_t),value :: stride_c
      integer(c_int),value :: batch_count
    end function


  end interface
  !> ! \brief BLAS Level 3 API
  !> 
  !>     \details
  !> 
  !>     trmm_strided_batched performs one of the strided_batched matrix-matrix operations
  !> 
  !>     B_i := alphaop( A_i )B_i,   or   B_i := alphaB_iop( A_i )  for i = 0, 1, ... batch_count -1
  !> 
  !>     where  alpha  is a scalar,  B_i  is an m by n matrix,  A_i  is a unit, or
  !>     non-unit,  upper or lower triangular matrix  and  op( A_i )  is one  of
  !> 
  !>         op( A_i ) = A_i   or   op( A_i ) = A_i^T   or   op( A_i ) = A_i^H.
  !> 
  !>     @param[in]
  !>     handle    [rocblas_handle]
  !>               handle to the rocblas library context queue.
  !> 
  !>     @param[in]
  !>     side    [rocblas_side]
  !>             Specifies whether op(A_i) multiplies B_i from the left or right as follows:
  !>             rocblas_side_left:       B_i := alphaop( A_i )B_i.
  !>             rocblas_side_right:      B_i := alphaB_iop( A_i ).
  !> 
  !>     @param[in]
  !>     uplo    [rocblas_fill]
  !>             Specifies whether the matrix A is an uppoer or lower triangular matrix as follows:
  !>             rocblas_fill_upper:  A is an upper triangular matrix.
  !>             rocblas_fill_lower:  A is a  lower triangular matrix.
  !> 
  !>     @param[in]
  !>     transA  [rocblas_operation]
  !>             Specifies the form of op(A_i) to be used in the matrix multiplication as follows:
  !>             rocblas_operation_none:    op(A_i) = A_i.
  !>             rocblas_operation_transpose:      op(A_i) = A_i^T.
  !>             rocblas_operation_conjugate_transpose:  op(A_i) = A_i^H.
  !> 
  !>     @param[in]
  !>     diag    [rocblas_diagonal]
  !>             Specifies whether or not A_i is unit triangular as follows:
  !>             rocblas_diagonal_unit:      A_i is assumed to be unit triangular.
  !>             rocblas_diagonal_non_unit:  A_i is not assumed to be unit triangular.
  !> 
  !>     @param[in]
  !>     m       [rocblas_int]
  !>             m specifies the number of rows of B_i. m >= 0.
  !> 
  !>     @param[in]
  !>     n       [rocblas_int]
  !>             n specifies the number of columns of B_i. n >= 0.
  !> 
  !>     @param[in]
  !>     alpha
  !>             alpha specifies the scalar alpha. When alpha is
  !>             zero then A_i is not referenced and B_i need not be set before
  !>             entry.
  !> 
  !>     @param[in]
  !>     A       Device pointer to the first matrix A_0 on the GPU.
  !>             Each A_i is of dimension ( lda, k ), where k is m
  !>             when  side == rocblas_side_left  and
  !>             is  n  when  side == rocblas_side_right.
  !> 
  !>         When uplo == rocblas_fill_upper the  leading  k by k
  !>         upper triangular part of the array  A must contain the upper
  !>         triangular matrix  and the strictly lower triangular part of
  !>         A is not referenced.
  !> 
  !>         When uplo == rocblas_fill_lower the  leading  k by k
  !>         lower triangular part of the array  A must contain the lower
  !>         triangular matrix  and the strictly upper triangular part of
  !>         A is not referenced.
  !> 
  !>         Note that when  diag == rocblas_diagonal_unit  the diagonal elements of
  !>         A_i  are not referenced either,  but are assumed to be  unity.
  !> 
  !>     @param[in]
  !>     lda     [rocblas_int]
  !>             lda specifies the first dimension of A.
  !>             if side == rocblas_side_left,  lda >= max( 1, m ),
  !>             if side == rocblas_side_right, lda >= max( 1, n ).
  !> 
  !>     @param[in]
  !>     stride_A  [rocblas_stride]
  !>               stride from the start of one matrix (A_i) and the next one (A_i+1)
  !> 
  !>     @param[in]
  !>     B       Device pointer to the first matrix B_0 on the GPU.
  !>             On entry,  the leading  m by n part of the array  B_i must
  !>            contain the matrix  B_i,  and  on exit  is overwritten  by the
  !>            transformed matrix.
  !> 
  !>     @param[in]
  !>     ldb    [rocblas_int]
  !>            ldb specifies the first dimension of B_i. ldb >= max( 1, m ).
  !> 
  !>            @param[in]
  !>     stride_B  [rocblas_stride]
  !>               stride from the start of one matrix (B_i) and the next one (B_i+1)
  !>     @param[in]
  !>     batch_count [rocblas_int]
  !>                 number of instances i in the batch.
  !>     
  interface rocblas_ztrmm_strided_batched
    function rocblas_ztrmm_strided_batched_orig(handle,side,uplo,transa,diag,m,n,alpha,a,lda,stride_a,c,ldc,stride_c,batch_count) bind(c, name="rocblas_ztrmm_strided_batched")
      use iso_c_binding
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocblas_ztrmm_strided_batched_orig
      type(c_ptr),value :: handle
      integer(kind(rocblas_side_left)),value :: side
      integer(kind(rocblas_fill_upper)),value :: uplo
      integer(kind(rocblas_operation_none)),value :: transa
      integer(kind(rocblas_diagonal_non_unit)),value :: diag
      integer(c_int),value :: m
      integer(c_int),value :: n
      complex(c_double_complex) :: alpha
      type(c_ptr),value :: a
      integer(c_int),value :: lda
      integer(c_int64_t),value :: stride_a
      type(c_ptr),value :: c
      integer(c_int),value :: ldc
      integer(c_int64_t),value :: stride_c
      integer(c_int),value :: batch_count
    end function


  end interface
  
  interface rocblas_strtri
    function rocblas_strtri_orig(handle,uplo,diag,n,A,lda,invA,ldinvA) bind(c, name="rocblas_strtri")
      use iso_c_binding
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocblas_strtri_orig
      type(c_ptr),value :: handle
      integer(kind(rocblas_fill_upper)),value :: uplo
      integer(kind(rocblas_diagonal_non_unit)),value :: diag
      integer(c_int),value :: n
      type(c_ptr),value :: A
      integer(c_int),value :: lda
      type(c_ptr),value :: invA
      integer(c_int),value :: ldinvA
    end function

#ifdef USE_FPOINTER_INTERFACES
    module procedure rocblas_strtri_full_rank,rocblas_strtri_rank_0,rocblas_strtri_rank_1
#endif

  end interface
  
  interface rocblas_dtrtri
    function rocblas_dtrtri_orig(handle,uplo,diag,n,A,lda,invA,ldinvA) bind(c, name="rocblas_dtrtri")
      use iso_c_binding
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocblas_dtrtri_orig
      type(c_ptr),value :: handle
      integer(kind(rocblas_fill_upper)),value :: uplo
      integer(kind(rocblas_diagonal_non_unit)),value :: diag
      integer(c_int),value :: n
      type(c_ptr),value :: A
      integer(c_int),value :: lda
      type(c_ptr),value :: invA
      integer(c_int),value :: ldinvA
    end function

#ifdef USE_FPOINTER_INTERFACES
    module procedure rocblas_dtrtri_full_rank,rocblas_dtrtri_rank_0,rocblas_dtrtri_rank_1
#endif

  end interface
  
  interface rocblas_ctrtri
    function rocblas_ctrtri_orig(handle,uplo,diag,n,A,lda,invA,ldinvA) bind(c, name="rocblas_ctrtri")
      use iso_c_binding
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocblas_ctrtri_orig
      type(c_ptr),value :: handle
      integer(kind(rocblas_fill_upper)),value :: uplo
      integer(kind(rocblas_diagonal_non_unit)),value :: diag
      integer(c_int),value :: n
      type(c_ptr),value :: A
      integer(c_int),value :: lda
      type(c_ptr),value :: invA
      integer(c_int),value :: ldinvA
    end function

#ifdef USE_FPOINTER_INTERFACES
    module procedure rocblas_ctrtri_full_rank,rocblas_ctrtri_rank_0,rocblas_ctrtri_rank_1
#endif

  end interface
  !> ! \brief BLAS Level 3 API
  !> 
  !>     \details
  !>     trtri  compute the inverse of a matrix A, namely, invA
  !> 
  !>         and write the result into invA;
  !> 
  !>     @param[in]
  !>     handle    [rocblas_handle]
  !>               handle to the rocblas library context queue.
  !>     @param[in]
  !>     uplo      [rocblas_fill]
  !>               specifies whether the upper 'rocblas_fill_upper' or lower 'rocblas_fill_lower'
  !>               if rocblas_fill_upper, the lower part of A is not referenced
  !>               if rocblas_fill_lower, the upper part of A is not referenced
  !>     @param[in]
  !>     diag      [rocblas_diagonal]
  !>               = 'rocblas_diagonal_non_unit', A is non-unit triangular;
  !>               = 'rocblas_diagonal_unit', A is unit triangular;
  !>     @param[in]
  !>     n         [rocblas_int]
  !>               size of matrix A and invA
  !>     @param[in]
  !>     A         device pointer storing matrix A.
  !>     @param[in]
  !>     lda       [rocblas_int]
  !>               specifies the leading dimension of A.
  !>     @param[out]
  !>     invA      device pointer storing matrix invA.
  !>     @param[in]
  !>     ldinvA    [rocblas_int]
  !>               specifies the leading dimension of invA.
  !> 
  !> 
  interface rocblas_ztrtri
    function rocblas_ztrtri_orig(handle,uplo,diag,n,A,lda,invA,ldinvA) bind(c, name="rocblas_ztrtri")
      use iso_c_binding
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocblas_ztrtri_orig
      type(c_ptr),value :: handle
      integer(kind(rocblas_fill_upper)),value :: uplo
      integer(kind(rocblas_diagonal_non_unit)),value :: diag
      integer(c_int),value :: n
      type(c_ptr),value :: A
      integer(c_int),value :: lda
      type(c_ptr),value :: invA
      integer(c_int),value :: ldinvA
    end function

#ifdef USE_FPOINTER_INTERFACES
    module procedure rocblas_ztrtri_full_rank,rocblas_ztrtri_rank_0,rocblas_ztrtri_rank_1
#endif

  end interface
  
  interface rocblas_strtri_batched
    function rocblas_strtri_batched_orig(handle,uplo,diag,n,A,lda,invA,ldinvA,batch_count) bind(c, name="rocblas_strtri_batched")
      use iso_c_binding
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocblas_strtri_batched_orig
      type(c_ptr),value :: handle
      integer(kind(rocblas_fill_upper)),value :: uplo
      integer(kind(rocblas_diagonal_non_unit)),value :: diag
      integer(c_int),value :: n
      type(c_ptr) :: A
      integer(c_int),value :: lda
      type(c_ptr) :: invA
      integer(c_int),value :: ldinvA
      integer(c_int),value :: batch_count
    end function

#ifdef USE_FPOINTER_INTERFACES
    module procedure rocblas_strtri_batched_full_rank,rocblas_strtri_batched_rank_0,rocblas_strtri_batched_rank_1
#endif

  end interface
  
  interface rocblas_dtrtri_batched
    function rocblas_dtrtri_batched_orig(handle,uplo,diag,n,A,lda,invA,ldinvA,batch_count) bind(c, name="rocblas_dtrtri_batched")
      use iso_c_binding
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocblas_dtrtri_batched_orig
      type(c_ptr),value :: handle
      integer(kind(rocblas_fill_upper)),value :: uplo
      integer(kind(rocblas_diagonal_non_unit)),value :: diag
      integer(c_int),value :: n
      type(c_ptr) :: A
      integer(c_int),value :: lda
      type(c_ptr) :: invA
      integer(c_int),value :: ldinvA
      integer(c_int),value :: batch_count
    end function

#ifdef USE_FPOINTER_INTERFACES
    module procedure rocblas_dtrtri_batched_full_rank,rocblas_dtrtri_batched_rank_0,rocblas_dtrtri_batched_rank_1
#endif

  end interface
  
  interface rocblas_ctrtri_batched
    function rocblas_ctrtri_batched_orig(handle,uplo,diag,n,A,lda,invA,ldinvA,batch_count) bind(c, name="rocblas_ctrtri_batched")
      use iso_c_binding
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocblas_ctrtri_batched_orig
      type(c_ptr),value :: handle
      integer(kind(rocblas_fill_upper)),value :: uplo
      integer(kind(rocblas_diagonal_non_unit)),value :: diag
      integer(c_int),value :: n
      type(c_ptr) :: A
      integer(c_int),value :: lda
      type(c_ptr) :: invA
      integer(c_int),value :: ldinvA
      integer(c_int),value :: batch_count
    end function

#ifdef USE_FPOINTER_INTERFACES
    module procedure rocblas_ctrtri_batched_full_rank,rocblas_ctrtri_batched_rank_0,rocblas_ctrtri_batched_rank_1
#endif

  end interface
  !> ! \brief BLAS Level 3 API
  !> 
  !>     \details
  !>     trtri_batched  compute the inverse of A_i and write into invA_i where
  !>                    A_i and invA_i are the i-th matrices in the batch,
  !>                    for i = 1, ..., batch_count.
  !> 
  !>     @param[in]
  !>     handle    [rocblas_handle]
  !>               handle to the rocblas library context queue.
  !>     @param[in]
  !>     uplo      [rocblas_fill]
  !>               specifies whether the upper 'rocblas_fill_upper' or lower 'rocblas_fill_lower'
  !>     @param[in]
  !>     diag      [rocblas_diagonal]
  !>               = 'rocblas_diagonal_non_unit', A is non-unit triangular;
  !>               = 'rocblas_diagonal_unit', A is unit triangular;
  !>     @param[in]
  !>     n         [rocblas_int]
  !>     @param[in]
  !>     A         device array of device pointers storing each matrix A_i.
  !>     @param[in]
  !>     lda       [rocblas_int]
  !>               specifies the leading dimension of each A_i.
  !>     @param[out]
  !>     invA      device array of device pointers storing the inverse of each matrix A_i.
  !>               Partial inplace operation is supported, see below.
  !>               If UPLO = 'U', the leading N-by-N upper triangular part of the invA will store
  !>               the inverse of the upper triangular matrix, and the strictly lower
  !>               triangular part of invA is cleared.
  !>               If UPLO = 'L', the leading N-by-N lower triangular part of the invA will store
  !>               the inverse of the lower triangular matrix, and the strictly upper
  !>               triangular part of invA is cleared.
  !>     @param[in]
  !>     ldinvA    [rocblas_int]
  !>               specifies the leading dimension of each invA_i.
  !>     @param[in]
  !>     batch_count [rocblas_int]
  !>               numbers of matrices in the batch
  !>     
  interface rocblas_ztrtri_batched
    function rocblas_ztrtri_batched_orig(handle,uplo,diag,n,A,lda,invA,ldinvA,batch_count) bind(c, name="rocblas_ztrtri_batched")
      use iso_c_binding
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocblas_ztrtri_batched_orig
      type(c_ptr),value :: handle
      integer(kind(rocblas_fill_upper)),value :: uplo
      integer(kind(rocblas_diagonal_non_unit)),value :: diag
      integer(c_int),value :: n
      type(c_ptr) :: A
      integer(c_int),value :: lda
      type(c_ptr) :: invA
      integer(c_int),value :: ldinvA
      integer(c_int),value :: batch_count
    end function

#ifdef USE_FPOINTER_INTERFACES
    module procedure rocblas_ztrtri_batched_full_rank,rocblas_ztrtri_batched_rank_0,rocblas_ztrtri_batched_rank_1
#endif

  end interface
  
  interface rocblas_strtri_strided_batched
    function rocblas_strtri_strided_batched_orig(handle,uplo,diag,n,A,lda,stride_a,invA,ldinvA,stride_invA,batch_count) bind(c, name="rocblas_strtri_strided_batched")
      use iso_c_binding
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocblas_strtri_strided_batched_orig
      type(c_ptr),value :: handle
      integer(kind(rocblas_fill_upper)),value :: uplo
      integer(kind(rocblas_diagonal_non_unit)),value :: diag
      integer(c_int),value :: n
      type(c_ptr),value :: A
      integer(c_int),value :: lda
      integer(c_int64_t),value :: stride_a
      type(c_ptr),value :: invA
      integer(c_int),value :: ldinvA
      integer(c_int64_t),value :: stride_invA
      integer(c_int),value :: batch_count
    end function

#ifdef USE_FPOINTER_INTERFACES
    module procedure rocblas_strtri_strided_batched_full_rank,rocblas_strtri_strided_batched_rank_0,rocblas_strtri_strided_batched_rank_1
#endif

  end interface
  
  interface rocblas_dtrtri_strided_batched
    function rocblas_dtrtri_strided_batched_orig(handle,uplo,diag,n,A,lda,stride_a,invA,ldinvA,stride_invA,batch_count) bind(c, name="rocblas_dtrtri_strided_batched")
      use iso_c_binding
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocblas_dtrtri_strided_batched_orig
      type(c_ptr),value :: handle
      integer(kind(rocblas_fill_upper)),value :: uplo
      integer(kind(rocblas_diagonal_non_unit)),value :: diag
      integer(c_int),value :: n
      type(c_ptr),value :: A
      integer(c_int),value :: lda
      integer(c_int64_t),value :: stride_a
      type(c_ptr),value :: invA
      integer(c_int),value :: ldinvA
      integer(c_int64_t),value :: stride_invA
      integer(c_int),value :: batch_count
    end function

#ifdef USE_FPOINTER_INTERFACES
    module procedure rocblas_dtrtri_strided_batched_full_rank,rocblas_dtrtri_strided_batched_rank_0,rocblas_dtrtri_strided_batched_rank_1
#endif

  end interface
  
  interface rocblas_ctrtri_strided_batched
    function rocblas_ctrtri_strided_batched_orig(handle,uplo,diag,n,A,lda,stride_a,invA,ldinvA,stride_invA,batch_count) bind(c, name="rocblas_ctrtri_strided_batched")
      use iso_c_binding
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocblas_ctrtri_strided_batched_orig
      type(c_ptr),value :: handle
      integer(kind(rocblas_fill_upper)),value :: uplo
      integer(kind(rocblas_diagonal_non_unit)),value :: diag
      integer(c_int),value :: n
      type(c_ptr),value :: A
      integer(c_int),value :: lda
      integer(c_int64_t),value :: stride_a
      type(c_ptr),value :: invA
      integer(c_int),value :: ldinvA
      integer(c_int64_t),value :: stride_invA
      integer(c_int),value :: batch_count
    end function

#ifdef USE_FPOINTER_INTERFACES
    module procedure rocblas_ctrtri_strided_batched_full_rank,rocblas_ctrtri_strided_batched_rank_0,rocblas_ctrtri_strided_batched_rank_1
#endif

  end interface
  !> ! \brief BLAS Level 3 API
  !> 
  !>     \details
  !>     trtri_strided_batched compute the inverse of A_i and write into invA_i where
  !>                    A_i and invA_i are the i-th matrices in the batch,
  !>                    for i = 1, ..., batch_count
  !> 
  !>     @param[in]
  !>     handle    [rocblas_handle]
  !>               handle to the rocblas library context queue.
  !>     @param[in]
  !>     uplo      [rocblas_fill]
  !>               specifies whether the upper 'rocblas_fill_upper' or lower 'rocblas_fill_lower'
  !>     @param[in]
  !>     diag      [rocblas_diagonal]
  !>               = 'rocblas_diagonal_non_unit', A is non-unit triangular;
  !>               = 'rocblas_diagonal_unit', A is unit triangular;
  !>     @param[in]
  !>     n         [rocblas_int]
  !>     @param[in]
  !>     A         device pointer pointing to address of first matrix A_1.
  !>     @param[in]
  !>     lda       [rocblas_int]
  !>               specifies the leading dimension of each A.
  !>     @param[in]
  !>     stride_a  [rocblas_stride]
  !>              "batch stride a": stride from the start of one A_i matrix to the next A_(i + 1).
  !>     @param[out]
  !>     invA      device pointer storing the inverses of each matrix A_i.
  !>               Partial inplace operation is supported, see below.
  !>               If UPLO = 'U', the leading N-by-N upper triangular part of the invA will store
  !>               the inverse of the upper triangular matrix, and the strictly lower
  !>               triangular part of invA is cleared.
  !>               If UPLO = 'L', the leading N-by-N lower triangular part of the invA will store
  !>               the inverse of the lower triangular matrix, and the strictly upper
  !>               triangular part of invA is cleared.
  !>     @param[in]
  !>     ldinvA    [rocblas_int]
  !>               specifies the leading dimension of each invA_i.
  !>     @param[in]
  !>     stride_invA  [rocblas_stride]
  !>                  "batch stride invA": stride from the start of one invA_i matrix to the next invA_(i + 1).
  !>     @param[in]
  !>     batch_count  [rocblas_int]
  !>                  numbers of matrices in the batch
  !>     
  interface rocblas_ztrtri_strided_batched
    function rocblas_ztrtri_strided_batched_orig(handle,uplo,diag,n,A,lda,stride_a,invA,ldinvA,stride_invA,batch_count) bind(c, name="rocblas_ztrtri_strided_batched")
      use iso_c_binding
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocblas_ztrtri_strided_batched_orig
      type(c_ptr),value :: handle
      integer(kind(rocblas_fill_upper)),value :: uplo
      integer(kind(rocblas_diagonal_non_unit)),value :: diag
      integer(c_int),value :: n
      type(c_ptr),value :: A
      integer(c_int),value :: lda
      integer(c_int64_t),value :: stride_a
      type(c_ptr),value :: invA
      integer(c_int),value :: ldinvA
      integer(c_int64_t),value :: stride_invA
      integer(c_int),value :: batch_count
    end function

#ifdef USE_FPOINTER_INTERFACES
    module procedure rocblas_ztrtri_strided_batched_full_rank,rocblas_ztrtri_strided_batched_rank_0,rocblas_ztrtri_strided_batched_rank_1
#endif

  end interface
  
  interface rocblas_strsm
    function rocblas_strsm_orig(handle,side,uplo,transA,diag,m,n,alpha,A,lda,B,ldb) bind(c, name="rocblas_strsm")
      use iso_c_binding
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocblas_strsm_orig
      type(c_ptr),value :: handle
      integer(kind(rocblas_side_left)),value :: side
      integer(kind(rocblas_fill_upper)),value :: uplo
      integer(kind(rocblas_operation_none)),value :: transA
      integer(kind(rocblas_diagonal_non_unit)),value :: diag
      integer(c_int),value :: m
      integer(c_int),value :: n
      real(c_float) :: alpha
      type(c_ptr),value :: A
      integer(c_int),value :: lda
      type(c_ptr),value :: B
      integer(c_int),value :: ldb
    end function

#ifdef USE_FPOINTER_INTERFACES
    module procedure rocblas_strsm_full_rank,rocblas_strsm_rank_0,rocblas_strsm_rank_1
#endif

  end interface
  
  interface rocblas_dtrsm
    function rocblas_dtrsm_orig(handle,side,uplo,transA,diag,m,n,alpha,A,lda,B,ldb) bind(c, name="rocblas_dtrsm")
      use iso_c_binding
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocblas_dtrsm_orig
      type(c_ptr),value :: handle
      integer(kind(rocblas_side_left)),value :: side
      integer(kind(rocblas_fill_upper)),value :: uplo
      integer(kind(rocblas_operation_none)),value :: transA
      integer(kind(rocblas_diagonal_non_unit)),value :: diag
      integer(c_int),value :: m
      integer(c_int),value :: n
      real(c_double) :: alpha
      type(c_ptr),value :: A
      integer(c_int),value :: lda
      type(c_ptr),value :: B
      integer(c_int),value :: ldb
    end function

#ifdef USE_FPOINTER_INTERFACES
    module procedure rocblas_dtrsm_full_rank,rocblas_dtrsm_rank_0,rocblas_dtrsm_rank_1
#endif

  end interface
  
  interface rocblas_ctrsm
    function rocblas_ctrsm_orig(handle,side,uplo,transA,diag,m,n,alpha,A,lda,B,ldb) bind(c, name="rocblas_ctrsm")
      use iso_c_binding
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocblas_ctrsm_orig
      type(c_ptr),value :: handle
      integer(kind(rocblas_side_left)),value :: side
      integer(kind(rocblas_fill_upper)),value :: uplo
      integer(kind(rocblas_operation_none)),value :: transA
      integer(kind(rocblas_diagonal_non_unit)),value :: diag
      integer(c_int),value :: m
      integer(c_int),value :: n
      complex(c_float_complex) :: alpha
      type(c_ptr),value :: A
      integer(c_int),value :: lda
      type(c_ptr),value :: B
      integer(c_int),value :: ldb
    end function

#ifdef USE_FPOINTER_INTERFACES
    module procedure rocblas_ctrsm_full_rank,rocblas_ctrsm_rank_0,rocblas_ctrsm_rank_1
#endif

  end interface
  !> ! \brief BLAS Level 3 API
  !> 
  !>     \details
  !> 
  !>     trsm solves
  !> 
  !>         op(A)X = alphaB or  Xop(A) = alphaB,
  !> 
  !>     where alpha is a scalar, X and B are m by n matrices,
  !>     A is triangular matrix and op(A) is one of
  !> 
  !>         op( A ) = A   or   op( A ) = A^T   or   op( A ) = A^H.
  !> 
  !>     The matrix X is overwritten on B.
  !> 
  !>     Note about memory allocation:
  !>     When trsm is launched with a k evenly divisible by the internal block size of 128,
  !>     and is no larger than 10 of these blocks, the API takes advantage of utilizing pre-allocated
  !>     memory found in the handle to increase overall performance. This memory can be managed by using
  !>     the environment variable WORKBUF_TRSM_B_CHNK. When this variable is not set the device memory
  !>     used for temporary storage will default to 1 MB and may result in chunking, which in turn may
  !>     reduce performance. Under these circumstances it is recommended that WORKBUF_TRSM_B_CHNK be set
  !>     to the desired chunk of right hand sides to be used at a time.
  !> 
  !>     (where k is m when rocblas_side_left and is n when rocblas_side_right)
  !> 
  !>     @param[in]
  !>     handle    [rocblas_handle]
  !>               handle to the rocblas library context queue.
  !> 
  !>     @param[in]
  !>     side    [rocblas_side]
  !>             rocblas_side_left:       op(A)X = alphaB.
  !>             rocblas_side_right:      Xop(A) = alphaB.
  !> 
  !>     @param[in]
  !>     uplo    [rocblas_fill]
  !>             rocblas_fill_upper:  A is an upper triangular matrix.
  !>             rocblas_fill_lower:  A is a  lower triangular matrix.
  !> 
  !>     @param[in]
  !>     transA  [rocblas_operation]
  !>             transB:    op(A) = A.
  !>             rocblas_operation_transpose:      op(A) = A^T.
  !>             rocblas_operation_conjugate_transpose:  op(A) = A^H.
  !> 
  !>     @param[in]
  !>     diag    [rocblas_diagonal]
  !>             rocblas_diagonal_unit:     A is assumed to be unit triangular.
  !>             rocblas_diagonal_non_unit:  A is not assumed to be unit triangular.
  !> 
  !>     @param[in]
  !>     m       [rocblas_int]
  !>             m specifies the number of rows of B. m >= 0.
  !> 
  !>     @param[in]
  !>     n       [rocblas_int]
  !>             n specifies the number of columns of B. n >= 0.
  !> 
  !>     @param[in]
  !>     alpha
  !>             device pointer or host pointer specifying the scalar alpha. When alpha is
  !>             &zero then A is not referenced and B need not be set before
  !>             entry.
  !> 
  !>     @param[in]
  !>     A       device pointer storing matrix A.
  !>             of dimension ( lda, k ), where k is m
  !>             when  rocblas_side_left  and
  !>             is  n  when  rocblas_side_right
  !>             only the upperlower triangular part is accessed.
  !> 
  !>     @param[in]
  !>     lda     [rocblas_int]
  !>             lda specifies the first dimension of A.
  !>             if side = rocblas_side_left,  lda >= max( 1, m ),
  !>             if side = rocblas_side_right, lda >= max( 1, n ).
  !> 
  !>     @param[in,out]
  !>     B       device pointer storing matrix B.
  !> 
  !>     @param[in]
  !>     ldb    [rocblas_int]
  !>            ldb specifies the first dimension of B. ldb >= max( 1, m ).
  !> 
  !>     
  interface rocblas_ztrsm
    function rocblas_ztrsm_orig(handle,side,uplo,transA,diag,m,n,alpha,A,lda,B,ldb) bind(c, name="rocblas_ztrsm")
      use iso_c_binding
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocblas_ztrsm_orig
      type(c_ptr),value :: handle
      integer(kind(rocblas_side_left)),value :: side
      integer(kind(rocblas_fill_upper)),value :: uplo
      integer(kind(rocblas_operation_none)),value :: transA
      integer(kind(rocblas_diagonal_non_unit)),value :: diag
      integer(c_int),value :: m
      integer(c_int),value :: n
      complex(c_double_complex) :: alpha
      type(c_ptr),value :: A
      integer(c_int),value :: lda
      type(c_ptr),value :: B
      integer(c_int),value :: ldb
    end function

#ifdef USE_FPOINTER_INTERFACES
    module procedure rocblas_ztrsm_full_rank,rocblas_ztrsm_rank_0,rocblas_ztrsm_rank_1
#endif

  end interface
  
  interface rocblas_strsm_batched
    function rocblas_strsm_batched_orig(handle,side,uplo,transA,diag,m,n,alpha,A,lda,B,ldb,batch_count) bind(c, name="rocblas_strsm_batched")
      use iso_c_binding
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocblas_strsm_batched_orig
      type(c_ptr),value :: handle
      integer(kind(rocblas_side_left)),value :: side
      integer(kind(rocblas_fill_upper)),value :: uplo
      integer(kind(rocblas_operation_none)),value :: transA
      integer(kind(rocblas_diagonal_non_unit)),value :: diag
      integer(c_int),value :: m
      integer(c_int),value :: n
      real(c_float) :: alpha
      type(c_ptr) :: A
      integer(c_int),value :: lda
      type(c_ptr) :: B
      integer(c_int),value :: ldb
      integer(c_int),value :: batch_count
    end function

#ifdef USE_FPOINTER_INTERFACES
    module procedure rocblas_strsm_batched_full_rank,rocblas_strsm_batched_rank_0,rocblas_strsm_batched_rank_1
#endif

  end interface
  
  interface rocblas_dtrsm_batched
    function rocblas_dtrsm_batched_orig(handle,side,uplo,transA,diag,m,n,alpha,A,lda,B,ldb,batch_count) bind(c, name="rocblas_dtrsm_batched")
      use iso_c_binding
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocblas_dtrsm_batched_orig
      type(c_ptr),value :: handle
      integer(kind(rocblas_side_left)),value :: side
      integer(kind(rocblas_fill_upper)),value :: uplo
      integer(kind(rocblas_operation_none)),value :: transA
      integer(kind(rocblas_diagonal_non_unit)),value :: diag
      integer(c_int),value :: m
      integer(c_int),value :: n
      real(c_double) :: alpha
      type(c_ptr) :: A
      integer(c_int),value :: lda
      type(c_ptr) :: B
      integer(c_int),value :: ldb
      integer(c_int),value :: batch_count
    end function

#ifdef USE_FPOINTER_INTERFACES
    module procedure rocblas_dtrsm_batched_full_rank,rocblas_dtrsm_batched_rank_0,rocblas_dtrsm_batched_rank_1
#endif

  end interface
  
  interface rocblas_ctrsm_batched
    function rocblas_ctrsm_batched_orig(handle,side,uplo,transA,diag,m,n,alpha,A,lda,B,ldb,batch_count) bind(c, name="rocblas_ctrsm_batched")
      use iso_c_binding
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocblas_ctrsm_batched_orig
      type(c_ptr),value :: handle
      integer(kind(rocblas_side_left)),value :: side
      integer(kind(rocblas_fill_upper)),value :: uplo
      integer(kind(rocblas_operation_none)),value :: transA
      integer(kind(rocblas_diagonal_non_unit)),value :: diag
      integer(c_int),value :: m
      integer(c_int),value :: n
      complex(c_float_complex) :: alpha
      type(c_ptr) :: A
      integer(c_int),value :: lda
      type(c_ptr) :: B
      integer(c_int),value :: ldb
      integer(c_int),value :: batch_count
    end function

#ifdef USE_FPOINTER_INTERFACES
    module procedure rocblas_ctrsm_batched_full_rank,rocblas_ctrsm_batched_rank_0,rocblas_ctrsm_batched_rank_1
#endif

  end interface
  !> ! \brief BLAS Level 3 API
  !>     \details
  !>     trsm_batched performs the following batched operation:
  !> 
  !>         op(A_i)X_i = alphaB_i or  X_iop(A_i) = alphaB_i, for i = 1, ..., batch_count.
  !> 
  !>     where alpha is a scalar, X and B are batched m by n matrices,
  !>     A is triangular batched matrix and op(A) is one of
  !> 
  !>         op( A ) = A   or   op( A ) = A^T   or   op( A ) = A^H.
  !> 
  !>     Each matrix X_i is overwritten on B_i for i = 1, ..., batch_count.
  !> 
  !>     Note about memory allocation:
  !>     When trsm is launched with a k evenly divisible by the internal block size of 128,
  !>     and is no larger than 10 of these blocks, the API takes advantage of utilizing pre-allocated
  !>     memory found in the handle to increase overall performance. This memory can be managed by using
  !>     the environment variable WORKBUF_TRSM_B_CHNK. When this variable is not set the device memory
  !>     used for temporary storage will default to 1 MB and may result in chunking, which in turn may
  !>     reduce performance. Under these circumstances it is recommended that WORKBUF_TRSM_B_CHNK be set
  !>     to the desired chunk of right hand sides to be used at a time.
  !>     (where k is m when rocblas_side_left and is n when rocblas_side_right)
  !> 
  !>     @param[in]
  !>     handle    [rocblas_handle]
  !>               handle to the rocblas library context queue.
  !>     @param[in]
  !>     side    [rocblas_side]
  !>             rocblas_side_left:       op(A)X = alphaB.
  !>             rocblas_side_right:      Xop(A) = alphaB.
  !>     @param[in]
  !>     uplo    [rocblas_fill]
  !>             rocblas_fill_upper:  each A_i is an upper triangular matrix.
  !>             rocblas_fill_lower:  each A_i is a  lower triangular matrix.
  !>     @param[in]
  !>     transA  [rocblas_operation]
  !>             transB:    op(A) = A.
  !>             rocblas_operation_transpose:      op(A) = A^T.
  !>             rocblas_operation_conjugate_transpose:  op(A) = A^H.
  !>     @param[in]
  !>     diag    [rocblas_diagonal]
  !>             rocblas_diagonal_unit:     each A_i is assumed to be unit triangular.
  !>             rocblas_diagonal_non_unit:  each A_i is not assumed to be unit triangular.
  !>     @param[in]
  !>     m       [rocblas_int]
  !>             m specifies the number of rows of each B_i. m >= 0.
  !>     @param[in]
  !>     n       [rocblas_int]
  !>             n specifies the number of columns of each B_i. n >= 0.
  !>     @param[in]
  !>     alpha
  !>             device pointer or host pointer specifying the scalar alpha. When alpha is
  !>             &zero then A is not referenced and B need not be set before
  !>             entry.
  !>     @param[in]
  !>     A       device array of device pointers storing each matrix A_i on the GPU.
  !>             Matricies are of dimension ( lda, k ), where k is m
  !>             when  rocblas_side_left  and is  n  when  rocblas_side_right
  !>             only the upperlower triangular part is accessed.
  !>     @param[in]
  !>     lda     [rocblas_int]
  !>             lda specifies the first dimension of each A_i.
  !>             if side = rocblas_side_left,  lda >= max( 1, m ),
  !>             if side = rocblas_side_right, lda >= max( 1, n ).
  !>     @param[in,out]
  !>     B       device array of device pointers storing each matrix B_i on the GPU.
  !>     @param[in]
  !>     ldb    [rocblas_int]
  !>            ldb specifies the first dimension of each B_i. ldb >= max( 1, m ).
  !>     @param[in]
  !>     batch_count [rocblas_int]
  !>                 number of trsm operatons in the batch.
  !>     
  interface rocblas_ztrsm_batched
    function rocblas_ztrsm_batched_orig(handle,side,uplo,transA,diag,m,n,alpha,A,lda,B,ldb,batch_count) bind(c, name="rocblas_ztrsm_batched")
      use iso_c_binding
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocblas_ztrsm_batched_orig
      type(c_ptr),value :: handle
      integer(kind(rocblas_side_left)),value :: side
      integer(kind(rocblas_fill_upper)),value :: uplo
      integer(kind(rocblas_operation_none)),value :: transA
      integer(kind(rocblas_diagonal_non_unit)),value :: diag
      integer(c_int),value :: m
      integer(c_int),value :: n
      complex(c_double_complex) :: alpha
      type(c_ptr) :: A
      integer(c_int),value :: lda
      type(c_ptr) :: B
      integer(c_int),value :: ldb
      integer(c_int),value :: batch_count
    end function

#ifdef USE_FPOINTER_INTERFACES
    module procedure rocblas_ztrsm_batched_full_rank,rocblas_ztrsm_batched_rank_0,rocblas_ztrsm_batched_rank_1
#endif

  end interface
  
  interface rocblas_strsm_strided_batched
    function rocblas_strsm_strided_batched_orig(handle,side,uplo,transA,diag,m,n,alpha,A,lda,stride_a,B,ldb,stride_b,batch_count) bind(c, name="rocblas_strsm_strided_batched")
      use iso_c_binding
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocblas_strsm_strided_batched_orig
      type(c_ptr),value :: handle
      integer(kind(rocblas_side_left)),value :: side
      integer(kind(rocblas_fill_upper)),value :: uplo
      integer(kind(rocblas_operation_none)),value :: transA
      integer(kind(rocblas_diagonal_non_unit)),value :: diag
      integer(c_int),value :: m
      integer(c_int),value :: n
      real(c_float) :: alpha
      type(c_ptr),value :: A
      integer(c_int),value :: lda
      integer(c_int64_t),value :: stride_a
      type(c_ptr),value :: B
      integer(c_int),value :: ldb
      integer(c_int64_t),value :: stride_b
      integer(c_int),value :: batch_count
    end function

#ifdef USE_FPOINTER_INTERFACES
    module procedure rocblas_strsm_strided_batched_full_rank,rocblas_strsm_strided_batched_rank_0,rocblas_strsm_strided_batched_rank_1
#endif

  end interface
  
  interface rocblas_dtrsm_strided_batched
    function rocblas_dtrsm_strided_batched_orig(handle,side,uplo,transA,diag,m,n,alpha,A,lda,stride_a,B,ldb,stride_b,batch_count) bind(c, name="rocblas_dtrsm_strided_batched")
      use iso_c_binding
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocblas_dtrsm_strided_batched_orig
      type(c_ptr),value :: handle
      integer(kind(rocblas_side_left)),value :: side
      integer(kind(rocblas_fill_upper)),value :: uplo
      integer(kind(rocblas_operation_none)),value :: transA
      integer(kind(rocblas_diagonal_non_unit)),value :: diag
      integer(c_int),value :: m
      integer(c_int),value :: n
      real(c_double) :: alpha
      type(c_ptr),value :: A
      integer(c_int),value :: lda
      integer(c_int64_t),value :: stride_a
      type(c_ptr),value :: B
      integer(c_int),value :: ldb
      integer(c_int64_t),value :: stride_b
      integer(c_int),value :: batch_count
    end function

#ifdef USE_FPOINTER_INTERFACES
    module procedure rocblas_dtrsm_strided_batched_full_rank,rocblas_dtrsm_strided_batched_rank_0,rocblas_dtrsm_strided_batched_rank_1
#endif

  end interface
  
  interface rocblas_ctrsm_strided_batched
    function rocblas_ctrsm_strided_batched_orig(handle,side,uplo,transA,diag,m,n,alpha,A,lda,stride_a,B,ldb,stride_b,batch_count) bind(c, name="rocblas_ctrsm_strided_batched")
      use iso_c_binding
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocblas_ctrsm_strided_batched_orig
      type(c_ptr),value :: handle
      integer(kind(rocblas_side_left)),value :: side
      integer(kind(rocblas_fill_upper)),value :: uplo
      integer(kind(rocblas_operation_none)),value :: transA
      integer(kind(rocblas_diagonal_non_unit)),value :: diag
      integer(c_int),value :: m
      integer(c_int),value :: n
      complex(c_float_complex) :: alpha
      type(c_ptr),value :: A
      integer(c_int),value :: lda
      integer(c_int64_t),value :: stride_a
      type(c_ptr),value :: B
      integer(c_int),value :: ldb
      integer(c_int64_t),value :: stride_b
      integer(c_int),value :: batch_count
    end function

#ifdef USE_FPOINTER_INTERFACES
    module procedure rocblas_ctrsm_strided_batched_full_rank,rocblas_ctrsm_strided_batched_rank_0,rocblas_ctrsm_strided_batched_rank_1
#endif

  end interface
  !> ! \brief BLAS Level 3 API
  !>     \details
  !>     trsm_srided_batched performs the following strided batched operation:
  !> 
  !>         op(A_i)X_i = alphaB_i or  X_iop(A_i) = alphaB_i, for i = 1, ..., batch_count.
  !> 
  !>     where alpha is a scalar, X and B are strided batched m by n matrices,
  !>     A is triangular strided batched matrix and op(A) is one of
  !> 
  !>         op( A ) = A   or   op( A ) = A^T   or   op( A ) = A^H.
  !> 
  !>     Each matrix X_i is overwritten on B_i for i = 1, ..., batch_count.
  !> 
  !>     Note about memory allocation:
  !>     When trsm is launched with a k evenly divisible by the internal block size of 128,
  !>     and is no larger than 10 of these blocks, the API takes advantage of utilizing pre-allocated
  !>     memory found in the handle to increase overall performance. This memory can be managed by using
  !>     the environment variable WORKBUF_TRSM_B_CHNK. When this variable is not set the device memory
  !>     used for temporary storage will default to 1 MB and may result in chunking, which in turn may
  !>     reduce performance. Under these circumstances it is recommended that WORKBUF_TRSM_B_CHNK be set
  !>     to the desired chunk of right hand sides to be used at a time.
  !>     (where k is m when rocblas_side_left and is n when rocblas_side_right)
  !>     @param[in]
  !>     handle    [rocblas_handle]
  !>               handle to the rocblas library context queue.
  !>     @param[in]
  !>     side    [rocblas_side]
  !>             rocblas_side_left:       op(A)X = alphaB.
  !>             rocblas_side_right:      Xop(A) = alphaB.
  !>     @param[in]
  !>     uplo    [rocblas_fill]
  !>             rocblas_fill_upper:  each A_i is an upper triangular matrix.
  !>             rocblas_fill_lower:  each A_i is a  lower triangular matrix.
  !>     @param[in]
  !>     transA  [rocblas_operation]
  !>             transB:    op(A) = A.
  !>             rocblas_operation_transpose:      op(A) = A^T.
  !>             rocblas_operation_conjugate_transpose:  op(A) = A^H.
  !>     @param[in]
  !>     diag    [rocblas_diagonal]
  !>             rocblas_diagonal_unit:     each A_i is assumed to be unit triangular.
  !>             rocblas_diagonal_non_unit:  each A_i is not assumed to be unit triangular.
  !>     @param[in]
  !>     m       [rocblas_int]
  !>             m specifies the number of rows of each B_i. m >= 0.
  !>     @param[in]
  !>     n       [rocblas_int]
  !>             n specifies the number of columns of each B_i. n >= 0.
  !>     @param[in]
  !>     alpha
  !>             device pointer or host pointer specifying the scalar alpha. When alpha is
  !>             &zero then A is not referenced and B need not be set before
  !>             entry.
  !>     @param[in]
  !>     A       device pointer pointing to the first matrix A_1.
  !>             of dimension ( lda, k ), where k is m
  !>             when  rocblas_side_left  and
  !>             is  n  when  rocblas_side_right
  !>             only the upperlower triangular part is accessed.
  !>     @param[in]
  !>     lda     [rocblas_int]
  !>             lda specifies the first dimension of each A_i.
  !>             if side = rocblas_side_left,  lda >= max( 1, m ),
  !>             if side = rocblas_side_right, lda >= max( 1, n ).
  !>     @param[in]
  !>     stride_a [rocblas_stride]
  !>              stride from the start of one A_i matrix to the next A_(i + 1).
  !>     @param[in,out]
  !>     B       device pointer pointing to the first matrix B_1.
  !>     @param[in]
  !>     ldb    [rocblas_int]
  !>            ldb specifies the first dimension of each B_i. ldb >= max( 1, m ).
  !>     @param[in]
  !>     stride_b [rocblas_stride]
  !>              stride from the start of one B_i matrix to the next B_(i + 1).
  !>     @param[in]
  !>     batch_count [rocblas_int]
  !>                 number of trsm operatons in the batch.
  !>     
  interface rocblas_ztrsm_strided_batched
    function rocblas_ztrsm_strided_batched_orig(handle,side,uplo,transA,diag,m,n,alpha,A,lda,stride_a,B,ldb,stride_b,batch_count) bind(c, name="rocblas_ztrsm_strided_batched")
      use iso_c_binding
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocblas_ztrsm_strided_batched_orig
      type(c_ptr),value :: handle
      integer(kind(rocblas_side_left)),value :: side
      integer(kind(rocblas_fill_upper)),value :: uplo
      integer(kind(rocblas_operation_none)),value :: transA
      integer(kind(rocblas_diagonal_non_unit)),value :: diag
      integer(c_int),value :: m
      integer(c_int),value :: n
      complex(c_double_complex) :: alpha
      type(c_ptr),value :: A
      integer(c_int),value :: lda
      integer(c_int64_t),value :: stride_a
      type(c_ptr),value :: B
      integer(c_int),value :: ldb
      integer(c_int64_t),value :: stride_b
      integer(c_int),value :: batch_count
    end function

#ifdef USE_FPOINTER_INTERFACES
    module procedure rocblas_ztrsm_strided_batched_full_rank,rocblas_ztrsm_strided_batched_rank_0,rocblas_ztrsm_strided_batched_rank_1
#endif

  end interface
  
  interface rocblas_sgemm
    function rocblas_sgemm_orig(handle,transA,transB,m,n,k,alpha,A,lda,B,ldb,beta,C,ldc) bind(c, name="rocblas_sgemm")
      use iso_c_binding
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocblas_sgemm_orig
      type(c_ptr),value :: handle
      integer(kind(rocblas_operation_none)),value :: transA
      integer(kind(rocblas_operation_none)),value :: transB
      integer(c_int),value :: m
      integer(c_int),value :: n
      integer(c_int),value :: k
      real(c_float) :: alpha
      type(c_ptr),value :: A
      integer(c_int),value :: lda
      type(c_ptr),value :: B
      integer(c_int),value :: ldb
      real(c_float) :: beta
      type(c_ptr),value :: C
      integer(c_int),value :: ldc
    end function

#ifdef USE_FPOINTER_INTERFACES
    module procedure rocblas_sgemm_full_rank,rocblas_sgemm_rank_0,rocblas_sgemm_rank_1
#endif

  end interface
  
  interface rocblas_dgemm
    function rocblas_dgemm_orig(handle,transA,transB,m,n,k,alpha,A,lda,B,ldb,beta,C,ldc) bind(c, name="rocblas_dgemm")
      use iso_c_binding
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocblas_dgemm_orig
      type(c_ptr),value :: handle
      integer(kind(rocblas_operation_none)),value :: transA
      integer(kind(rocblas_operation_none)),value :: transB
      integer(c_int),value :: m
      integer(c_int),value :: n
      integer(c_int),value :: k
      real(c_double) :: alpha
      type(c_ptr),value :: A
      integer(c_int),value :: lda
      type(c_ptr),value :: B
      integer(c_int),value :: ldb
      real(c_double) :: beta
      type(c_ptr),value :: C
      integer(c_int),value :: ldc
    end function

#ifdef USE_FPOINTER_INTERFACES
    module procedure rocblas_dgemm_full_rank,rocblas_dgemm_rank_0,rocblas_dgemm_rank_1
#endif

  end interface
  
  interface rocblas_cgemm
    function rocblas_cgemm_orig(handle,transA,transB,m,n,k,alpha,A,lda,B,ldb,beta,C,ldc) bind(c, name="rocblas_cgemm")
      use iso_c_binding
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocblas_cgemm_orig
      type(c_ptr),value :: handle
      integer(kind(rocblas_operation_none)),value :: transA
      integer(kind(rocblas_operation_none)),value :: transB
      integer(c_int),value :: m
      integer(c_int),value :: n
      integer(c_int),value :: k
      complex(c_float_complex) :: alpha
      type(c_ptr),value :: A
      integer(c_int),value :: lda
      type(c_ptr),value :: B
      integer(c_int),value :: ldb
      complex(c_float_complex) :: beta
      type(c_ptr),value :: C
      integer(c_int),value :: ldc
    end function

#ifdef USE_FPOINTER_INTERFACES
    module procedure rocblas_cgemm_full_rank,rocblas_cgemm_rank_0,rocblas_cgemm_rank_1
#endif

  end interface
  !> ! \brief BLAS Level 3 API
  !> 
  !>     \details
  !>     xGEMM performs one of the matrix-matrix operations
  !> 
  !>         C = alphaop( A )op( B ) + betaC,
  !> 
  !>     where op( X ) is one of
  !> 
  !>         op( X ) = X      or
  !>         op( X ) = XT   or
  !>         op( X ) = XH,
  !> 
  !>     alpha and beta are scalars, and A, B and C are matrices, with
  !>     op( A ) an m by k matrix, op( B ) a k by n matrix and C an m by n matrix.
  !> 
  !>     @param[in]
  !>     handle    [rocblas_handle]
  !>               handle to the rocblas library context queue.
  !>     @param[in]
  !>     transA    [rocblas_operation]
  !>               specifies the form of op( A )
  !>     @param[in]
  !>     transB    [rocblas_operation]
  !>               specifies the form of op( B )
  !>     @param[in]
  !>     m         [rocblas_int]
  !>               number or rows of matrices op( A ) and C
  !>     @param[in]
  !>     n         [rocblas_int]
  !>               number of columns of matrices op( B ) and C
  !>     @param[in]
  !>     k         [rocblas_int]
  !>               number of columns of matrix op( A ) and number of rows of matrix op( B )
  !>     @param[in]
  !>     alpha     device pointer or host pointer specifying the scalar alpha.
  !>     @param[in]
  !>     A         device pointer storing matrix A.
  !>     @param[in]
  !>     lda       [rocblas_int]
  !>               specifies the leading dimension of A.
  !>     @param[in]
  !>     B         device pointer storing matrix B.
  !>     @param[in]
  !>     ldb       [rocblas_int]
  !>               specifies the leading dimension of B.
  !>     @param[in]
  !>     beta      device pointer or host pointer specifying the scalar beta.
  !>     @param[in, out]
  !>     C         device pointer storing matrix C on the GPU.
  !>     @param[in]
  !>     ldc       [rocblas_int]
  !>               specifies the leading dimension of C.
  !> 
  !>     
  interface rocblas_zgemm
    function rocblas_zgemm_orig(handle,transA,transB,m,n,k,alpha,A,lda,B,ldb,beta,C,ldc) bind(c, name="rocblas_zgemm")
      use iso_c_binding
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocblas_zgemm_orig
      type(c_ptr),value :: handle
      integer(kind(rocblas_operation_none)),value :: transA
      integer(kind(rocblas_operation_none)),value :: transB
      integer(c_int),value :: m
      integer(c_int),value :: n
      integer(c_int),value :: k
      complex(c_double_complex) :: alpha
      type(c_ptr),value :: A
      integer(c_int),value :: lda
      type(c_ptr),value :: B
      integer(c_int),value :: ldb
      complex(c_double_complex) :: beta
      type(c_ptr),value :: C
      integer(c_int),value :: ldc
    end function

#ifdef USE_FPOINTER_INTERFACES
    module procedure rocblas_zgemm_full_rank,rocblas_zgemm_rank_0,rocblas_zgemm_rank_1
#endif

  end interface
  
  interface rocblas_sgemm_batched
    function rocblas_sgemm_batched_orig(handle,transA,transB,m,n,k,alpha,A,lda,B,ldb,beta,C,ldc,batch_count) bind(c, name="rocblas_sgemm_batched")
      use iso_c_binding
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocblas_sgemm_batched_orig
      type(c_ptr),value :: handle
      integer(kind(rocblas_operation_none)),value :: transA
      integer(kind(rocblas_operation_none)),value :: transB
      integer(c_int),value :: m
      integer(c_int),value :: n
      integer(c_int),value :: k
      real(c_float) :: alpha
      type(c_ptr) :: A
      integer(c_int),value :: lda
      type(c_ptr) :: B
      integer(c_int),value :: ldb
      real(c_float) :: beta
      type(c_ptr) :: C
      integer(c_int),value :: ldc
      integer(c_int),value :: batch_count
    end function

#ifdef USE_FPOINTER_INTERFACES
    module procedure rocblas_sgemm_batched_full_rank,rocblas_sgemm_batched_rank_0,rocblas_sgemm_batched_rank_1
#endif

  end interface
  
  interface rocblas_dgemm_batched
    function rocblas_dgemm_batched_orig(handle,transA,transB,m,n,k,alpha,A,lda,B,ldb,beta,C,ldc,batch_count) bind(c, name="rocblas_dgemm_batched")
      use iso_c_binding
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocblas_dgemm_batched_orig
      type(c_ptr),value :: handle
      integer(kind(rocblas_operation_none)),value :: transA
      integer(kind(rocblas_operation_none)),value :: transB
      integer(c_int),value :: m
      integer(c_int),value :: n
      integer(c_int),value :: k
      real(c_double) :: alpha
      type(c_ptr) :: A
      integer(c_int),value :: lda
      type(c_ptr) :: B
      integer(c_int),value :: ldb
      real(c_double) :: beta
      type(c_ptr) :: C
      integer(c_int),value :: ldc
      integer(c_int),value :: batch_count
    end function

#ifdef USE_FPOINTER_INTERFACES
    module procedure rocblas_dgemm_batched_full_rank,rocblas_dgemm_batched_rank_0,rocblas_dgemm_batched_rank_1
#endif

  end interface
  
  interface rocblas_cgemm_batched
    function rocblas_cgemm_batched_orig(handle,transA,transB,m,n,k,alpha,A,lda,B,ldb,beta,C,ldc,batch_count) bind(c, name="rocblas_cgemm_batched")
      use iso_c_binding
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocblas_cgemm_batched_orig
      type(c_ptr),value :: handle
      integer(kind(rocblas_operation_none)),value :: transA
      integer(kind(rocblas_operation_none)),value :: transB
      integer(c_int),value :: m
      integer(c_int),value :: n
      integer(c_int),value :: k
      complex(c_float_complex) :: alpha
      type(c_ptr) :: A
      integer(c_int),value :: lda
      type(c_ptr) :: B
      integer(c_int),value :: ldb
      complex(c_float_complex) :: beta
      type(c_ptr) :: C
      integer(c_int),value :: ldc
      integer(c_int),value :: batch_count
    end function

#ifdef USE_FPOINTER_INTERFACES
    module procedure rocblas_cgemm_batched_full_rank,rocblas_cgemm_batched_rank_0,rocblas_cgemm_batched_rank_1
#endif

  end interface
  !> ! \brief BLAS Level 3 API
  !>      \details
  !>     xGEMM_BATCHED performs one of the batched matrix-matrix operations
  !>          C_i = alphaop( A_i )op( B_i ) + betaC_i, for i = 1, ..., batch_count.
  !>      where op( X ) is one of
  !>          op( X ) = X      or
  !>         op( X ) = XT   or
  !>         op( X ) = XH,
  !>      alpha and beta are scalars, and A, B and C are strided batched matrices, with
  !>     op( A ) an m by k by batch_count strided_batched matrix,
  !>     op( B ) an k by n by batch_count strided_batched matrix and
  !>     C an m by n by batch_count strided_batched matrix.
  !>     @param[in]
  !>     handle    [rocblas_handle
  !>               handle to the rocblas library context queue.
  !>     @param[in]
  !>     transA    [rocblas_operation]
  !>               specifies the form of op( A )
  !>     @param[in]
  !>     transB    [rocblas_operation]
  !>               specifies the form of op( B )
  !>     @param[in]
  !>     m         [rocblas_int]
  !>               matrix dimention m.
  !>     @param[in]
  !>     n         [rocblas_int]
  !>               matrix dimention n.
  !>     @param[in]
  !>     k         [rocblas_int]
  !>               matrix dimention k.
  !>     @param[in]
  !>     alpha     device pointer or host pointer specifying the scalar alpha.
  !>     @param[in]
  !>     A         device array of device pointers storing each matrix A_i.
  !>     @param[in]
  !>     lda       [rocblas_int]
  !>               specifies the leading dimension of each A_i.
  !>     @param[in]
  !>     B         device array of device pointers storing each matrix B_i.
  !>     @param[in]
  !>     ldb       [rocblas_int]
  !>               specifies the leading dimension of each B_i.
  !>     @param[in]
  !>     beta      device pointer or host pointer specifying the scalar beta.
  !>     @param[in, out]
  !>     C         device array of device pointers storing each matrix C_i.
  !>     @param[in]
  !>     ldc       [rocblas_int]
  !>               specifies the leading dimension of each C_i.
  !>     @param[in]
  !>     batch_count
  !>               [rocblas_int]
  !>               number of gemm operations in the batch
  !>      
  interface rocblas_zgemm_batched
    function rocblas_zgemm_batched_orig(handle,transa,transb,m,n,k,alpha,A,lda,B,ldb,beta,C,ldc,batch_count) bind(c, name="rocblas_zgemm_batched")
      use iso_c_binding
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocblas_zgemm_batched_orig
      type(c_ptr),value :: handle
      integer(kind(rocblas_operation_none)),value :: transa
      integer(kind(rocblas_operation_none)),value :: transb
      integer(c_int),value :: m
      integer(c_int),value :: n
      integer(c_int),value :: k
      complex(c_double_complex) :: alpha
      type(c_ptr) :: A
      integer(c_int),value :: lda
      type(c_ptr) :: B
      integer(c_int),value :: ldb
      complex(c_double_complex) :: beta
      type(c_ptr) :: C
      integer(c_int),value :: ldc
      integer(c_int),value :: batch_count
    end function

#ifdef USE_FPOINTER_INTERFACES
    module procedure rocblas_zgemm_batched_full_rank,rocblas_zgemm_batched_rank_0,rocblas_zgemm_batched_rank_1
#endif

  end interface
  
  interface rocblas_sgemm_strided_batched
    function rocblas_sgemm_strided_batched_orig(handle,transA,transB,m,n,k,alpha,A,lda,stride_a,B,ldb,stride_b,beta,C,ldc,stride_c,batch_count) bind(c, name="rocblas_sgemm_strided_batched")
      use iso_c_binding
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocblas_sgemm_strided_batched_orig
      type(c_ptr),value :: handle
      integer(kind(rocblas_operation_none)),value :: transA
      integer(kind(rocblas_operation_none)),value :: transB
      integer(c_int),value :: m
      integer(c_int),value :: n
      integer(c_int),value :: k
      real(c_float) :: alpha
      type(c_ptr),value :: A
      integer(c_int),value :: lda
      integer(c_int64_t),value :: stride_a
      type(c_ptr),value :: B
      integer(c_int),value :: ldb
      integer(c_int64_t),value :: stride_b
      real(c_float) :: beta
      type(c_ptr),value :: C
      integer(c_int),value :: ldc
      integer(c_int64_t),value :: stride_c
      integer(c_int),value :: batch_count
    end function

#ifdef USE_FPOINTER_INTERFACES
    module procedure rocblas_sgemm_strided_batched_full_rank,rocblas_sgemm_strided_batched_rank_0,rocblas_sgemm_strided_batched_rank_1
#endif

  end interface
  
  interface rocblas_dgemm_strided_batched
    function rocblas_dgemm_strided_batched_orig(handle,transA,transB,m,n,k,alpha,A,lda,stride_a,B,ldb,stride_b,beta,C,ldc,stride_c,batch_count) bind(c, name="rocblas_dgemm_strided_batched")
      use iso_c_binding
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocblas_dgemm_strided_batched_orig
      type(c_ptr),value :: handle
      integer(kind(rocblas_operation_none)),value :: transA
      integer(kind(rocblas_operation_none)),value :: transB
      integer(c_int),value :: m
      integer(c_int),value :: n
      integer(c_int),value :: k
      real(c_double) :: alpha
      type(c_ptr),value :: A
      integer(c_int),value :: lda
      integer(c_int64_t),value :: stride_a
      type(c_ptr),value :: B
      integer(c_int),value :: ldb
      integer(c_int64_t),value :: stride_b
      real(c_double) :: beta
      type(c_ptr),value :: C
      integer(c_int),value :: ldc
      integer(c_int64_t),value :: stride_c
      integer(c_int),value :: batch_count
    end function

#ifdef USE_FPOINTER_INTERFACES
    module procedure rocblas_dgemm_strided_batched_full_rank,rocblas_dgemm_strided_batched_rank_0,rocblas_dgemm_strided_batched_rank_1
#endif

  end interface
  
  interface rocblas_sgemm_kernel_name
    function rocblas_sgemm_kernel_name_orig(handle,transA,transB,m,n,k,alpha,A,lda,stride_a,B,ldb,stride_b,beta,C,ldc,stride_c,batch_count) bind(c, name="rocblas_sgemm_kernel_name")
      use iso_c_binding
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocblas_sgemm_kernel_name_orig
      type(c_ptr),value :: handle
      integer(kind(rocblas_operation_none)),value :: transA
      integer(kind(rocblas_operation_none)),value :: transB
      integer(c_int),value :: m
      integer(c_int),value :: n
      integer(c_int),value :: k
      real(c_float) :: alpha
      type(c_ptr),value :: A
      integer(c_int),value :: lda
      integer(c_int64_t),value :: stride_a
      type(c_ptr),value :: B
      integer(c_int),value :: ldb
      integer(c_int64_t),value :: stride_b
      real(c_float) :: beta
      type(c_ptr),value :: C
      integer(c_int),value :: ldc
      integer(c_int64_t),value :: stride_c
      integer(c_int),value :: batch_count
    end function

#ifdef USE_FPOINTER_INTERFACES
    module procedure rocblas_sgemm_kernel_name_full_rank,rocblas_sgemm_kernel_name_rank_0,rocblas_sgemm_kernel_name_rank_1
#endif

  end interface
  
  interface rocblas_dgemm_kernel_name
    function rocblas_dgemm_kernel_name_orig(handle,transA,transB,m,n,k,alpha,A,lda,stride_a,B,ldb,stride_b,beta,C,ldc,stride_c,batch_count) bind(c, name="rocblas_dgemm_kernel_name")
      use iso_c_binding
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocblas_dgemm_kernel_name_orig
      type(c_ptr),value :: handle
      integer(kind(rocblas_operation_none)),value :: transA
      integer(kind(rocblas_operation_none)),value :: transB
      integer(c_int),value :: m
      integer(c_int),value :: n
      integer(c_int),value :: k
      real(c_double) :: alpha
      type(c_ptr),value :: A
      integer(c_int),value :: lda
      integer(c_int64_t),value :: stride_a
      type(c_ptr),value :: B
      integer(c_int),value :: ldb
      integer(c_int64_t),value :: stride_b
      real(c_double) :: beta
      type(c_ptr),value :: C
      integer(c_int),value :: ldc
      integer(c_int64_t),value :: stride_c
      integer(c_int),value :: batch_count
    end function

#ifdef USE_FPOINTER_INTERFACES
    module procedure rocblas_dgemm_kernel_name_full_rank,rocblas_dgemm_kernel_name_rank_0,rocblas_dgemm_kernel_name_rank_1
#endif

  end interface
  
  interface rocblas_cgemm_strided_batched
    function rocblas_cgemm_strided_batched_orig(handle,transa,transb,m,n,k,alpha,A,lda,stride_a,B,ldb,stride_b,beta,C,ldc,stride_c,batch_count) bind(c, name="rocblas_cgemm_strided_batched")
      use iso_c_binding
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocblas_cgemm_strided_batched_orig
      type(c_ptr),value :: handle
      integer(kind(rocblas_operation_none)),value :: transa
      integer(kind(rocblas_operation_none)),value :: transb
      integer(c_int),value :: m
      integer(c_int),value :: n
      integer(c_int),value :: k
      complex(c_float_complex) :: alpha
      type(c_ptr),value :: A
      integer(c_int),value :: lda
      integer(c_int64_t),value :: stride_a
      type(c_ptr),value :: B
      integer(c_int),value :: ldb
      integer(c_int64_t),value :: stride_b
      complex(c_float_complex) :: beta
      type(c_ptr),value :: C
      integer(c_int),value :: ldc
      integer(c_int64_t),value :: stride_c
      integer(c_int),value :: batch_count
    end function

#ifdef USE_FPOINTER_INTERFACES
    module procedure rocblas_cgemm_strided_batched_full_rank,rocblas_cgemm_strided_batched_rank_0,rocblas_cgemm_strided_batched_rank_1
#endif

  end interface
  !> ! \brief BLAS Level 3 API
  !> 
  !>     \details
  !>     xGEMM_STRIDED_BATCHED performs one of the strided batched matrix-matrix operations
  !> 
  !>         C_i = alphaop( A_i )op( B_i ) + betaC_i, for i = 1, ..., batch_count.
  !> 
  !>     where op( X ) is one of
  !> 
  !>         op( X ) = X      or
  !>         op( X ) = XT   or
  !>         op( X ) = XH,
  !> 
  !>     alpha and beta are scalars, and A, B and C are strided batched matrices, with
  !>     op( A ) an m by k by batch_count strided_batched matrix,
  !>     op( B ) an k by n by batch_count strided_batched matrix and
  !>     C an m by n by batch_count strided_batched matrix.
  !> 
  !>     @param[in]
  !>     handle    [rocblas_handle]
  !>               handle to the rocblas library context queue.
  !>     @param[in]
  !>     transA    [rocblas_operation]
  !>               specifies the form of op( A )
  !>     @param[in]
  !>     transB    [rocblas_operation]
  !>               specifies the form of op( B )
  !>     @param[in]
  !>     m         [rocblas_int]
  !>               matrix dimention m.
  !>     @param[in]
  !>     n         [rocblas_int]
  !>               matrix dimention n.
  !>     @param[in]
  !>     k         [rocblas_int]
  !>               matrix dimention k.
  !>     @param[in]
  !>     alpha     device pointer or host pointer specifying the scalar alpha.
  !>     @param[in]
  !>     A         device pointer pointing to the first matrix A_1.
  !>     @param[in]
  !>     lda       [rocblas_int]
  !>               specifies the leading dimension of each A_i.
  !>     @param[in]
  !>     stride_a  [rocblas_stride]
  !>               stride from the start of one A_i matrix to the next A_(i + 1).
  !>     @param[in]
  !>     B         device pointer pointing to the first matrix B_1.
  !>     @param[in]
  !>     ldb       [rocblas_int]
  !>               specifies the leading dimension of each B_i.
  !>     @param[in]
  !>     stride_b  [rocblas_stride]
  !>               stride from the start of one B_i matrix to the next B_(i + 1).
  !>     @param[in]
  !>     beta      device pointer or host pointer specifying the scalar beta.
  !>     @param[in, out]
  !>     C         device pointer pointing to the first matrix C_1.
  !>     @param[in]
  !>     ldc       [rocblas_int]
  !>               specifies the leading dimension of each C_i.
  !>     @param[in]
  !>     stride_c  [rocblas_stride]
  !>               stride from the start of one C_i matrix to the next C_(i + 1).
  !>     @param[in]
  !>     batch_count
  !>               [rocblas_int]
  !>               number of gemm operatons in the batch
  !> 
  !>     
  interface rocblas_zgemm_strided_batched
    function rocblas_zgemm_strided_batched_orig(handle,transa,transb,m,n,k,alpha,A,lda,stride_a,B,ldb,stride_b,beta,C,ldc,stride_c,batch_count) bind(c, name="rocblas_zgemm_strided_batched")
      use iso_c_binding
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocblas_zgemm_strided_batched_orig
      type(c_ptr),value :: handle
      integer(kind(rocblas_operation_none)),value :: transa
      integer(kind(rocblas_operation_none)),value :: transb
      integer(c_int),value :: m
      integer(c_int),value :: n
      integer(c_int),value :: k
      complex(c_double_complex) :: alpha
      type(c_ptr),value :: A
      integer(c_int),value :: lda
      integer(c_int64_t),value :: stride_a
      type(c_ptr),value :: B
      integer(c_int),value :: ldb
      integer(c_int64_t),value :: stride_b
      complex(c_double_complex) :: beta
      type(c_ptr),value :: C
      integer(c_int),value :: ldc
      integer(c_int64_t),value :: stride_c
      integer(c_int),value :: batch_count
    end function

#ifdef USE_FPOINTER_INTERFACES
    module procedure rocblas_zgemm_strided_batched_full_rank,rocblas_zgemm_strided_batched_rank_0,rocblas_zgemm_strided_batched_rank_1
#endif

  end interface
  
  interface rocblas_sdgmm
    function rocblas_sdgmm_orig(handle,side,m,n,A,lda,x,incx,C,ldc) bind(c, name="rocblas_sdgmm")
      use iso_c_binding
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocblas_sdgmm_orig
      type(c_ptr),value :: handle
      integer(kind(rocblas_side_left)),value :: side
      integer(c_int),value :: m
      integer(c_int),value :: n
      type(c_ptr),value :: A
      integer(c_int),value :: lda
      type(c_ptr),value :: x
      integer(c_int),value :: incx
      type(c_ptr),value :: C
      integer(c_int),value :: ldc
    end function

#ifdef USE_FPOINTER_INTERFACES
    module procedure rocblas_sdgmm_full_rank,rocblas_sdgmm_rank_0,rocblas_sdgmm_rank_1
#endif

  end interface
  
  interface rocblas_ddgmm
    function rocblas_ddgmm_orig(handle,side,m,n,A,lda,x,incx,C,ldc) bind(c, name="rocblas_ddgmm")
      use iso_c_binding
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocblas_ddgmm_orig
      type(c_ptr),value :: handle
      integer(kind(rocblas_side_left)),value :: side
      integer(c_int),value :: m
      integer(c_int),value :: n
      type(c_ptr),value :: A
      integer(c_int),value :: lda
      type(c_ptr),value :: x
      integer(c_int),value :: incx
      type(c_ptr),value :: C
      integer(c_int),value :: ldc
    end function

#ifdef USE_FPOINTER_INTERFACES
    module procedure rocblas_ddgmm_full_rank,rocblas_ddgmm_rank_0,rocblas_ddgmm_rank_1
#endif

  end interface
  
  interface rocblas_cdgmm
    function rocblas_cdgmm_orig(handle,side,m,n,A,lda,x,incx,C,ldc) bind(c, name="rocblas_cdgmm")
      use iso_c_binding
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocblas_cdgmm_orig
      type(c_ptr),value :: handle
      integer(kind(rocblas_side_left)),value :: side
      integer(c_int),value :: m
      integer(c_int),value :: n
      type(c_ptr),value :: A
      integer(c_int),value :: lda
      type(c_ptr),value :: x
      integer(c_int),value :: incx
      type(c_ptr),value :: C
      integer(c_int),value :: ldc
    end function

#ifdef USE_FPOINTER_INTERFACES
    module procedure rocblas_cdgmm_full_rank,rocblas_cdgmm_rank_0,rocblas_cdgmm_rank_1
#endif

  end interface
  !> ! \brief BLAS Level 3 API
  !> 
  !>     \details
  !>     xDGMM performs one of the matrix-matrix operations
  !> 
  !>         C = A  diag(x) if side == rocblas_side_right
  !>         C = diag(x)  A if side == rocblas_side_left
  !> 
  !>     where C and A are m by n dimensional matrices. diag( x ) is a diagonal matrix
  !>     and x is vector of dimension n if side == rocblas_side_right and dimension m
  !>     if side == rocblas_side_left.
  !> 
  !> 
  !>     @param[in]
  !>     handle    [rocblas_handle]
  !>               handle to the rocblas library context queue.
  !>     @param[in]
  !>     side      [rocblas_side]
  !>               specifies the side of diag(x)
  !>     @param[in]
  !>     m         [rocblas_int]
  !>               matrix dimension m.
  !>     @param[in]
  !>     n         [rocblas_int]
  !>               matrix dimension n.
  !>     @param[in]
  !>     A         device pointer storing matrix A.
  !>     @param[in]
  !>     lda       [rocblas_int]
  !>               specifies the leading dimension of A.
  !>     @param[in]
  !>     x         device pointer storing vector x.
  !>     @param[in]
  !>     incx      [rocblas_int]
  !>               specifies the increment between values of x
  !>     @param[in, out]
  !>     C         device pointer storing matrix C.
  !>     @param[in]
  !>     ldc       [rocblas_int]
  !>               specifies the leading dimension of C.
  !> 
  !>     
  interface rocblas_zdgmm
    function rocblas_zdgmm_orig(handle,side,m,n,A,lda,x,incx,C,ldc) bind(c, name="rocblas_zdgmm")
      use iso_c_binding
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocblas_zdgmm_orig
      type(c_ptr),value :: handle
      integer(kind(rocblas_side_left)),value :: side
      integer(c_int),value :: m
      integer(c_int),value :: n
      type(c_ptr),value :: A
      integer(c_int),value :: lda
      type(c_ptr),value :: x
      integer(c_int),value :: incx
      type(c_ptr),value :: C
      integer(c_int),value :: ldc
    end function

#ifdef USE_FPOINTER_INTERFACES
    module procedure rocblas_zdgmm_full_rank,rocblas_zdgmm_rank_0,rocblas_zdgmm_rank_1
#endif

  end interface
  
  interface rocblas_sdgmm_batched
    function rocblas_sdgmm_batched_orig(handle,side,m,n,A,lda,x,incx,C,ldc,batch_count) bind(c, name="rocblas_sdgmm_batched")
      use iso_c_binding
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocblas_sdgmm_batched_orig
      type(c_ptr),value :: handle
      integer(kind(rocblas_side_left)),value :: side
      integer(c_int),value :: m
      integer(c_int),value :: n
      type(c_ptr) :: A
      integer(c_int),value :: lda
      type(c_ptr) :: x
      integer(c_int),value :: incx
      type(c_ptr) :: C
      integer(c_int),value :: ldc
      integer(c_int),value :: batch_count
    end function

#ifdef USE_FPOINTER_INTERFACES
    module procedure rocblas_sdgmm_batched_full_rank,rocblas_sdgmm_batched_rank_0,rocblas_sdgmm_batched_rank_1
#endif

  end interface
  
  interface rocblas_ddgmm_batched
    function rocblas_ddgmm_batched_orig(handle,side,m,n,A,lda,x,incx,C,ldc,batch_count) bind(c, name="rocblas_ddgmm_batched")
      use iso_c_binding
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocblas_ddgmm_batched_orig
      type(c_ptr),value :: handle
      integer(kind(rocblas_side_left)),value :: side
      integer(c_int),value :: m
      integer(c_int),value :: n
      type(c_ptr) :: A
      integer(c_int),value :: lda
      type(c_ptr) :: x
      integer(c_int),value :: incx
      type(c_ptr) :: C
      integer(c_int),value :: ldc
      integer(c_int),value :: batch_count
    end function

#ifdef USE_FPOINTER_INTERFACES
    module procedure rocblas_ddgmm_batched_full_rank,rocblas_ddgmm_batched_rank_0,rocblas_ddgmm_batched_rank_1
#endif

  end interface
  
  interface rocblas_cdgmm_batched
    function rocblas_cdgmm_batched_orig(handle,side,m,n,A,lda,x,incx,C,ldc,batch_count) bind(c, name="rocblas_cdgmm_batched")
      use iso_c_binding
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocblas_cdgmm_batched_orig
      type(c_ptr),value :: handle
      integer(kind(rocblas_side_left)),value :: side
      integer(c_int),value :: m
      integer(c_int),value :: n
      type(c_ptr) :: A
      integer(c_int),value :: lda
      type(c_ptr) :: x
      integer(c_int),value :: incx
      type(c_ptr) :: C
      integer(c_int),value :: ldc
      integer(c_int),value :: batch_count
    end function

#ifdef USE_FPOINTER_INTERFACES
    module procedure rocblas_cdgmm_batched_full_rank,rocblas_cdgmm_batched_rank_0,rocblas_cdgmm_batched_rank_1
#endif

  end interface
  !> ! \brief BLAS Level 3 API
  !> 
  !>     \details
  !>     xDGMM_batched performs one of the batched matrix-matrix operations
  !> 
  !>         C_i = A_i  diag(x_i) for i = 0, 1, ... batch_count-1 if side == rocblas_side_right
  !>         C_i = diag(x_i)  A_i for i = 0, 1, ... batch_count-1 if side == rocblas_side_left
  !> 
  !>     where C_i and A_i are m by n dimensional matrices. diag(x_i) is a diagonal matrix
  !>     and x_i is vector of dimension n if side == rocblas_side_right and dimension m
  !>     if side == rocblas_side_left.
  !> 
  !>     @param[in]
  !>     handle    [rocblas_handle]
  !>               handle to the rocblas library context queue.
  !>     @param[in]
  !>     side      [rocblas_side]
  !>               specifies the side of diag(x)
  !>     @param[in]
  !>     m         [rocblas_int]
  !>               matrix dimension m.
  !>     @param[in]
  !>     n         [rocblas_int]
  !>               matrix dimension n.
  !>     @param[in]
  !>     A         device array of device pointers storing each matrix A_i on the GPU.
  !>               Each A_i is of dimension ( lda, n )
  !>     @param[in]
  !>     lda       [rocblas_int]
  !>               specifies the leading dimension of A_i.
  !>     @param[in]
  !>     x         device array of device pointers storing each vector x_i on the GPU.
  !>               Each x_i is of dimension n if side == rocblas_side_right and dimension
  !>               m if side == rocblas_side_left
  !>     @param[in]
  !>     incx      [rocblas_int]
  !>               specifies the increment between values of x_i
  !>     @param[in, out]
  !>     C         device array of device pointers storing each matrix C_i on the GPU.
  !>               Each C_i is of dimension ( ldc, n ).
  !>     @param[in]
  !>     ldc       [rocblas_int]
  !>               specifies the leading dimension of C_i.
  !>     @param[in]
  !>     batch_count [rocblas_int]
  !>                 number of instances in the batch.
  !> 
  !>     
  interface rocblas_zdgmm_batched
    function rocblas_zdgmm_batched_orig(handle,side,m,n,A,lda,x,incx,C,ldc,batch_count) bind(c, name="rocblas_zdgmm_batched")
      use iso_c_binding
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocblas_zdgmm_batched_orig
      type(c_ptr),value :: handle
      integer(kind(rocblas_side_left)),value :: side
      integer(c_int),value :: m
      integer(c_int),value :: n
      type(c_ptr) :: A
      integer(c_int),value :: lda
      type(c_ptr) :: x
      integer(c_int),value :: incx
      type(c_ptr) :: C
      integer(c_int),value :: ldc
      integer(c_int),value :: batch_count
    end function

#ifdef USE_FPOINTER_INTERFACES
    module procedure rocblas_zdgmm_batched_full_rank,rocblas_zdgmm_batched_rank_0,rocblas_zdgmm_batched_rank_1
#endif

  end interface
  
  interface rocblas_sdgmm_strided_batched
    function rocblas_sdgmm_strided_batched_orig(handle,side,m,n,A,lda,stride_a,x,incx,stride_x,C,ldc,stride_c,batch_count) bind(c, name="rocblas_sdgmm_strided_batched")
      use iso_c_binding
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocblas_sdgmm_strided_batched_orig
      type(c_ptr),value :: handle
      integer(kind(rocblas_side_left)),value :: side
      integer(c_int),value :: m
      integer(c_int),value :: n
      type(c_ptr),value :: A
      integer(c_int),value :: lda
      integer(c_int64_t),value :: stride_a
      type(c_ptr),value :: x
      integer(c_int),value :: incx
      integer(c_int64_t),value :: stride_x
      type(c_ptr),value :: C
      integer(c_int),value :: ldc
      integer(c_int64_t),value :: stride_c
      integer(c_int),value :: batch_count
    end function

#ifdef USE_FPOINTER_INTERFACES
    module procedure rocblas_sdgmm_strided_batched_full_rank,rocblas_sdgmm_strided_batched_rank_0,rocblas_sdgmm_strided_batched_rank_1
#endif

  end interface
  
  interface rocblas_ddgmm_strided_batched
    function rocblas_ddgmm_strided_batched_orig(handle,side,m,n,A,lda,stride_a,x,incx,stride_x,C,ldc,stride_c,batch_count) bind(c, name="rocblas_ddgmm_strided_batched")
      use iso_c_binding
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocblas_ddgmm_strided_batched_orig
      type(c_ptr),value :: handle
      integer(kind(rocblas_side_left)),value :: side
      integer(c_int),value :: m
      integer(c_int),value :: n
      type(c_ptr),value :: A
      integer(c_int),value :: lda
      integer(c_int64_t),value :: stride_a
      type(c_ptr),value :: x
      integer(c_int),value :: incx
      integer(c_int64_t),value :: stride_x
      type(c_ptr),value :: C
      integer(c_int),value :: ldc
      integer(c_int64_t),value :: stride_c
      integer(c_int),value :: batch_count
    end function

#ifdef USE_FPOINTER_INTERFACES
    module procedure rocblas_ddgmm_strided_batched_full_rank,rocblas_ddgmm_strided_batched_rank_0,rocblas_ddgmm_strided_batched_rank_1
#endif

  end interface
  
  interface rocblas_cdgmm_strided_batched
    function rocblas_cdgmm_strided_batched_orig(handle,side,m,n,A,lda,stride_a,x,incx,stride_x,C,ldc,stride_c,batch_count) bind(c, name="rocblas_cdgmm_strided_batched")
      use iso_c_binding
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocblas_cdgmm_strided_batched_orig
      type(c_ptr),value :: handle
      integer(kind(rocblas_side_left)),value :: side
      integer(c_int),value :: m
      integer(c_int),value :: n
      type(c_ptr),value :: A
      integer(c_int),value :: lda
      integer(c_int64_t),value :: stride_a
      type(c_ptr),value :: x
      integer(c_int),value :: incx
      integer(c_int64_t),value :: stride_x
      type(c_ptr),value :: C
      integer(c_int),value :: ldc
      integer(c_int64_t),value :: stride_c
      integer(c_int),value :: batch_count
    end function

#ifdef USE_FPOINTER_INTERFACES
    module procedure rocblas_cdgmm_strided_batched_full_rank,rocblas_cdgmm_strided_batched_rank_0,rocblas_cdgmm_strided_batched_rank_1
#endif

  end interface
  !> ! \brief BLAS Level 3 API
  !> 
  !>     \details
  !>     xDGMM_strided_batched performs one of the batched matrix-matrix operations
  !> 
  !>         C_i = A_i  diag(x_i)   if side == rocblas_side_right   for i = 0, 1, ... batch_count-1
  !>         C_i = diag(x_i)  A_i   if side == rocblas_side_left    for i = 0, 1, ... batch_count-1
  !> 
  !>     where C_i and A_i are m by n dimensional matrices. diag(x_i) is a diagonal matrix
  !>     and x_i is vector of dimension n if side == rocblas_side_right and dimension m
  !>     if side == rocblas_side_left.
  !> 
  !>     @param[in]
  !>     handle    [rocblas_handle]
  !>               handle to the rocblas library context queue.
  !>     @param[in]
  !>     side      [rocblas_side]
  !>               specifies the side of diag(x)
  !>     @param[in]
  !>     m         [rocblas_int]
  !>               matrix dimension m.
  !>     @param[in]
  !>     n         [rocblas_int]
  !>               matrix dimension n.
  !>     @param[in]
  !>     A         device pointer to the first matrix A_0 on the GPU.
  !>               Each A_i is of dimension ( lda, n )
  !>     @param[in]
  !>     lda       [rocblas_int]
  !>               specifies the leading dimension of A.
  !>     @param[in]
  !>     stride_A  [rocblas_stride]
  !>               stride from the start of one matrix (A_i) and the next one (A_i+1)
  !>     @param[in]
  !>     x         pointer to the first vector x_0 on the GPU.
  !>               Each x_i is of dimension n if side == rocblas_side_right and dimension
  !>               m if side == rocblas_side_left
  !>     @param[in]
  !>     incx      [rocblas_int]
  !>               specifies the increment between values of x
  !>     @param[in]
  !>     stride_x  [rocblas_stride]
  !>               stride from the start of one vector(x_i) and the next one (x_i+1)
  !>     @param[in, out]
  !>     C         device pointer to the first matrix C_0 on the GPU.
  !>               Each C_i is of dimension ( ldc, n ).
  !>     @param[in]
  !>     ldc       [rocblas_int]
  !>               specifies the leading dimension of C.
  !>     @param[in]
  !>     stride_C  [rocblas_stride]
  !>               stride from the start of one matrix (C_i) and the next one (C_i+1)
  !>     @param[in]
  !>     batch_count [rocblas_int]
  !>                 number of instances i in the batch.
  !> 
  !>     
  interface rocblas_zdgmm_strided_batched
    function rocblas_zdgmm_strided_batched_orig(handle,side,m,n,A,lda,stride_a,x,incx,stride_x,C,ldc,stride_c,batch_count) bind(c, name="rocblas_zdgmm_strided_batched")
      use iso_c_binding
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocblas_zdgmm_strided_batched_orig
      type(c_ptr),value :: handle
      integer(kind(rocblas_side_left)),value :: side
      integer(c_int),value :: m
      integer(c_int),value :: n
      type(c_ptr),value :: A
      integer(c_int),value :: lda
      integer(c_int64_t),value :: stride_a
      type(c_ptr),value :: x
      integer(c_int),value :: incx
      integer(c_int64_t),value :: stride_x
      type(c_ptr),value :: C
      integer(c_int),value :: ldc
      integer(c_int64_t),value :: stride_c
      integer(c_int),value :: batch_count
    end function

#ifdef USE_FPOINTER_INTERFACES
    module procedure rocblas_zdgmm_strided_batched_full_rank,rocblas_zdgmm_strided_batched_rank_0,rocblas_zdgmm_strided_batched_rank_1
#endif

  end interface
  
  interface rocblas_sgeam
    function rocblas_sgeam_orig(handle,transA,transB,m,n,alpha,A,lda,beta,B,ldb,C,ldc) bind(c, name="rocblas_sgeam")
      use iso_c_binding
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocblas_sgeam_orig
      type(c_ptr),value :: handle
      integer(kind(rocblas_operation_none)),value :: transA
      integer(kind(rocblas_operation_none)),value :: transB
      integer(c_int),value :: m
      integer(c_int),value :: n
      real(c_float) :: alpha
      type(c_ptr),value :: A
      integer(c_int),value :: lda
      real(c_float) :: beta
      type(c_ptr),value :: B
      integer(c_int),value :: ldb
      type(c_ptr),value :: C
      integer(c_int),value :: ldc
    end function

#ifdef USE_FPOINTER_INTERFACES
    module procedure rocblas_sgeam_full_rank,rocblas_sgeam_rank_0,rocblas_sgeam_rank_1
#endif

  end interface
  
  interface rocblas_dgeam
    function rocblas_dgeam_orig(handle,transA,transB,m,n,alpha,A,lda,beta,B,ldb,C,ldc) bind(c, name="rocblas_dgeam")
      use iso_c_binding
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocblas_dgeam_orig
      type(c_ptr),value :: handle
      integer(kind(rocblas_operation_none)),value :: transA
      integer(kind(rocblas_operation_none)),value :: transB
      integer(c_int),value :: m
      integer(c_int),value :: n
      real(c_double) :: alpha
      type(c_ptr),value :: A
      integer(c_int),value :: lda
      real(c_double) :: beta
      type(c_ptr),value :: B
      integer(c_int),value :: ldb
      type(c_ptr),value :: C
      integer(c_int),value :: ldc
    end function

#ifdef USE_FPOINTER_INTERFACES
    module procedure rocblas_dgeam_full_rank,rocblas_dgeam_rank_0,rocblas_dgeam_rank_1
#endif

  end interface
  
  interface rocblas_cgeam
    function rocblas_cgeam_orig(handle,transA,transB,m,n,alpha,A,lda,beta,B,ldb,C,ldc) bind(c, name="rocblas_cgeam")
      use iso_c_binding
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocblas_cgeam_orig
      type(c_ptr),value :: handle
      integer(kind(rocblas_operation_none)),value :: transA
      integer(kind(rocblas_operation_none)),value :: transB
      integer(c_int),value :: m
      integer(c_int),value :: n
      complex(c_float_complex) :: alpha
      type(c_ptr),value :: A
      integer(c_int),value :: lda
      complex(c_float_complex) :: beta
      type(c_ptr),value :: B
      integer(c_int),value :: ldb
      type(c_ptr),value :: C
      integer(c_int),value :: ldc
    end function

#ifdef USE_FPOINTER_INTERFACES
    module procedure rocblas_cgeam_full_rank,rocblas_cgeam_rank_0,rocblas_cgeam_rank_1
#endif

  end interface
  !> ! \brief BLAS Level 3 API
  !> 
  !>     \details
  !>     xGEAM performs one of the matrix-matrix operations
  !> 
  !>         C = alphaop( A ) + betaop( B ),
  !> 
  !>     where op( X ) is one of
  !> 
  !>         op( X ) = X      or
  !>         op( X ) = XT   or
  !>         op( X ) = XH,
  !> 
  !>     alpha and beta are scalars, and A, B and C are matrices, with
  !>     op( A ) an m by n matrix, op( B ) an m by n matrix, and C an m by n matrix.
  !> 
  !>     @param[in]
  !>     handle    [rocblas_handle]
  !>               handle to the rocblas library context queue.
  !>     @param[in]
  !>     transA    [rocblas_operation]
  !>               specifies the form of op( A )
  !>     @param[in]
  !>     transB    [rocblas_operation]
  !>               specifies the form of op( B )
  !>     @param[in]
  !>     m         [rocblas_int]
  !>               matrix dimension m.
  !>     @param[in]
  !>     n         [rocblas_int]
  !>               matrix dimension n.
  !>     @param[in]
  !>     alpha     device pointer or host pointer specifying the scalar alpha.
  !>     @param[in]
  !>     A         device pointer storing matrix A.
  !>     @param[in]
  !>     lda       [rocblas_int]
  !>               specifies the leading dimension of A.
  !>     @param[in]
  !>     beta      device pointer or host pointer specifying the scalar beta.
  !>     @param[in]
  !>     B         device pointer storing matrix B.
  !>     @param[in]
  !>     ldb       [rocblas_int]
  !>               specifies the leading dimension of B.
  !>     @param[in, out]
  !>     C         device pointer storing matrix C.
  !>     @param[in]
  !>     ldc       [rocblas_int]
  !>               specifies the leading dimension of C.
  !> 
  !>     
  interface rocblas_zgeam
    function rocblas_zgeam_orig(handle,transA,transB,m,n,alpha,A,lda,beta,B,ldb,C,ldc) bind(c, name="rocblas_zgeam")
      use iso_c_binding
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocblas_zgeam_orig
      type(c_ptr),value :: handle
      integer(kind(rocblas_operation_none)),value :: transA
      integer(kind(rocblas_operation_none)),value :: transB
      integer(c_int),value :: m
      integer(c_int),value :: n
      complex(c_double_complex) :: alpha
      type(c_ptr),value :: A
      integer(c_int),value :: lda
      complex(c_double_complex) :: beta
      type(c_ptr),value :: B
      integer(c_int),value :: ldb
      type(c_ptr),value :: C
      integer(c_int),value :: ldc
    end function

#ifdef USE_FPOINTER_INTERFACES
    module procedure rocblas_zgeam_full_rank,rocblas_zgeam_rank_0,rocblas_zgeam_rank_1
#endif

  end interface
  
  interface rocblas_sgeam_batched
    function rocblas_sgeam_batched_orig(handle,transA,transB,m,n,alpha,A,lda,beta,B,ldb,C,ldc,batch_count) bind(c, name="rocblas_sgeam_batched")
      use iso_c_binding
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocblas_sgeam_batched_orig
      type(c_ptr),value :: handle
      integer(kind(rocblas_operation_none)),value :: transA
      integer(kind(rocblas_operation_none)),value :: transB
      integer(c_int),value :: m
      integer(c_int),value :: n
      real(c_float) :: alpha
      type(c_ptr) :: A
      integer(c_int),value :: lda
      real(c_float) :: beta
      type(c_ptr) :: B
      integer(c_int),value :: ldb
      type(c_ptr) :: C
      integer(c_int),value :: ldc
      integer(c_int),value :: batch_count
    end function

#ifdef USE_FPOINTER_INTERFACES
    module procedure rocblas_sgeam_batched_full_rank,rocblas_sgeam_batched_rank_0,rocblas_sgeam_batched_rank_1
#endif

  end interface
  
  interface rocblas_dgeam_batched
    function rocblas_dgeam_batched_orig(handle,transA,transB,m,n,alpha,A,lda,beta,B,ldb,C,ldc,batch_count) bind(c, name="rocblas_dgeam_batched")
      use iso_c_binding
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocblas_dgeam_batched_orig
      type(c_ptr),value :: handle
      integer(kind(rocblas_operation_none)),value :: transA
      integer(kind(rocblas_operation_none)),value :: transB
      integer(c_int),value :: m
      integer(c_int),value :: n
      real(c_double) :: alpha
      type(c_ptr) :: A
      integer(c_int),value :: lda
      real(c_double) :: beta
      type(c_ptr) :: B
      integer(c_int),value :: ldb
      type(c_ptr) :: C
      integer(c_int),value :: ldc
      integer(c_int),value :: batch_count
    end function

#ifdef USE_FPOINTER_INTERFACES
    module procedure rocblas_dgeam_batched_full_rank,rocblas_dgeam_batched_rank_0,rocblas_dgeam_batched_rank_1
#endif

  end interface
  
  interface rocblas_cgeam_batched
    function rocblas_cgeam_batched_orig(handle,transA,transB,m,n,alpha,A,lda,beta,B,ldb,C,ldc,batch_count) bind(c, name="rocblas_cgeam_batched")
      use iso_c_binding
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocblas_cgeam_batched_orig
      type(c_ptr),value :: handle
      integer(kind(rocblas_operation_none)),value :: transA
      integer(kind(rocblas_operation_none)),value :: transB
      integer(c_int),value :: m
      integer(c_int),value :: n
      complex(c_float_complex) :: alpha
      type(c_ptr) :: A
      integer(c_int),value :: lda
      complex(c_float_complex) :: beta
      type(c_ptr) :: B
      integer(c_int),value :: ldb
      type(c_ptr) :: C
      integer(c_int),value :: ldc
      integer(c_int),value :: batch_count
    end function

#ifdef USE_FPOINTER_INTERFACES
    module procedure rocblas_cgeam_batched_full_rank,rocblas_cgeam_batched_rank_0,rocblas_cgeam_batched_rank_1
#endif

  end interface
  !> ! \brief BLAS Level 3 API
  !> 
  !>     \details
  !>     xGEAM_batched performs one of the batched matrix-matrix operations
  !> 
  !>         C_i = alphaop( A_i ) + betaop( B_i )  for i = 0, 1, ... batch_count - 1
  !> 
  !>     where alpha and beta are scalars, and op(A_i), op(B_i) and C_i are m by n matrices
  !>     and op( X ) is one of
  !> 
  !>         op( X ) = X      or
  !>         op( X ) = XT
  !> 
  !>     @param[in]
  !>     handle    [rocblas_handle]
  !>               handle to the rocblas library context queue.
  !>     @param[in]
  !>     transA    [rocblas_operation]
  !>               specifies the form of op( A )
  !>     @param[in]
  !>     transB    [rocblas_operation]
  !>               specifies the form of op( B )
  !>     @param[in]
  !>     m         [rocblas_int]
  !>               matrix dimension m.
  !>     @param[in]
  !>     n         [rocblas_int]
  !>               matrix dimension n.
  !>     @param[in]
  !>     alpha     device pointer or host pointer specifying the scalar alpha.
  !>     @param[in]
  !>     A         device array of device pointers storing each matrix A_i on the GPU.
  !>               Each A_i is of dimension ( lda, k ), where k is m
  !>               when  transA == rocblas_operation_none and
  !>               is  n  when  transA == rocblas_operation_transpose.
  !>     @param[in]
  !>     lda       [rocblas_int]
  !>               specifies the leading dimension of A.
  !>     @param[in]
  !>     beta      device pointer or host pointer specifying the scalar beta.
  !>     @param[in]
  !>     B         device array of device pointers storing each matrix B_i on the GPU.
  !>               Each B_i is of dimension ( ldb, k ), where k is m
  !>               when  transB == rocblas_operation_none and
  !>               is  n  when  transB == rocblas_operation_transpose.
  !>     @param[in]
  !>     ldb       [rocblas_int]
  !>               specifies the leading dimension of B.
  !>     @param[in, out]
  !>     C         device array of device pointers storing each matrix C_i on the GPU.
  !>               Each C_i is of dimension ( ldc, n ).
  !>     @param[in]
  !>     ldc       [rocblas_int]
  !>               specifies the leading dimension of C.
  !> 
  !>     @param[in]
  !>     batch_count [rocblas_int]
  !>                 number of instances i in the batch.
  !> 
  !>     
  interface rocblas_zgeam_batched
    function rocblas_zgeam_batched_orig(handle,transA,transB,m,n,alpha,A,lda,beta,B,ldb,C,ldc,batch_count) bind(c, name="rocblas_zgeam_batched")
      use iso_c_binding
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocblas_zgeam_batched_orig
      type(c_ptr),value :: handle
      integer(kind(rocblas_operation_none)),value :: transA
      integer(kind(rocblas_operation_none)),value :: transB
      integer(c_int),value :: m
      integer(c_int),value :: n
      complex(c_double_complex) :: alpha
      type(c_ptr) :: A
      integer(c_int),value :: lda
      complex(c_double_complex) :: beta
      type(c_ptr) :: B
      integer(c_int),value :: ldb
      type(c_ptr) :: C
      integer(c_int),value :: ldc
      integer(c_int),value :: batch_count
    end function

#ifdef USE_FPOINTER_INTERFACES
    module procedure rocblas_zgeam_batched_full_rank,rocblas_zgeam_batched_rank_0,rocblas_zgeam_batched_rank_1
#endif

  end interface
  
  interface rocblas_sgeam_strided_batched
    function rocblas_sgeam_strided_batched_orig(handle,transA,transB,m,n,alpha,A,lda,stride_a,beta,B,ldb,stride_b,C,ldc,stride_c,batch_count) bind(c, name="rocblas_sgeam_strided_batched")
      use iso_c_binding
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocblas_sgeam_strided_batched_orig
      type(c_ptr),value :: handle
      integer(kind(rocblas_operation_none)),value :: transA
      integer(kind(rocblas_operation_none)),value :: transB
      integer(c_int),value :: m
      integer(c_int),value :: n
      real(c_float) :: alpha
      type(c_ptr),value :: A
      integer(c_int),value :: lda
      integer(c_int64_t),value :: stride_a
      real(c_float) :: beta
      type(c_ptr),value :: B
      integer(c_int),value :: ldb
      integer(c_int64_t),value :: stride_b
      type(c_ptr),value :: C
      integer(c_int),value :: ldc
      integer(c_int64_t),value :: stride_c
      integer(c_int),value :: batch_count
    end function

#ifdef USE_FPOINTER_INTERFACES
    module procedure rocblas_sgeam_strided_batched_full_rank,rocblas_sgeam_strided_batched_rank_0,rocblas_sgeam_strided_batched_rank_1
#endif

  end interface
  
  interface rocblas_dgeam_strided_batched
    function rocblas_dgeam_strided_batched_orig(handle,transA,transB,m,n,alpha,A,lda,stride_a,beta,B,ldb,stride_b,C,ldc,stride_c,batch_count) bind(c, name="rocblas_dgeam_strided_batched")
      use iso_c_binding
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocblas_dgeam_strided_batched_orig
      type(c_ptr),value :: handle
      integer(kind(rocblas_operation_none)),value :: transA
      integer(kind(rocblas_operation_none)),value :: transB
      integer(c_int),value :: m
      integer(c_int),value :: n
      real(c_double) :: alpha
      type(c_ptr),value :: A
      integer(c_int),value :: lda
      integer(c_int64_t),value :: stride_a
      real(c_double) :: beta
      type(c_ptr),value :: B
      integer(c_int),value :: ldb
      integer(c_int64_t),value :: stride_b
      type(c_ptr),value :: C
      integer(c_int),value :: ldc
      integer(c_int64_t),value :: stride_c
      integer(c_int),value :: batch_count
    end function

#ifdef USE_FPOINTER_INTERFACES
    module procedure rocblas_dgeam_strided_batched_full_rank,rocblas_dgeam_strided_batched_rank_0,rocblas_dgeam_strided_batched_rank_1
#endif

  end interface
  
  interface rocblas_cgeam_strided_batched
    function rocblas_cgeam_strided_batched_orig(handle,transA,transB,m,n,alpha,A,lda,stride_a,beta,B,ldb,stride_b,C,ldc,stride_c,batch_count) bind(c, name="rocblas_cgeam_strided_batched")
      use iso_c_binding
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocblas_cgeam_strided_batched_orig
      type(c_ptr),value :: handle
      integer(kind(rocblas_operation_none)),value :: transA
      integer(kind(rocblas_operation_none)),value :: transB
      integer(c_int),value :: m
      integer(c_int),value :: n
      complex(c_float_complex) :: alpha
      type(c_ptr),value :: A
      integer(c_int),value :: lda
      integer(c_int64_t),value :: stride_a
      complex(c_float_complex) :: beta
      type(c_ptr),value :: B
      integer(c_int),value :: ldb
      integer(c_int64_t),value :: stride_b
      type(c_ptr),value :: C
      integer(c_int),value :: ldc
      integer(c_int64_t),value :: stride_c
      integer(c_int),value :: batch_count
    end function

#ifdef USE_FPOINTER_INTERFACES
    module procedure rocblas_cgeam_strided_batched_full_rank,rocblas_cgeam_strided_batched_rank_0,rocblas_cgeam_strided_batched_rank_1
#endif

  end interface
  !> ! \brief BLAS Level 3 API
  !> 
  !>     \details
  !>     xGEAM_strided_batched performs one of the batched matrix-matrix operations
  !> 
  !>         C_i = alphaop( A_i ) + betaop( B_i )  for i = 0, 1, ... batch_count - 1
  !> 
  !>     where alpha and beta are scalars, and op(A_i), op(B_i) and C_i are m by n matrices
  !>     and op( X ) is one of
  !> 
  !>         op( X ) = X      or
  !>         op( X ) = XT
  !> 
  !>     @param[in]
  !>     handle    [rocblas_handle]
  !>               handle to the rocblas library context queue.
  !> 
  !>     @param[in]
  !>     transA    [rocblas_operation]
  !>               specifies the form of op( A )
  !> 
  !>     @param[in]
  !>     transB    [rocblas_operation]
  !>               specifies the form of op( B )
  !> 
  !>     @param[in]
  !>     m         [rocblas_int]
  !>               matrix dimension m.
  !> 
  !>     @param[in]
  !>     n         [rocblas_int]
  !>               matrix dimension n.
  !> 
  !>     @param[in]
  !>     alpha     device pointer or host pointer specifying the scalar alpha.
  !> 
  !>     @param[in]
  !>     A         device pointer to the first matrix A_0 on the GPU.
  !>               Each A_i is of dimension ( lda, k ), where k is m
  !>               when  transA == rocblas_operation_none and
  !>               is  n  when  transA == rocblas_operation_transpose.
  !> 
  !>     @param[in]
  !>     lda       [rocblas_int]
  !>               specifies the leading dimension of A.
  !> 
  !>     @param[in]
  !>     stride_A  [rocblas_stride]
  !>               stride from the start of one matrix (A_i) and the next one (A_i+1)
  !> 
  !>     @param[in]
  !>     beta      device pointer or host pointer specifying the scalar beta.
  !> 
  !>     @param[in]
  !>     B         pointer to the first matrix B_0 on the GPU.
  !>               Each B_i is of dimension ( ldb, k ), where k is m
  !>               when  transB == rocblas_operation_none and
  !>               is  n  when  transB == rocblas_operation_transpose.
  !> 
  !>     @param[in]
  !>     ldb       [rocblas_int]
  !>               specifies the leading dimension of B.
  !> 
  !>     @param[in]
  !>     stride_B  [rocblas_stride]
  !>               stride from the start of one matrix (B_i) and the next one (B_i+1)
  !> 
  !>     @param[in, out]
  !>     C         pointer to the first matrix C_0 on the GPU.
  !>               Each C_i is of dimension ( ldc, n ).
  !> 
  !>     @param[in]
  !>     ldc       [rocblas_int]
  !>               specifies the leading dimension of C.
  !> 
  !>     @param[in]
  !>     stride_C  [rocblas_stride]
  !>               stride from the start of one matrix (C_i) and the next one (C_i+1)
  !> 
  !>     @param[in]
  !>     batch_count [rocblas_int]
  !>                 number of instances i in the batch.
  !> 
  !>     
  interface rocblas_zgeam_strided_batched
    function rocblas_zgeam_strided_batched_orig(handle,transA,transB,m,n,alpha,A,lda,stride_a,beta,B,ldb,stride_b,C,ldc,stride_c,batch_count) bind(c, name="rocblas_zgeam_strided_batched")
      use iso_c_binding
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocblas_zgeam_strided_batched_orig
      type(c_ptr),value :: handle
      integer(kind(rocblas_operation_none)),value :: transA
      integer(kind(rocblas_operation_none)),value :: transB
      integer(c_int),value :: m
      integer(c_int),value :: n
      complex(c_double_complex) :: alpha
      type(c_ptr),value :: A
      integer(c_int),value :: lda
      integer(c_int64_t),value :: stride_a
      complex(c_double_complex) :: beta
      type(c_ptr),value :: B
      integer(c_int),value :: ldb
      integer(c_int64_t),value :: stride_b
      type(c_ptr),value :: C
      integer(c_int),value :: ldc
      integer(c_int64_t),value :: stride_c
      integer(c_int),value :: batch_count
    end function

#ifdef USE_FPOINTER_INTERFACES
    module procedure rocblas_zgeam_strided_batched_full_rank,rocblas_zgeam_strided_batched_rank_0,rocblas_zgeam_strided_batched_rank_1
#endif

  end interface
  !> ! \brief   loads char buf with the rocblas library version. size_t len
  !>     is the maximum length of char buf.
  !>     \details
  !> 
  !>     @param[in, out]
  !>     buf             pointer to buffer for version string
  !> 
  !>     @param[in]
  !>     len             length of buf
  !> 
  !>  
  interface rocblas_get_version_string
    function rocblas_get_version_string_orig(buf,len) bind(c, name="rocblas_get_version_string")
      use iso_c_binding
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocblas_get_version_string_orig
      type(c_ptr),value :: buf
      integer(c_size_t),value :: len
    end function


  end interface
  !> ! \brief
  !>     \details
  !>     Indicates that subsequent rocBLAS kernel calls should collect the optimal device memory size in bytes for their given kernel arguments,
  !>     and keep track of the maximum.
  !>     Each kernel call can reuse temporary device memory on the same stream, so the maximum is collected.
  !>     Returns rocblas_status_size_query_mismatch if another size query is already in progress; returns rocblas_status_success otherwise.
  !>     @param[in]
  !>     handle          rocblas handle
  !>  
  interface rocblas_start_device_memory_size_query
    function rocblas_start_device_memory_size_query_orig(handle) bind(c, name="rocblas_start_device_memory_size_query")
      use iso_c_binding
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocblas_start_device_memory_size_query_orig
      type(c_ptr),value :: handle
    end function


  end interface
  !> ! \brief
  !>     \details
  !>     Stops collecting optimal device memory size information
  !>     Returns rocblas_status_size_query_mismatch if a collection is not underway; rocblas_status_invalid_handle if handle is nullptr;
  !>     rocblas_status_invalid_pointer if size is nullptr; rocblas_status_success otherwise
  !>     @param[in]
  !>     handle          rocblas handle
  !>     @param[out]
  !>     size            maximum of the optimal sizes collected
  !>  
  interface rocblas_stop_device_memory_size_query
    function rocblas_stop_device_memory_size_query_orig(handle,mySize) bind(c, name="rocblas_stop_device_memory_size_query")
      use iso_c_binding
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocblas_stop_device_memory_size_query_orig
      type(c_ptr),value :: handle
      type(c_ptr),value :: mySize
    end function


  end interface
  
  interface rocblas_device_malloc_ptr
    function rocblas_device_malloc_ptr_orig(ptr,res) bind(c, name="rocblas_device_malloc_ptr")
      use iso_c_binding
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocblas_device_malloc_ptr_orig
      type(c_ptr),value :: ptr
      type(c_ptr) :: res
    end function


  end interface
  
  interface rocblas_device_malloc_get
    function rocblas_device_malloc_get_orig(ptr,index,res) bind(c, name="rocblas_device_malloc_get")
      use iso_c_binding
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocblas_device_malloc_get_orig
      type(c_ptr),value :: ptr
      integer(c_size_t),value :: index
      type(c_ptr) :: res
    end function


  end interface
  
  interface rocblas_device_malloc_free
    function rocblas_device_malloc_free_orig(ptr) bind(c, name="rocblas_device_malloc_free")
      use iso_c_binding
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocblas_device_malloc_free_orig
      type(c_ptr),value :: ptr
    end function


  end interface
  !> ! \brief
  !>     \details
  !>     Gets the current device memory size for the handle
  !>     Returns rocblas_status_invalid_handle if handle is nullptr; rocblas_status_invalid_pointer if size is nullptr; rocblas_status_success otherwise
  !>     @param[in]
  !>     handle          rocblas handle
  !>     @param[out]
  !>     size             current device memory size for the handle
  !>  
  interface rocblas_get_device_memory_size
    function rocblas_get_device_memory_size_orig(handle,mySize) bind(c, name="rocblas_get_device_memory_size")
      use iso_c_binding
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocblas_get_device_memory_size_orig
      type(c_ptr),value :: handle
      type(c_ptr),value :: mySize
    end function


  end interface
  !> ! \brief
  !>     \details
  !>     Changes the size of allocated device memory at runtime.
  !> 
  !>     Any previously allocated device memory is freed.
  !> 
  !>     If size > 0 sets the device memory size to the specified size (in bytes)
  !>     If size == 0 frees the memory allocated so far, and lets rocBLAS manage device memory in the future, expanding it when necessary
  !>     Returns rocblas_status_invalid_handle if handle is nullptr; rocblas_status_invalid_pointer if size is nullptr; rocblas_status_success otherwise
  !>     @param[in]
  !>     handle          rocblas handle
  !>     @param[in]
  !>     size             size of allocated device memory
  !>  
  interface rocblas_set_device_memory_size
    function rocblas_set_device_memory_size_orig(handle,mySize) bind(c, name="rocblas_set_device_memory_size")
      use iso_c_binding
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocblas_set_device_memory_size_orig
      type(c_ptr),value :: handle
      integer(c_size_t),value :: mySize
    end function


  end interface
  !> ! \brief create handle
  !>  
  interface rocblas_create_handle
    function rocblas_create_handle_orig(handle) bind(c, name="rocblas_create_handle")
      use iso_c_binding
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocblas_create_handle_orig
      type(c_ptr) :: handle
    end function


  end interface
  !> ! \brief destroy handle
  !>  
  interface rocblas_destroy_handle
    function rocblas_destroy_handle_orig(handle) bind(c, name="rocblas_destroy_handle")
      use iso_c_binding
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocblas_destroy_handle_orig
      type(c_ptr),value :: handle
    end function


  end interface
  !> ! \brief set stream for handle
  !>  
  interface rocblas_set_stream
    function rocblas_set_stream_orig(handle,stream) bind(c, name="rocblas_set_stream")
      use iso_c_binding
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocblas_set_stream_orig
      type(c_ptr),value :: handle
      type(c_ptr),value :: stream
    end function


  end interface
  !> ! \brief get stream [0] from handle
  !>  
  interface rocblas_get_stream
    function rocblas_get_stream_orig(handle,stream) bind(c, name="rocblas_get_stream")
      use iso_c_binding
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocblas_get_stream_orig
      type(c_ptr),value :: handle
      type(c_ptr) :: stream
    end function


  end interface
  !> ! \brief set rocblas_pointer_mode
  !>  
  interface rocblas_set_pointer_mode
    function rocblas_set_pointer_mode_orig(handle,pointer_mode) bind(c, name="rocblas_set_pointer_mode")
      use iso_c_binding
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocblas_set_pointer_mode_orig
      type(c_ptr),value :: handle
      integer(kind(rocblas_pointer_mode_host)),value :: pointer_mode
    end function


  end interface
  !> ! \brief get rocblas_pointer_mode
  !>  
  interface rocblas_get_pointer_mode
    function rocblas_get_pointer_mode_orig(handle,pointer_mode) bind(c, name="rocblas_get_pointer_mode")
      use iso_c_binding
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocblas_get_pointer_mode_orig
      type(c_ptr),value :: handle
      type(c_ptr),value :: pointer_mode
    end function


  end interface
  !> ! \brief set rocblas_atomics_mode
  !>  
  interface rocblas_set_atomics_mode
    function rocblas_set_atomics_mode_orig(handle,atomics_mode) bind(c, name="rocblas_set_atomics_mode")
      use iso_c_binding
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocblas_set_atomics_mode_orig
      type(c_ptr),value :: handle
      integer(kind(rocblas_atomics_not_allowed)),value :: atomics_mode
    end function


  end interface
  !> ! \brief get rocblas_atomics_mode
  !>  
  interface rocblas_get_atomics_mode
    function rocblas_get_atomics_mode_orig(handle,atomics_mode) bind(c, name="rocblas_get_atomics_mode")
      use iso_c_binding
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocblas_get_atomics_mode_orig
      type(c_ptr),value :: handle
      type(c_ptr),value :: atomics_mode
    end function


  end interface
  !> 
  !>   Function to set startstop event handlers (for internal use only)
  !>  
  interface rocblas_set_start_stop_events
    function rocblas_set_start_stop_events_orig(handle,startEvent,stopEvent) bind(c, name="rocblas_set_start_stop_events")
      use iso_c_binding
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocblas_set_start_stop_events_orig
      type(c_ptr),value :: handle
      type(c_ptr),value :: startEvent
      type(c_ptr),value :: stopEvent
    end function


  end interface

#ifdef USE_FPOINTER_INTERFACES
  contains
    function rocblas_cscal_rank_0(handle,n,alpha,x,incx)
      use iso_c_binding
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocblas_cscal_rank_0
      type(c_ptr),value :: handle
      integer(c_int),value :: n
      complex(c_float_complex) :: alpha
      complex(c_float_complex),target :: x
      integer(c_int),value :: incx
      !
      rocblas_cscal_rank_0 = rocblas_cscal_orig(handle,n,alpha,c_loc(x),incx)
    end function

    function rocblas_cscal_rank_1(handle,n,alpha,x,incx)
      use iso_c_binding
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocblas_cscal_rank_1
      type(c_ptr),value :: handle
      integer(c_int),value :: n
      complex(c_float_complex) :: alpha
      complex(c_float_complex),target,dimension(:) :: x
      integer(c_int),value :: incx
      !
      rocblas_cscal_rank_1 = rocblas_cscal_orig(handle,n,alpha,c_loc(x),incx)
    end function

    function rocblas_zscal_rank_0(handle,n,alpha,x,incx)
      use iso_c_binding
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocblas_zscal_rank_0
      type(c_ptr),value :: handle
      integer(c_int),value :: n
      complex(c_double_complex) :: alpha
      complex(c_double_complex),target :: x
      integer(c_int),value :: incx
      !
      rocblas_zscal_rank_0 = rocblas_zscal_orig(handle,n,alpha,c_loc(x),incx)
    end function

    function rocblas_zscal_rank_1(handle,n,alpha,x,incx)
      use iso_c_binding
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocblas_zscal_rank_1
      type(c_ptr),value :: handle
      integer(c_int),value :: n
      complex(c_double_complex) :: alpha
      complex(c_double_complex),target,dimension(:) :: x
      integer(c_int),value :: incx
      !
      rocblas_zscal_rank_1 = rocblas_zscal_orig(handle,n,alpha,c_loc(x),incx)
    end function

    function rocblas_csscal_rank_0(handle,n,alpha,x,incx)
      use iso_c_binding
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocblas_csscal_rank_0
      type(c_ptr),value :: handle
      integer(c_int),value :: n
      real(c_float) :: alpha
      complex(c_float_complex),target :: x
      integer(c_int),value :: incx
      !
      rocblas_csscal_rank_0 = rocblas_csscal_orig(handle,n,alpha,c_loc(x),incx)
    end function

    function rocblas_csscal_rank_1(handle,n,alpha,x,incx)
      use iso_c_binding
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocblas_csscal_rank_1
      type(c_ptr),value :: handle
      integer(c_int),value :: n
      real(c_float) :: alpha
      complex(c_float_complex),target,dimension(:) :: x
      integer(c_int),value :: incx
      !
      rocblas_csscal_rank_1 = rocblas_csscal_orig(handle,n,alpha,c_loc(x),incx)
    end function

    function rocblas_zdscal_rank_0(handle,n,alpha,x,incx)
      use iso_c_binding
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocblas_zdscal_rank_0
      type(c_ptr),value :: handle
      integer(c_int),value :: n
      real(c_double) :: alpha
      complex(c_double_complex),target :: x
      integer(c_int),value :: incx
      !
      rocblas_zdscal_rank_0 = rocblas_zdscal_orig(handle,n,alpha,c_loc(x),incx)
    end function

    function rocblas_zdscal_rank_1(handle,n,alpha,x,incx)
      use iso_c_binding
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocblas_zdscal_rank_1
      type(c_ptr),value :: handle
      integer(c_int),value :: n
      real(c_double) :: alpha
      complex(c_double_complex),target,dimension(:) :: x
      integer(c_int),value :: incx
      !
      rocblas_zdscal_rank_1 = rocblas_zdscal_orig(handle,n,alpha,c_loc(x),incx)
    end function

    function rocblas_sscal_batched_full_rank(handle,n,alpha,x,incx,batch_count)
      use iso_c_binding
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocblas_sscal_batched_full_rank
      type(c_ptr),value :: handle
      integer(c_int),value :: n
      real(c_float) :: alpha
      real(c_float),target,dimension(:,:) :: x
      integer(c_int),value :: incx
      integer(c_int),value :: batch_count
      !
      rocblas_sscal_batched_full_rank = rocblas_sscal_batched_orig(handle,n,alpha,c_loc(x),incx,batch_count)
    end function

    function rocblas_sscal_batched_rank_0(handle,n,alpha,x,incx,batch_count)
      use iso_c_binding
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocblas_sscal_batched_rank_0
      type(c_ptr),value :: handle
      integer(c_int),value :: n
      real(c_float) :: alpha
      real(c_float),target :: x
      integer(c_int),value :: incx
      integer(c_int),value :: batch_count
      !
      rocblas_sscal_batched_rank_0 = rocblas_sscal_batched_orig(handle,n,alpha,c_loc(x),incx,batch_count)
    end function

    function rocblas_sscal_batched_rank_1(handle,n,alpha,x,incx,batch_count)
      use iso_c_binding
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocblas_sscal_batched_rank_1
      type(c_ptr),value :: handle
      integer(c_int),value :: n
      real(c_float) :: alpha
      real(c_float),target,dimension(:) :: x
      integer(c_int),value :: incx
      integer(c_int),value :: batch_count
      !
      rocblas_sscal_batched_rank_1 = rocblas_sscal_batched_orig(handle,n,alpha,c_loc(x),incx,batch_count)
    end function

    function rocblas_dscal_batched_full_rank(handle,n,alpha,x,incx,batch_count)
      use iso_c_binding
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocblas_dscal_batched_full_rank
      type(c_ptr),value :: handle
      integer(c_int),value :: n
      real(c_double) :: alpha
      real(c_double),target,dimension(:,:) :: x
      integer(c_int),value :: incx
      integer(c_int),value :: batch_count
      !
      rocblas_dscal_batched_full_rank = rocblas_dscal_batched_orig(handle,n,alpha,c_loc(x),incx,batch_count)
    end function

    function rocblas_dscal_batched_rank_0(handle,n,alpha,x,incx,batch_count)
      use iso_c_binding
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocblas_dscal_batched_rank_0
      type(c_ptr),value :: handle
      integer(c_int),value :: n
      real(c_double) :: alpha
      real(c_double),target :: x
      integer(c_int),value :: incx
      integer(c_int),value :: batch_count
      !
      rocblas_dscal_batched_rank_0 = rocblas_dscal_batched_orig(handle,n,alpha,c_loc(x),incx,batch_count)
    end function

    function rocblas_dscal_batched_rank_1(handle,n,alpha,x,incx,batch_count)
      use iso_c_binding
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocblas_dscal_batched_rank_1
      type(c_ptr),value :: handle
      integer(c_int),value :: n
      real(c_double) :: alpha
      real(c_double),target,dimension(:) :: x
      integer(c_int),value :: incx
      integer(c_int),value :: batch_count
      !
      rocblas_dscal_batched_rank_1 = rocblas_dscal_batched_orig(handle,n,alpha,c_loc(x),incx,batch_count)
    end function

    function rocblas_cscal_batched_full_rank(handle,n,alpha,x,incx,batch_count)
      use iso_c_binding
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocblas_cscal_batched_full_rank
      type(c_ptr),value :: handle
      integer(c_int),value :: n
      complex(c_float_complex) :: alpha
      complex(c_float_complex),target,dimension(:,:) :: x
      integer(c_int),value :: incx
      integer(c_int),value :: batch_count
      !
      rocblas_cscal_batched_full_rank = rocblas_cscal_batched_orig(handle,n,alpha,c_loc(x),incx,batch_count)
    end function

    function rocblas_cscal_batched_rank_0(handle,n,alpha,x,incx,batch_count)
      use iso_c_binding
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocblas_cscal_batched_rank_0
      type(c_ptr),value :: handle
      integer(c_int),value :: n
      complex(c_float_complex) :: alpha
      complex(c_float_complex),target :: x
      integer(c_int),value :: incx
      integer(c_int),value :: batch_count
      !
      rocblas_cscal_batched_rank_0 = rocblas_cscal_batched_orig(handle,n,alpha,c_loc(x),incx,batch_count)
    end function

    function rocblas_cscal_batched_rank_1(handle,n,alpha,x,incx,batch_count)
      use iso_c_binding
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocblas_cscal_batched_rank_1
      type(c_ptr),value :: handle
      integer(c_int),value :: n
      complex(c_float_complex) :: alpha
      complex(c_float_complex),target,dimension(:) :: x
      integer(c_int),value :: incx
      integer(c_int),value :: batch_count
      !
      rocblas_cscal_batched_rank_1 = rocblas_cscal_batched_orig(handle,n,alpha,c_loc(x),incx,batch_count)
    end function

    function rocblas_zscal_batched_full_rank(handle,n,alpha,x,incx,batch_count)
      use iso_c_binding
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocblas_zscal_batched_full_rank
      type(c_ptr),value :: handle
      integer(c_int),value :: n
      complex(c_double_complex) :: alpha
      complex(c_double_complex),target,dimension(:,:) :: x
      integer(c_int),value :: incx
      integer(c_int),value :: batch_count
      !
      rocblas_zscal_batched_full_rank = rocblas_zscal_batched_orig(handle,n,alpha,c_loc(x),incx,batch_count)
    end function

    function rocblas_zscal_batched_rank_0(handle,n,alpha,x,incx,batch_count)
      use iso_c_binding
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocblas_zscal_batched_rank_0
      type(c_ptr),value :: handle
      integer(c_int),value :: n
      complex(c_double_complex) :: alpha
      complex(c_double_complex),target :: x
      integer(c_int),value :: incx
      integer(c_int),value :: batch_count
      !
      rocblas_zscal_batched_rank_0 = rocblas_zscal_batched_orig(handle,n,alpha,c_loc(x),incx,batch_count)
    end function

    function rocblas_zscal_batched_rank_1(handle,n,alpha,x,incx,batch_count)
      use iso_c_binding
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocblas_zscal_batched_rank_1
      type(c_ptr),value :: handle
      integer(c_int),value :: n
      complex(c_double_complex) :: alpha
      complex(c_double_complex),target,dimension(:) :: x
      integer(c_int),value :: incx
      integer(c_int),value :: batch_count
      !
      rocblas_zscal_batched_rank_1 = rocblas_zscal_batched_orig(handle,n,alpha,c_loc(x),incx,batch_count)
    end function

    function rocblas_csscal_batched_full_rank(handle,n,alpha,x,incx,batch_count)
      use iso_c_binding
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocblas_csscal_batched_full_rank
      type(c_ptr),value :: handle
      integer(c_int),value :: n
      real(c_float) :: alpha
      complex(c_float_complex),target,dimension(:,:) :: x
      integer(c_int),value :: incx
      integer(c_int),value :: batch_count
      !
      rocblas_csscal_batched_full_rank = rocblas_csscal_batched_orig(handle,n,alpha,c_loc(x),incx,batch_count)
    end function

    function rocblas_csscal_batched_rank_0(handle,n,alpha,x,incx,batch_count)
      use iso_c_binding
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocblas_csscal_batched_rank_0
      type(c_ptr),value :: handle
      integer(c_int),value :: n
      real(c_float) :: alpha
      complex(c_float_complex),target :: x
      integer(c_int),value :: incx
      integer(c_int),value :: batch_count
      !
      rocblas_csscal_batched_rank_0 = rocblas_csscal_batched_orig(handle,n,alpha,c_loc(x),incx,batch_count)
    end function

    function rocblas_csscal_batched_rank_1(handle,n,alpha,x,incx,batch_count)
      use iso_c_binding
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocblas_csscal_batched_rank_1
      type(c_ptr),value :: handle
      integer(c_int),value :: n
      real(c_float) :: alpha
      complex(c_float_complex),target,dimension(:) :: x
      integer(c_int),value :: incx
      integer(c_int),value :: batch_count
      !
      rocblas_csscal_batched_rank_1 = rocblas_csscal_batched_orig(handle,n,alpha,c_loc(x),incx,batch_count)
    end function

    function rocblas_zdscal_batched_full_rank(handle,n,alpha,x,incx,batch_count)
      use iso_c_binding
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocblas_zdscal_batched_full_rank
      type(c_ptr),value :: handle
      integer(c_int),value :: n
      real(c_double) :: alpha
      complex(c_double_complex),target,dimension(:,:) :: x
      integer(c_int),value :: incx
      integer(c_int),value :: batch_count
      !
      rocblas_zdscal_batched_full_rank = rocblas_zdscal_batched_orig(handle,n,alpha,c_loc(x),incx,batch_count)
    end function

    function rocblas_zdscal_batched_rank_0(handle,n,alpha,x,incx,batch_count)
      use iso_c_binding
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocblas_zdscal_batched_rank_0
      type(c_ptr),value :: handle
      integer(c_int),value :: n
      real(c_double) :: alpha
      complex(c_double_complex),target :: x
      integer(c_int),value :: incx
      integer(c_int),value :: batch_count
      !
      rocblas_zdscal_batched_rank_0 = rocblas_zdscal_batched_orig(handle,n,alpha,c_loc(x),incx,batch_count)
    end function

    function rocblas_zdscal_batched_rank_1(handle,n,alpha,x,incx,batch_count)
      use iso_c_binding
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocblas_zdscal_batched_rank_1
      type(c_ptr),value :: handle
      integer(c_int),value :: n
      real(c_double) :: alpha
      complex(c_double_complex),target,dimension(:) :: x
      integer(c_int),value :: incx
      integer(c_int),value :: batch_count
      !
      rocblas_zdscal_batched_rank_1 = rocblas_zdscal_batched_orig(handle,n,alpha,c_loc(x),incx,batch_count)
    end function

    function rocblas_sscal_strided_batched_rank_0(handle,n,alpha,x,incx,stride_x,batch_count)
      use iso_c_binding
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocblas_sscal_strided_batched_rank_0
      type(c_ptr),value :: handle
      integer(c_int),value :: n
      real(c_float) :: alpha
      real(c_float),target :: x
      integer(c_int),value :: incx
      integer(c_int64_t),value :: stride_x
      integer(c_int),value :: batch_count
      !
      rocblas_sscal_strided_batched_rank_0 = rocblas_sscal_strided_batched_orig(handle,n,alpha,c_loc(x),incx,stride_x,batch_count)
    end function

    function rocblas_sscal_strided_batched_rank_1(handle,n,alpha,x,incx,stride_x,batch_count)
      use iso_c_binding
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocblas_sscal_strided_batched_rank_1
      type(c_ptr),value :: handle
      integer(c_int),value :: n
      real(c_float) :: alpha
      real(c_float),target,dimension(:) :: x
      integer(c_int),value :: incx
      integer(c_int64_t),value :: stride_x
      integer(c_int),value :: batch_count
      !
      rocblas_sscal_strided_batched_rank_1 = rocblas_sscal_strided_batched_orig(handle,n,alpha,c_loc(x),incx,stride_x,batch_count)
    end function

    function rocblas_dscal_strided_batched_rank_0(handle,n,alpha,x,incx,stride_x,batch_count)
      use iso_c_binding
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocblas_dscal_strided_batched_rank_0
      type(c_ptr),value :: handle
      integer(c_int),value :: n
      real(c_double) :: alpha
      real(c_double),target :: x
      integer(c_int),value :: incx
      integer(c_int64_t),value :: stride_x
      integer(c_int),value :: batch_count
      !
      rocblas_dscal_strided_batched_rank_0 = rocblas_dscal_strided_batched_orig(handle,n,alpha,c_loc(x),incx,stride_x,batch_count)
    end function

    function rocblas_dscal_strided_batched_rank_1(handle,n,alpha,x,incx,stride_x,batch_count)
      use iso_c_binding
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocblas_dscal_strided_batched_rank_1
      type(c_ptr),value :: handle
      integer(c_int),value :: n
      real(c_double) :: alpha
      real(c_double),target,dimension(:) :: x
      integer(c_int),value :: incx
      integer(c_int64_t),value :: stride_x
      integer(c_int),value :: batch_count
      !
      rocblas_dscal_strided_batched_rank_1 = rocblas_dscal_strided_batched_orig(handle,n,alpha,c_loc(x),incx,stride_x,batch_count)
    end function

    function rocblas_cscal_strided_batched_rank_0(handle,n,alpha,x,incx,stride_x,batch_count)
      use iso_c_binding
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocblas_cscal_strided_batched_rank_0
      type(c_ptr),value :: handle
      integer(c_int),value :: n
      complex(c_float_complex) :: alpha
      complex(c_float_complex),target :: x
      integer(c_int),value :: incx
      integer(c_int64_t),value :: stride_x
      integer(c_int),value :: batch_count
      !
      rocblas_cscal_strided_batched_rank_0 = rocblas_cscal_strided_batched_orig(handle,n,alpha,c_loc(x),incx,stride_x,batch_count)
    end function

    function rocblas_cscal_strided_batched_rank_1(handle,n,alpha,x,incx,stride_x,batch_count)
      use iso_c_binding
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocblas_cscal_strided_batched_rank_1
      type(c_ptr),value :: handle
      integer(c_int),value :: n
      complex(c_float_complex) :: alpha
      complex(c_float_complex),target,dimension(:) :: x
      integer(c_int),value :: incx
      integer(c_int64_t),value :: stride_x
      integer(c_int),value :: batch_count
      !
      rocblas_cscal_strided_batched_rank_1 = rocblas_cscal_strided_batched_orig(handle,n,alpha,c_loc(x),incx,stride_x,batch_count)
    end function

    function rocblas_zscal_strided_batched_rank_0(handle,n,alpha,x,incx,stride_x,batch_count)
      use iso_c_binding
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocblas_zscal_strided_batched_rank_0
      type(c_ptr),value :: handle
      integer(c_int),value :: n
      complex(c_double_complex) :: alpha
      complex(c_double_complex),target :: x
      integer(c_int),value :: incx
      integer(c_int64_t),value :: stride_x
      integer(c_int),value :: batch_count
      !
      rocblas_zscal_strided_batched_rank_0 = rocblas_zscal_strided_batched_orig(handle,n,alpha,c_loc(x),incx,stride_x,batch_count)
    end function

    function rocblas_zscal_strided_batched_rank_1(handle,n,alpha,x,incx,stride_x,batch_count)
      use iso_c_binding
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocblas_zscal_strided_batched_rank_1
      type(c_ptr),value :: handle
      integer(c_int),value :: n
      complex(c_double_complex) :: alpha
      complex(c_double_complex),target,dimension(:) :: x
      integer(c_int),value :: incx
      integer(c_int64_t),value :: stride_x
      integer(c_int),value :: batch_count
      !
      rocblas_zscal_strided_batched_rank_1 = rocblas_zscal_strided_batched_orig(handle,n,alpha,c_loc(x),incx,stride_x,batch_count)
    end function

    function rocblas_csscal_strided_batched_rank_0(handle,n,alpha,x,incx,stride_x,batch_count)
      use iso_c_binding
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocblas_csscal_strided_batched_rank_0
      type(c_ptr),value :: handle
      integer(c_int),value :: n
      real(c_float) :: alpha
      complex(c_float_complex),target :: x
      integer(c_int),value :: incx
      integer(c_int64_t),value :: stride_x
      integer(c_int),value :: batch_count
      !
      rocblas_csscal_strided_batched_rank_0 = rocblas_csscal_strided_batched_orig(handle,n,alpha,c_loc(x),incx,stride_x,batch_count)
    end function

    function rocblas_csscal_strided_batched_rank_1(handle,n,alpha,x,incx,stride_x,batch_count)
      use iso_c_binding
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocblas_csscal_strided_batched_rank_1
      type(c_ptr),value :: handle
      integer(c_int),value :: n
      real(c_float) :: alpha
      complex(c_float_complex),target,dimension(:) :: x
      integer(c_int),value :: incx
      integer(c_int64_t),value :: stride_x
      integer(c_int),value :: batch_count
      !
      rocblas_csscal_strided_batched_rank_1 = rocblas_csscal_strided_batched_orig(handle,n,alpha,c_loc(x),incx,stride_x,batch_count)
    end function

    function rocblas_zdscal_strided_batched_rank_0(handle,n,alpha,x,incx,stride_x,batch_count)
      use iso_c_binding
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocblas_zdscal_strided_batched_rank_0
      type(c_ptr),value :: handle
      integer(c_int),value :: n
      real(c_double) :: alpha
      complex(c_double_complex),target :: x
      integer(c_int),value :: incx
      integer(c_int64_t),value :: stride_x
      integer(c_int),value :: batch_count
      !
      rocblas_zdscal_strided_batched_rank_0 = rocblas_zdscal_strided_batched_orig(handle,n,alpha,c_loc(x),incx,stride_x,batch_count)
    end function

    function rocblas_zdscal_strided_batched_rank_1(handle,n,alpha,x,incx,stride_x,batch_count)
      use iso_c_binding
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocblas_zdscal_strided_batched_rank_1
      type(c_ptr),value :: handle
      integer(c_int),value :: n
      real(c_double) :: alpha
      complex(c_double_complex),target,dimension(:) :: x
      integer(c_int),value :: incx
      integer(c_int64_t),value :: stride_x
      integer(c_int),value :: batch_count
      !
      rocblas_zdscal_strided_batched_rank_1 = rocblas_zdscal_strided_batched_orig(handle,n,alpha,c_loc(x),incx,stride_x,batch_count)
    end function

    function rocblas_scopy_rank_0(handle,n,x,incx,y,incy)
      use iso_c_binding
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocblas_scopy_rank_0
      type(c_ptr),value :: handle
      integer(c_int),value :: n
      real(c_float),target :: x
      integer(c_int),value :: incx
      real(c_float),target :: y
      integer(c_int),value :: incy
      !
      rocblas_scopy_rank_0 = rocblas_scopy_orig(handle,n,c_loc(x),incx,c_loc(y),incy)
    end function

    function rocblas_scopy_rank_1(handle,n,x,incx,y,incy)
      use iso_c_binding
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocblas_scopy_rank_1
      type(c_ptr),value :: handle
      integer(c_int),value :: n
      real(c_float),target,dimension(:) :: x
      integer(c_int),value :: incx
      real(c_float),target,dimension(:) :: y
      integer(c_int),value :: incy
      !
      rocblas_scopy_rank_1 = rocblas_scopy_orig(handle,n,c_loc(x),incx,c_loc(y),incy)
    end function

    function rocblas_dcopy_rank_0(handle,n,x,incx,y,incy)
      use iso_c_binding
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocblas_dcopy_rank_0
      type(c_ptr),value :: handle
      integer(c_int),value :: n
      real(c_double),target :: x
      integer(c_int),value :: incx
      real(c_double),target :: y
      integer(c_int),value :: incy
      !
      rocblas_dcopy_rank_0 = rocblas_dcopy_orig(handle,n,c_loc(x),incx,c_loc(y),incy)
    end function

    function rocblas_dcopy_rank_1(handle,n,x,incx,y,incy)
      use iso_c_binding
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocblas_dcopy_rank_1
      type(c_ptr),value :: handle
      integer(c_int),value :: n
      real(c_double),target,dimension(:) :: x
      integer(c_int),value :: incx
      real(c_double),target,dimension(:) :: y
      integer(c_int),value :: incy
      !
      rocblas_dcopy_rank_1 = rocblas_dcopy_orig(handle,n,c_loc(x),incx,c_loc(y),incy)
    end function

    function rocblas_ccopy_rank_0(handle,n,x,incx,y,incy)
      use iso_c_binding
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocblas_ccopy_rank_0
      type(c_ptr),value :: handle
      integer(c_int),value :: n
      complex(c_float_complex),target :: x
      integer(c_int),value :: incx
      complex(c_float_complex),target :: y
      integer(c_int),value :: incy
      !
      rocblas_ccopy_rank_0 = rocblas_ccopy_orig(handle,n,c_loc(x),incx,c_loc(y),incy)
    end function

    function rocblas_ccopy_rank_1(handle,n,x,incx,y,incy)
      use iso_c_binding
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocblas_ccopy_rank_1
      type(c_ptr),value :: handle
      integer(c_int),value :: n
      complex(c_float_complex),target,dimension(:) :: x
      integer(c_int),value :: incx
      complex(c_float_complex),target,dimension(:) :: y
      integer(c_int),value :: incy
      !
      rocblas_ccopy_rank_1 = rocblas_ccopy_orig(handle,n,c_loc(x),incx,c_loc(y),incy)
    end function

    function rocblas_zcopy_rank_0(handle,n,x,incx,y,incy)
      use iso_c_binding
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocblas_zcopy_rank_0
      type(c_ptr),value :: handle
      integer(c_int),value :: n
      complex(c_double_complex),target :: x
      integer(c_int),value :: incx
      complex(c_double_complex),target :: y
      integer(c_int),value :: incy
      !
      rocblas_zcopy_rank_0 = rocblas_zcopy_orig(handle,n,c_loc(x),incx,c_loc(y),incy)
    end function

    function rocblas_zcopy_rank_1(handle,n,x,incx,y,incy)
      use iso_c_binding
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocblas_zcopy_rank_1
      type(c_ptr),value :: handle
      integer(c_int),value :: n
      complex(c_double_complex),target,dimension(:) :: x
      integer(c_int),value :: incx
      complex(c_double_complex),target,dimension(:) :: y
      integer(c_int),value :: incy
      !
      rocblas_zcopy_rank_1 = rocblas_zcopy_orig(handle,n,c_loc(x),incx,c_loc(y),incy)
    end function

    function rocblas_scopy_batched_full_rank(handle,n,x,incx,y,incy,batch_count)
      use iso_c_binding
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocblas_scopy_batched_full_rank
      type(c_ptr),value :: handle
      integer(c_int),value :: n
      real(c_float),target,dimension(:,:) :: x
      integer(c_int),value :: incx
      real(c_float),target,dimension(:,:) :: y
      integer(c_int),value :: incy
      integer(c_int),value :: batch_count
      !
      rocblas_scopy_batched_full_rank = rocblas_scopy_batched_orig(handle,n,c_loc(x),incx,c_loc(y),incy,batch_count)
    end function

    function rocblas_scopy_batched_rank_0(handle,n,x,incx,y,incy,batch_count)
      use iso_c_binding
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocblas_scopy_batched_rank_0
      type(c_ptr),value :: handle
      integer(c_int),value :: n
      real(c_float),target :: x
      integer(c_int),value :: incx
      real(c_float),target :: y
      integer(c_int),value :: incy
      integer(c_int),value :: batch_count
      !
      rocblas_scopy_batched_rank_0 = rocblas_scopy_batched_orig(handle,n,c_loc(x),incx,c_loc(y),incy,batch_count)
    end function

    function rocblas_scopy_batched_rank_1(handle,n,x,incx,y,incy,batch_count)
      use iso_c_binding
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocblas_scopy_batched_rank_1
      type(c_ptr),value :: handle
      integer(c_int),value :: n
      real(c_float),target,dimension(:) :: x
      integer(c_int),value :: incx
      real(c_float),target,dimension(:) :: y
      integer(c_int),value :: incy
      integer(c_int),value :: batch_count
      !
      rocblas_scopy_batched_rank_1 = rocblas_scopy_batched_orig(handle,n,c_loc(x),incx,c_loc(y),incy,batch_count)
    end function

    function rocblas_dcopy_batched_full_rank(handle,n,x,incx,y,incy,batch_count)
      use iso_c_binding
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocblas_dcopy_batched_full_rank
      type(c_ptr),value :: handle
      integer(c_int),value :: n
      real(c_double),target,dimension(:,:) :: x
      integer(c_int),value :: incx
      real(c_double),target,dimension(:,:) :: y
      integer(c_int),value :: incy
      integer(c_int),value :: batch_count
      !
      rocblas_dcopy_batched_full_rank = rocblas_dcopy_batched_orig(handle,n,c_loc(x),incx,c_loc(y),incy,batch_count)
    end function

    function rocblas_dcopy_batched_rank_0(handle,n,x,incx,y,incy,batch_count)
      use iso_c_binding
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocblas_dcopy_batched_rank_0
      type(c_ptr),value :: handle
      integer(c_int),value :: n
      real(c_double),target :: x
      integer(c_int),value :: incx
      real(c_double),target :: y
      integer(c_int),value :: incy
      integer(c_int),value :: batch_count
      !
      rocblas_dcopy_batched_rank_0 = rocblas_dcopy_batched_orig(handle,n,c_loc(x),incx,c_loc(y),incy,batch_count)
    end function

    function rocblas_dcopy_batched_rank_1(handle,n,x,incx,y,incy,batch_count)
      use iso_c_binding
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocblas_dcopy_batched_rank_1
      type(c_ptr),value :: handle
      integer(c_int),value :: n
      real(c_double),target,dimension(:) :: x
      integer(c_int),value :: incx
      real(c_double),target,dimension(:) :: y
      integer(c_int),value :: incy
      integer(c_int),value :: batch_count
      !
      rocblas_dcopy_batched_rank_1 = rocblas_dcopy_batched_orig(handle,n,c_loc(x),incx,c_loc(y),incy,batch_count)
    end function

    function rocblas_ccopy_batched_full_rank(handle,n,x,incx,y,incy,batch_count)
      use iso_c_binding
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocblas_ccopy_batched_full_rank
      type(c_ptr),value :: handle
      integer(c_int),value :: n
      complex(c_float_complex),target,dimension(:,:) :: x
      integer(c_int),value :: incx
      complex(c_float_complex),target,dimension(:,:) :: y
      integer(c_int),value :: incy
      integer(c_int),value :: batch_count
      !
      rocblas_ccopy_batched_full_rank = rocblas_ccopy_batched_orig(handle,n,c_loc(x),incx,c_loc(y),incy,batch_count)
    end function

    function rocblas_ccopy_batched_rank_0(handle,n,x,incx,y,incy,batch_count)
      use iso_c_binding
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocblas_ccopy_batched_rank_0
      type(c_ptr),value :: handle
      integer(c_int),value :: n
      complex(c_float_complex),target :: x
      integer(c_int),value :: incx
      complex(c_float_complex),target :: y
      integer(c_int),value :: incy
      integer(c_int),value :: batch_count
      !
      rocblas_ccopy_batched_rank_0 = rocblas_ccopy_batched_orig(handle,n,c_loc(x),incx,c_loc(y),incy,batch_count)
    end function

    function rocblas_ccopy_batched_rank_1(handle,n,x,incx,y,incy,batch_count)
      use iso_c_binding
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocblas_ccopy_batched_rank_1
      type(c_ptr),value :: handle
      integer(c_int),value :: n
      complex(c_float_complex),target,dimension(:) :: x
      integer(c_int),value :: incx
      complex(c_float_complex),target,dimension(:) :: y
      integer(c_int),value :: incy
      integer(c_int),value :: batch_count
      !
      rocblas_ccopy_batched_rank_1 = rocblas_ccopy_batched_orig(handle,n,c_loc(x),incx,c_loc(y),incy,batch_count)
    end function

    function rocblas_zcopy_batched_full_rank(handle,n,x,incx,y,incy,batch_count)
      use iso_c_binding
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocblas_zcopy_batched_full_rank
      type(c_ptr),value :: handle
      integer(c_int),value :: n
      complex(c_double_complex),target,dimension(:,:) :: x
      integer(c_int),value :: incx
      complex(c_double_complex),target,dimension(:,:) :: y
      integer(c_int),value :: incy
      integer(c_int),value :: batch_count
      !
      rocblas_zcopy_batched_full_rank = rocblas_zcopy_batched_orig(handle,n,c_loc(x),incx,c_loc(y),incy,batch_count)
    end function

    function rocblas_zcopy_batched_rank_0(handle,n,x,incx,y,incy,batch_count)
      use iso_c_binding
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocblas_zcopy_batched_rank_0
      type(c_ptr),value :: handle
      integer(c_int),value :: n
      complex(c_double_complex),target :: x
      integer(c_int),value :: incx
      complex(c_double_complex),target :: y
      integer(c_int),value :: incy
      integer(c_int),value :: batch_count
      !
      rocblas_zcopy_batched_rank_0 = rocblas_zcopy_batched_orig(handle,n,c_loc(x),incx,c_loc(y),incy,batch_count)
    end function

    function rocblas_zcopy_batched_rank_1(handle,n,x,incx,y,incy,batch_count)
      use iso_c_binding
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocblas_zcopy_batched_rank_1
      type(c_ptr),value :: handle
      integer(c_int),value :: n
      complex(c_double_complex),target,dimension(:) :: x
      integer(c_int),value :: incx
      complex(c_double_complex),target,dimension(:) :: y
      integer(c_int),value :: incy
      integer(c_int),value :: batch_count
      !
      rocblas_zcopy_batched_rank_1 = rocblas_zcopy_batched_orig(handle,n,c_loc(x),incx,c_loc(y),incy,batch_count)
    end function

    function rocblas_scopy_strided_batched_rank_0(handle,n,x,incx,stridex,y,incy,stridey,batch_count)
      use iso_c_binding
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocblas_scopy_strided_batched_rank_0
      type(c_ptr),value :: handle
      integer(c_int),value :: n
      real(c_float),target :: x
      integer(c_int),value :: incx
      integer(c_int64_t),value :: stridex
      real(c_float),target :: y
      integer(c_int),value :: incy
      integer(c_int64_t),value :: stridey
      integer(c_int),value :: batch_count
      !
      rocblas_scopy_strided_batched_rank_0 = rocblas_scopy_strided_batched_orig(handle,n,c_loc(x),incx,stridex,c_loc(y),incy,stridey,batch_count)
    end function

    function rocblas_scopy_strided_batched_rank_1(handle,n,x,incx,stridex,y,incy,stridey,batch_count)
      use iso_c_binding
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocblas_scopy_strided_batched_rank_1
      type(c_ptr),value :: handle
      integer(c_int),value :: n
      real(c_float),target,dimension(:) :: x
      integer(c_int),value :: incx
      integer(c_int64_t),value :: stridex
      real(c_float),target,dimension(:) :: y
      integer(c_int),value :: incy
      integer(c_int64_t),value :: stridey
      integer(c_int),value :: batch_count
      !
      rocblas_scopy_strided_batched_rank_1 = rocblas_scopy_strided_batched_orig(handle,n,c_loc(x),incx,stridex,c_loc(y),incy,stridey,batch_count)
    end function

    function rocblas_dcopy_strided_batched_rank_0(handle,n,x,incx,stridex,y,incy,stridey,batch_count)
      use iso_c_binding
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocblas_dcopy_strided_batched_rank_0
      type(c_ptr),value :: handle
      integer(c_int),value :: n
      real(c_double),target :: x
      integer(c_int),value :: incx
      integer(c_int64_t),value :: stridex
      real(c_double),target :: y
      integer(c_int),value :: incy
      integer(c_int64_t),value :: stridey
      integer(c_int),value :: batch_count
      !
      rocblas_dcopy_strided_batched_rank_0 = rocblas_dcopy_strided_batched_orig(handle,n,c_loc(x),incx,stridex,c_loc(y),incy,stridey,batch_count)
    end function

    function rocblas_dcopy_strided_batched_rank_1(handle,n,x,incx,stridex,y,incy,stridey,batch_count)
      use iso_c_binding
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocblas_dcopy_strided_batched_rank_1
      type(c_ptr),value :: handle
      integer(c_int),value :: n
      real(c_double),target,dimension(:) :: x
      integer(c_int),value :: incx
      integer(c_int64_t),value :: stridex
      real(c_double),target,dimension(:) :: y
      integer(c_int),value :: incy
      integer(c_int64_t),value :: stridey
      integer(c_int),value :: batch_count
      !
      rocblas_dcopy_strided_batched_rank_1 = rocblas_dcopy_strided_batched_orig(handle,n,c_loc(x),incx,stridex,c_loc(y),incy,stridey,batch_count)
    end function

    function rocblas_ccopy_strided_batched_rank_0(handle,n,x,incx,stridex,y,incy,stridey,batch_count)
      use iso_c_binding
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocblas_ccopy_strided_batched_rank_0
      type(c_ptr),value :: handle
      integer(c_int),value :: n
      complex(c_float_complex),target :: x
      integer(c_int),value :: incx
      integer(c_int64_t),value :: stridex
      complex(c_float_complex),target :: y
      integer(c_int),value :: incy
      integer(c_int64_t),value :: stridey
      integer(c_int),value :: batch_count
      !
      rocblas_ccopy_strided_batched_rank_0 = rocblas_ccopy_strided_batched_orig(handle,n,c_loc(x),incx,stridex,c_loc(y),incy,stridey,batch_count)
    end function

    function rocblas_ccopy_strided_batched_rank_1(handle,n,x,incx,stridex,y,incy,stridey,batch_count)
      use iso_c_binding
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocblas_ccopy_strided_batched_rank_1
      type(c_ptr),value :: handle
      integer(c_int),value :: n
      complex(c_float_complex),target,dimension(:) :: x
      integer(c_int),value :: incx
      integer(c_int64_t),value :: stridex
      complex(c_float_complex),target,dimension(:) :: y
      integer(c_int),value :: incy
      integer(c_int64_t),value :: stridey
      integer(c_int),value :: batch_count
      !
      rocblas_ccopy_strided_batched_rank_1 = rocblas_ccopy_strided_batched_orig(handle,n,c_loc(x),incx,stridex,c_loc(y),incy,stridey,batch_count)
    end function

    function rocblas_zcopy_strided_batched_rank_0(handle,n,x,incx,stridex,y,incy,stridey,batch_count)
      use iso_c_binding
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocblas_zcopy_strided_batched_rank_0
      type(c_ptr),value :: handle
      integer(c_int),value :: n
      complex(c_double_complex),target :: x
      integer(c_int),value :: incx
      integer(c_int64_t),value :: stridex
      complex(c_double_complex),target :: y
      integer(c_int),value :: incy
      integer(c_int64_t),value :: stridey
      integer(c_int),value :: batch_count
      !
      rocblas_zcopy_strided_batched_rank_0 = rocblas_zcopy_strided_batched_orig(handle,n,c_loc(x),incx,stridex,c_loc(y),incy,stridey,batch_count)
    end function

    function rocblas_zcopy_strided_batched_rank_1(handle,n,x,incx,stridex,y,incy,stridey,batch_count)
      use iso_c_binding
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocblas_zcopy_strided_batched_rank_1
      type(c_ptr),value :: handle
      integer(c_int),value :: n
      complex(c_double_complex),target,dimension(:) :: x
      integer(c_int),value :: incx
      integer(c_int64_t),value :: stridex
      complex(c_double_complex),target,dimension(:) :: y
      integer(c_int),value :: incy
      integer(c_int64_t),value :: stridey
      integer(c_int),value :: batch_count
      !
      rocblas_zcopy_strided_batched_rank_1 = rocblas_zcopy_strided_batched_orig(handle,n,c_loc(x),incx,stridex,c_loc(y),incy,stridey,batch_count)
    end function

    function rocblas_sdot_rank_0(handle,n,x,incx,y,incy,myResult)
      use iso_c_binding
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocblas_sdot_rank_0
      type(c_ptr),value :: handle
      integer(c_int),value :: n
      real(c_float),target :: x
      integer(c_int),value :: incx
      real(c_float),target :: y
      integer(c_int),value :: incy
      type(c_ptr),value :: myResult
      !
      rocblas_sdot_rank_0 = rocblas_sdot_orig(handle,n,c_loc(x),incx,c_loc(y),incy,myResult)
    end function

    function rocblas_sdot_rank_1(handle,n,x,incx,y,incy,myResult)
      use iso_c_binding
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocblas_sdot_rank_1
      type(c_ptr),value :: handle
      integer(c_int),value :: n
      real(c_float),target,dimension(:) :: x
      integer(c_int),value :: incx
      real(c_float),target,dimension(:) :: y
      integer(c_int),value :: incy
      type(c_ptr),value :: myResult
      !
      rocblas_sdot_rank_1 = rocblas_sdot_orig(handle,n,c_loc(x),incx,c_loc(y),incy,myResult)
    end function

    function rocblas_ddot_rank_0(handle,n,x,incx,y,incy,myResult)
      use iso_c_binding
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocblas_ddot_rank_0
      type(c_ptr),value :: handle
      integer(c_int),value :: n
      real(c_double),target :: x
      integer(c_int),value :: incx
      real(c_double),target :: y
      integer(c_int),value :: incy
      type(c_ptr),value :: myResult
      !
      rocblas_ddot_rank_0 = rocblas_ddot_orig(handle,n,c_loc(x),incx,c_loc(y),incy,myResult)
    end function

    function rocblas_ddot_rank_1(handle,n,x,incx,y,incy,myResult)
      use iso_c_binding
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocblas_ddot_rank_1
      type(c_ptr),value :: handle
      integer(c_int),value :: n
      real(c_double),target,dimension(:) :: x
      integer(c_int),value :: incx
      real(c_double),target,dimension(:) :: y
      integer(c_int),value :: incy
      type(c_ptr),value :: myResult
      !
      rocblas_ddot_rank_1 = rocblas_ddot_orig(handle,n,c_loc(x),incx,c_loc(y),incy,myResult)
    end function

    function rocblas_cdotu_rank_0(handle,n,x,incx,y,incy,myResult)
      use iso_c_binding
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocblas_cdotu_rank_0
      type(c_ptr),value :: handle
      integer(c_int),value :: n
      complex(c_float_complex),target :: x
      integer(c_int),value :: incx
      complex(c_float_complex),target :: y
      integer(c_int),value :: incy
      type(c_ptr),value :: myResult
      !
      rocblas_cdotu_rank_0 = rocblas_cdotu_orig(handle,n,c_loc(x),incx,c_loc(y),incy,myResult)
    end function

    function rocblas_cdotu_rank_1(handle,n,x,incx,y,incy,myResult)
      use iso_c_binding
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocblas_cdotu_rank_1
      type(c_ptr),value :: handle
      integer(c_int),value :: n
      complex(c_float_complex),target,dimension(:) :: x
      integer(c_int),value :: incx
      complex(c_float_complex),target,dimension(:) :: y
      integer(c_int),value :: incy
      type(c_ptr),value :: myResult
      !
      rocblas_cdotu_rank_1 = rocblas_cdotu_orig(handle,n,c_loc(x),incx,c_loc(y),incy,myResult)
    end function

    function rocblas_zdotu_rank_0(handle,n,x,incx,y,incy,myResult)
      use iso_c_binding
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocblas_zdotu_rank_0
      type(c_ptr),value :: handle
      integer(c_int),value :: n
      complex(c_double_complex),target :: x
      integer(c_int),value :: incx
      complex(c_double_complex),target :: y
      integer(c_int),value :: incy
      type(c_ptr),value :: myResult
      !
      rocblas_zdotu_rank_0 = rocblas_zdotu_orig(handle,n,c_loc(x),incx,c_loc(y),incy,myResult)
    end function

    function rocblas_zdotu_rank_1(handle,n,x,incx,y,incy,myResult)
      use iso_c_binding
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocblas_zdotu_rank_1
      type(c_ptr),value :: handle
      integer(c_int),value :: n
      complex(c_double_complex),target,dimension(:) :: x
      integer(c_int),value :: incx
      complex(c_double_complex),target,dimension(:) :: y
      integer(c_int),value :: incy
      type(c_ptr),value :: myResult
      !
      rocblas_zdotu_rank_1 = rocblas_zdotu_orig(handle,n,c_loc(x),incx,c_loc(y),incy,myResult)
    end function

    function rocblas_cdotc_rank_0(handle,n,x,incx,y,incy,myResult)
      use iso_c_binding
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocblas_cdotc_rank_0
      type(c_ptr),value :: handle
      integer(c_int),value :: n
      complex(c_float_complex),target :: x
      integer(c_int),value :: incx
      complex(c_float_complex),target :: y
      integer(c_int),value :: incy
      type(c_ptr),value :: myResult
      !
      rocblas_cdotc_rank_0 = rocblas_cdotc_orig(handle,n,c_loc(x),incx,c_loc(y),incy,myResult)
    end function

    function rocblas_cdotc_rank_1(handle,n,x,incx,y,incy,myResult)
      use iso_c_binding
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocblas_cdotc_rank_1
      type(c_ptr),value :: handle
      integer(c_int),value :: n
      complex(c_float_complex),target,dimension(:) :: x
      integer(c_int),value :: incx
      complex(c_float_complex),target,dimension(:) :: y
      integer(c_int),value :: incy
      type(c_ptr),value :: myResult
      !
      rocblas_cdotc_rank_1 = rocblas_cdotc_orig(handle,n,c_loc(x),incx,c_loc(y),incy,myResult)
    end function

    function rocblas_zdotc_rank_0(handle,n,x,incx,y,incy,myResult)
      use iso_c_binding
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocblas_zdotc_rank_0
      type(c_ptr),value :: handle
      integer(c_int),value :: n
      complex(c_double_complex),target :: x
      integer(c_int),value :: incx
      complex(c_double_complex),target :: y
      integer(c_int),value :: incy
      type(c_ptr),value :: myResult
      !
      rocblas_zdotc_rank_0 = rocblas_zdotc_orig(handle,n,c_loc(x),incx,c_loc(y),incy,myResult)
    end function

    function rocblas_zdotc_rank_1(handle,n,x,incx,y,incy,myResult)
      use iso_c_binding
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocblas_zdotc_rank_1
      type(c_ptr),value :: handle
      integer(c_int),value :: n
      complex(c_double_complex),target,dimension(:) :: x
      integer(c_int),value :: incx
      complex(c_double_complex),target,dimension(:) :: y
      integer(c_int),value :: incy
      type(c_ptr),value :: myResult
      !
      rocblas_zdotc_rank_1 = rocblas_zdotc_orig(handle,n,c_loc(x),incx,c_loc(y),incy,myResult)
    end function

    function rocblas_sdot_batched_full_rank(handle,n,x,incx,y,incy,batch_count,myResult)
      use iso_c_binding
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocblas_sdot_batched_full_rank
      type(c_ptr),value :: handle
      integer(c_int),value :: n
      real(c_float),target,dimension(:,:) :: x
      integer(c_int),value :: incx
      real(c_float),target,dimension(:,:) :: y
      integer(c_int),value :: incy
      integer(c_int),value :: batch_count
      type(c_ptr),value :: myResult
      !
      rocblas_sdot_batched_full_rank = rocblas_sdot_batched_orig(handle,n,c_loc(x),incx,c_loc(y),incy,batch_count,myResult)
    end function

    function rocblas_sdot_batched_rank_0(handle,n,x,incx,y,incy,batch_count,myResult)
      use iso_c_binding
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocblas_sdot_batched_rank_0
      type(c_ptr),value :: handle
      integer(c_int),value :: n
      real(c_float),target :: x
      integer(c_int),value :: incx
      real(c_float),target :: y
      integer(c_int),value :: incy
      integer(c_int),value :: batch_count
      type(c_ptr),value :: myResult
      !
      rocblas_sdot_batched_rank_0 = rocblas_sdot_batched_orig(handle,n,c_loc(x),incx,c_loc(y),incy,batch_count,myResult)
    end function

    function rocblas_sdot_batched_rank_1(handle,n,x,incx,y,incy,batch_count,myResult)
      use iso_c_binding
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocblas_sdot_batched_rank_1
      type(c_ptr),value :: handle
      integer(c_int),value :: n
      real(c_float),target,dimension(:) :: x
      integer(c_int),value :: incx
      real(c_float),target,dimension(:) :: y
      integer(c_int),value :: incy
      integer(c_int),value :: batch_count
      type(c_ptr),value :: myResult
      !
      rocblas_sdot_batched_rank_1 = rocblas_sdot_batched_orig(handle,n,c_loc(x),incx,c_loc(y),incy,batch_count,myResult)
    end function

    function rocblas_ddot_batched_full_rank(handle,n,x,incx,y,incy,batch_count,myResult)
      use iso_c_binding
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocblas_ddot_batched_full_rank
      type(c_ptr),value :: handle
      integer(c_int),value :: n
      real(c_double),target,dimension(:,:) :: x
      integer(c_int),value :: incx
      real(c_double),target,dimension(:,:) :: y
      integer(c_int),value :: incy
      integer(c_int),value :: batch_count
      type(c_ptr),value :: myResult
      !
      rocblas_ddot_batched_full_rank = rocblas_ddot_batched_orig(handle,n,c_loc(x),incx,c_loc(y),incy,batch_count,myResult)
    end function

    function rocblas_ddot_batched_rank_0(handle,n,x,incx,y,incy,batch_count,myResult)
      use iso_c_binding
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocblas_ddot_batched_rank_0
      type(c_ptr),value :: handle
      integer(c_int),value :: n
      real(c_double),target :: x
      integer(c_int),value :: incx
      real(c_double),target :: y
      integer(c_int),value :: incy
      integer(c_int),value :: batch_count
      type(c_ptr),value :: myResult
      !
      rocblas_ddot_batched_rank_0 = rocblas_ddot_batched_orig(handle,n,c_loc(x),incx,c_loc(y),incy,batch_count,myResult)
    end function

    function rocblas_ddot_batched_rank_1(handle,n,x,incx,y,incy,batch_count,myResult)
      use iso_c_binding
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocblas_ddot_batched_rank_1
      type(c_ptr),value :: handle
      integer(c_int),value :: n
      real(c_double),target,dimension(:) :: x
      integer(c_int),value :: incx
      real(c_double),target,dimension(:) :: y
      integer(c_int),value :: incy
      integer(c_int),value :: batch_count
      type(c_ptr),value :: myResult
      !
      rocblas_ddot_batched_rank_1 = rocblas_ddot_batched_orig(handle,n,c_loc(x),incx,c_loc(y),incy,batch_count,myResult)
    end function

    function rocblas_cdotu_batched_full_rank(handle,n,x,incx,y,incy,batch_count,myResult)
      use iso_c_binding
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocblas_cdotu_batched_full_rank
      type(c_ptr),value :: handle
      integer(c_int),value :: n
      complex(c_float_complex),target,dimension(:,:) :: x
      integer(c_int),value :: incx
      complex(c_float_complex),target,dimension(:,:) :: y
      integer(c_int),value :: incy
      integer(c_int),value :: batch_count
      type(c_ptr),value :: myResult
      !
      rocblas_cdotu_batched_full_rank = rocblas_cdotu_batched_orig(handle,n,c_loc(x),incx,c_loc(y),incy,batch_count,myResult)
    end function

    function rocblas_cdotu_batched_rank_0(handle,n,x,incx,y,incy,batch_count,myResult)
      use iso_c_binding
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocblas_cdotu_batched_rank_0
      type(c_ptr),value :: handle
      integer(c_int),value :: n
      complex(c_float_complex),target :: x
      integer(c_int),value :: incx
      complex(c_float_complex),target :: y
      integer(c_int),value :: incy
      integer(c_int),value :: batch_count
      type(c_ptr),value :: myResult
      !
      rocblas_cdotu_batched_rank_0 = rocblas_cdotu_batched_orig(handle,n,c_loc(x),incx,c_loc(y),incy,batch_count,myResult)
    end function

    function rocblas_cdotu_batched_rank_1(handle,n,x,incx,y,incy,batch_count,myResult)
      use iso_c_binding
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocblas_cdotu_batched_rank_1
      type(c_ptr),value :: handle
      integer(c_int),value :: n
      complex(c_float_complex),target,dimension(:) :: x
      integer(c_int),value :: incx
      complex(c_float_complex),target,dimension(:) :: y
      integer(c_int),value :: incy
      integer(c_int),value :: batch_count
      type(c_ptr),value :: myResult
      !
      rocblas_cdotu_batched_rank_1 = rocblas_cdotu_batched_orig(handle,n,c_loc(x),incx,c_loc(y),incy,batch_count,myResult)
    end function

    function rocblas_zdotu_batched_full_rank(handle,n,x,incx,y,incy,batch_count,myResult)
      use iso_c_binding
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocblas_zdotu_batched_full_rank
      type(c_ptr),value :: handle
      integer(c_int),value :: n
      complex(c_double_complex),target,dimension(:,:) :: x
      integer(c_int),value :: incx
      complex(c_double_complex),target,dimension(:,:) :: y
      integer(c_int),value :: incy
      integer(c_int),value :: batch_count
      type(c_ptr),value :: myResult
      !
      rocblas_zdotu_batched_full_rank = rocblas_zdotu_batched_orig(handle,n,c_loc(x),incx,c_loc(y),incy,batch_count,myResult)
    end function

    function rocblas_zdotu_batched_rank_0(handle,n,x,incx,y,incy,batch_count,myResult)
      use iso_c_binding
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocblas_zdotu_batched_rank_0
      type(c_ptr),value :: handle
      integer(c_int),value :: n
      complex(c_double_complex),target :: x
      integer(c_int),value :: incx
      complex(c_double_complex),target :: y
      integer(c_int),value :: incy
      integer(c_int),value :: batch_count
      type(c_ptr),value :: myResult
      !
      rocblas_zdotu_batched_rank_0 = rocblas_zdotu_batched_orig(handle,n,c_loc(x),incx,c_loc(y),incy,batch_count,myResult)
    end function

    function rocblas_zdotu_batched_rank_1(handle,n,x,incx,y,incy,batch_count,myResult)
      use iso_c_binding
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocblas_zdotu_batched_rank_1
      type(c_ptr),value :: handle
      integer(c_int),value :: n
      complex(c_double_complex),target,dimension(:) :: x
      integer(c_int),value :: incx
      complex(c_double_complex),target,dimension(:) :: y
      integer(c_int),value :: incy
      integer(c_int),value :: batch_count
      type(c_ptr),value :: myResult
      !
      rocblas_zdotu_batched_rank_1 = rocblas_zdotu_batched_orig(handle,n,c_loc(x),incx,c_loc(y),incy,batch_count,myResult)
    end function

    function rocblas_cdotc_batched_full_rank(handle,n,x,incx,y,incy,batch_count,myResult)
      use iso_c_binding
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocblas_cdotc_batched_full_rank
      type(c_ptr),value :: handle
      integer(c_int),value :: n
      complex(c_float_complex),target,dimension(:,:) :: x
      integer(c_int),value :: incx
      complex(c_float_complex),target,dimension(:,:) :: y
      integer(c_int),value :: incy
      integer(c_int),value :: batch_count
      type(c_ptr),value :: myResult
      !
      rocblas_cdotc_batched_full_rank = rocblas_cdotc_batched_orig(handle,n,c_loc(x),incx,c_loc(y),incy,batch_count,myResult)
    end function

    function rocblas_cdotc_batched_rank_0(handle,n,x,incx,y,incy,batch_count,myResult)
      use iso_c_binding
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocblas_cdotc_batched_rank_0
      type(c_ptr),value :: handle
      integer(c_int),value :: n
      complex(c_float_complex),target :: x
      integer(c_int),value :: incx
      complex(c_float_complex),target :: y
      integer(c_int),value :: incy
      integer(c_int),value :: batch_count
      type(c_ptr),value :: myResult
      !
      rocblas_cdotc_batched_rank_0 = rocblas_cdotc_batched_orig(handle,n,c_loc(x),incx,c_loc(y),incy,batch_count,myResult)
    end function

    function rocblas_cdotc_batched_rank_1(handle,n,x,incx,y,incy,batch_count,myResult)
      use iso_c_binding
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocblas_cdotc_batched_rank_1
      type(c_ptr),value :: handle
      integer(c_int),value :: n
      complex(c_float_complex),target,dimension(:) :: x
      integer(c_int),value :: incx
      complex(c_float_complex),target,dimension(:) :: y
      integer(c_int),value :: incy
      integer(c_int),value :: batch_count
      type(c_ptr),value :: myResult
      !
      rocblas_cdotc_batched_rank_1 = rocblas_cdotc_batched_orig(handle,n,c_loc(x),incx,c_loc(y),incy,batch_count,myResult)
    end function

    function rocblas_zdotc_batched_full_rank(handle,n,x,incx,y,incy,batch_count,myResult)
      use iso_c_binding
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocblas_zdotc_batched_full_rank
      type(c_ptr),value :: handle
      integer(c_int),value :: n
      complex(c_double_complex),target,dimension(:,:) :: x
      integer(c_int),value :: incx
      complex(c_double_complex),target,dimension(:,:) :: y
      integer(c_int),value :: incy
      integer(c_int),value :: batch_count
      type(c_ptr),value :: myResult
      !
      rocblas_zdotc_batched_full_rank = rocblas_zdotc_batched_orig(handle,n,c_loc(x),incx,c_loc(y),incy,batch_count,myResult)
    end function

    function rocblas_zdotc_batched_rank_0(handle,n,x,incx,y,incy,batch_count,myResult)
      use iso_c_binding
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocblas_zdotc_batched_rank_0
      type(c_ptr),value :: handle
      integer(c_int),value :: n
      complex(c_double_complex),target :: x
      integer(c_int),value :: incx
      complex(c_double_complex),target :: y
      integer(c_int),value :: incy
      integer(c_int),value :: batch_count
      type(c_ptr),value :: myResult
      !
      rocblas_zdotc_batched_rank_0 = rocblas_zdotc_batched_orig(handle,n,c_loc(x),incx,c_loc(y),incy,batch_count,myResult)
    end function

    function rocblas_zdotc_batched_rank_1(handle,n,x,incx,y,incy,batch_count,myResult)
      use iso_c_binding
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocblas_zdotc_batched_rank_1
      type(c_ptr),value :: handle
      integer(c_int),value :: n
      complex(c_double_complex),target,dimension(:) :: x
      integer(c_int),value :: incx
      complex(c_double_complex),target,dimension(:) :: y
      integer(c_int),value :: incy
      integer(c_int),value :: batch_count
      type(c_ptr),value :: myResult
      !
      rocblas_zdotc_batched_rank_1 = rocblas_zdotc_batched_orig(handle,n,c_loc(x),incx,c_loc(y),incy,batch_count,myResult)
    end function

    function rocblas_sdot_strided_batched_rank_0(handle,n,x,incx,stridex,y,incy,stridey,batch_count,myResult)
      use iso_c_binding
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocblas_sdot_strided_batched_rank_0
      type(c_ptr),value :: handle
      integer(c_int),value :: n
      real(c_float),target :: x
      integer(c_int),value :: incx
      integer(c_int64_t),value :: stridex
      real(c_float),target :: y
      integer(c_int),value :: incy
      integer(c_int64_t),value :: stridey
      integer(c_int),value :: batch_count
      type(c_ptr),value :: myResult
      !
      rocblas_sdot_strided_batched_rank_0 = rocblas_sdot_strided_batched_orig(handle,n,c_loc(x),incx,stridex,c_loc(y),incy,stridey,batch_count,myResult)
    end function

    function rocblas_sdot_strided_batched_rank_1(handle,n,x,incx,stridex,y,incy,stridey,batch_count,myResult)
      use iso_c_binding
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocblas_sdot_strided_batched_rank_1
      type(c_ptr),value :: handle
      integer(c_int),value :: n
      real(c_float),target,dimension(:) :: x
      integer(c_int),value :: incx
      integer(c_int64_t),value :: stridex
      real(c_float),target,dimension(:) :: y
      integer(c_int),value :: incy
      integer(c_int64_t),value :: stridey
      integer(c_int),value :: batch_count
      type(c_ptr),value :: myResult
      !
      rocblas_sdot_strided_batched_rank_1 = rocblas_sdot_strided_batched_orig(handle,n,c_loc(x),incx,stridex,c_loc(y),incy,stridey,batch_count,myResult)
    end function

    function rocblas_ddot_strided_batched_rank_0(handle,n,x,incx,stridex,y,incy,stridey,batch_count,myResult)
      use iso_c_binding
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocblas_ddot_strided_batched_rank_0
      type(c_ptr),value :: handle
      integer(c_int),value :: n
      real(c_double),target :: x
      integer(c_int),value :: incx
      integer(c_int64_t),value :: stridex
      real(c_double),target :: y
      integer(c_int),value :: incy
      integer(c_int64_t),value :: stridey
      integer(c_int),value :: batch_count
      type(c_ptr),value :: myResult
      !
      rocblas_ddot_strided_batched_rank_0 = rocblas_ddot_strided_batched_orig(handle,n,c_loc(x),incx,stridex,c_loc(y),incy,stridey,batch_count,myResult)
    end function

    function rocblas_ddot_strided_batched_rank_1(handle,n,x,incx,stridex,y,incy,stridey,batch_count,myResult)
      use iso_c_binding
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocblas_ddot_strided_batched_rank_1
      type(c_ptr),value :: handle
      integer(c_int),value :: n
      real(c_double),target,dimension(:) :: x
      integer(c_int),value :: incx
      integer(c_int64_t),value :: stridex
      real(c_double),target,dimension(:) :: y
      integer(c_int),value :: incy
      integer(c_int64_t),value :: stridey
      integer(c_int),value :: batch_count
      type(c_ptr),value :: myResult
      !
      rocblas_ddot_strided_batched_rank_1 = rocblas_ddot_strided_batched_orig(handle,n,c_loc(x),incx,stridex,c_loc(y),incy,stridey,batch_count,myResult)
    end function

    function rocblas_cdotu_strided_batched_rank_0(handle,n,x,incx,stridex,y,incy,stridey,batch_count,myResult)
      use iso_c_binding
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocblas_cdotu_strided_batched_rank_0
      type(c_ptr),value :: handle
      integer(c_int),value :: n
      complex(c_float_complex),target :: x
      integer(c_int),value :: incx
      integer(c_int64_t),value :: stridex
      complex(c_float_complex),target :: y
      integer(c_int),value :: incy
      integer(c_int64_t),value :: stridey
      integer(c_int),value :: batch_count
      type(c_ptr),value :: myResult
      !
      rocblas_cdotu_strided_batched_rank_0 = rocblas_cdotu_strided_batched_orig(handle,n,c_loc(x),incx,stridex,c_loc(y),incy,stridey,batch_count,myResult)
    end function

    function rocblas_cdotu_strided_batched_rank_1(handle,n,x,incx,stridex,y,incy,stridey,batch_count,myResult)
      use iso_c_binding
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocblas_cdotu_strided_batched_rank_1
      type(c_ptr),value :: handle
      integer(c_int),value :: n
      complex(c_float_complex),target,dimension(:) :: x
      integer(c_int),value :: incx
      integer(c_int64_t),value :: stridex
      complex(c_float_complex),target,dimension(:) :: y
      integer(c_int),value :: incy
      integer(c_int64_t),value :: stridey
      integer(c_int),value :: batch_count
      type(c_ptr),value :: myResult
      !
      rocblas_cdotu_strided_batched_rank_1 = rocblas_cdotu_strided_batched_orig(handle,n,c_loc(x),incx,stridex,c_loc(y),incy,stridey,batch_count,myResult)
    end function

    function rocblas_zdotu_strided_batched_rank_0(handle,n,x,incx,stridex,y,incy,stridey,batch_count,myResult)
      use iso_c_binding
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocblas_zdotu_strided_batched_rank_0
      type(c_ptr),value :: handle
      integer(c_int),value :: n
      complex(c_double_complex),target :: x
      integer(c_int),value :: incx
      integer(c_int64_t),value :: stridex
      complex(c_double_complex),target :: y
      integer(c_int),value :: incy
      integer(c_int64_t),value :: stridey
      integer(c_int),value :: batch_count
      type(c_ptr),value :: myResult
      !
      rocblas_zdotu_strided_batched_rank_0 = rocblas_zdotu_strided_batched_orig(handle,n,c_loc(x),incx,stridex,c_loc(y),incy,stridey,batch_count,myResult)
    end function

    function rocblas_zdotu_strided_batched_rank_1(handle,n,x,incx,stridex,y,incy,stridey,batch_count,myResult)
      use iso_c_binding
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocblas_zdotu_strided_batched_rank_1
      type(c_ptr),value :: handle
      integer(c_int),value :: n
      complex(c_double_complex),target,dimension(:) :: x
      integer(c_int),value :: incx
      integer(c_int64_t),value :: stridex
      complex(c_double_complex),target,dimension(:) :: y
      integer(c_int),value :: incy
      integer(c_int64_t),value :: stridey
      integer(c_int),value :: batch_count
      type(c_ptr),value :: myResult
      !
      rocblas_zdotu_strided_batched_rank_1 = rocblas_zdotu_strided_batched_orig(handle,n,c_loc(x),incx,stridex,c_loc(y),incy,stridey,batch_count,myResult)
    end function

    function rocblas_cdotc_strided_batched_rank_0(handle,n,x,incx,stridex,y,incy,stridey,batch_count,myResult)
      use iso_c_binding
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocblas_cdotc_strided_batched_rank_0
      type(c_ptr),value :: handle
      integer(c_int),value :: n
      complex(c_float_complex),target :: x
      integer(c_int),value :: incx
      integer(c_int64_t),value :: stridex
      complex(c_float_complex),target :: y
      integer(c_int),value :: incy
      integer(c_int64_t),value :: stridey
      integer(c_int),value :: batch_count
      type(c_ptr),value :: myResult
      !
      rocblas_cdotc_strided_batched_rank_0 = rocblas_cdotc_strided_batched_orig(handle,n,c_loc(x),incx,stridex,c_loc(y),incy,stridey,batch_count,myResult)
    end function

    function rocblas_cdotc_strided_batched_rank_1(handle,n,x,incx,stridex,y,incy,stridey,batch_count,myResult)
      use iso_c_binding
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocblas_cdotc_strided_batched_rank_1
      type(c_ptr),value :: handle
      integer(c_int),value :: n
      complex(c_float_complex),target,dimension(:) :: x
      integer(c_int),value :: incx
      integer(c_int64_t),value :: stridex
      complex(c_float_complex),target,dimension(:) :: y
      integer(c_int),value :: incy
      integer(c_int64_t),value :: stridey
      integer(c_int),value :: batch_count
      type(c_ptr),value :: myResult
      !
      rocblas_cdotc_strided_batched_rank_1 = rocblas_cdotc_strided_batched_orig(handle,n,c_loc(x),incx,stridex,c_loc(y),incy,stridey,batch_count,myResult)
    end function

    function rocblas_zdotc_strided_batched_rank_0(handle,n,x,incx,stridex,y,incy,stridey,batch_count,myResult)
      use iso_c_binding
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocblas_zdotc_strided_batched_rank_0
      type(c_ptr),value :: handle
      integer(c_int),value :: n
      complex(c_double_complex),target :: x
      integer(c_int),value :: incx
      integer(c_int64_t),value :: stridex
      complex(c_double_complex),target :: y
      integer(c_int),value :: incy
      integer(c_int64_t),value :: stridey
      integer(c_int),value :: batch_count
      type(c_ptr),value :: myResult
      !
      rocblas_zdotc_strided_batched_rank_0 = rocblas_zdotc_strided_batched_orig(handle,n,c_loc(x),incx,stridex,c_loc(y),incy,stridey,batch_count,myResult)
    end function

    function rocblas_zdotc_strided_batched_rank_1(handle,n,x,incx,stridex,y,incy,stridey,batch_count,myResult)
      use iso_c_binding
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocblas_zdotc_strided_batched_rank_1
      type(c_ptr),value :: handle
      integer(c_int),value :: n
      complex(c_double_complex),target,dimension(:) :: x
      integer(c_int),value :: incx
      integer(c_int64_t),value :: stridex
      complex(c_double_complex),target,dimension(:) :: y
      integer(c_int),value :: incy
      integer(c_int64_t),value :: stridey
      integer(c_int),value :: batch_count
      type(c_ptr),value :: myResult
      !
      rocblas_zdotc_strided_batched_rank_1 = rocblas_zdotc_strided_batched_orig(handle,n,c_loc(x),incx,stridex,c_loc(y),incy,stridey,batch_count,myResult)
    end function

    function rocblas_cswap_rank_0(handle,n,x,incx,y,incy)
      use iso_c_binding
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocblas_cswap_rank_0
      type(c_ptr),value :: handle
      integer(c_int),value :: n
      complex(c_float_complex),target :: x
      integer(c_int),value :: incx
      complex(c_float_complex),target :: y
      integer(c_int),value :: incy
      !
      rocblas_cswap_rank_0 = rocblas_cswap_orig(handle,n,c_loc(x),incx,c_loc(y),incy)
    end function

    function rocblas_cswap_rank_1(handle,n,x,incx,y,incy)
      use iso_c_binding
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocblas_cswap_rank_1
      type(c_ptr),value :: handle
      integer(c_int),value :: n
      complex(c_float_complex),target,dimension(:) :: x
      integer(c_int),value :: incx
      complex(c_float_complex),target,dimension(:) :: y
      integer(c_int),value :: incy
      !
      rocblas_cswap_rank_1 = rocblas_cswap_orig(handle,n,c_loc(x),incx,c_loc(y),incy)
    end function

    function rocblas_zswap_rank_0(handle,n,x,incx,y,incy)
      use iso_c_binding
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocblas_zswap_rank_0
      type(c_ptr),value :: handle
      integer(c_int),value :: n
      complex(c_double_complex),target :: x
      integer(c_int),value :: incx
      complex(c_double_complex),target :: y
      integer(c_int),value :: incy
      !
      rocblas_zswap_rank_0 = rocblas_zswap_orig(handle,n,c_loc(x),incx,c_loc(y),incy)
    end function

    function rocblas_zswap_rank_1(handle,n,x,incx,y,incy)
      use iso_c_binding
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocblas_zswap_rank_1
      type(c_ptr),value :: handle
      integer(c_int),value :: n
      complex(c_double_complex),target,dimension(:) :: x
      integer(c_int),value :: incx
      complex(c_double_complex),target,dimension(:) :: y
      integer(c_int),value :: incy
      !
      rocblas_zswap_rank_1 = rocblas_zswap_orig(handle,n,c_loc(x),incx,c_loc(y),incy)
    end function

    function rocblas_sswap_batched_full_rank(handle,n,x,incx,y,incy,batch_count)
      use iso_c_binding
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocblas_sswap_batched_full_rank
      type(c_ptr),value :: handle
      integer(c_int),value :: n
      real(c_float),target,dimension(:,:) :: x
      integer(c_int),value :: incx
      real(c_float),target,dimension(:,:) :: y
      integer(c_int),value :: incy
      integer(c_int),value :: batch_count
      !
      rocblas_sswap_batched_full_rank = rocblas_sswap_batched_orig(handle,n,c_loc(x),incx,c_loc(y),incy,batch_count)
    end function

    function rocblas_sswap_batched_rank_0(handle,n,x,incx,y,incy,batch_count)
      use iso_c_binding
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocblas_sswap_batched_rank_0
      type(c_ptr),value :: handle
      integer(c_int),value :: n
      real(c_float),target :: x
      integer(c_int),value :: incx
      real(c_float),target :: y
      integer(c_int),value :: incy
      integer(c_int),value :: batch_count
      !
      rocblas_sswap_batched_rank_0 = rocblas_sswap_batched_orig(handle,n,c_loc(x),incx,c_loc(y),incy,batch_count)
    end function

    function rocblas_sswap_batched_rank_1(handle,n,x,incx,y,incy,batch_count)
      use iso_c_binding
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocblas_sswap_batched_rank_1
      type(c_ptr),value :: handle
      integer(c_int),value :: n
      real(c_float),target,dimension(:) :: x
      integer(c_int),value :: incx
      real(c_float),target,dimension(:) :: y
      integer(c_int),value :: incy
      integer(c_int),value :: batch_count
      !
      rocblas_sswap_batched_rank_1 = rocblas_sswap_batched_orig(handle,n,c_loc(x),incx,c_loc(y),incy,batch_count)
    end function

    function rocblas_dswap_batched_full_rank(handle,n,x,incx,y,incy,batch_count)
      use iso_c_binding
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocblas_dswap_batched_full_rank
      type(c_ptr),value :: handle
      integer(c_int),value :: n
      real(c_double),target,dimension(:,:) :: x
      integer(c_int),value :: incx
      real(c_double),target,dimension(:,:) :: y
      integer(c_int),value :: incy
      integer(c_int),value :: batch_count
      !
      rocblas_dswap_batched_full_rank = rocblas_dswap_batched_orig(handle,n,c_loc(x),incx,c_loc(y),incy,batch_count)
    end function

    function rocblas_dswap_batched_rank_0(handle,n,x,incx,y,incy,batch_count)
      use iso_c_binding
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocblas_dswap_batched_rank_0
      type(c_ptr),value :: handle
      integer(c_int),value :: n
      real(c_double),target :: x
      integer(c_int),value :: incx
      real(c_double),target :: y
      integer(c_int),value :: incy
      integer(c_int),value :: batch_count
      !
      rocblas_dswap_batched_rank_0 = rocblas_dswap_batched_orig(handle,n,c_loc(x),incx,c_loc(y),incy,batch_count)
    end function

    function rocblas_dswap_batched_rank_1(handle,n,x,incx,y,incy,batch_count)
      use iso_c_binding
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocblas_dswap_batched_rank_1
      type(c_ptr),value :: handle
      integer(c_int),value :: n
      real(c_double),target,dimension(:) :: x
      integer(c_int),value :: incx
      real(c_double),target,dimension(:) :: y
      integer(c_int),value :: incy
      integer(c_int),value :: batch_count
      !
      rocblas_dswap_batched_rank_1 = rocblas_dswap_batched_orig(handle,n,c_loc(x),incx,c_loc(y),incy,batch_count)
    end function

    function rocblas_cswap_batched_full_rank(handle,n,x,incx,y,incy,batch_count)
      use iso_c_binding
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocblas_cswap_batched_full_rank
      type(c_ptr),value :: handle
      integer(c_int),value :: n
      complex(c_float_complex),target,dimension(:,:) :: x
      integer(c_int),value :: incx
      complex(c_float_complex),target,dimension(:,:) :: y
      integer(c_int),value :: incy
      integer(c_int),value :: batch_count
      !
      rocblas_cswap_batched_full_rank = rocblas_cswap_batched_orig(handle,n,c_loc(x),incx,c_loc(y),incy,batch_count)
    end function

    function rocblas_cswap_batched_rank_0(handle,n,x,incx,y,incy,batch_count)
      use iso_c_binding
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocblas_cswap_batched_rank_0
      type(c_ptr),value :: handle
      integer(c_int),value :: n
      complex(c_float_complex),target :: x
      integer(c_int),value :: incx
      complex(c_float_complex),target :: y
      integer(c_int),value :: incy
      integer(c_int),value :: batch_count
      !
      rocblas_cswap_batched_rank_0 = rocblas_cswap_batched_orig(handle,n,c_loc(x),incx,c_loc(y),incy,batch_count)
    end function

    function rocblas_cswap_batched_rank_1(handle,n,x,incx,y,incy,batch_count)
      use iso_c_binding
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocblas_cswap_batched_rank_1
      type(c_ptr),value :: handle
      integer(c_int),value :: n
      complex(c_float_complex),target,dimension(:) :: x
      integer(c_int),value :: incx
      complex(c_float_complex),target,dimension(:) :: y
      integer(c_int),value :: incy
      integer(c_int),value :: batch_count
      !
      rocblas_cswap_batched_rank_1 = rocblas_cswap_batched_orig(handle,n,c_loc(x),incx,c_loc(y),incy,batch_count)
    end function

    function rocblas_zswap_batched_full_rank(handle,n,x,incx,y,incy,batch_count)
      use iso_c_binding
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocblas_zswap_batched_full_rank
      type(c_ptr),value :: handle
      integer(c_int),value :: n
      complex(c_double_complex),target,dimension(:,:) :: x
      integer(c_int),value :: incx
      complex(c_double_complex),target,dimension(:,:) :: y
      integer(c_int),value :: incy
      integer(c_int),value :: batch_count
      !
      rocblas_zswap_batched_full_rank = rocblas_zswap_batched_orig(handle,n,c_loc(x),incx,c_loc(y),incy,batch_count)
    end function

    function rocblas_zswap_batched_rank_0(handle,n,x,incx,y,incy,batch_count)
      use iso_c_binding
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocblas_zswap_batched_rank_0
      type(c_ptr),value :: handle
      integer(c_int),value :: n
      complex(c_double_complex),target :: x
      integer(c_int),value :: incx
      complex(c_double_complex),target :: y
      integer(c_int),value :: incy
      integer(c_int),value :: batch_count
      !
      rocblas_zswap_batched_rank_0 = rocblas_zswap_batched_orig(handle,n,c_loc(x),incx,c_loc(y),incy,batch_count)
    end function

    function rocblas_zswap_batched_rank_1(handle,n,x,incx,y,incy,batch_count)
      use iso_c_binding
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocblas_zswap_batched_rank_1
      type(c_ptr),value :: handle
      integer(c_int),value :: n
      complex(c_double_complex),target,dimension(:) :: x
      integer(c_int),value :: incx
      complex(c_double_complex),target,dimension(:) :: y
      integer(c_int),value :: incy
      integer(c_int),value :: batch_count
      !
      rocblas_zswap_batched_rank_1 = rocblas_zswap_batched_orig(handle,n,c_loc(x),incx,c_loc(y),incy,batch_count)
    end function

    function rocblas_sswap_strided_batched_rank_0(handle,n,x,incx,stridex,y,incy,stridey,batch_count)
      use iso_c_binding
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocblas_sswap_strided_batched_rank_0
      type(c_ptr),value :: handle
      integer(c_int),value :: n
      real(c_float),target :: x
      integer(c_int),value :: incx
      integer(c_int64_t),value :: stridex
      real(c_float),target :: y
      integer(c_int),value :: incy
      integer(c_int64_t),value :: stridey
      integer(c_int),value :: batch_count
      !
      rocblas_sswap_strided_batched_rank_0 = rocblas_sswap_strided_batched_orig(handle,n,c_loc(x),incx,stridex,c_loc(y),incy,stridey,batch_count)
    end function

    function rocblas_sswap_strided_batched_rank_1(handle,n,x,incx,stridex,y,incy,stridey,batch_count)
      use iso_c_binding
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocblas_sswap_strided_batched_rank_1
      type(c_ptr),value :: handle
      integer(c_int),value :: n
      real(c_float),target,dimension(:) :: x
      integer(c_int),value :: incx
      integer(c_int64_t),value :: stridex
      real(c_float),target,dimension(:) :: y
      integer(c_int),value :: incy
      integer(c_int64_t),value :: stridey
      integer(c_int),value :: batch_count
      !
      rocblas_sswap_strided_batched_rank_1 = rocblas_sswap_strided_batched_orig(handle,n,c_loc(x),incx,stridex,c_loc(y),incy,stridey,batch_count)
    end function

    function rocblas_dswap_strided_batched_rank_0(handle,n,x,incx,stridex,y,incy,stridey,batch_count)
      use iso_c_binding
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocblas_dswap_strided_batched_rank_0
      type(c_ptr),value :: handle
      integer(c_int),value :: n
      real(c_double),target :: x
      integer(c_int),value :: incx
      integer(c_int64_t),value :: stridex
      real(c_double),target :: y
      integer(c_int),value :: incy
      integer(c_int64_t),value :: stridey
      integer(c_int),value :: batch_count
      !
      rocblas_dswap_strided_batched_rank_0 = rocblas_dswap_strided_batched_orig(handle,n,c_loc(x),incx,stridex,c_loc(y),incy,stridey,batch_count)
    end function

    function rocblas_dswap_strided_batched_rank_1(handle,n,x,incx,stridex,y,incy,stridey,batch_count)
      use iso_c_binding
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocblas_dswap_strided_batched_rank_1
      type(c_ptr),value :: handle
      integer(c_int),value :: n
      real(c_double),target,dimension(:) :: x
      integer(c_int),value :: incx
      integer(c_int64_t),value :: stridex
      real(c_double),target,dimension(:) :: y
      integer(c_int),value :: incy
      integer(c_int64_t),value :: stridey
      integer(c_int),value :: batch_count
      !
      rocblas_dswap_strided_batched_rank_1 = rocblas_dswap_strided_batched_orig(handle,n,c_loc(x),incx,stridex,c_loc(y),incy,stridey,batch_count)
    end function

    function rocblas_cswap_strided_batched_rank_0(handle,n,x,incx,stridex,y,incy,stridey,batch_count)
      use iso_c_binding
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocblas_cswap_strided_batched_rank_0
      type(c_ptr),value :: handle
      integer(c_int),value :: n
      complex(c_float_complex),target :: x
      integer(c_int),value :: incx
      integer(c_int64_t),value :: stridex
      complex(c_float_complex),target :: y
      integer(c_int),value :: incy
      integer(c_int64_t),value :: stridey
      integer(c_int),value :: batch_count
      !
      rocblas_cswap_strided_batched_rank_0 = rocblas_cswap_strided_batched_orig(handle,n,c_loc(x),incx,stridex,c_loc(y),incy,stridey,batch_count)
    end function

    function rocblas_cswap_strided_batched_rank_1(handle,n,x,incx,stridex,y,incy,stridey,batch_count)
      use iso_c_binding
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocblas_cswap_strided_batched_rank_1
      type(c_ptr),value :: handle
      integer(c_int),value :: n
      complex(c_float_complex),target,dimension(:) :: x
      integer(c_int),value :: incx
      integer(c_int64_t),value :: stridex
      complex(c_float_complex),target,dimension(:) :: y
      integer(c_int),value :: incy
      integer(c_int64_t),value :: stridey
      integer(c_int),value :: batch_count
      !
      rocblas_cswap_strided_batched_rank_1 = rocblas_cswap_strided_batched_orig(handle,n,c_loc(x),incx,stridex,c_loc(y),incy,stridey,batch_count)
    end function

    function rocblas_zswap_strided_batched_rank_0(handle,n,x,incx,stridex,y,incy,stridey,batch_count)
      use iso_c_binding
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocblas_zswap_strided_batched_rank_0
      type(c_ptr),value :: handle
      integer(c_int),value :: n
      complex(c_double_complex),target :: x
      integer(c_int),value :: incx
      integer(c_int64_t),value :: stridex
      complex(c_double_complex),target :: y
      integer(c_int),value :: incy
      integer(c_int64_t),value :: stridey
      integer(c_int),value :: batch_count
      !
      rocblas_zswap_strided_batched_rank_0 = rocblas_zswap_strided_batched_orig(handle,n,c_loc(x),incx,stridex,c_loc(y),incy,stridey,batch_count)
    end function

    function rocblas_zswap_strided_batched_rank_1(handle,n,x,incx,stridex,y,incy,stridey,batch_count)
      use iso_c_binding
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocblas_zswap_strided_batched_rank_1
      type(c_ptr),value :: handle
      integer(c_int),value :: n
      complex(c_double_complex),target,dimension(:) :: x
      integer(c_int),value :: incx
      integer(c_int64_t),value :: stridex
      complex(c_double_complex),target,dimension(:) :: y
      integer(c_int),value :: incy
      integer(c_int64_t),value :: stridey
      integer(c_int),value :: batch_count
      !
      rocblas_zswap_strided_batched_rank_1 = rocblas_zswap_strided_batched_orig(handle,n,c_loc(x),incx,stridex,c_loc(y),incy,stridey,batch_count)
    end function

    function rocblas_saxpy_rank_0(handle,n,alpha,x,incx,y,incy)
      use iso_c_binding
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocblas_saxpy_rank_0
      type(c_ptr),value :: handle
      integer(c_int),value :: n
      real(c_float) :: alpha
      real(c_float),target :: x
      integer(c_int),value :: incx
      real(c_float),target :: y
      integer(c_int),value :: incy
      !
      rocblas_saxpy_rank_0 = rocblas_saxpy_orig(handle,n,alpha,c_loc(x),incx,c_loc(y),incy)
    end function

    function rocblas_saxpy_rank_1(handle,n,alpha,x,incx,y,incy)
      use iso_c_binding
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocblas_saxpy_rank_1
      type(c_ptr),value :: handle
      integer(c_int),value :: n
      real(c_float) :: alpha
      real(c_float),target,dimension(:) :: x
      integer(c_int),value :: incx
      real(c_float),target,dimension(:) :: y
      integer(c_int),value :: incy
      !
      rocblas_saxpy_rank_1 = rocblas_saxpy_orig(handle,n,alpha,c_loc(x),incx,c_loc(y),incy)
    end function

    function rocblas_daxpy_rank_0(handle,n,alpha,x,incx,y,incy)
      use iso_c_binding
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocblas_daxpy_rank_0
      type(c_ptr),value :: handle
      integer(c_int),value :: n
      real(c_double) :: alpha
      real(c_double),target :: x
      integer(c_int),value :: incx
      real(c_double),target :: y
      integer(c_int),value :: incy
      !
      rocblas_daxpy_rank_0 = rocblas_daxpy_orig(handle,n,alpha,c_loc(x),incx,c_loc(y),incy)
    end function

    function rocblas_daxpy_rank_1(handle,n,alpha,x,incx,y,incy)
      use iso_c_binding
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocblas_daxpy_rank_1
      type(c_ptr),value :: handle
      integer(c_int),value :: n
      real(c_double) :: alpha
      real(c_double),target,dimension(:) :: x
      integer(c_int),value :: incx
      real(c_double),target,dimension(:) :: y
      integer(c_int),value :: incy
      !
      rocblas_daxpy_rank_1 = rocblas_daxpy_orig(handle,n,alpha,c_loc(x),incx,c_loc(y),incy)
    end function

    function rocblas_caxpy_rank_0(handle,n,alpha,x,incx,y,incy)
      use iso_c_binding
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocblas_caxpy_rank_0
      type(c_ptr),value :: handle
      integer(c_int),value :: n
      complex(c_float_complex) :: alpha
      complex(c_float_complex),target :: x
      integer(c_int),value :: incx
      complex(c_float_complex),target :: y
      integer(c_int),value :: incy
      !
      rocblas_caxpy_rank_0 = rocblas_caxpy_orig(handle,n,alpha,c_loc(x),incx,c_loc(y),incy)
    end function

    function rocblas_caxpy_rank_1(handle,n,alpha,x,incx,y,incy)
      use iso_c_binding
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocblas_caxpy_rank_1
      type(c_ptr),value :: handle
      integer(c_int),value :: n
      complex(c_float_complex) :: alpha
      complex(c_float_complex),target,dimension(:) :: x
      integer(c_int),value :: incx
      complex(c_float_complex),target,dimension(:) :: y
      integer(c_int),value :: incy
      !
      rocblas_caxpy_rank_1 = rocblas_caxpy_orig(handle,n,alpha,c_loc(x),incx,c_loc(y),incy)
    end function

    function rocblas_zaxpy_rank_0(handle,n,alpha,x,incx,y,incy)
      use iso_c_binding
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocblas_zaxpy_rank_0
      type(c_ptr),value :: handle
      integer(c_int),value :: n
      complex(c_double_complex) :: alpha
      complex(c_double_complex),target :: x
      integer(c_int),value :: incx
      complex(c_double_complex),target :: y
      integer(c_int),value :: incy
      !
      rocblas_zaxpy_rank_0 = rocblas_zaxpy_orig(handle,n,alpha,c_loc(x),incx,c_loc(y),incy)
    end function

    function rocblas_zaxpy_rank_1(handle,n,alpha,x,incx,y,incy)
      use iso_c_binding
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocblas_zaxpy_rank_1
      type(c_ptr),value :: handle
      integer(c_int),value :: n
      complex(c_double_complex) :: alpha
      complex(c_double_complex),target,dimension(:) :: x
      integer(c_int),value :: incx
      complex(c_double_complex),target,dimension(:) :: y
      integer(c_int),value :: incy
      !
      rocblas_zaxpy_rank_1 = rocblas_zaxpy_orig(handle,n,alpha,c_loc(x),incx,c_loc(y),incy)
    end function

    function rocblas_saxpy_batched_full_rank(handle,n,alpha,x,incx,y,incy,batch_count)
      use iso_c_binding
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocblas_saxpy_batched_full_rank
      type(c_ptr),value :: handle
      integer(c_int),value :: n
      real(c_float) :: alpha
      real(c_float),target,dimension(:,:) :: x
      integer(c_int),value :: incx
      real(c_float),target,dimension(:,:) :: y
      integer(c_int),value :: incy
      integer(c_int),value :: batch_count
      !
      rocblas_saxpy_batched_full_rank = rocblas_saxpy_batched_orig(handle,n,alpha,c_loc(x),incx,c_loc(y),incy,batch_count)
    end function

    function rocblas_saxpy_batched_rank_0(handle,n,alpha,x,incx,y,incy,batch_count)
      use iso_c_binding
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocblas_saxpy_batched_rank_0
      type(c_ptr),value :: handle
      integer(c_int),value :: n
      real(c_float) :: alpha
      real(c_float),target :: x
      integer(c_int),value :: incx
      real(c_float),target :: y
      integer(c_int),value :: incy
      integer(c_int),value :: batch_count
      !
      rocblas_saxpy_batched_rank_0 = rocblas_saxpy_batched_orig(handle,n,alpha,c_loc(x),incx,c_loc(y),incy,batch_count)
    end function

    function rocblas_saxpy_batched_rank_1(handle,n,alpha,x,incx,y,incy,batch_count)
      use iso_c_binding
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocblas_saxpy_batched_rank_1
      type(c_ptr),value :: handle
      integer(c_int),value :: n
      real(c_float) :: alpha
      real(c_float),target,dimension(:) :: x
      integer(c_int),value :: incx
      real(c_float),target,dimension(:) :: y
      integer(c_int),value :: incy
      integer(c_int),value :: batch_count
      !
      rocblas_saxpy_batched_rank_1 = rocblas_saxpy_batched_orig(handle,n,alpha,c_loc(x),incx,c_loc(y),incy,batch_count)
    end function

    function rocblas_daxpy_batched_full_rank(handle,n,alpha,x,incx,y,incy,batch_count)
      use iso_c_binding
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocblas_daxpy_batched_full_rank
      type(c_ptr),value :: handle
      integer(c_int),value :: n
      real(c_double) :: alpha
      real(c_double),target,dimension(:,:) :: x
      integer(c_int),value :: incx
      real(c_double),target,dimension(:,:) :: y
      integer(c_int),value :: incy
      integer(c_int),value :: batch_count
      !
      rocblas_daxpy_batched_full_rank = rocblas_daxpy_batched_orig(handle,n,alpha,c_loc(x),incx,c_loc(y),incy,batch_count)
    end function

    function rocblas_daxpy_batched_rank_0(handle,n,alpha,x,incx,y,incy,batch_count)
      use iso_c_binding
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocblas_daxpy_batched_rank_0
      type(c_ptr),value :: handle
      integer(c_int),value :: n
      real(c_double) :: alpha
      real(c_double),target :: x
      integer(c_int),value :: incx
      real(c_double),target :: y
      integer(c_int),value :: incy
      integer(c_int),value :: batch_count
      !
      rocblas_daxpy_batched_rank_0 = rocblas_daxpy_batched_orig(handle,n,alpha,c_loc(x),incx,c_loc(y),incy,batch_count)
    end function

    function rocblas_daxpy_batched_rank_1(handle,n,alpha,x,incx,y,incy,batch_count)
      use iso_c_binding
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocblas_daxpy_batched_rank_1
      type(c_ptr),value :: handle
      integer(c_int),value :: n
      real(c_double) :: alpha
      real(c_double),target,dimension(:) :: x
      integer(c_int),value :: incx
      real(c_double),target,dimension(:) :: y
      integer(c_int),value :: incy
      integer(c_int),value :: batch_count
      !
      rocblas_daxpy_batched_rank_1 = rocblas_daxpy_batched_orig(handle,n,alpha,c_loc(x),incx,c_loc(y),incy,batch_count)
    end function

    function rocblas_caxpy_batched_full_rank(handle,n,alpha,x,incx,y,incy,batch_count)
      use iso_c_binding
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocblas_caxpy_batched_full_rank
      type(c_ptr),value :: handle
      integer(c_int),value :: n
      complex(c_float_complex) :: alpha
      complex(c_float_complex),target,dimension(:,:) :: x
      integer(c_int),value :: incx
      complex(c_float_complex),target,dimension(:,:) :: y
      integer(c_int),value :: incy
      integer(c_int),value :: batch_count
      !
      rocblas_caxpy_batched_full_rank = rocblas_caxpy_batched_orig(handle,n,alpha,c_loc(x),incx,c_loc(y),incy,batch_count)
    end function

    function rocblas_caxpy_batched_rank_0(handle,n,alpha,x,incx,y,incy,batch_count)
      use iso_c_binding
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocblas_caxpy_batched_rank_0
      type(c_ptr),value :: handle
      integer(c_int),value :: n
      complex(c_float_complex) :: alpha
      complex(c_float_complex),target :: x
      integer(c_int),value :: incx
      complex(c_float_complex),target :: y
      integer(c_int),value :: incy
      integer(c_int),value :: batch_count
      !
      rocblas_caxpy_batched_rank_0 = rocblas_caxpy_batched_orig(handle,n,alpha,c_loc(x),incx,c_loc(y),incy,batch_count)
    end function

    function rocblas_caxpy_batched_rank_1(handle,n,alpha,x,incx,y,incy,batch_count)
      use iso_c_binding
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocblas_caxpy_batched_rank_1
      type(c_ptr),value :: handle
      integer(c_int),value :: n
      complex(c_float_complex) :: alpha
      complex(c_float_complex),target,dimension(:) :: x
      integer(c_int),value :: incx
      complex(c_float_complex),target,dimension(:) :: y
      integer(c_int),value :: incy
      integer(c_int),value :: batch_count
      !
      rocblas_caxpy_batched_rank_1 = rocblas_caxpy_batched_orig(handle,n,alpha,c_loc(x),incx,c_loc(y),incy,batch_count)
    end function

    function rocblas_zaxpy_batched_full_rank(handle,n,alpha,x,incx,y,incy,batch_count)
      use iso_c_binding
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocblas_zaxpy_batched_full_rank
      type(c_ptr),value :: handle
      integer(c_int),value :: n
      complex(c_double_complex) :: alpha
      complex(c_double_complex),target,dimension(:,:) :: x
      integer(c_int),value :: incx
      complex(c_double_complex),target,dimension(:,:) :: y
      integer(c_int),value :: incy
      integer(c_int),value :: batch_count
      !
      rocblas_zaxpy_batched_full_rank = rocblas_zaxpy_batched_orig(handle,n,alpha,c_loc(x),incx,c_loc(y),incy,batch_count)
    end function

    function rocblas_zaxpy_batched_rank_0(handle,n,alpha,x,incx,y,incy,batch_count)
      use iso_c_binding
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocblas_zaxpy_batched_rank_0
      type(c_ptr),value :: handle
      integer(c_int),value :: n
      complex(c_double_complex) :: alpha
      complex(c_double_complex),target :: x
      integer(c_int),value :: incx
      complex(c_double_complex),target :: y
      integer(c_int),value :: incy
      integer(c_int),value :: batch_count
      !
      rocblas_zaxpy_batched_rank_0 = rocblas_zaxpy_batched_orig(handle,n,alpha,c_loc(x),incx,c_loc(y),incy,batch_count)
    end function

    function rocblas_zaxpy_batched_rank_1(handle,n,alpha,x,incx,y,incy,batch_count)
      use iso_c_binding
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocblas_zaxpy_batched_rank_1
      type(c_ptr),value :: handle
      integer(c_int),value :: n
      complex(c_double_complex) :: alpha
      complex(c_double_complex),target,dimension(:) :: x
      integer(c_int),value :: incx
      complex(c_double_complex),target,dimension(:) :: y
      integer(c_int),value :: incy
      integer(c_int),value :: batch_count
      !
      rocblas_zaxpy_batched_rank_1 = rocblas_zaxpy_batched_orig(handle,n,alpha,c_loc(x),incx,c_loc(y),incy,batch_count)
    end function

    function rocblas_saxpy_strided_batched_rank_0(handle,n,alpha,x,incx,stridex,y,incy,stridey,batch_count)
      use iso_c_binding
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocblas_saxpy_strided_batched_rank_0
      type(c_ptr),value :: handle
      integer(c_int),value :: n
      real(c_float) :: alpha
      real(c_float),target :: x
      integer(c_int),value :: incx
      integer(c_int64_t),value :: stridex
      real(c_float),target :: y
      integer(c_int),value :: incy
      integer(c_int64_t),value :: stridey
      integer(c_int),value :: batch_count
      !
      rocblas_saxpy_strided_batched_rank_0 = rocblas_saxpy_strided_batched_orig(handle,n,alpha,c_loc(x),incx,stridex,c_loc(y),incy,stridey,batch_count)
    end function

    function rocblas_saxpy_strided_batched_rank_1(handle,n,alpha,x,incx,stridex,y,incy,stridey,batch_count)
      use iso_c_binding
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocblas_saxpy_strided_batched_rank_1
      type(c_ptr),value :: handle
      integer(c_int),value :: n
      real(c_float) :: alpha
      real(c_float),target,dimension(:) :: x
      integer(c_int),value :: incx
      integer(c_int64_t),value :: stridex
      real(c_float),target,dimension(:) :: y
      integer(c_int),value :: incy
      integer(c_int64_t),value :: stridey
      integer(c_int),value :: batch_count
      !
      rocblas_saxpy_strided_batched_rank_1 = rocblas_saxpy_strided_batched_orig(handle,n,alpha,c_loc(x),incx,stridex,c_loc(y),incy,stridey,batch_count)
    end function

    function rocblas_daxpy_strided_batched_rank_0(handle,n,alpha,x,incx,stridex,y,incy,stridey,batch_count)
      use iso_c_binding
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocblas_daxpy_strided_batched_rank_0
      type(c_ptr),value :: handle
      integer(c_int),value :: n
      real(c_double) :: alpha
      real(c_double),target :: x
      integer(c_int),value :: incx
      integer(c_int64_t),value :: stridex
      real(c_double),target :: y
      integer(c_int),value :: incy
      integer(c_int64_t),value :: stridey
      integer(c_int),value :: batch_count
      !
      rocblas_daxpy_strided_batched_rank_0 = rocblas_daxpy_strided_batched_orig(handle,n,alpha,c_loc(x),incx,stridex,c_loc(y),incy,stridey,batch_count)
    end function

    function rocblas_daxpy_strided_batched_rank_1(handle,n,alpha,x,incx,stridex,y,incy,stridey,batch_count)
      use iso_c_binding
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocblas_daxpy_strided_batched_rank_1
      type(c_ptr),value :: handle
      integer(c_int),value :: n
      real(c_double) :: alpha
      real(c_double),target,dimension(:) :: x
      integer(c_int),value :: incx
      integer(c_int64_t),value :: stridex
      real(c_double),target,dimension(:) :: y
      integer(c_int),value :: incy
      integer(c_int64_t),value :: stridey
      integer(c_int),value :: batch_count
      !
      rocblas_daxpy_strided_batched_rank_1 = rocblas_daxpy_strided_batched_orig(handle,n,alpha,c_loc(x),incx,stridex,c_loc(y),incy,stridey,batch_count)
    end function

    function rocblas_caxpy_strided_batched_rank_0(handle,n,alpha,x,incx,stridex,y,incy,stridey,batch_count)
      use iso_c_binding
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocblas_caxpy_strided_batched_rank_0
      type(c_ptr),value :: handle
      integer(c_int),value :: n
      complex(c_float_complex) :: alpha
      complex(c_float_complex),target :: x
      integer(c_int),value :: incx
      integer(c_int64_t),value :: stridex
      complex(c_float_complex),target :: y
      integer(c_int),value :: incy
      integer(c_int64_t),value :: stridey
      integer(c_int),value :: batch_count
      !
      rocblas_caxpy_strided_batched_rank_0 = rocblas_caxpy_strided_batched_orig(handle,n,alpha,c_loc(x),incx,stridex,c_loc(y),incy,stridey,batch_count)
    end function

    function rocblas_caxpy_strided_batched_rank_1(handle,n,alpha,x,incx,stridex,y,incy,stridey,batch_count)
      use iso_c_binding
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocblas_caxpy_strided_batched_rank_1
      type(c_ptr),value :: handle
      integer(c_int),value :: n
      complex(c_float_complex) :: alpha
      complex(c_float_complex),target,dimension(:) :: x
      integer(c_int),value :: incx
      integer(c_int64_t),value :: stridex
      complex(c_float_complex),target,dimension(:) :: y
      integer(c_int),value :: incy
      integer(c_int64_t),value :: stridey
      integer(c_int),value :: batch_count
      !
      rocblas_caxpy_strided_batched_rank_1 = rocblas_caxpy_strided_batched_orig(handle,n,alpha,c_loc(x),incx,stridex,c_loc(y),incy,stridey,batch_count)
    end function

    function rocblas_zaxpy_strided_batched_rank_0(handle,n,alpha,x,incx,stridex,y,incy,stridey,batch_count)
      use iso_c_binding
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocblas_zaxpy_strided_batched_rank_0
      type(c_ptr),value :: handle
      integer(c_int),value :: n
      complex(c_double_complex) :: alpha
      complex(c_double_complex),target :: x
      integer(c_int),value :: incx
      integer(c_int64_t),value :: stridex
      complex(c_double_complex),target :: y
      integer(c_int),value :: incy
      integer(c_int64_t),value :: stridey
      integer(c_int),value :: batch_count
      !
      rocblas_zaxpy_strided_batched_rank_0 = rocblas_zaxpy_strided_batched_orig(handle,n,alpha,c_loc(x),incx,stridex,c_loc(y),incy,stridey,batch_count)
    end function

    function rocblas_zaxpy_strided_batched_rank_1(handle,n,alpha,x,incx,stridex,y,incy,stridey,batch_count)
      use iso_c_binding
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocblas_zaxpy_strided_batched_rank_1
      type(c_ptr),value :: handle
      integer(c_int),value :: n
      complex(c_double_complex) :: alpha
      complex(c_double_complex),target,dimension(:) :: x
      integer(c_int),value :: incx
      integer(c_int64_t),value :: stridex
      complex(c_double_complex),target,dimension(:) :: y
      integer(c_int),value :: incy
      integer(c_int64_t),value :: stridey
      integer(c_int),value :: batch_count
      !
      rocblas_zaxpy_strided_batched_rank_1 = rocblas_zaxpy_strided_batched_orig(handle,n,alpha,c_loc(x),incx,stridex,c_loc(y),incy,stridey,batch_count)
    end function

    function rocblas_scasum_rank_0(handle,n,x,incx,myResult)
      use iso_c_binding
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocblas_scasum_rank_0
      type(c_ptr),value :: handle
      integer(c_int),value :: n
      complex(c_float_complex),target :: x
      integer(c_int),value :: incx
      type(c_ptr),value :: myResult
      !
      rocblas_scasum_rank_0 = rocblas_scasum_orig(handle,n,c_loc(x),incx,myResult)
    end function

    function rocblas_scasum_rank_1(handle,n,x,incx,myResult)
      use iso_c_binding
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocblas_scasum_rank_1
      type(c_ptr),value :: handle
      integer(c_int),value :: n
      complex(c_float_complex),target,dimension(:) :: x
      integer(c_int),value :: incx
      type(c_ptr),value :: myResult
      !
      rocblas_scasum_rank_1 = rocblas_scasum_orig(handle,n,c_loc(x),incx,myResult)
    end function

    function rocblas_dzasum_rank_0(handle,n,x,incx,myResult)
      use iso_c_binding
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocblas_dzasum_rank_0
      type(c_ptr),value :: handle
      integer(c_int),value :: n
      complex(c_double_complex),target :: x
      integer(c_int),value :: incx
      type(c_ptr),value :: myResult
      !
      rocblas_dzasum_rank_0 = rocblas_dzasum_orig(handle,n,c_loc(x),incx,myResult)
    end function

    function rocblas_dzasum_rank_1(handle,n,x,incx,myResult)
      use iso_c_binding
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocblas_dzasum_rank_1
      type(c_ptr),value :: handle
      integer(c_int),value :: n
      complex(c_double_complex),target,dimension(:) :: x
      integer(c_int),value :: incx
      type(c_ptr),value :: myResult
      !
      rocblas_dzasum_rank_1 = rocblas_dzasum_orig(handle,n,c_loc(x),incx,myResult)
    end function

    function rocblas_sasum_batched_full_rank(handle,n,x,incx,batch_count,results)
      use iso_c_binding
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocblas_sasum_batched_full_rank
      type(c_ptr),value :: handle
      integer(c_int),value :: n
      real(c_float),target,dimension(:,:) :: x
      integer(c_int),value :: incx
      integer(c_int),value :: batch_count
      type(c_ptr),value :: results
      !
      rocblas_sasum_batched_full_rank = rocblas_sasum_batched_orig(handle,n,c_loc(x),incx,batch_count,results)
    end function

    function rocblas_sasum_batched_rank_0(handle,n,x,incx,batch_count,results)
      use iso_c_binding
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocblas_sasum_batched_rank_0
      type(c_ptr),value :: handle
      integer(c_int),value :: n
      real(c_float),target :: x
      integer(c_int),value :: incx
      integer(c_int),value :: batch_count
      type(c_ptr),value :: results
      !
      rocblas_sasum_batched_rank_0 = rocblas_sasum_batched_orig(handle,n,c_loc(x),incx,batch_count,results)
    end function

    function rocblas_sasum_batched_rank_1(handle,n,x,incx,batch_count,results)
      use iso_c_binding
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocblas_sasum_batched_rank_1
      type(c_ptr),value :: handle
      integer(c_int),value :: n
      real(c_float),target,dimension(:) :: x
      integer(c_int),value :: incx
      integer(c_int),value :: batch_count
      type(c_ptr),value :: results
      !
      rocblas_sasum_batched_rank_1 = rocblas_sasum_batched_orig(handle,n,c_loc(x),incx,batch_count,results)
    end function

    function rocblas_dasum_batched_full_rank(handle,n,x,incx,batch_count,results)
      use iso_c_binding
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocblas_dasum_batched_full_rank
      type(c_ptr),value :: handle
      integer(c_int),value :: n
      real(c_double),target,dimension(:,:) :: x
      integer(c_int),value :: incx
      integer(c_int),value :: batch_count
      type(c_ptr),value :: results
      !
      rocblas_dasum_batched_full_rank = rocblas_dasum_batched_orig(handle,n,c_loc(x),incx,batch_count,results)
    end function

    function rocblas_dasum_batched_rank_0(handle,n,x,incx,batch_count,results)
      use iso_c_binding
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocblas_dasum_batched_rank_0
      type(c_ptr),value :: handle
      integer(c_int),value :: n
      real(c_double),target :: x
      integer(c_int),value :: incx
      integer(c_int),value :: batch_count
      type(c_ptr),value :: results
      !
      rocblas_dasum_batched_rank_0 = rocblas_dasum_batched_orig(handle,n,c_loc(x),incx,batch_count,results)
    end function

    function rocblas_dasum_batched_rank_1(handle,n,x,incx,batch_count,results)
      use iso_c_binding
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocblas_dasum_batched_rank_1
      type(c_ptr),value :: handle
      integer(c_int),value :: n
      real(c_double),target,dimension(:) :: x
      integer(c_int),value :: incx
      integer(c_int),value :: batch_count
      type(c_ptr),value :: results
      !
      rocblas_dasum_batched_rank_1 = rocblas_dasum_batched_orig(handle,n,c_loc(x),incx,batch_count,results)
    end function

    function rocblas_scasum_batched_full_rank(handle,n,x,incx,batch_count,results)
      use iso_c_binding
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocblas_scasum_batched_full_rank
      type(c_ptr),value :: handle
      integer(c_int),value :: n
      complex(c_float_complex),target,dimension(:,:) :: x
      integer(c_int),value :: incx
      integer(c_int),value :: batch_count
      type(c_ptr),value :: results
      !
      rocblas_scasum_batched_full_rank = rocblas_scasum_batched_orig(handle,n,c_loc(x),incx,batch_count,results)
    end function

    function rocblas_scasum_batched_rank_0(handle,n,x,incx,batch_count,results)
      use iso_c_binding
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocblas_scasum_batched_rank_0
      type(c_ptr),value :: handle
      integer(c_int),value :: n
      complex(c_float_complex),target :: x
      integer(c_int),value :: incx
      integer(c_int),value :: batch_count
      type(c_ptr),value :: results
      !
      rocblas_scasum_batched_rank_0 = rocblas_scasum_batched_orig(handle,n,c_loc(x),incx,batch_count,results)
    end function

    function rocblas_scasum_batched_rank_1(handle,n,x,incx,batch_count,results)
      use iso_c_binding
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocblas_scasum_batched_rank_1
      type(c_ptr),value :: handle
      integer(c_int),value :: n
      complex(c_float_complex),target,dimension(:) :: x
      integer(c_int),value :: incx
      integer(c_int),value :: batch_count
      type(c_ptr),value :: results
      !
      rocblas_scasum_batched_rank_1 = rocblas_scasum_batched_orig(handle,n,c_loc(x),incx,batch_count,results)
    end function

    function rocblas_dzasum_batched_full_rank(handle,n,x,incx,batch_count,results)
      use iso_c_binding
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocblas_dzasum_batched_full_rank
      type(c_ptr),value :: handle
      integer(c_int),value :: n
      complex(c_double_complex),target,dimension(:,:) :: x
      integer(c_int),value :: incx
      integer(c_int),value :: batch_count
      type(c_ptr),value :: results
      !
      rocblas_dzasum_batched_full_rank = rocblas_dzasum_batched_orig(handle,n,c_loc(x),incx,batch_count,results)
    end function

    function rocblas_dzasum_batched_rank_0(handle,n,x,incx,batch_count,results)
      use iso_c_binding
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocblas_dzasum_batched_rank_0
      type(c_ptr),value :: handle
      integer(c_int),value :: n
      complex(c_double_complex),target :: x
      integer(c_int),value :: incx
      integer(c_int),value :: batch_count
      type(c_ptr),value :: results
      !
      rocblas_dzasum_batched_rank_0 = rocblas_dzasum_batched_orig(handle,n,c_loc(x),incx,batch_count,results)
    end function

    function rocblas_dzasum_batched_rank_1(handle,n,x,incx,batch_count,results)
      use iso_c_binding
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocblas_dzasum_batched_rank_1
      type(c_ptr),value :: handle
      integer(c_int),value :: n
      complex(c_double_complex),target,dimension(:) :: x
      integer(c_int),value :: incx
      integer(c_int),value :: batch_count
      type(c_ptr),value :: results
      !
      rocblas_dzasum_batched_rank_1 = rocblas_dzasum_batched_orig(handle,n,c_loc(x),incx,batch_count,results)
    end function

    function rocblas_sasum_strided_batched_rank_0(handle,n,x,incx,stridex,batch_count,results)
      use iso_c_binding
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocblas_sasum_strided_batched_rank_0
      type(c_ptr),value :: handle
      integer(c_int),value :: n
      real(c_float),target :: x
      integer(c_int),value :: incx
      integer(c_int64_t),value :: stridex
      integer(c_int),value :: batch_count
      type(c_ptr),value :: results
      !
      rocblas_sasum_strided_batched_rank_0 = rocblas_sasum_strided_batched_orig(handle,n,c_loc(x),incx,stridex,batch_count,results)
    end function

    function rocblas_sasum_strided_batched_rank_1(handle,n,x,incx,stridex,batch_count,results)
      use iso_c_binding
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocblas_sasum_strided_batched_rank_1
      type(c_ptr),value :: handle
      integer(c_int),value :: n
      real(c_float),target,dimension(:) :: x
      integer(c_int),value :: incx
      integer(c_int64_t),value :: stridex
      integer(c_int),value :: batch_count
      type(c_ptr),value :: results
      !
      rocblas_sasum_strided_batched_rank_1 = rocblas_sasum_strided_batched_orig(handle,n,c_loc(x),incx,stridex,batch_count,results)
    end function

    function rocblas_dasum_strided_batched_rank_0(handle,n,x,incx,stridex,batch_count,results)
      use iso_c_binding
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocblas_dasum_strided_batched_rank_0
      type(c_ptr),value :: handle
      integer(c_int),value :: n
      real(c_double),target :: x
      integer(c_int),value :: incx
      integer(c_int64_t),value :: stridex
      integer(c_int),value :: batch_count
      type(c_ptr),value :: results
      !
      rocblas_dasum_strided_batched_rank_0 = rocblas_dasum_strided_batched_orig(handle,n,c_loc(x),incx,stridex,batch_count,results)
    end function

    function rocblas_dasum_strided_batched_rank_1(handle,n,x,incx,stridex,batch_count,results)
      use iso_c_binding
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocblas_dasum_strided_batched_rank_1
      type(c_ptr),value :: handle
      integer(c_int),value :: n
      real(c_double),target,dimension(:) :: x
      integer(c_int),value :: incx
      integer(c_int64_t),value :: stridex
      integer(c_int),value :: batch_count
      type(c_ptr),value :: results
      !
      rocblas_dasum_strided_batched_rank_1 = rocblas_dasum_strided_batched_orig(handle,n,c_loc(x),incx,stridex,batch_count,results)
    end function

    function rocblas_scasum_strided_batched_rank_0(handle,n,x,incx,stridex,batch_count,results)
      use iso_c_binding
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocblas_scasum_strided_batched_rank_0
      type(c_ptr),value :: handle
      integer(c_int),value :: n
      complex(c_float_complex),target :: x
      integer(c_int),value :: incx
      integer(c_int64_t),value :: stridex
      integer(c_int),value :: batch_count
      type(c_ptr),value :: results
      !
      rocblas_scasum_strided_batched_rank_0 = rocblas_scasum_strided_batched_orig(handle,n,c_loc(x),incx,stridex,batch_count,results)
    end function

    function rocblas_scasum_strided_batched_rank_1(handle,n,x,incx,stridex,batch_count,results)
      use iso_c_binding
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocblas_scasum_strided_batched_rank_1
      type(c_ptr),value :: handle
      integer(c_int),value :: n
      complex(c_float_complex),target,dimension(:) :: x
      integer(c_int),value :: incx
      integer(c_int64_t),value :: stridex
      integer(c_int),value :: batch_count
      type(c_ptr),value :: results
      !
      rocblas_scasum_strided_batched_rank_1 = rocblas_scasum_strided_batched_orig(handle,n,c_loc(x),incx,stridex,batch_count,results)
    end function

    function rocblas_dzasum_strided_batched_rank_0(handle,n,x,incx,stridex,batch_count,results)
      use iso_c_binding
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocblas_dzasum_strided_batched_rank_0
      type(c_ptr),value :: handle
      integer(c_int),value :: n
      complex(c_double_complex),target :: x
      integer(c_int),value :: incx
      integer(c_int64_t),value :: stridex
      integer(c_int),value :: batch_count
      type(c_ptr),value :: results
      !
      rocblas_dzasum_strided_batched_rank_0 = rocblas_dzasum_strided_batched_orig(handle,n,c_loc(x),incx,stridex,batch_count,results)
    end function

    function rocblas_dzasum_strided_batched_rank_1(handle,n,x,incx,stridex,batch_count,results)
      use iso_c_binding
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocblas_dzasum_strided_batched_rank_1
      type(c_ptr),value :: handle
      integer(c_int),value :: n
      complex(c_double_complex),target,dimension(:) :: x
      integer(c_int),value :: incx
      integer(c_int64_t),value :: stridex
      integer(c_int),value :: batch_count
      type(c_ptr),value :: results
      !
      rocblas_dzasum_strided_batched_rank_1 = rocblas_dzasum_strided_batched_orig(handle,n,c_loc(x),incx,stridex,batch_count,results)
    end function

    function rocblas_scnrm2_rank_0(handle,n,x,incx,myResult)
      use iso_c_binding
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocblas_scnrm2_rank_0
      type(c_ptr),value :: handle
      integer(c_int),value :: n
      complex(c_float_complex),target :: x
      integer(c_int),value :: incx
      type(c_ptr),value :: myResult
      !
      rocblas_scnrm2_rank_0 = rocblas_scnrm2_orig(handle,n,c_loc(x),incx,myResult)
    end function

    function rocblas_scnrm2_rank_1(handle,n,x,incx,myResult)
      use iso_c_binding
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocblas_scnrm2_rank_1
      type(c_ptr),value :: handle
      integer(c_int),value :: n
      complex(c_float_complex),target,dimension(:) :: x
      integer(c_int),value :: incx
      type(c_ptr),value :: myResult
      !
      rocblas_scnrm2_rank_1 = rocblas_scnrm2_orig(handle,n,c_loc(x),incx,myResult)
    end function

    function rocblas_dznrm2_rank_0(handle,n,x,incx,myResult)
      use iso_c_binding
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocblas_dznrm2_rank_0
      type(c_ptr),value :: handle
      integer(c_int),value :: n
      complex(c_double_complex),target :: x
      integer(c_int),value :: incx
      type(c_ptr),value :: myResult
      !
      rocblas_dznrm2_rank_0 = rocblas_dznrm2_orig(handle,n,c_loc(x),incx,myResult)
    end function

    function rocblas_dznrm2_rank_1(handle,n,x,incx,myResult)
      use iso_c_binding
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocblas_dznrm2_rank_1
      type(c_ptr),value :: handle
      integer(c_int),value :: n
      complex(c_double_complex),target,dimension(:) :: x
      integer(c_int),value :: incx
      type(c_ptr),value :: myResult
      !
      rocblas_dznrm2_rank_1 = rocblas_dznrm2_orig(handle,n,c_loc(x),incx,myResult)
    end function

    function rocblas_snrm2_batched_full_rank(handle,n,x,incx,batch_count,results)
      use iso_c_binding
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocblas_snrm2_batched_full_rank
      type(c_ptr),value :: handle
      integer(c_int),value :: n
      real(c_float),target,dimension(:,:) :: x
      integer(c_int),value :: incx
      integer(c_int),value :: batch_count
      type(c_ptr),value :: results
      !
      rocblas_snrm2_batched_full_rank = rocblas_snrm2_batched_orig(handle,n,c_loc(x),incx,batch_count,results)
    end function

    function rocblas_snrm2_batched_rank_0(handle,n,x,incx,batch_count,results)
      use iso_c_binding
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocblas_snrm2_batched_rank_0
      type(c_ptr),value :: handle
      integer(c_int),value :: n
      real(c_float),target :: x
      integer(c_int),value :: incx
      integer(c_int),value :: batch_count
      type(c_ptr),value :: results
      !
      rocblas_snrm2_batched_rank_0 = rocblas_snrm2_batched_orig(handle,n,c_loc(x),incx,batch_count,results)
    end function

    function rocblas_snrm2_batched_rank_1(handle,n,x,incx,batch_count,results)
      use iso_c_binding
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocblas_snrm2_batched_rank_1
      type(c_ptr),value :: handle
      integer(c_int),value :: n
      real(c_float),target,dimension(:) :: x
      integer(c_int),value :: incx
      integer(c_int),value :: batch_count
      type(c_ptr),value :: results
      !
      rocblas_snrm2_batched_rank_1 = rocblas_snrm2_batched_orig(handle,n,c_loc(x),incx,batch_count,results)
    end function

    function rocblas_dnrm2_batched_full_rank(handle,n,x,incx,batch_count,results)
      use iso_c_binding
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocblas_dnrm2_batched_full_rank
      type(c_ptr),value :: handle
      integer(c_int),value :: n
      real(c_double),target,dimension(:,:) :: x
      integer(c_int),value :: incx
      integer(c_int),value :: batch_count
      type(c_ptr),value :: results
      !
      rocblas_dnrm2_batched_full_rank = rocblas_dnrm2_batched_orig(handle,n,c_loc(x),incx,batch_count,results)
    end function

    function rocblas_dnrm2_batched_rank_0(handle,n,x,incx,batch_count,results)
      use iso_c_binding
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocblas_dnrm2_batched_rank_0
      type(c_ptr),value :: handle
      integer(c_int),value :: n
      real(c_double),target :: x
      integer(c_int),value :: incx
      integer(c_int),value :: batch_count
      type(c_ptr),value :: results
      !
      rocblas_dnrm2_batched_rank_0 = rocblas_dnrm2_batched_orig(handle,n,c_loc(x),incx,batch_count,results)
    end function

    function rocblas_dnrm2_batched_rank_1(handle,n,x,incx,batch_count,results)
      use iso_c_binding
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocblas_dnrm2_batched_rank_1
      type(c_ptr),value :: handle
      integer(c_int),value :: n
      real(c_double),target,dimension(:) :: x
      integer(c_int),value :: incx
      integer(c_int),value :: batch_count
      type(c_ptr),value :: results
      !
      rocblas_dnrm2_batched_rank_1 = rocblas_dnrm2_batched_orig(handle,n,c_loc(x),incx,batch_count,results)
    end function

    function rocblas_scnrm2_batched_full_rank(handle,n,x,incx,batch_count,results)
      use iso_c_binding
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocblas_scnrm2_batched_full_rank
      type(c_ptr),value :: handle
      integer(c_int),value :: n
      complex(c_float_complex),target,dimension(:,:) :: x
      integer(c_int),value :: incx
      integer(c_int),value :: batch_count
      type(c_ptr),value :: results
      !
      rocblas_scnrm2_batched_full_rank = rocblas_scnrm2_batched_orig(handle,n,c_loc(x),incx,batch_count,results)
    end function

    function rocblas_scnrm2_batched_rank_0(handle,n,x,incx,batch_count,results)
      use iso_c_binding
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocblas_scnrm2_batched_rank_0
      type(c_ptr),value :: handle
      integer(c_int),value :: n
      complex(c_float_complex),target :: x
      integer(c_int),value :: incx
      integer(c_int),value :: batch_count
      type(c_ptr),value :: results
      !
      rocblas_scnrm2_batched_rank_0 = rocblas_scnrm2_batched_orig(handle,n,c_loc(x),incx,batch_count,results)
    end function

    function rocblas_scnrm2_batched_rank_1(handle,n,x,incx,batch_count,results)
      use iso_c_binding
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocblas_scnrm2_batched_rank_1
      type(c_ptr),value :: handle
      integer(c_int),value :: n
      complex(c_float_complex),target,dimension(:) :: x
      integer(c_int),value :: incx
      integer(c_int),value :: batch_count
      type(c_ptr),value :: results
      !
      rocblas_scnrm2_batched_rank_1 = rocblas_scnrm2_batched_orig(handle,n,c_loc(x),incx,batch_count,results)
    end function

    function rocblas_dznrm2_batched_full_rank(handle,n,x,incx,batch_count,results)
      use iso_c_binding
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocblas_dznrm2_batched_full_rank
      type(c_ptr),value :: handle
      integer(c_int),value :: n
      complex(c_double_complex),target,dimension(:,:) :: x
      integer(c_int),value :: incx
      integer(c_int),value :: batch_count
      type(c_ptr),value :: results
      !
      rocblas_dznrm2_batched_full_rank = rocblas_dznrm2_batched_orig(handle,n,c_loc(x),incx,batch_count,results)
    end function

    function rocblas_dznrm2_batched_rank_0(handle,n,x,incx,batch_count,results)
      use iso_c_binding
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocblas_dznrm2_batched_rank_0
      type(c_ptr),value :: handle
      integer(c_int),value :: n
      complex(c_double_complex),target :: x
      integer(c_int),value :: incx
      integer(c_int),value :: batch_count
      type(c_ptr),value :: results
      !
      rocblas_dznrm2_batched_rank_0 = rocblas_dznrm2_batched_orig(handle,n,c_loc(x),incx,batch_count,results)
    end function

    function rocblas_dznrm2_batched_rank_1(handle,n,x,incx,batch_count,results)
      use iso_c_binding
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocblas_dznrm2_batched_rank_1
      type(c_ptr),value :: handle
      integer(c_int),value :: n
      complex(c_double_complex),target,dimension(:) :: x
      integer(c_int),value :: incx
      integer(c_int),value :: batch_count
      type(c_ptr),value :: results
      !
      rocblas_dznrm2_batched_rank_1 = rocblas_dznrm2_batched_orig(handle,n,c_loc(x),incx,batch_count,results)
    end function

    function rocblas_snrm2_strided_batched_rank_0(handle,n,x,incx,stridex,batch_count,results)
      use iso_c_binding
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocblas_snrm2_strided_batched_rank_0
      type(c_ptr),value :: handle
      integer(c_int),value :: n
      real(c_float),target :: x
      integer(c_int),value :: incx
      integer(c_int64_t),value :: stridex
      integer(c_int),value :: batch_count
      type(c_ptr),value :: results
      !
      rocblas_snrm2_strided_batched_rank_0 = rocblas_snrm2_strided_batched_orig(handle,n,c_loc(x),incx,stridex,batch_count,results)
    end function

    function rocblas_snrm2_strided_batched_rank_1(handle,n,x,incx,stridex,batch_count,results)
      use iso_c_binding
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocblas_snrm2_strided_batched_rank_1
      type(c_ptr),value :: handle
      integer(c_int),value :: n
      real(c_float),target,dimension(:) :: x
      integer(c_int),value :: incx
      integer(c_int64_t),value :: stridex
      integer(c_int),value :: batch_count
      type(c_ptr),value :: results
      !
      rocblas_snrm2_strided_batched_rank_1 = rocblas_snrm2_strided_batched_orig(handle,n,c_loc(x),incx,stridex,batch_count,results)
    end function

    function rocblas_dnrm2_strided_batched_rank_0(handle,n,x,incx,stridex,batch_count,results)
      use iso_c_binding
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocblas_dnrm2_strided_batched_rank_0
      type(c_ptr),value :: handle
      integer(c_int),value :: n
      real(c_double),target :: x
      integer(c_int),value :: incx
      integer(c_int64_t),value :: stridex
      integer(c_int),value :: batch_count
      type(c_ptr),value :: results
      !
      rocblas_dnrm2_strided_batched_rank_0 = rocblas_dnrm2_strided_batched_orig(handle,n,c_loc(x),incx,stridex,batch_count,results)
    end function

    function rocblas_dnrm2_strided_batched_rank_1(handle,n,x,incx,stridex,batch_count,results)
      use iso_c_binding
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocblas_dnrm2_strided_batched_rank_1
      type(c_ptr),value :: handle
      integer(c_int),value :: n
      real(c_double),target,dimension(:) :: x
      integer(c_int),value :: incx
      integer(c_int64_t),value :: stridex
      integer(c_int),value :: batch_count
      type(c_ptr),value :: results
      !
      rocblas_dnrm2_strided_batched_rank_1 = rocblas_dnrm2_strided_batched_orig(handle,n,c_loc(x),incx,stridex,batch_count,results)
    end function

    function rocblas_scnrm2_strided_batched_rank_0(handle,n,x,incx,stridex,batch_count,results)
      use iso_c_binding
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocblas_scnrm2_strided_batched_rank_0
      type(c_ptr),value :: handle
      integer(c_int),value :: n
      complex(c_float_complex),target :: x
      integer(c_int),value :: incx
      integer(c_int64_t),value :: stridex
      integer(c_int),value :: batch_count
      type(c_ptr),value :: results
      !
      rocblas_scnrm2_strided_batched_rank_0 = rocblas_scnrm2_strided_batched_orig(handle,n,c_loc(x),incx,stridex,batch_count,results)
    end function

    function rocblas_scnrm2_strided_batched_rank_1(handle,n,x,incx,stridex,batch_count,results)
      use iso_c_binding
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocblas_scnrm2_strided_batched_rank_1
      type(c_ptr),value :: handle
      integer(c_int),value :: n
      complex(c_float_complex),target,dimension(:) :: x
      integer(c_int),value :: incx
      integer(c_int64_t),value :: stridex
      integer(c_int),value :: batch_count
      type(c_ptr),value :: results
      !
      rocblas_scnrm2_strided_batched_rank_1 = rocblas_scnrm2_strided_batched_orig(handle,n,c_loc(x),incx,stridex,batch_count,results)
    end function

    function rocblas_dznrm2_strided_batched_rank_0(handle,n,x,incx,stridex,batch_count,results)
      use iso_c_binding
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocblas_dznrm2_strided_batched_rank_0
      type(c_ptr),value :: handle
      integer(c_int),value :: n
      complex(c_double_complex),target :: x
      integer(c_int),value :: incx
      integer(c_int64_t),value :: stridex
      integer(c_int),value :: batch_count
      type(c_ptr),value :: results
      !
      rocblas_dznrm2_strided_batched_rank_0 = rocblas_dznrm2_strided_batched_orig(handle,n,c_loc(x),incx,stridex,batch_count,results)
    end function

    function rocblas_dznrm2_strided_batched_rank_1(handle,n,x,incx,stridex,batch_count,results)
      use iso_c_binding
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocblas_dznrm2_strided_batched_rank_1
      type(c_ptr),value :: handle
      integer(c_int),value :: n
      complex(c_double_complex),target,dimension(:) :: x
      integer(c_int),value :: incx
      integer(c_int64_t),value :: stridex
      integer(c_int),value :: batch_count
      type(c_ptr),value :: results
      !
      rocblas_dznrm2_strided_batched_rank_1 = rocblas_dznrm2_strided_batched_orig(handle,n,c_loc(x),incx,stridex,batch_count,results)
    end function

    function rocblas_icamax_rank_0(handle,n,x,incx,myResult)
      use iso_c_binding
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocblas_icamax_rank_0
      type(c_ptr),value :: handle
      integer(c_int),value :: n
      complex(c_float_complex),target :: x
      integer(c_int),value :: incx
      type(c_ptr),value :: myResult
      !
      rocblas_icamax_rank_0 = rocblas_icamax_orig(handle,n,c_loc(x),incx,myResult)
    end function

    function rocblas_icamax_rank_1(handle,n,x,incx,myResult)
      use iso_c_binding
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocblas_icamax_rank_1
      type(c_ptr),value :: handle
      integer(c_int),value :: n
      complex(c_float_complex),target,dimension(:) :: x
      integer(c_int),value :: incx
      type(c_ptr),value :: myResult
      !
      rocblas_icamax_rank_1 = rocblas_icamax_orig(handle,n,c_loc(x),incx,myResult)
    end function

    function rocblas_izamax_rank_0(handle,n,x,incx,myResult)
      use iso_c_binding
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocblas_izamax_rank_0
      type(c_ptr),value :: handle
      integer(c_int),value :: n
      complex(c_double_complex),target :: x
      integer(c_int),value :: incx
      type(c_ptr),value :: myResult
      !
      rocblas_izamax_rank_0 = rocblas_izamax_orig(handle,n,c_loc(x),incx,myResult)
    end function

    function rocblas_izamax_rank_1(handle,n,x,incx,myResult)
      use iso_c_binding
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocblas_izamax_rank_1
      type(c_ptr),value :: handle
      integer(c_int),value :: n
      complex(c_double_complex),target,dimension(:) :: x
      integer(c_int),value :: incx
      type(c_ptr),value :: myResult
      !
      rocblas_izamax_rank_1 = rocblas_izamax_orig(handle,n,c_loc(x),incx,myResult)
    end function

    function rocblas_isamax_batched_full_rank(handle,n,x,incx,batch_count,myResult)
      use iso_c_binding
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocblas_isamax_batched_full_rank
      type(c_ptr),value :: handle
      integer(c_int),value :: n
      real(c_float),target,dimension(:,:) :: x
      integer(c_int),value :: incx
      integer(c_int),value :: batch_count
      type(c_ptr),value :: myResult
      !
      rocblas_isamax_batched_full_rank = rocblas_isamax_batched_orig(handle,n,c_loc(x),incx,batch_count,myResult)
    end function

    function rocblas_isamax_batched_rank_0(handle,n,x,incx,batch_count,myResult)
      use iso_c_binding
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocblas_isamax_batched_rank_0
      type(c_ptr),value :: handle
      integer(c_int),value :: n
      real(c_float),target :: x
      integer(c_int),value :: incx
      integer(c_int),value :: batch_count
      type(c_ptr),value :: myResult
      !
      rocblas_isamax_batched_rank_0 = rocblas_isamax_batched_orig(handle,n,c_loc(x),incx,batch_count,myResult)
    end function

    function rocblas_isamax_batched_rank_1(handle,n,x,incx,batch_count,myResult)
      use iso_c_binding
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocblas_isamax_batched_rank_1
      type(c_ptr),value :: handle
      integer(c_int),value :: n
      real(c_float),target,dimension(:) :: x
      integer(c_int),value :: incx
      integer(c_int),value :: batch_count
      type(c_ptr),value :: myResult
      !
      rocblas_isamax_batched_rank_1 = rocblas_isamax_batched_orig(handle,n,c_loc(x),incx,batch_count,myResult)
    end function

    function rocblas_idamax_batched_full_rank(handle,n,x,incx,batch_count,myResult)
      use iso_c_binding
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocblas_idamax_batched_full_rank
      type(c_ptr),value :: handle
      integer(c_int),value :: n
      real(c_double),target,dimension(:,:) :: x
      integer(c_int),value :: incx
      integer(c_int),value :: batch_count
      type(c_ptr),value :: myResult
      !
      rocblas_idamax_batched_full_rank = rocblas_idamax_batched_orig(handle,n,c_loc(x),incx,batch_count,myResult)
    end function

    function rocblas_idamax_batched_rank_0(handle,n,x,incx,batch_count,myResult)
      use iso_c_binding
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocblas_idamax_batched_rank_0
      type(c_ptr),value :: handle
      integer(c_int),value :: n
      real(c_double),target :: x
      integer(c_int),value :: incx
      integer(c_int),value :: batch_count
      type(c_ptr),value :: myResult
      !
      rocblas_idamax_batched_rank_0 = rocblas_idamax_batched_orig(handle,n,c_loc(x),incx,batch_count,myResult)
    end function

    function rocblas_idamax_batched_rank_1(handle,n,x,incx,batch_count,myResult)
      use iso_c_binding
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocblas_idamax_batched_rank_1
      type(c_ptr),value :: handle
      integer(c_int),value :: n
      real(c_double),target,dimension(:) :: x
      integer(c_int),value :: incx
      integer(c_int),value :: batch_count
      type(c_ptr),value :: myResult
      !
      rocblas_idamax_batched_rank_1 = rocblas_idamax_batched_orig(handle,n,c_loc(x),incx,batch_count,myResult)
    end function

    function rocblas_icamax_batched_full_rank(handle,n,x,incx,batch_count,myResult)
      use iso_c_binding
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocblas_icamax_batched_full_rank
      type(c_ptr),value :: handle
      integer(c_int),value :: n
      complex(c_float_complex),target,dimension(:,:) :: x
      integer(c_int),value :: incx
      integer(c_int),value :: batch_count
      type(c_ptr),value :: myResult
      !
      rocblas_icamax_batched_full_rank = rocblas_icamax_batched_orig(handle,n,c_loc(x),incx,batch_count,myResult)
    end function

    function rocblas_icamax_batched_rank_0(handle,n,x,incx,batch_count,myResult)
      use iso_c_binding
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocblas_icamax_batched_rank_0
      type(c_ptr),value :: handle
      integer(c_int),value :: n
      complex(c_float_complex),target :: x
      integer(c_int),value :: incx
      integer(c_int),value :: batch_count
      type(c_ptr),value :: myResult
      !
      rocblas_icamax_batched_rank_0 = rocblas_icamax_batched_orig(handle,n,c_loc(x),incx,batch_count,myResult)
    end function

    function rocblas_icamax_batched_rank_1(handle,n,x,incx,batch_count,myResult)
      use iso_c_binding
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocblas_icamax_batched_rank_1
      type(c_ptr),value :: handle
      integer(c_int),value :: n
      complex(c_float_complex),target,dimension(:) :: x
      integer(c_int),value :: incx
      integer(c_int),value :: batch_count
      type(c_ptr),value :: myResult
      !
      rocblas_icamax_batched_rank_1 = rocblas_icamax_batched_orig(handle,n,c_loc(x),incx,batch_count,myResult)
    end function

    function rocblas_izamax_batched_full_rank(handle,n,x,incx,batch_count,myResult)
      use iso_c_binding
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocblas_izamax_batched_full_rank
      type(c_ptr),value :: handle
      integer(c_int),value :: n
      complex(c_double_complex),target,dimension(:,:) :: x
      integer(c_int),value :: incx
      integer(c_int),value :: batch_count
      type(c_ptr),value :: myResult
      !
      rocblas_izamax_batched_full_rank = rocblas_izamax_batched_orig(handle,n,c_loc(x),incx,batch_count,myResult)
    end function

    function rocblas_izamax_batched_rank_0(handle,n,x,incx,batch_count,myResult)
      use iso_c_binding
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocblas_izamax_batched_rank_0
      type(c_ptr),value :: handle
      integer(c_int),value :: n
      complex(c_double_complex),target :: x
      integer(c_int),value :: incx
      integer(c_int),value :: batch_count
      type(c_ptr),value :: myResult
      !
      rocblas_izamax_batched_rank_0 = rocblas_izamax_batched_orig(handle,n,c_loc(x),incx,batch_count,myResult)
    end function

    function rocblas_izamax_batched_rank_1(handle,n,x,incx,batch_count,myResult)
      use iso_c_binding
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocblas_izamax_batched_rank_1
      type(c_ptr),value :: handle
      integer(c_int),value :: n
      complex(c_double_complex),target,dimension(:) :: x
      integer(c_int),value :: incx
      integer(c_int),value :: batch_count
      type(c_ptr),value :: myResult
      !
      rocblas_izamax_batched_rank_1 = rocblas_izamax_batched_orig(handle,n,c_loc(x),incx,batch_count,myResult)
    end function

    function rocblas_isamax_strided_batched_rank_0(handle,n,x,incx,stridex,batch_count,myResult)
      use iso_c_binding
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocblas_isamax_strided_batched_rank_0
      type(c_ptr),value :: handle
      integer(c_int),value :: n
      real(c_float),target :: x
      integer(c_int),value :: incx
      integer(c_int64_t),value :: stridex
      integer(c_int),value :: batch_count
      type(c_ptr),value :: myResult
      !
      rocblas_isamax_strided_batched_rank_0 = rocblas_isamax_strided_batched_orig(handle,n,c_loc(x),incx,stridex,batch_count,myResult)
    end function

    function rocblas_isamax_strided_batched_rank_1(handle,n,x,incx,stridex,batch_count,myResult)
      use iso_c_binding
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocblas_isamax_strided_batched_rank_1
      type(c_ptr),value :: handle
      integer(c_int),value :: n
      real(c_float),target,dimension(:) :: x
      integer(c_int),value :: incx
      integer(c_int64_t),value :: stridex
      integer(c_int),value :: batch_count
      type(c_ptr),value :: myResult
      !
      rocblas_isamax_strided_batched_rank_1 = rocblas_isamax_strided_batched_orig(handle,n,c_loc(x),incx,stridex,batch_count,myResult)
    end function

    function rocblas_idamax_strided_batched_rank_0(handle,n,x,incx,stridex,batch_count,myResult)
      use iso_c_binding
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocblas_idamax_strided_batched_rank_0
      type(c_ptr),value :: handle
      integer(c_int),value :: n
      real(c_double),target :: x
      integer(c_int),value :: incx
      integer(c_int64_t),value :: stridex
      integer(c_int),value :: batch_count
      type(c_ptr),value :: myResult
      !
      rocblas_idamax_strided_batched_rank_0 = rocblas_idamax_strided_batched_orig(handle,n,c_loc(x),incx,stridex,batch_count,myResult)
    end function

    function rocblas_idamax_strided_batched_rank_1(handle,n,x,incx,stridex,batch_count,myResult)
      use iso_c_binding
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocblas_idamax_strided_batched_rank_1
      type(c_ptr),value :: handle
      integer(c_int),value :: n
      real(c_double),target,dimension(:) :: x
      integer(c_int),value :: incx
      integer(c_int64_t),value :: stridex
      integer(c_int),value :: batch_count
      type(c_ptr),value :: myResult
      !
      rocblas_idamax_strided_batched_rank_1 = rocblas_idamax_strided_batched_orig(handle,n,c_loc(x),incx,stridex,batch_count,myResult)
    end function

    function rocblas_icamax_strided_batched_rank_0(handle,n,x,incx,stridex,batch_count,myResult)
      use iso_c_binding
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocblas_icamax_strided_batched_rank_0
      type(c_ptr),value :: handle
      integer(c_int),value :: n
      complex(c_float_complex),target :: x
      integer(c_int),value :: incx
      integer(c_int64_t),value :: stridex
      integer(c_int),value :: batch_count
      type(c_ptr),value :: myResult
      !
      rocblas_icamax_strided_batched_rank_0 = rocblas_icamax_strided_batched_orig(handle,n,c_loc(x),incx,stridex,batch_count,myResult)
    end function

    function rocblas_icamax_strided_batched_rank_1(handle,n,x,incx,stridex,batch_count,myResult)
      use iso_c_binding
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocblas_icamax_strided_batched_rank_1
      type(c_ptr),value :: handle
      integer(c_int),value :: n
      complex(c_float_complex),target,dimension(:) :: x
      integer(c_int),value :: incx
      integer(c_int64_t),value :: stridex
      integer(c_int),value :: batch_count
      type(c_ptr),value :: myResult
      !
      rocblas_icamax_strided_batched_rank_1 = rocblas_icamax_strided_batched_orig(handle,n,c_loc(x),incx,stridex,batch_count,myResult)
    end function

    function rocblas_izamax_strided_batched_rank_0(handle,n,x,incx,stridex,batch_count,myResult)
      use iso_c_binding
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocblas_izamax_strided_batched_rank_0
      type(c_ptr),value :: handle
      integer(c_int),value :: n
      complex(c_double_complex),target :: x
      integer(c_int),value :: incx
      integer(c_int64_t),value :: stridex
      integer(c_int),value :: batch_count
      type(c_ptr),value :: myResult
      !
      rocblas_izamax_strided_batched_rank_0 = rocblas_izamax_strided_batched_orig(handle,n,c_loc(x),incx,stridex,batch_count,myResult)
    end function

    function rocblas_izamax_strided_batched_rank_1(handle,n,x,incx,stridex,batch_count,myResult)
      use iso_c_binding
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocblas_izamax_strided_batched_rank_1
      type(c_ptr),value :: handle
      integer(c_int),value :: n
      complex(c_double_complex),target,dimension(:) :: x
      integer(c_int),value :: incx
      integer(c_int64_t),value :: stridex
      integer(c_int),value :: batch_count
      type(c_ptr),value :: myResult
      !
      rocblas_izamax_strided_batched_rank_1 = rocblas_izamax_strided_batched_orig(handle,n,c_loc(x),incx,stridex,batch_count,myResult)
    end function

    function rocblas_icamin_rank_0(handle,n,x,incx,myResult)
      use iso_c_binding
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocblas_icamin_rank_0
      type(c_ptr),value :: handle
      integer(c_int),value :: n
      complex(c_float_complex),target :: x
      integer(c_int),value :: incx
      type(c_ptr),value :: myResult
      !
      rocblas_icamin_rank_0 = rocblas_icamin_orig(handle,n,c_loc(x),incx,myResult)
    end function

    function rocblas_icamin_rank_1(handle,n,x,incx,myResult)
      use iso_c_binding
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocblas_icamin_rank_1
      type(c_ptr),value :: handle
      integer(c_int),value :: n
      complex(c_float_complex),target,dimension(:) :: x
      integer(c_int),value :: incx
      type(c_ptr),value :: myResult
      !
      rocblas_icamin_rank_1 = rocblas_icamin_orig(handle,n,c_loc(x),incx,myResult)
    end function

    function rocblas_izamin_rank_0(handle,n,x,incx,myResult)
      use iso_c_binding
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocblas_izamin_rank_0
      type(c_ptr),value :: handle
      integer(c_int),value :: n
      complex(c_double_complex),target :: x
      integer(c_int),value :: incx
      type(c_ptr),value :: myResult
      !
      rocblas_izamin_rank_0 = rocblas_izamin_orig(handle,n,c_loc(x),incx,myResult)
    end function

    function rocblas_izamin_rank_1(handle,n,x,incx,myResult)
      use iso_c_binding
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocblas_izamin_rank_1
      type(c_ptr),value :: handle
      integer(c_int),value :: n
      complex(c_double_complex),target,dimension(:) :: x
      integer(c_int),value :: incx
      type(c_ptr),value :: myResult
      !
      rocblas_izamin_rank_1 = rocblas_izamin_orig(handle,n,c_loc(x),incx,myResult)
    end function

    function rocblas_isamin_batched_full_rank(handle,n,x,incx,batch_count,myResult)
      use iso_c_binding
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocblas_isamin_batched_full_rank
      type(c_ptr),value :: handle
      integer(c_int),value :: n
      real(c_float),target,dimension(:,:) :: x
      integer(c_int),value :: incx
      integer(c_int),value :: batch_count
      type(c_ptr),value :: myResult
      !
      rocblas_isamin_batched_full_rank = rocblas_isamin_batched_orig(handle,n,c_loc(x),incx,batch_count,myResult)
    end function

    function rocblas_isamin_batched_rank_0(handle,n,x,incx,batch_count,myResult)
      use iso_c_binding
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocblas_isamin_batched_rank_0
      type(c_ptr),value :: handle
      integer(c_int),value :: n
      real(c_float),target :: x
      integer(c_int),value :: incx
      integer(c_int),value :: batch_count
      type(c_ptr),value :: myResult
      !
      rocblas_isamin_batched_rank_0 = rocblas_isamin_batched_orig(handle,n,c_loc(x),incx,batch_count,myResult)
    end function

    function rocblas_isamin_batched_rank_1(handle,n,x,incx,batch_count,myResult)
      use iso_c_binding
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocblas_isamin_batched_rank_1
      type(c_ptr),value :: handle
      integer(c_int),value :: n
      real(c_float),target,dimension(:) :: x
      integer(c_int),value :: incx
      integer(c_int),value :: batch_count
      type(c_ptr),value :: myResult
      !
      rocblas_isamin_batched_rank_1 = rocblas_isamin_batched_orig(handle,n,c_loc(x),incx,batch_count,myResult)
    end function

    function rocblas_idamin_batched_full_rank(handle,n,x,incx,batch_count,myResult)
      use iso_c_binding
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocblas_idamin_batched_full_rank
      type(c_ptr),value :: handle
      integer(c_int),value :: n
      real(c_double),target,dimension(:,:) :: x
      integer(c_int),value :: incx
      integer(c_int),value :: batch_count
      type(c_ptr),value :: myResult
      !
      rocblas_idamin_batched_full_rank = rocblas_idamin_batched_orig(handle,n,c_loc(x),incx,batch_count,myResult)
    end function

    function rocblas_idamin_batched_rank_0(handle,n,x,incx,batch_count,myResult)
      use iso_c_binding
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocblas_idamin_batched_rank_0
      type(c_ptr),value :: handle
      integer(c_int),value :: n
      real(c_double),target :: x
      integer(c_int),value :: incx
      integer(c_int),value :: batch_count
      type(c_ptr),value :: myResult
      !
      rocblas_idamin_batched_rank_0 = rocblas_idamin_batched_orig(handle,n,c_loc(x),incx,batch_count,myResult)
    end function

    function rocblas_idamin_batched_rank_1(handle,n,x,incx,batch_count,myResult)
      use iso_c_binding
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocblas_idamin_batched_rank_1
      type(c_ptr),value :: handle
      integer(c_int),value :: n
      real(c_double),target,dimension(:) :: x
      integer(c_int),value :: incx
      integer(c_int),value :: batch_count
      type(c_ptr),value :: myResult
      !
      rocblas_idamin_batched_rank_1 = rocblas_idamin_batched_orig(handle,n,c_loc(x),incx,batch_count,myResult)
    end function

    function rocblas_icamin_batched_full_rank(handle,n,x,incx,batch_count,myResult)
      use iso_c_binding
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocblas_icamin_batched_full_rank
      type(c_ptr),value :: handle
      integer(c_int),value :: n
      complex(c_float_complex),target,dimension(:,:) :: x
      integer(c_int),value :: incx
      integer(c_int),value :: batch_count
      type(c_ptr),value :: myResult
      !
      rocblas_icamin_batched_full_rank = rocblas_icamin_batched_orig(handle,n,c_loc(x),incx,batch_count,myResult)
    end function

    function rocblas_icamin_batched_rank_0(handle,n,x,incx,batch_count,myResult)
      use iso_c_binding
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocblas_icamin_batched_rank_0
      type(c_ptr),value :: handle
      integer(c_int),value :: n
      complex(c_float_complex),target :: x
      integer(c_int),value :: incx
      integer(c_int),value :: batch_count
      type(c_ptr),value :: myResult
      !
      rocblas_icamin_batched_rank_0 = rocblas_icamin_batched_orig(handle,n,c_loc(x),incx,batch_count,myResult)
    end function

    function rocblas_icamin_batched_rank_1(handle,n,x,incx,batch_count,myResult)
      use iso_c_binding
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocblas_icamin_batched_rank_1
      type(c_ptr),value :: handle
      integer(c_int),value :: n
      complex(c_float_complex),target,dimension(:) :: x
      integer(c_int),value :: incx
      integer(c_int),value :: batch_count
      type(c_ptr),value :: myResult
      !
      rocblas_icamin_batched_rank_1 = rocblas_icamin_batched_orig(handle,n,c_loc(x),incx,batch_count,myResult)
    end function

    function rocblas_izamin_batched_full_rank(handle,n,x,incx,batch_count,myResult)
      use iso_c_binding
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocblas_izamin_batched_full_rank
      type(c_ptr),value :: handle
      integer(c_int),value :: n
      complex(c_double_complex),target,dimension(:,:) :: x
      integer(c_int),value :: incx
      integer(c_int),value :: batch_count
      type(c_ptr),value :: myResult
      !
      rocblas_izamin_batched_full_rank = rocblas_izamin_batched_orig(handle,n,c_loc(x),incx,batch_count,myResult)
    end function

    function rocblas_izamin_batched_rank_0(handle,n,x,incx,batch_count,myResult)
      use iso_c_binding
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocblas_izamin_batched_rank_0
      type(c_ptr),value :: handle
      integer(c_int),value :: n
      complex(c_double_complex),target :: x
      integer(c_int),value :: incx
      integer(c_int),value :: batch_count
      type(c_ptr),value :: myResult
      !
      rocblas_izamin_batched_rank_0 = rocblas_izamin_batched_orig(handle,n,c_loc(x),incx,batch_count,myResult)
    end function

    function rocblas_izamin_batched_rank_1(handle,n,x,incx,batch_count,myResult)
      use iso_c_binding
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocblas_izamin_batched_rank_1
      type(c_ptr),value :: handle
      integer(c_int),value :: n
      complex(c_double_complex),target,dimension(:) :: x
      integer(c_int),value :: incx
      integer(c_int),value :: batch_count
      type(c_ptr),value :: myResult
      !
      rocblas_izamin_batched_rank_1 = rocblas_izamin_batched_orig(handle,n,c_loc(x),incx,batch_count,myResult)
    end function

    function rocblas_isamin_strided_batched_rank_0(handle,n,x,incx,stridex,batch_count,myResult)
      use iso_c_binding
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocblas_isamin_strided_batched_rank_0
      type(c_ptr),value :: handle
      integer(c_int),value :: n
      real(c_float),target :: x
      integer(c_int),value :: incx
      integer(c_int64_t),value :: stridex
      integer(c_int),value :: batch_count
      type(c_ptr),value :: myResult
      !
      rocblas_isamin_strided_batched_rank_0 = rocblas_isamin_strided_batched_orig(handle,n,c_loc(x),incx,stridex,batch_count,myResult)
    end function

    function rocblas_isamin_strided_batched_rank_1(handle,n,x,incx,stridex,batch_count,myResult)
      use iso_c_binding
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocblas_isamin_strided_batched_rank_1
      type(c_ptr),value :: handle
      integer(c_int),value :: n
      real(c_float),target,dimension(:) :: x
      integer(c_int),value :: incx
      integer(c_int64_t),value :: stridex
      integer(c_int),value :: batch_count
      type(c_ptr),value :: myResult
      !
      rocblas_isamin_strided_batched_rank_1 = rocblas_isamin_strided_batched_orig(handle,n,c_loc(x),incx,stridex,batch_count,myResult)
    end function

    function rocblas_idamin_strided_batched_rank_0(handle,n,x,incx,stridex,batch_count,myResult)
      use iso_c_binding
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocblas_idamin_strided_batched_rank_0
      type(c_ptr),value :: handle
      integer(c_int),value :: n
      real(c_double),target :: x
      integer(c_int),value :: incx
      integer(c_int64_t),value :: stridex
      integer(c_int),value :: batch_count
      type(c_ptr),value :: myResult
      !
      rocblas_idamin_strided_batched_rank_0 = rocblas_idamin_strided_batched_orig(handle,n,c_loc(x),incx,stridex,batch_count,myResult)
    end function

    function rocblas_idamin_strided_batched_rank_1(handle,n,x,incx,stridex,batch_count,myResult)
      use iso_c_binding
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocblas_idamin_strided_batched_rank_1
      type(c_ptr),value :: handle
      integer(c_int),value :: n
      real(c_double),target,dimension(:) :: x
      integer(c_int),value :: incx
      integer(c_int64_t),value :: stridex
      integer(c_int),value :: batch_count
      type(c_ptr),value :: myResult
      !
      rocblas_idamin_strided_batched_rank_1 = rocblas_idamin_strided_batched_orig(handle,n,c_loc(x),incx,stridex,batch_count,myResult)
    end function

    function rocblas_icamin_strided_batched_rank_0(handle,n,x,incx,stridex,batch_count,myResult)
      use iso_c_binding
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocblas_icamin_strided_batched_rank_0
      type(c_ptr),value :: handle
      integer(c_int),value :: n
      complex(c_float_complex),target :: x
      integer(c_int),value :: incx
      integer(c_int64_t),value :: stridex
      integer(c_int),value :: batch_count
      type(c_ptr),value :: myResult
      !
      rocblas_icamin_strided_batched_rank_0 = rocblas_icamin_strided_batched_orig(handle,n,c_loc(x),incx,stridex,batch_count,myResult)
    end function

    function rocblas_icamin_strided_batched_rank_1(handle,n,x,incx,stridex,batch_count,myResult)
      use iso_c_binding
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocblas_icamin_strided_batched_rank_1
      type(c_ptr),value :: handle
      integer(c_int),value :: n
      complex(c_float_complex),target,dimension(:) :: x
      integer(c_int),value :: incx
      integer(c_int64_t),value :: stridex
      integer(c_int),value :: batch_count
      type(c_ptr),value :: myResult
      !
      rocblas_icamin_strided_batched_rank_1 = rocblas_icamin_strided_batched_orig(handle,n,c_loc(x),incx,stridex,batch_count,myResult)
    end function

    function rocblas_izamin_strided_batched_rank_0(handle,n,x,incx,stridex,batch_count,myResult)
      use iso_c_binding
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocblas_izamin_strided_batched_rank_0
      type(c_ptr),value :: handle
      integer(c_int),value :: n
      complex(c_double_complex),target :: x
      integer(c_int),value :: incx
      integer(c_int64_t),value :: stridex
      integer(c_int),value :: batch_count
      type(c_ptr),value :: myResult
      !
      rocblas_izamin_strided_batched_rank_0 = rocblas_izamin_strided_batched_orig(handle,n,c_loc(x),incx,stridex,batch_count,myResult)
    end function

    function rocblas_izamin_strided_batched_rank_1(handle,n,x,incx,stridex,batch_count,myResult)
      use iso_c_binding
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocblas_izamin_strided_batched_rank_1
      type(c_ptr),value :: handle
      integer(c_int),value :: n
      complex(c_double_complex),target,dimension(:) :: x
      integer(c_int),value :: incx
      integer(c_int64_t),value :: stridex
      integer(c_int),value :: batch_count
      type(c_ptr),value :: myResult
      !
      rocblas_izamin_strided_batched_rank_1 = rocblas_izamin_strided_batched_orig(handle,n,c_loc(x),incx,stridex,batch_count,myResult)
    end function

    function rocblas_srot_rank_0(handle,n,x,incx,y,incy,c,s)
      use iso_c_binding
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocblas_srot_rank_0
      type(c_ptr),value :: handle
      integer(c_int),value :: n
      real(c_float),target :: x
      integer(c_int),value :: incx
      real(c_float),target :: y
      integer(c_int),value :: incy
      type(c_ptr),value :: c
      type(c_ptr),value :: s
      !
      rocblas_srot_rank_0 = rocblas_srot_orig(handle,n,c_loc(x),incx,c_loc(y),incy,c,s)
    end function

    function rocblas_srot_rank_1(handle,n,x,incx,y,incy,c,s)
      use iso_c_binding
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocblas_srot_rank_1
      type(c_ptr),value :: handle
      integer(c_int),value :: n
      real(c_float),target,dimension(:) :: x
      integer(c_int),value :: incx
      real(c_float),target,dimension(:) :: y
      integer(c_int),value :: incy
      type(c_ptr),value :: c
      type(c_ptr),value :: s
      !
      rocblas_srot_rank_1 = rocblas_srot_orig(handle,n,c_loc(x),incx,c_loc(y),incy,c,s)
    end function

    function rocblas_drot_rank_0(handle,n,x,incx,y,incy,c,s)
      use iso_c_binding
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocblas_drot_rank_0
      type(c_ptr),value :: handle
      integer(c_int),value :: n
      real(c_double),target :: x
      integer(c_int),value :: incx
      real(c_double),target :: y
      integer(c_int),value :: incy
      type(c_ptr),value :: c
      type(c_ptr),value :: s
      !
      rocblas_drot_rank_0 = rocblas_drot_orig(handle,n,c_loc(x),incx,c_loc(y),incy,c,s)
    end function

    function rocblas_drot_rank_1(handle,n,x,incx,y,incy,c,s)
      use iso_c_binding
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocblas_drot_rank_1
      type(c_ptr),value :: handle
      integer(c_int),value :: n
      real(c_double),target,dimension(:) :: x
      integer(c_int),value :: incx
      real(c_double),target,dimension(:) :: y
      integer(c_int),value :: incy
      type(c_ptr),value :: c
      type(c_ptr),value :: s
      !
      rocblas_drot_rank_1 = rocblas_drot_orig(handle,n,c_loc(x),incx,c_loc(y),incy,c,s)
    end function

    function rocblas_crot_rank_0(handle,n,x,incx,y,incy,c,s)
      use iso_c_binding
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocblas_crot_rank_0
      type(c_ptr),value :: handle
      integer(c_int),value :: n
      complex(c_float_complex),target :: x
      integer(c_int),value :: incx
      complex(c_float_complex),target :: y
      integer(c_int),value :: incy
      type(c_ptr),value :: c
      type(c_ptr),value :: s
      !
      rocblas_crot_rank_0 = rocblas_crot_orig(handle,n,c_loc(x),incx,c_loc(y),incy,c,s)
    end function

    function rocblas_crot_rank_1(handle,n,x,incx,y,incy,c,s)
      use iso_c_binding
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocblas_crot_rank_1
      type(c_ptr),value :: handle
      integer(c_int),value :: n
      complex(c_float_complex),target,dimension(:) :: x
      integer(c_int),value :: incx
      complex(c_float_complex),target,dimension(:) :: y
      integer(c_int),value :: incy
      type(c_ptr),value :: c
      type(c_ptr),value :: s
      !
      rocblas_crot_rank_1 = rocblas_crot_orig(handle,n,c_loc(x),incx,c_loc(y),incy,c,s)
    end function

    function rocblas_csrot_rank_0(handle,n,x,incx,y,incy,c,s)
      use iso_c_binding
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocblas_csrot_rank_0
      type(c_ptr),value :: handle
      integer(c_int),value :: n
      complex(c_float_complex),target :: x
      integer(c_int),value :: incx
      complex(c_float_complex),target :: y
      integer(c_int),value :: incy
      type(c_ptr),value :: c
      type(c_ptr),value :: s
      !
      rocblas_csrot_rank_0 = rocblas_csrot_orig(handle,n,c_loc(x),incx,c_loc(y),incy,c,s)
    end function

    function rocblas_csrot_rank_1(handle,n,x,incx,y,incy,c,s)
      use iso_c_binding
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocblas_csrot_rank_1
      type(c_ptr),value :: handle
      integer(c_int),value :: n
      complex(c_float_complex),target,dimension(:) :: x
      integer(c_int),value :: incx
      complex(c_float_complex),target,dimension(:) :: y
      integer(c_int),value :: incy
      type(c_ptr),value :: c
      type(c_ptr),value :: s
      !
      rocblas_csrot_rank_1 = rocblas_csrot_orig(handle,n,c_loc(x),incx,c_loc(y),incy,c,s)
    end function

    function rocblas_zrot_rank_0(handle,n,x,incx,y,incy,c,s)
      use iso_c_binding
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocblas_zrot_rank_0
      type(c_ptr),value :: handle
      integer(c_int),value :: n
      complex(c_double_complex),target :: x
      integer(c_int),value :: incx
      complex(c_double_complex),target :: y
      integer(c_int),value :: incy
      type(c_ptr),value :: c
      type(c_ptr),value :: s
      !
      rocblas_zrot_rank_0 = rocblas_zrot_orig(handle,n,c_loc(x),incx,c_loc(y),incy,c,s)
    end function

    function rocblas_zrot_rank_1(handle,n,x,incx,y,incy,c,s)
      use iso_c_binding
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocblas_zrot_rank_1
      type(c_ptr),value :: handle
      integer(c_int),value :: n
      complex(c_double_complex),target,dimension(:) :: x
      integer(c_int),value :: incx
      complex(c_double_complex),target,dimension(:) :: y
      integer(c_int),value :: incy
      type(c_ptr),value :: c
      type(c_ptr),value :: s
      !
      rocblas_zrot_rank_1 = rocblas_zrot_orig(handle,n,c_loc(x),incx,c_loc(y),incy,c,s)
    end function

    function rocblas_zdrot_rank_0(handle,n,x,incx,y,incy,c,s)
      use iso_c_binding
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocblas_zdrot_rank_0
      type(c_ptr),value :: handle
      integer(c_int),value :: n
      complex(c_double_complex),target :: x
      integer(c_int),value :: incx
      complex(c_double_complex),target :: y
      integer(c_int),value :: incy
      type(c_ptr),value :: c
      type(c_ptr),value :: s
      !
      rocblas_zdrot_rank_0 = rocblas_zdrot_orig(handle,n,c_loc(x),incx,c_loc(y),incy,c,s)
    end function

    function rocblas_zdrot_rank_1(handle,n,x,incx,y,incy,c,s)
      use iso_c_binding
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocblas_zdrot_rank_1
      type(c_ptr),value :: handle
      integer(c_int),value :: n
      complex(c_double_complex),target,dimension(:) :: x
      integer(c_int),value :: incx
      complex(c_double_complex),target,dimension(:) :: y
      integer(c_int),value :: incy
      type(c_ptr),value :: c
      type(c_ptr),value :: s
      !
      rocblas_zdrot_rank_1 = rocblas_zdrot_orig(handle,n,c_loc(x),incx,c_loc(y),incy,c,s)
    end function

    function rocblas_srot_batched_full_rank(handle,n,x,incx,y,incy,c,s,batch_count)
      use iso_c_binding
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocblas_srot_batched_full_rank
      type(c_ptr),value :: handle
      integer(c_int),value :: n
      real(c_float),target,dimension(:,:) :: x
      integer(c_int),value :: incx
      real(c_float),target,dimension(:,:) :: y
      integer(c_int),value :: incy
      type(c_ptr),value :: c
      type(c_ptr),value :: s
      integer(c_int),value :: batch_count
      !
      rocblas_srot_batched_full_rank = rocblas_srot_batched_orig(handle,n,c_loc(x),incx,c_loc(y),incy,c,s,batch_count)
    end function

    function rocblas_srot_batched_rank_0(handle,n,x,incx,y,incy,c,s,batch_count)
      use iso_c_binding
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocblas_srot_batched_rank_0
      type(c_ptr),value :: handle
      integer(c_int),value :: n
      real(c_float),target :: x
      integer(c_int),value :: incx
      real(c_float),target :: y
      integer(c_int),value :: incy
      type(c_ptr),value :: c
      type(c_ptr),value :: s
      integer(c_int),value :: batch_count
      !
      rocblas_srot_batched_rank_0 = rocblas_srot_batched_orig(handle,n,c_loc(x),incx,c_loc(y),incy,c,s,batch_count)
    end function

    function rocblas_srot_batched_rank_1(handle,n,x,incx,y,incy,c,s,batch_count)
      use iso_c_binding
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocblas_srot_batched_rank_1
      type(c_ptr),value :: handle
      integer(c_int),value :: n
      real(c_float),target,dimension(:) :: x
      integer(c_int),value :: incx
      real(c_float),target,dimension(:) :: y
      integer(c_int),value :: incy
      type(c_ptr),value :: c
      type(c_ptr),value :: s
      integer(c_int),value :: batch_count
      !
      rocblas_srot_batched_rank_1 = rocblas_srot_batched_orig(handle,n,c_loc(x),incx,c_loc(y),incy,c,s,batch_count)
    end function

    function rocblas_drot_batched_full_rank(handle,n,x,incx,y,incy,c,s,batch_count)
      use iso_c_binding
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocblas_drot_batched_full_rank
      type(c_ptr),value :: handle
      integer(c_int),value :: n
      real(c_double),target,dimension(:,:) :: x
      integer(c_int),value :: incx
      real(c_double),target,dimension(:,:) :: y
      integer(c_int),value :: incy
      type(c_ptr),value :: c
      type(c_ptr),value :: s
      integer(c_int),value :: batch_count
      !
      rocblas_drot_batched_full_rank = rocblas_drot_batched_orig(handle,n,c_loc(x),incx,c_loc(y),incy,c,s,batch_count)
    end function

    function rocblas_drot_batched_rank_0(handle,n,x,incx,y,incy,c,s,batch_count)
      use iso_c_binding
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocblas_drot_batched_rank_0
      type(c_ptr),value :: handle
      integer(c_int),value :: n
      real(c_double),target :: x
      integer(c_int),value :: incx
      real(c_double),target :: y
      integer(c_int),value :: incy
      type(c_ptr),value :: c
      type(c_ptr),value :: s
      integer(c_int),value :: batch_count
      !
      rocblas_drot_batched_rank_0 = rocblas_drot_batched_orig(handle,n,c_loc(x),incx,c_loc(y),incy,c,s,batch_count)
    end function

    function rocblas_drot_batched_rank_1(handle,n,x,incx,y,incy,c,s,batch_count)
      use iso_c_binding
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocblas_drot_batched_rank_1
      type(c_ptr),value :: handle
      integer(c_int),value :: n
      real(c_double),target,dimension(:) :: x
      integer(c_int),value :: incx
      real(c_double),target,dimension(:) :: y
      integer(c_int),value :: incy
      type(c_ptr),value :: c
      type(c_ptr),value :: s
      integer(c_int),value :: batch_count
      !
      rocblas_drot_batched_rank_1 = rocblas_drot_batched_orig(handle,n,c_loc(x),incx,c_loc(y),incy,c,s,batch_count)
    end function

    function rocblas_crot_batched_full_rank(handle,n,x,incx,y,incy,c,s,batch_count)
      use iso_c_binding
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocblas_crot_batched_full_rank
      type(c_ptr),value :: handle
      integer(c_int),value :: n
      complex(c_float_complex),target,dimension(:,:) :: x
      integer(c_int),value :: incx
      complex(c_float_complex),target,dimension(:,:) :: y
      integer(c_int),value :: incy
      type(c_ptr),value :: c
      type(c_ptr),value :: s
      integer(c_int),value :: batch_count
      !
      rocblas_crot_batched_full_rank = rocblas_crot_batched_orig(handle,n,c_loc(x),incx,c_loc(y),incy,c,s,batch_count)
    end function

    function rocblas_crot_batched_rank_0(handle,n,x,incx,y,incy,c,s,batch_count)
      use iso_c_binding
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocblas_crot_batched_rank_0
      type(c_ptr),value :: handle
      integer(c_int),value :: n
      complex(c_float_complex),target :: x
      integer(c_int),value :: incx
      complex(c_float_complex),target :: y
      integer(c_int),value :: incy
      type(c_ptr),value :: c
      type(c_ptr),value :: s
      integer(c_int),value :: batch_count
      !
      rocblas_crot_batched_rank_0 = rocblas_crot_batched_orig(handle,n,c_loc(x),incx,c_loc(y),incy,c,s,batch_count)
    end function

    function rocblas_crot_batched_rank_1(handle,n,x,incx,y,incy,c,s,batch_count)
      use iso_c_binding
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocblas_crot_batched_rank_1
      type(c_ptr),value :: handle
      integer(c_int),value :: n
      complex(c_float_complex),target,dimension(:) :: x
      integer(c_int),value :: incx
      complex(c_float_complex),target,dimension(:) :: y
      integer(c_int),value :: incy
      type(c_ptr),value :: c
      type(c_ptr),value :: s
      integer(c_int),value :: batch_count
      !
      rocblas_crot_batched_rank_1 = rocblas_crot_batched_orig(handle,n,c_loc(x),incx,c_loc(y),incy,c,s,batch_count)
    end function

    function rocblas_csrot_batched_full_rank(handle,n,x,incx,y,incy,c,s,batch_count)
      use iso_c_binding
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocblas_csrot_batched_full_rank
      type(c_ptr),value :: handle
      integer(c_int),value :: n
      complex(c_float_complex),target,dimension(:,:) :: x
      integer(c_int),value :: incx
      complex(c_float_complex),target,dimension(:,:) :: y
      integer(c_int),value :: incy
      type(c_ptr),value :: c
      type(c_ptr),value :: s
      integer(c_int),value :: batch_count
      !
      rocblas_csrot_batched_full_rank = rocblas_csrot_batched_orig(handle,n,c_loc(x),incx,c_loc(y),incy,c,s,batch_count)
    end function

    function rocblas_csrot_batched_rank_0(handle,n,x,incx,y,incy,c,s,batch_count)
      use iso_c_binding
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocblas_csrot_batched_rank_0
      type(c_ptr),value :: handle
      integer(c_int),value :: n
      complex(c_float_complex),target :: x
      integer(c_int),value :: incx
      complex(c_float_complex),target :: y
      integer(c_int),value :: incy
      type(c_ptr),value :: c
      type(c_ptr),value :: s
      integer(c_int),value :: batch_count
      !
      rocblas_csrot_batched_rank_0 = rocblas_csrot_batched_orig(handle,n,c_loc(x),incx,c_loc(y),incy,c,s,batch_count)
    end function

    function rocblas_csrot_batched_rank_1(handle,n,x,incx,y,incy,c,s,batch_count)
      use iso_c_binding
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocblas_csrot_batched_rank_1
      type(c_ptr),value :: handle
      integer(c_int),value :: n
      complex(c_float_complex),target,dimension(:) :: x
      integer(c_int),value :: incx
      complex(c_float_complex),target,dimension(:) :: y
      integer(c_int),value :: incy
      type(c_ptr),value :: c
      type(c_ptr),value :: s
      integer(c_int),value :: batch_count
      !
      rocblas_csrot_batched_rank_1 = rocblas_csrot_batched_orig(handle,n,c_loc(x),incx,c_loc(y),incy,c,s,batch_count)
    end function

    function rocblas_zrot_batched_full_rank(handle,n,x,incx,y,incy,c,s,batch_count)
      use iso_c_binding
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocblas_zrot_batched_full_rank
      type(c_ptr),value :: handle
      integer(c_int),value :: n
      complex(c_double_complex),target,dimension(:,:) :: x
      integer(c_int),value :: incx
      complex(c_double_complex),target,dimension(:,:) :: y
      integer(c_int),value :: incy
      type(c_ptr),value :: c
      type(c_ptr),value :: s
      integer(c_int),value :: batch_count
      !
      rocblas_zrot_batched_full_rank = rocblas_zrot_batched_orig(handle,n,c_loc(x),incx,c_loc(y),incy,c,s,batch_count)
    end function

    function rocblas_zrot_batched_rank_0(handle,n,x,incx,y,incy,c,s,batch_count)
      use iso_c_binding
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocblas_zrot_batched_rank_0
      type(c_ptr),value :: handle
      integer(c_int),value :: n
      complex(c_double_complex),target :: x
      integer(c_int),value :: incx
      complex(c_double_complex),target :: y
      integer(c_int),value :: incy
      type(c_ptr),value :: c
      type(c_ptr),value :: s
      integer(c_int),value :: batch_count
      !
      rocblas_zrot_batched_rank_0 = rocblas_zrot_batched_orig(handle,n,c_loc(x),incx,c_loc(y),incy,c,s,batch_count)
    end function

    function rocblas_zrot_batched_rank_1(handle,n,x,incx,y,incy,c,s,batch_count)
      use iso_c_binding
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocblas_zrot_batched_rank_1
      type(c_ptr),value :: handle
      integer(c_int),value :: n
      complex(c_double_complex),target,dimension(:) :: x
      integer(c_int),value :: incx
      complex(c_double_complex),target,dimension(:) :: y
      integer(c_int),value :: incy
      type(c_ptr),value :: c
      type(c_ptr),value :: s
      integer(c_int),value :: batch_count
      !
      rocblas_zrot_batched_rank_1 = rocblas_zrot_batched_orig(handle,n,c_loc(x),incx,c_loc(y),incy,c,s,batch_count)
    end function

    function rocblas_zdrot_batched_full_rank(handle,n,x,incx,y,incy,c,s,batch_count)
      use iso_c_binding
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocblas_zdrot_batched_full_rank
      type(c_ptr),value :: handle
      integer(c_int),value :: n
      complex(c_double_complex),target,dimension(:,:) :: x
      integer(c_int),value :: incx
      complex(c_double_complex),target,dimension(:,:) :: y
      integer(c_int),value :: incy
      type(c_ptr),value :: c
      type(c_ptr),value :: s
      integer(c_int),value :: batch_count
      !
      rocblas_zdrot_batched_full_rank = rocblas_zdrot_batched_orig(handle,n,c_loc(x),incx,c_loc(y),incy,c,s,batch_count)
    end function

    function rocblas_zdrot_batched_rank_0(handle,n,x,incx,y,incy,c,s,batch_count)
      use iso_c_binding
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocblas_zdrot_batched_rank_0
      type(c_ptr),value :: handle
      integer(c_int),value :: n
      complex(c_double_complex),target :: x
      integer(c_int),value :: incx
      complex(c_double_complex),target :: y
      integer(c_int),value :: incy
      type(c_ptr),value :: c
      type(c_ptr),value :: s
      integer(c_int),value :: batch_count
      !
      rocblas_zdrot_batched_rank_0 = rocblas_zdrot_batched_orig(handle,n,c_loc(x),incx,c_loc(y),incy,c,s,batch_count)
    end function

    function rocblas_zdrot_batched_rank_1(handle,n,x,incx,y,incy,c,s,batch_count)
      use iso_c_binding
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocblas_zdrot_batched_rank_1
      type(c_ptr),value :: handle
      integer(c_int),value :: n
      complex(c_double_complex),target,dimension(:) :: x
      integer(c_int),value :: incx
      complex(c_double_complex),target,dimension(:) :: y
      integer(c_int),value :: incy
      type(c_ptr),value :: c
      type(c_ptr),value :: s
      integer(c_int),value :: batch_count
      !
      rocblas_zdrot_batched_rank_1 = rocblas_zdrot_batched_orig(handle,n,c_loc(x),incx,c_loc(y),incy,c,s,batch_count)
    end function

    function rocblas_srot_strided_batched_rank_0(handle,n,x,incx,stride_x,y,incy,stride_y,c,s,batch_count)
      use iso_c_binding
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocblas_srot_strided_batched_rank_0
      type(c_ptr),value :: handle
      integer(c_int),value :: n
      real(c_float),target :: x
      integer(c_int),value :: incx
      integer(c_int64_t),value :: stride_x
      real(c_float),target :: y
      integer(c_int),value :: incy
      integer(c_int64_t),value :: stride_y
      type(c_ptr),value :: c
      type(c_ptr),value :: s
      integer(c_int),value :: batch_count
      !
      rocblas_srot_strided_batched_rank_0 = rocblas_srot_strided_batched_orig(handle,n,c_loc(x),incx,stride_x,c_loc(y),incy,stride_y,c,s,batch_count)
    end function

    function rocblas_srot_strided_batched_rank_1(handle,n,x,incx,stride_x,y,incy,stride_y,c,s,batch_count)
      use iso_c_binding
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocblas_srot_strided_batched_rank_1
      type(c_ptr),value :: handle
      integer(c_int),value :: n
      real(c_float),target,dimension(:) :: x
      integer(c_int),value :: incx
      integer(c_int64_t),value :: stride_x
      real(c_float),target,dimension(:) :: y
      integer(c_int),value :: incy
      integer(c_int64_t),value :: stride_y
      type(c_ptr),value :: c
      type(c_ptr),value :: s
      integer(c_int),value :: batch_count
      !
      rocblas_srot_strided_batched_rank_1 = rocblas_srot_strided_batched_orig(handle,n,c_loc(x),incx,stride_x,c_loc(y),incy,stride_y,c,s,batch_count)
    end function

    function rocblas_drot_strided_batched_rank_0(handle,n,x,incx,stride_x,y,incy,stride_y,c,s,batch_count)
      use iso_c_binding
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocblas_drot_strided_batched_rank_0
      type(c_ptr),value :: handle
      integer(c_int),value :: n
      real(c_double),target :: x
      integer(c_int),value :: incx
      integer(c_int64_t),value :: stride_x
      real(c_double),target :: y
      integer(c_int),value :: incy
      integer(c_int64_t),value :: stride_y
      type(c_ptr),value :: c
      type(c_ptr),value :: s
      integer(c_int),value :: batch_count
      !
      rocblas_drot_strided_batched_rank_0 = rocblas_drot_strided_batched_orig(handle,n,c_loc(x),incx,stride_x,c_loc(y),incy,stride_y,c,s,batch_count)
    end function

    function rocblas_drot_strided_batched_rank_1(handle,n,x,incx,stride_x,y,incy,stride_y,c,s,batch_count)
      use iso_c_binding
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocblas_drot_strided_batched_rank_1
      type(c_ptr),value :: handle
      integer(c_int),value :: n
      real(c_double),target,dimension(:) :: x
      integer(c_int),value :: incx
      integer(c_int64_t),value :: stride_x
      real(c_double),target,dimension(:) :: y
      integer(c_int),value :: incy
      integer(c_int64_t),value :: stride_y
      type(c_ptr),value :: c
      type(c_ptr),value :: s
      integer(c_int),value :: batch_count
      !
      rocblas_drot_strided_batched_rank_1 = rocblas_drot_strided_batched_orig(handle,n,c_loc(x),incx,stride_x,c_loc(y),incy,stride_y,c,s,batch_count)
    end function

    function rocblas_crot_strided_batched_rank_0(handle,n,x,incx,stride_x,y,incy,stride_y,c,s,batch_count)
      use iso_c_binding
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocblas_crot_strided_batched_rank_0
      type(c_ptr),value :: handle
      integer(c_int),value :: n
      complex(c_float_complex),target :: x
      integer(c_int),value :: incx
      integer(c_int64_t),value :: stride_x
      complex(c_float_complex),target :: y
      integer(c_int),value :: incy
      integer(c_int64_t),value :: stride_y
      type(c_ptr),value :: c
      type(c_ptr),value :: s
      integer(c_int),value :: batch_count
      !
      rocblas_crot_strided_batched_rank_0 = rocblas_crot_strided_batched_orig(handle,n,c_loc(x),incx,stride_x,c_loc(y),incy,stride_y,c,s,batch_count)
    end function

    function rocblas_crot_strided_batched_rank_1(handle,n,x,incx,stride_x,y,incy,stride_y,c,s,batch_count)
      use iso_c_binding
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocblas_crot_strided_batched_rank_1
      type(c_ptr),value :: handle
      integer(c_int),value :: n
      complex(c_float_complex),target,dimension(:) :: x
      integer(c_int),value :: incx
      integer(c_int64_t),value :: stride_x
      complex(c_float_complex),target,dimension(:) :: y
      integer(c_int),value :: incy
      integer(c_int64_t),value :: stride_y
      type(c_ptr),value :: c
      type(c_ptr),value :: s
      integer(c_int),value :: batch_count
      !
      rocblas_crot_strided_batched_rank_1 = rocblas_crot_strided_batched_orig(handle,n,c_loc(x),incx,stride_x,c_loc(y),incy,stride_y,c,s,batch_count)
    end function

    function rocblas_csrot_strided_batched_rank_0(handle,n,x,incx,stride_x,y,incy,stride_y,c,s,batch_count)
      use iso_c_binding
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocblas_csrot_strided_batched_rank_0
      type(c_ptr),value :: handle
      integer(c_int),value :: n
      complex(c_float_complex),target :: x
      integer(c_int),value :: incx
      integer(c_int64_t),value :: stride_x
      complex(c_float_complex),target :: y
      integer(c_int),value :: incy
      integer(c_int64_t),value :: stride_y
      type(c_ptr),value :: c
      type(c_ptr),value :: s
      integer(c_int),value :: batch_count
      !
      rocblas_csrot_strided_batched_rank_0 = rocblas_csrot_strided_batched_orig(handle,n,c_loc(x),incx,stride_x,c_loc(y),incy,stride_y,c,s,batch_count)
    end function

    function rocblas_csrot_strided_batched_rank_1(handle,n,x,incx,stride_x,y,incy,stride_y,c,s,batch_count)
      use iso_c_binding
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocblas_csrot_strided_batched_rank_1
      type(c_ptr),value :: handle
      integer(c_int),value :: n
      complex(c_float_complex),target,dimension(:) :: x
      integer(c_int),value :: incx
      integer(c_int64_t),value :: stride_x
      complex(c_float_complex),target,dimension(:) :: y
      integer(c_int),value :: incy
      integer(c_int64_t),value :: stride_y
      type(c_ptr),value :: c
      type(c_ptr),value :: s
      integer(c_int),value :: batch_count
      !
      rocblas_csrot_strided_batched_rank_1 = rocblas_csrot_strided_batched_orig(handle,n,c_loc(x),incx,stride_x,c_loc(y),incy,stride_y,c,s,batch_count)
    end function

    function rocblas_zrot_strided_batched_rank_0(handle,n,x,incx,stride_x,y,incy,stride_y,c,s,batch_count)
      use iso_c_binding
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocblas_zrot_strided_batched_rank_0
      type(c_ptr),value :: handle
      integer(c_int),value :: n
      complex(c_double_complex),target :: x
      integer(c_int),value :: incx
      integer(c_int64_t),value :: stride_x
      complex(c_double_complex),target :: y
      integer(c_int),value :: incy
      integer(c_int64_t),value :: stride_y
      type(c_ptr),value :: c
      type(c_ptr),value :: s
      integer(c_int),value :: batch_count
      !
      rocblas_zrot_strided_batched_rank_0 = rocblas_zrot_strided_batched_orig(handle,n,c_loc(x),incx,stride_x,c_loc(y),incy,stride_y,c,s,batch_count)
    end function

    function rocblas_zrot_strided_batched_rank_1(handle,n,x,incx,stride_x,y,incy,stride_y,c,s,batch_count)
      use iso_c_binding
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocblas_zrot_strided_batched_rank_1
      type(c_ptr),value :: handle
      integer(c_int),value :: n
      complex(c_double_complex),target,dimension(:) :: x
      integer(c_int),value :: incx
      integer(c_int64_t),value :: stride_x
      complex(c_double_complex),target,dimension(:) :: y
      integer(c_int),value :: incy
      integer(c_int64_t),value :: stride_y
      type(c_ptr),value :: c
      type(c_ptr),value :: s
      integer(c_int),value :: batch_count
      !
      rocblas_zrot_strided_batched_rank_1 = rocblas_zrot_strided_batched_orig(handle,n,c_loc(x),incx,stride_x,c_loc(y),incy,stride_y,c,s,batch_count)
    end function

    function rocblas_zdrot_strided_batched_rank_0(handle,n,x,incx,stride_x,y,incy,stride_y,c,s,batch_count)
      use iso_c_binding
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocblas_zdrot_strided_batched_rank_0
      type(c_ptr),value :: handle
      integer(c_int),value :: n
      complex(c_double_complex),target :: x
      integer(c_int),value :: incx
      integer(c_int64_t),value :: stride_x
      complex(c_double_complex),target :: y
      integer(c_int),value :: incy
      integer(c_int64_t),value :: stride_y
      type(c_ptr),value :: c
      type(c_ptr),value :: s
      integer(c_int),value :: batch_count
      !
      rocblas_zdrot_strided_batched_rank_0 = rocblas_zdrot_strided_batched_orig(handle,n,c_loc(x),incx,stride_x,c_loc(y),incy,stride_y,c,s,batch_count)
    end function

    function rocblas_zdrot_strided_batched_rank_1(handle,n,x,incx,stride_x,y,incy,stride_y,c,s,batch_count)
      use iso_c_binding
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocblas_zdrot_strided_batched_rank_1
      type(c_ptr),value :: handle
      integer(c_int),value :: n
      complex(c_double_complex),target,dimension(:) :: x
      integer(c_int),value :: incx
      integer(c_int64_t),value :: stride_x
      complex(c_double_complex),target,dimension(:) :: y
      integer(c_int),value :: incy
      integer(c_int64_t),value :: stride_y
      type(c_ptr),value :: c
      type(c_ptr),value :: s
      integer(c_int),value :: batch_count
      !
      rocblas_zdrot_strided_batched_rank_1 = rocblas_zdrot_strided_batched_orig(handle,n,c_loc(x),incx,stride_x,c_loc(y),incy,stride_y,c,s,batch_count)
    end function

    function rocblas_srotm_rank_0(handle,n,x,incx,y,incy,param)
      use iso_c_binding
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocblas_srotm_rank_0
      type(c_ptr),value :: handle
      integer(c_int),value :: n
      real(c_float),target :: x
      integer(c_int),value :: incx
      real(c_float),target :: y
      integer(c_int),value :: incy
      type(c_ptr),value :: param
      !
      rocblas_srotm_rank_0 = rocblas_srotm_orig(handle,n,c_loc(x),incx,c_loc(y),incy,param)
    end function

    function rocblas_srotm_rank_1(handle,n,x,incx,y,incy,param)
      use iso_c_binding
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocblas_srotm_rank_1
      type(c_ptr),value :: handle
      integer(c_int),value :: n
      real(c_float),target,dimension(:) :: x
      integer(c_int),value :: incx
      real(c_float),target,dimension(:) :: y
      integer(c_int),value :: incy
      type(c_ptr),value :: param
      !
      rocblas_srotm_rank_1 = rocblas_srotm_orig(handle,n,c_loc(x),incx,c_loc(y),incy,param)
    end function

    function rocblas_drotm_rank_0(handle,n,x,incx,y,incy,param)
      use iso_c_binding
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocblas_drotm_rank_0
      type(c_ptr),value :: handle
      integer(c_int),value :: n
      real(c_double),target :: x
      integer(c_int),value :: incx
      real(c_double),target :: y
      integer(c_int),value :: incy
      type(c_ptr),value :: param
      !
      rocblas_drotm_rank_0 = rocblas_drotm_orig(handle,n,c_loc(x),incx,c_loc(y),incy,param)
    end function

    function rocblas_drotm_rank_1(handle,n,x,incx,y,incy,param)
      use iso_c_binding
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocblas_drotm_rank_1
      type(c_ptr),value :: handle
      integer(c_int),value :: n
      real(c_double),target,dimension(:) :: x
      integer(c_int),value :: incx
      real(c_double),target,dimension(:) :: y
      integer(c_int),value :: incy
      type(c_ptr),value :: param
      !
      rocblas_drotm_rank_1 = rocblas_drotm_orig(handle,n,c_loc(x),incx,c_loc(y),incy,param)
    end function

    function rocblas_srotm_batched_full_rank(handle,n,x,incx,y,incy,param,batch_count)
      use iso_c_binding
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocblas_srotm_batched_full_rank
      type(c_ptr),value :: handle
      integer(c_int),value :: n
      real(c_float),target,dimension(:,:) :: x
      integer(c_int),value :: incx
      real(c_float),target,dimension(:,:) :: y
      integer(c_int),value :: incy
      type(c_ptr) :: param
      integer(c_int),value :: batch_count
      !
      rocblas_srotm_batched_full_rank = rocblas_srotm_batched_orig(handle,n,c_loc(x),incx,c_loc(y),incy,param,batch_count)
    end function

    function rocblas_srotm_batched_rank_0(handle,n,x,incx,y,incy,param,batch_count)
      use iso_c_binding
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocblas_srotm_batched_rank_0
      type(c_ptr),value :: handle
      integer(c_int),value :: n
      real(c_float),target :: x
      integer(c_int),value :: incx
      real(c_float),target :: y
      integer(c_int),value :: incy
      type(c_ptr) :: param
      integer(c_int),value :: batch_count
      !
      rocblas_srotm_batched_rank_0 = rocblas_srotm_batched_orig(handle,n,c_loc(x),incx,c_loc(y),incy,param,batch_count)
    end function

    function rocblas_srotm_batched_rank_1(handle,n,x,incx,y,incy,param,batch_count)
      use iso_c_binding
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocblas_srotm_batched_rank_1
      type(c_ptr),value :: handle
      integer(c_int),value :: n
      real(c_float),target,dimension(:) :: x
      integer(c_int),value :: incx
      real(c_float),target,dimension(:) :: y
      integer(c_int),value :: incy
      type(c_ptr) :: param
      integer(c_int),value :: batch_count
      !
      rocblas_srotm_batched_rank_1 = rocblas_srotm_batched_orig(handle,n,c_loc(x),incx,c_loc(y),incy,param,batch_count)
    end function

    function rocblas_drotm_batched_full_rank(handle,n,x,incx,y,incy,param,batch_count)
      use iso_c_binding
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocblas_drotm_batched_full_rank
      type(c_ptr),value :: handle
      integer(c_int),value :: n
      real(c_double),target,dimension(:,:) :: x
      integer(c_int),value :: incx
      real(c_double),target,dimension(:,:) :: y
      integer(c_int),value :: incy
      type(c_ptr) :: param
      integer(c_int),value :: batch_count
      !
      rocblas_drotm_batched_full_rank = rocblas_drotm_batched_orig(handle,n,c_loc(x),incx,c_loc(y),incy,param,batch_count)
    end function

    function rocblas_drotm_batched_rank_0(handle,n,x,incx,y,incy,param,batch_count)
      use iso_c_binding
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocblas_drotm_batched_rank_0
      type(c_ptr),value :: handle
      integer(c_int),value :: n
      real(c_double),target :: x
      integer(c_int),value :: incx
      real(c_double),target :: y
      integer(c_int),value :: incy
      type(c_ptr) :: param
      integer(c_int),value :: batch_count
      !
      rocblas_drotm_batched_rank_0 = rocblas_drotm_batched_orig(handle,n,c_loc(x),incx,c_loc(y),incy,param,batch_count)
    end function

    function rocblas_drotm_batched_rank_1(handle,n,x,incx,y,incy,param,batch_count)
      use iso_c_binding
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocblas_drotm_batched_rank_1
      type(c_ptr),value :: handle
      integer(c_int),value :: n
      real(c_double),target,dimension(:) :: x
      integer(c_int),value :: incx
      real(c_double),target,dimension(:) :: y
      integer(c_int),value :: incy
      type(c_ptr) :: param
      integer(c_int),value :: batch_count
      !
      rocblas_drotm_batched_rank_1 = rocblas_drotm_batched_orig(handle,n,c_loc(x),incx,c_loc(y),incy,param,batch_count)
    end function

    function rocblas_srotm_strided_batched_rank_0(handle,n,x,incx,stride_x,y,incy,stride_y,param,stride_param,batch_count)
      use iso_c_binding
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocblas_srotm_strided_batched_rank_0
      type(c_ptr),value :: handle
      integer(c_int),value :: n
      real(c_float),target :: x
      integer(c_int),value :: incx
      integer(c_int64_t),value :: stride_x
      real(c_float),target :: y
      integer(c_int),value :: incy
      integer(c_int64_t),value :: stride_y
      type(c_ptr),value :: param
      integer(c_int64_t),value :: stride_param
      integer(c_int),value :: batch_count
      !
      rocblas_srotm_strided_batched_rank_0 = rocblas_srotm_strided_batched_orig(handle,n,c_loc(x),incx,stride_x,c_loc(y),incy,stride_y,param,stride_param,batch_count)
    end function

    function rocblas_srotm_strided_batched_rank_1(handle,n,x,incx,stride_x,y,incy,stride_y,param,stride_param,batch_count)
      use iso_c_binding
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocblas_srotm_strided_batched_rank_1
      type(c_ptr),value :: handle
      integer(c_int),value :: n
      real(c_float),target,dimension(:) :: x
      integer(c_int),value :: incx
      integer(c_int64_t),value :: stride_x
      real(c_float),target,dimension(:) :: y
      integer(c_int),value :: incy
      integer(c_int64_t),value :: stride_y
      type(c_ptr),value :: param
      integer(c_int64_t),value :: stride_param
      integer(c_int),value :: batch_count
      !
      rocblas_srotm_strided_batched_rank_1 = rocblas_srotm_strided_batched_orig(handle,n,c_loc(x),incx,stride_x,c_loc(y),incy,stride_y,param,stride_param,batch_count)
    end function

    function rocblas_drotm_strided_batched_rank_0(handle,n,x,incx,stride_x,y,incy,stride_y,param,stride_param,batch_count)
      use iso_c_binding
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocblas_drotm_strided_batched_rank_0
      type(c_ptr),value :: handle
      integer(c_int),value :: n
      real(c_double),target :: x
      integer(c_int),value :: incx
      integer(c_int64_t),value :: stride_x
      real(c_double),target :: y
      integer(c_int),value :: incy
      integer(c_int64_t),value :: stride_y
      type(c_ptr),value :: param
      integer(c_int64_t),value :: stride_param
      integer(c_int),value :: batch_count
      !
      rocblas_drotm_strided_batched_rank_0 = rocblas_drotm_strided_batched_orig(handle,n,c_loc(x),incx,stride_x,c_loc(y),incy,stride_y,param,stride_param,batch_count)
    end function

    function rocblas_drotm_strided_batched_rank_1(handle,n,x,incx,stride_x,y,incy,stride_y,param,stride_param,batch_count)
      use iso_c_binding
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocblas_drotm_strided_batched_rank_1
      type(c_ptr),value :: handle
      integer(c_int),value :: n
      real(c_double),target,dimension(:) :: x
      integer(c_int),value :: incx
      integer(c_int64_t),value :: stride_x
      real(c_double),target,dimension(:) :: y
      integer(c_int),value :: incy
      integer(c_int64_t),value :: stride_y
      type(c_ptr),value :: param
      integer(c_int64_t),value :: stride_param
      integer(c_int),value :: batch_count
      !
      rocblas_drotm_strided_batched_rank_1 = rocblas_drotm_strided_batched_orig(handle,n,c_loc(x),incx,stride_x,c_loc(y),incy,stride_y,param,stride_param,batch_count)
    end function

    function rocblas_sgbmv_full_rank(handle,trans,m,n,kl,ku,alpha,A,lda,x,incx,beta,y,incy)
      use iso_c_binding
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocblas_sgbmv_full_rank
      type(c_ptr),value :: handle
      integer(kind(rocblas_operation_none)),value :: trans
      integer(c_int),value :: m
      integer(c_int),value :: n
      integer(c_int),value :: kl
      integer(c_int),value :: ku
      real(c_float) :: alpha
      real(c_float),target,dimension(:,:) :: A
      integer(c_int),value :: lda
      real(c_float),target,dimension(:) :: x
      integer(c_int),value :: incx
      real(c_float) :: beta
      real(c_float),target,dimension(:) :: y
      integer(c_int),value :: incy
      !
      rocblas_sgbmv_full_rank = rocblas_sgbmv_orig(handle,trans,m,n,kl,ku,alpha,c_loc(A),lda,c_loc(x),incx,beta,c_loc(y),incy)
    end function

    function rocblas_sgbmv_rank_0(handle,trans,m,n,kl,ku,alpha,A,lda,x,incx,beta,y,incy)
      use iso_c_binding
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocblas_sgbmv_rank_0
      type(c_ptr),value :: handle
      integer(kind(rocblas_operation_none)),value :: trans
      integer(c_int),value :: m
      integer(c_int),value :: n
      integer(c_int),value :: kl
      integer(c_int),value :: ku
      real(c_float) :: alpha
      real(c_float),target :: A
      integer(c_int),value :: lda
      real(c_float),target :: x
      integer(c_int),value :: incx
      real(c_float) :: beta
      real(c_float),target :: y
      integer(c_int),value :: incy
      !
      rocblas_sgbmv_rank_0 = rocblas_sgbmv_orig(handle,trans,m,n,kl,ku,alpha,c_loc(A),lda,c_loc(x),incx,beta,c_loc(y),incy)
    end function

    function rocblas_sgbmv_rank_1(handle,trans,m,n,kl,ku,alpha,A,lda,x,incx,beta,y,incy)
      use iso_c_binding
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocblas_sgbmv_rank_1
      type(c_ptr),value :: handle
      integer(kind(rocblas_operation_none)),value :: trans
      integer(c_int),value :: m
      integer(c_int),value :: n
      integer(c_int),value :: kl
      integer(c_int),value :: ku
      real(c_float) :: alpha
      real(c_float),target,dimension(:) :: A
      integer(c_int),value :: lda
      real(c_float),target,dimension(:) :: x
      integer(c_int),value :: incx
      real(c_float) :: beta
      real(c_float),target,dimension(:) :: y
      integer(c_int),value :: incy
      !
      rocblas_sgbmv_rank_1 = rocblas_sgbmv_orig(handle,trans,m,n,kl,ku,alpha,c_loc(A),lda,c_loc(x),incx,beta,c_loc(y),incy)
    end function

    function rocblas_dgbmv_full_rank(handle,trans,m,n,kl,ku,alpha,A,lda,x,incx,beta,y,incy)
      use iso_c_binding
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocblas_dgbmv_full_rank
      type(c_ptr),value :: handle
      integer(kind(rocblas_operation_none)),value :: trans
      integer(c_int),value :: m
      integer(c_int),value :: n
      integer(c_int),value :: kl
      integer(c_int),value :: ku
      real(c_double) :: alpha
      real(c_double),target,dimension(:,:) :: A
      integer(c_int),value :: lda
      real(c_double),target,dimension(:) :: x
      integer(c_int),value :: incx
      real(c_double) :: beta
      real(c_double),target,dimension(:) :: y
      integer(c_int),value :: incy
      !
      rocblas_dgbmv_full_rank = rocblas_dgbmv_orig(handle,trans,m,n,kl,ku,alpha,c_loc(A),lda,c_loc(x),incx,beta,c_loc(y),incy)
    end function

    function rocblas_dgbmv_rank_0(handle,trans,m,n,kl,ku,alpha,A,lda,x,incx,beta,y,incy)
      use iso_c_binding
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocblas_dgbmv_rank_0
      type(c_ptr),value :: handle
      integer(kind(rocblas_operation_none)),value :: trans
      integer(c_int),value :: m
      integer(c_int),value :: n
      integer(c_int),value :: kl
      integer(c_int),value :: ku
      real(c_double) :: alpha
      real(c_double),target :: A
      integer(c_int),value :: lda
      real(c_double),target :: x
      integer(c_int),value :: incx
      real(c_double) :: beta
      real(c_double),target :: y
      integer(c_int),value :: incy
      !
      rocblas_dgbmv_rank_0 = rocblas_dgbmv_orig(handle,trans,m,n,kl,ku,alpha,c_loc(A),lda,c_loc(x),incx,beta,c_loc(y),incy)
    end function

    function rocblas_dgbmv_rank_1(handle,trans,m,n,kl,ku,alpha,A,lda,x,incx,beta,y,incy)
      use iso_c_binding
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocblas_dgbmv_rank_1
      type(c_ptr),value :: handle
      integer(kind(rocblas_operation_none)),value :: trans
      integer(c_int),value :: m
      integer(c_int),value :: n
      integer(c_int),value :: kl
      integer(c_int),value :: ku
      real(c_double) :: alpha
      real(c_double),target,dimension(:) :: A
      integer(c_int),value :: lda
      real(c_double),target,dimension(:) :: x
      integer(c_int),value :: incx
      real(c_double) :: beta
      real(c_double),target,dimension(:) :: y
      integer(c_int),value :: incy
      !
      rocblas_dgbmv_rank_1 = rocblas_dgbmv_orig(handle,trans,m,n,kl,ku,alpha,c_loc(A),lda,c_loc(x),incx,beta,c_loc(y),incy)
    end function

    function rocblas_cgbmv_full_rank(handle,trans,m,n,kl,ku,alpha,A,lda,x,incx,beta,y,incy)
      use iso_c_binding
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocblas_cgbmv_full_rank
      type(c_ptr),value :: handle
      integer(kind(rocblas_operation_none)),value :: trans
      integer(c_int),value :: m
      integer(c_int),value :: n
      integer(c_int),value :: kl
      integer(c_int),value :: ku
      complex(c_float_complex) :: alpha
      complex(c_float_complex),target,dimension(:,:) :: A
      integer(c_int),value :: lda
      complex(c_float_complex),target,dimension(:) :: x
      integer(c_int),value :: incx
      complex(c_float_complex) :: beta
      complex(c_float_complex),target,dimension(:) :: y
      integer(c_int),value :: incy
      !
      rocblas_cgbmv_full_rank = rocblas_cgbmv_orig(handle,trans,m,n,kl,ku,alpha,c_loc(A),lda,c_loc(x),incx,beta,c_loc(y),incy)
    end function

    function rocblas_cgbmv_rank_0(handle,trans,m,n,kl,ku,alpha,A,lda,x,incx,beta,y,incy)
      use iso_c_binding
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocblas_cgbmv_rank_0
      type(c_ptr),value :: handle
      integer(kind(rocblas_operation_none)),value :: trans
      integer(c_int),value :: m
      integer(c_int),value :: n
      integer(c_int),value :: kl
      integer(c_int),value :: ku
      complex(c_float_complex) :: alpha
      complex(c_float_complex),target :: A
      integer(c_int),value :: lda
      complex(c_float_complex),target :: x
      integer(c_int),value :: incx
      complex(c_float_complex) :: beta
      complex(c_float_complex),target :: y
      integer(c_int),value :: incy
      !
      rocblas_cgbmv_rank_0 = rocblas_cgbmv_orig(handle,trans,m,n,kl,ku,alpha,c_loc(A),lda,c_loc(x),incx,beta,c_loc(y),incy)
    end function

    function rocblas_cgbmv_rank_1(handle,trans,m,n,kl,ku,alpha,A,lda,x,incx,beta,y,incy)
      use iso_c_binding
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocblas_cgbmv_rank_1
      type(c_ptr),value :: handle
      integer(kind(rocblas_operation_none)),value :: trans
      integer(c_int),value :: m
      integer(c_int),value :: n
      integer(c_int),value :: kl
      integer(c_int),value :: ku
      complex(c_float_complex) :: alpha
      complex(c_float_complex),target,dimension(:) :: A
      integer(c_int),value :: lda
      complex(c_float_complex),target,dimension(:) :: x
      integer(c_int),value :: incx
      complex(c_float_complex) :: beta
      complex(c_float_complex),target,dimension(:) :: y
      integer(c_int),value :: incy
      !
      rocblas_cgbmv_rank_1 = rocblas_cgbmv_orig(handle,trans,m,n,kl,ku,alpha,c_loc(A),lda,c_loc(x),incx,beta,c_loc(y),incy)
    end function

    function rocblas_zgbmv_full_rank(handle,trans,m,n,kl,ku,alpha,A,lda,x,incx,beta,y,incy)
      use iso_c_binding
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocblas_zgbmv_full_rank
      type(c_ptr),value :: handle
      integer(kind(rocblas_operation_none)),value :: trans
      integer(c_int),value :: m
      integer(c_int),value :: n
      integer(c_int),value :: kl
      integer(c_int),value :: ku
      complex(c_double_complex) :: alpha
      complex(c_double_complex),target,dimension(:,:) :: A
      integer(c_int),value :: lda
      complex(c_double_complex),target,dimension(:) :: x
      integer(c_int),value :: incx
      complex(c_double_complex) :: beta
      complex(c_double_complex),target,dimension(:) :: y
      integer(c_int),value :: incy
      !
      rocblas_zgbmv_full_rank = rocblas_zgbmv_orig(handle,trans,m,n,kl,ku,alpha,c_loc(A),lda,c_loc(x),incx,beta,c_loc(y),incy)
    end function

    function rocblas_zgbmv_rank_0(handle,trans,m,n,kl,ku,alpha,A,lda,x,incx,beta,y,incy)
      use iso_c_binding
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocblas_zgbmv_rank_0
      type(c_ptr),value :: handle
      integer(kind(rocblas_operation_none)),value :: trans
      integer(c_int),value :: m
      integer(c_int),value :: n
      integer(c_int),value :: kl
      integer(c_int),value :: ku
      complex(c_double_complex) :: alpha
      complex(c_double_complex),target :: A
      integer(c_int),value :: lda
      complex(c_double_complex),target :: x
      integer(c_int),value :: incx
      complex(c_double_complex) :: beta
      complex(c_double_complex),target :: y
      integer(c_int),value :: incy
      !
      rocblas_zgbmv_rank_0 = rocblas_zgbmv_orig(handle,trans,m,n,kl,ku,alpha,c_loc(A),lda,c_loc(x),incx,beta,c_loc(y),incy)
    end function

    function rocblas_zgbmv_rank_1(handle,trans,m,n,kl,ku,alpha,A,lda,x,incx,beta,y,incy)
      use iso_c_binding
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocblas_zgbmv_rank_1
      type(c_ptr),value :: handle
      integer(kind(rocblas_operation_none)),value :: trans
      integer(c_int),value :: m
      integer(c_int),value :: n
      integer(c_int),value :: kl
      integer(c_int),value :: ku
      complex(c_double_complex) :: alpha
      complex(c_double_complex),target,dimension(:) :: A
      integer(c_int),value :: lda
      complex(c_double_complex),target,dimension(:) :: x
      integer(c_int),value :: incx
      complex(c_double_complex) :: beta
      complex(c_double_complex),target,dimension(:) :: y
      integer(c_int),value :: incy
      !
      rocblas_zgbmv_rank_1 = rocblas_zgbmv_orig(handle,trans,m,n,kl,ku,alpha,c_loc(A),lda,c_loc(x),incx,beta,c_loc(y),incy)
    end function

    function rocblas_sgbmv_batched_full_rank(handle,trans,m,n,kl,ku,alpha,A,lda,x,incx,beta,y,incy,batch_count)
      use iso_c_binding
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocblas_sgbmv_batched_full_rank
      type(c_ptr),value :: handle
      integer(kind(rocblas_operation_none)),value :: trans
      integer(c_int),value :: m
      integer(c_int),value :: n
      integer(c_int),value :: kl
      integer(c_int),value :: ku
      real(c_float) :: alpha
      real(c_float),target,dimension(:,:,:) :: A
      integer(c_int),value :: lda
      real(c_float),target,dimension(:,:) :: x
      integer(c_int),value :: incx
      real(c_float) :: beta
      real(c_float),target,dimension(:,:) :: y
      integer(c_int),value :: incy
      integer(c_int),value :: batch_count
      !
      rocblas_sgbmv_batched_full_rank = rocblas_sgbmv_batched_orig(handle,trans,m,n,kl,ku,alpha,c_loc(A),lda,c_loc(x),incx,beta,c_loc(y),incy,batch_count)
    end function

    function rocblas_sgbmv_batched_rank_0(handle,trans,m,n,kl,ku,alpha,A,lda,x,incx,beta,y,incy,batch_count)
      use iso_c_binding
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocblas_sgbmv_batched_rank_0
      type(c_ptr),value :: handle
      integer(kind(rocblas_operation_none)),value :: trans
      integer(c_int),value :: m
      integer(c_int),value :: n
      integer(c_int),value :: kl
      integer(c_int),value :: ku
      real(c_float) :: alpha
      real(c_float),target :: A
      integer(c_int),value :: lda
      real(c_float),target :: x
      integer(c_int),value :: incx
      real(c_float) :: beta
      real(c_float),target :: y
      integer(c_int),value :: incy
      integer(c_int),value :: batch_count
      !
      rocblas_sgbmv_batched_rank_0 = rocblas_sgbmv_batched_orig(handle,trans,m,n,kl,ku,alpha,c_loc(A),lda,c_loc(x),incx,beta,c_loc(y),incy,batch_count)
    end function

    function rocblas_sgbmv_batched_rank_1(handle,trans,m,n,kl,ku,alpha,A,lda,x,incx,beta,y,incy,batch_count)
      use iso_c_binding
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocblas_sgbmv_batched_rank_1
      type(c_ptr),value :: handle
      integer(kind(rocblas_operation_none)),value :: trans
      integer(c_int),value :: m
      integer(c_int),value :: n
      integer(c_int),value :: kl
      integer(c_int),value :: ku
      real(c_float) :: alpha
      real(c_float),target,dimension(:) :: A
      integer(c_int),value :: lda
      real(c_float),target,dimension(:) :: x
      integer(c_int),value :: incx
      real(c_float) :: beta
      real(c_float),target,dimension(:) :: y
      integer(c_int),value :: incy
      integer(c_int),value :: batch_count
      !
      rocblas_sgbmv_batched_rank_1 = rocblas_sgbmv_batched_orig(handle,trans,m,n,kl,ku,alpha,c_loc(A),lda,c_loc(x),incx,beta,c_loc(y),incy,batch_count)
    end function

    function rocblas_dgbmv_batched_full_rank(handle,trans,m,n,kl,ku,alpha,A,lda,x,incx,beta,y,incy,batch_count)
      use iso_c_binding
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocblas_dgbmv_batched_full_rank
      type(c_ptr),value :: handle
      integer(kind(rocblas_operation_none)),value :: trans
      integer(c_int),value :: m
      integer(c_int),value :: n
      integer(c_int),value :: kl
      integer(c_int),value :: ku
      real(c_double) :: alpha
      real(c_double),target,dimension(:,:,:) :: A
      integer(c_int),value :: lda
      real(c_double),target,dimension(:,:) :: x
      integer(c_int),value :: incx
      real(c_double) :: beta
      real(c_double),target,dimension(:,:) :: y
      integer(c_int),value :: incy
      integer(c_int),value :: batch_count
      !
      rocblas_dgbmv_batched_full_rank = rocblas_dgbmv_batched_orig(handle,trans,m,n,kl,ku,alpha,c_loc(A),lda,c_loc(x),incx,beta,c_loc(y),incy,batch_count)
    end function

    function rocblas_dgbmv_batched_rank_0(handle,trans,m,n,kl,ku,alpha,A,lda,x,incx,beta,y,incy,batch_count)
      use iso_c_binding
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocblas_dgbmv_batched_rank_0
      type(c_ptr),value :: handle
      integer(kind(rocblas_operation_none)),value :: trans
      integer(c_int),value :: m
      integer(c_int),value :: n
      integer(c_int),value :: kl
      integer(c_int),value :: ku
      real(c_double) :: alpha
      real(c_double),target :: A
      integer(c_int),value :: lda
      real(c_double),target :: x
      integer(c_int),value :: incx
      real(c_double) :: beta
      real(c_double),target :: y
      integer(c_int),value :: incy
      integer(c_int),value :: batch_count
      !
      rocblas_dgbmv_batched_rank_0 = rocblas_dgbmv_batched_orig(handle,trans,m,n,kl,ku,alpha,c_loc(A),lda,c_loc(x),incx,beta,c_loc(y),incy,batch_count)
    end function

    function rocblas_dgbmv_batched_rank_1(handle,trans,m,n,kl,ku,alpha,A,lda,x,incx,beta,y,incy,batch_count)
      use iso_c_binding
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocblas_dgbmv_batched_rank_1
      type(c_ptr),value :: handle
      integer(kind(rocblas_operation_none)),value :: trans
      integer(c_int),value :: m
      integer(c_int),value :: n
      integer(c_int),value :: kl
      integer(c_int),value :: ku
      real(c_double) :: alpha
      real(c_double),target,dimension(:) :: A
      integer(c_int),value :: lda
      real(c_double),target,dimension(:) :: x
      integer(c_int),value :: incx
      real(c_double) :: beta
      real(c_double),target,dimension(:) :: y
      integer(c_int),value :: incy
      integer(c_int),value :: batch_count
      !
      rocblas_dgbmv_batched_rank_1 = rocblas_dgbmv_batched_orig(handle,trans,m,n,kl,ku,alpha,c_loc(A),lda,c_loc(x),incx,beta,c_loc(y),incy,batch_count)
    end function

    function rocblas_cgbmv_batched_full_rank(handle,trans,m,n,kl,ku,alpha,A,lda,x,incx,beta,y,incy,batch_count)
      use iso_c_binding
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocblas_cgbmv_batched_full_rank
      type(c_ptr),value :: handle
      integer(kind(rocblas_operation_none)),value :: trans
      integer(c_int),value :: m
      integer(c_int),value :: n
      integer(c_int),value :: kl
      integer(c_int),value :: ku
      complex(c_float_complex) :: alpha
      complex(c_float_complex),target,dimension(:,:,:) :: A
      integer(c_int),value :: lda
      complex(c_float_complex),target,dimension(:,:) :: x
      integer(c_int),value :: incx
      complex(c_float_complex) :: beta
      complex(c_float_complex),target,dimension(:,:) :: y
      integer(c_int),value :: incy
      integer(c_int),value :: batch_count
      !
      rocblas_cgbmv_batched_full_rank = rocblas_cgbmv_batched_orig(handle,trans,m,n,kl,ku,alpha,c_loc(A),lda,c_loc(x),incx,beta,c_loc(y),incy,batch_count)
    end function

    function rocblas_cgbmv_batched_rank_0(handle,trans,m,n,kl,ku,alpha,A,lda,x,incx,beta,y,incy,batch_count)
      use iso_c_binding
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocblas_cgbmv_batched_rank_0
      type(c_ptr),value :: handle
      integer(kind(rocblas_operation_none)),value :: trans
      integer(c_int),value :: m
      integer(c_int),value :: n
      integer(c_int),value :: kl
      integer(c_int),value :: ku
      complex(c_float_complex) :: alpha
      complex(c_float_complex),target :: A
      integer(c_int),value :: lda
      complex(c_float_complex),target :: x
      integer(c_int),value :: incx
      complex(c_float_complex) :: beta
      complex(c_float_complex),target :: y
      integer(c_int),value :: incy
      integer(c_int),value :: batch_count
      !
      rocblas_cgbmv_batched_rank_0 = rocblas_cgbmv_batched_orig(handle,trans,m,n,kl,ku,alpha,c_loc(A),lda,c_loc(x),incx,beta,c_loc(y),incy,batch_count)
    end function

    function rocblas_cgbmv_batched_rank_1(handle,trans,m,n,kl,ku,alpha,A,lda,x,incx,beta,y,incy,batch_count)
      use iso_c_binding
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocblas_cgbmv_batched_rank_1
      type(c_ptr),value :: handle
      integer(kind(rocblas_operation_none)),value :: trans
      integer(c_int),value :: m
      integer(c_int),value :: n
      integer(c_int),value :: kl
      integer(c_int),value :: ku
      complex(c_float_complex) :: alpha
      complex(c_float_complex),target,dimension(:) :: A
      integer(c_int),value :: lda
      complex(c_float_complex),target,dimension(:) :: x
      integer(c_int),value :: incx
      complex(c_float_complex) :: beta
      complex(c_float_complex),target,dimension(:) :: y
      integer(c_int),value :: incy
      integer(c_int),value :: batch_count
      !
      rocblas_cgbmv_batched_rank_1 = rocblas_cgbmv_batched_orig(handle,trans,m,n,kl,ku,alpha,c_loc(A),lda,c_loc(x),incx,beta,c_loc(y),incy,batch_count)
    end function

    function rocblas_zgbmv_batched_full_rank(handle,trans,m,n,kl,ku,alpha,A,lda,x,incx,beta,y,incy,batch_count)
      use iso_c_binding
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocblas_zgbmv_batched_full_rank
      type(c_ptr),value :: handle
      integer(kind(rocblas_operation_none)),value :: trans
      integer(c_int),value :: m
      integer(c_int),value :: n
      integer(c_int),value :: kl
      integer(c_int),value :: ku
      complex(c_double_complex) :: alpha
      complex(c_double_complex),target,dimension(:,:,:) :: A
      integer(c_int),value :: lda
      complex(c_double_complex),target,dimension(:,:) :: x
      integer(c_int),value :: incx
      complex(c_double_complex) :: beta
      complex(c_double_complex),target,dimension(:,:) :: y
      integer(c_int),value :: incy
      integer(c_int),value :: batch_count
      !
      rocblas_zgbmv_batched_full_rank = rocblas_zgbmv_batched_orig(handle,trans,m,n,kl,ku,alpha,c_loc(A),lda,c_loc(x),incx,beta,c_loc(y),incy,batch_count)
    end function

    function rocblas_zgbmv_batched_rank_0(handle,trans,m,n,kl,ku,alpha,A,lda,x,incx,beta,y,incy,batch_count)
      use iso_c_binding
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocblas_zgbmv_batched_rank_0
      type(c_ptr),value :: handle
      integer(kind(rocblas_operation_none)),value :: trans
      integer(c_int),value :: m
      integer(c_int),value :: n
      integer(c_int),value :: kl
      integer(c_int),value :: ku
      complex(c_double_complex) :: alpha
      complex(c_double_complex),target :: A
      integer(c_int),value :: lda
      complex(c_double_complex),target :: x
      integer(c_int),value :: incx
      complex(c_double_complex) :: beta
      complex(c_double_complex),target :: y
      integer(c_int),value :: incy
      integer(c_int),value :: batch_count
      !
      rocblas_zgbmv_batched_rank_0 = rocblas_zgbmv_batched_orig(handle,trans,m,n,kl,ku,alpha,c_loc(A),lda,c_loc(x),incx,beta,c_loc(y),incy,batch_count)
    end function

    function rocblas_zgbmv_batched_rank_1(handle,trans,m,n,kl,ku,alpha,A,lda,x,incx,beta,y,incy,batch_count)
      use iso_c_binding
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocblas_zgbmv_batched_rank_1
      type(c_ptr),value :: handle
      integer(kind(rocblas_operation_none)),value :: trans
      integer(c_int),value :: m
      integer(c_int),value :: n
      integer(c_int),value :: kl
      integer(c_int),value :: ku
      complex(c_double_complex) :: alpha
      complex(c_double_complex),target,dimension(:) :: A
      integer(c_int),value :: lda
      complex(c_double_complex),target,dimension(:) :: x
      integer(c_int),value :: incx
      complex(c_double_complex) :: beta
      complex(c_double_complex),target,dimension(:) :: y
      integer(c_int),value :: incy
      integer(c_int),value :: batch_count
      !
      rocblas_zgbmv_batched_rank_1 = rocblas_zgbmv_batched_orig(handle,trans,m,n,kl,ku,alpha,c_loc(A),lda,c_loc(x),incx,beta,c_loc(y),incy,batch_count)
    end function

    function rocblas_sgbmv_strided_batched_full_rank(handle,trans,m,n,kl,ku,alpha,A,lda,stride_A,x,incx,stride_x,beta,y,incy,stride_y,batch_count)
      use iso_c_binding
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocblas_sgbmv_strided_batched_full_rank
      type(c_ptr),value :: handle
      integer(kind(rocblas_operation_none)),value :: trans
      integer(c_int),value :: m
      integer(c_int),value :: n
      integer(c_int),value :: kl
      integer(c_int),value :: ku
      real(c_float) :: alpha
      real(c_float),target,dimension(:,:) :: A
      integer(c_int),value :: lda
      integer(c_int64_t),value :: stride_A
      real(c_float),target,dimension(:) :: x
      integer(c_int),value :: incx
      integer(c_int64_t),value :: stride_x
      real(c_float) :: beta
      real(c_float),target,dimension(:) :: y
      integer(c_int),value :: incy
      integer(c_int64_t),value :: stride_y
      integer(c_int),value :: batch_count
      !
      rocblas_sgbmv_strided_batched_full_rank = rocblas_sgbmv_strided_batched_orig(handle,trans,m,n,kl,ku,alpha,c_loc(A),lda,stride_A,c_loc(x),incx,stride_x,beta,c_loc(y),incy,stride_y,batch_count)
    end function

    function rocblas_sgbmv_strided_batched_rank_0(handle,trans,m,n,kl,ku,alpha,A,lda,stride_A,x,incx,stride_x,beta,y,incy,stride_y,batch_count)
      use iso_c_binding
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocblas_sgbmv_strided_batched_rank_0
      type(c_ptr),value :: handle
      integer(kind(rocblas_operation_none)),value :: trans
      integer(c_int),value :: m
      integer(c_int),value :: n
      integer(c_int),value :: kl
      integer(c_int),value :: ku
      real(c_float) :: alpha
      real(c_float),target :: A
      integer(c_int),value :: lda
      integer(c_int64_t),value :: stride_A
      real(c_float),target :: x
      integer(c_int),value :: incx
      integer(c_int64_t),value :: stride_x
      real(c_float) :: beta
      real(c_float),target :: y
      integer(c_int),value :: incy
      integer(c_int64_t),value :: stride_y
      integer(c_int),value :: batch_count
      !
      rocblas_sgbmv_strided_batched_rank_0 = rocblas_sgbmv_strided_batched_orig(handle,trans,m,n,kl,ku,alpha,c_loc(A),lda,stride_A,c_loc(x),incx,stride_x,beta,c_loc(y),incy,stride_y,batch_count)
    end function

    function rocblas_sgbmv_strided_batched_rank_1(handle,trans,m,n,kl,ku,alpha,A,lda,stride_A,x,incx,stride_x,beta,y,incy,stride_y,batch_count)
      use iso_c_binding
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocblas_sgbmv_strided_batched_rank_1
      type(c_ptr),value :: handle
      integer(kind(rocblas_operation_none)),value :: trans
      integer(c_int),value :: m
      integer(c_int),value :: n
      integer(c_int),value :: kl
      integer(c_int),value :: ku
      real(c_float) :: alpha
      real(c_float),target,dimension(:) :: A
      integer(c_int),value :: lda
      integer(c_int64_t),value :: stride_A
      real(c_float),target,dimension(:) :: x
      integer(c_int),value :: incx
      integer(c_int64_t),value :: stride_x
      real(c_float) :: beta
      real(c_float),target,dimension(:) :: y
      integer(c_int),value :: incy
      integer(c_int64_t),value :: stride_y
      integer(c_int),value :: batch_count
      !
      rocblas_sgbmv_strided_batched_rank_1 = rocblas_sgbmv_strided_batched_orig(handle,trans,m,n,kl,ku,alpha,c_loc(A),lda,stride_A,c_loc(x),incx,stride_x,beta,c_loc(y),incy,stride_y,batch_count)
    end function

    function rocblas_dgbmv_strided_batched_full_rank(handle,trans,m,n,kl,ku,alpha,A,lda,stride_A,x,incx,stride_x,beta,y,incy,stride_y,batch_count)
      use iso_c_binding
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocblas_dgbmv_strided_batched_full_rank
      type(c_ptr),value :: handle
      integer(kind(rocblas_operation_none)),value :: trans
      integer(c_int),value :: m
      integer(c_int),value :: n
      integer(c_int),value :: kl
      integer(c_int),value :: ku
      real(c_double) :: alpha
      real(c_double),target,dimension(:,:) :: A
      integer(c_int),value :: lda
      integer(c_int64_t),value :: stride_A
      real(c_double),target,dimension(:) :: x
      integer(c_int),value :: incx
      integer(c_int64_t),value :: stride_x
      real(c_double) :: beta
      real(c_double),target,dimension(:) :: y
      integer(c_int),value :: incy
      integer(c_int64_t),value :: stride_y
      integer(c_int),value :: batch_count
      !
      rocblas_dgbmv_strided_batched_full_rank = rocblas_dgbmv_strided_batched_orig(handle,trans,m,n,kl,ku,alpha,c_loc(A),lda,stride_A,c_loc(x),incx,stride_x,beta,c_loc(y),incy,stride_y,batch_count)
    end function

    function rocblas_dgbmv_strided_batched_rank_0(handle,trans,m,n,kl,ku,alpha,A,lda,stride_A,x,incx,stride_x,beta,y,incy,stride_y,batch_count)
      use iso_c_binding
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocblas_dgbmv_strided_batched_rank_0
      type(c_ptr),value :: handle
      integer(kind(rocblas_operation_none)),value :: trans
      integer(c_int),value :: m
      integer(c_int),value :: n
      integer(c_int),value :: kl
      integer(c_int),value :: ku
      real(c_double) :: alpha
      real(c_double),target :: A
      integer(c_int),value :: lda
      integer(c_int64_t),value :: stride_A
      real(c_double),target :: x
      integer(c_int),value :: incx
      integer(c_int64_t),value :: stride_x
      real(c_double) :: beta
      real(c_double),target :: y
      integer(c_int),value :: incy
      integer(c_int64_t),value :: stride_y
      integer(c_int),value :: batch_count
      !
      rocblas_dgbmv_strided_batched_rank_0 = rocblas_dgbmv_strided_batched_orig(handle,trans,m,n,kl,ku,alpha,c_loc(A),lda,stride_A,c_loc(x),incx,stride_x,beta,c_loc(y),incy,stride_y,batch_count)
    end function

    function rocblas_dgbmv_strided_batched_rank_1(handle,trans,m,n,kl,ku,alpha,A,lda,stride_A,x,incx,stride_x,beta,y,incy,stride_y,batch_count)
      use iso_c_binding
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocblas_dgbmv_strided_batched_rank_1
      type(c_ptr),value :: handle
      integer(kind(rocblas_operation_none)),value :: trans
      integer(c_int),value :: m
      integer(c_int),value :: n
      integer(c_int),value :: kl
      integer(c_int),value :: ku
      real(c_double) :: alpha
      real(c_double),target,dimension(:) :: A
      integer(c_int),value :: lda
      integer(c_int64_t),value :: stride_A
      real(c_double),target,dimension(:) :: x
      integer(c_int),value :: incx
      integer(c_int64_t),value :: stride_x
      real(c_double) :: beta
      real(c_double),target,dimension(:) :: y
      integer(c_int),value :: incy
      integer(c_int64_t),value :: stride_y
      integer(c_int),value :: batch_count
      !
      rocblas_dgbmv_strided_batched_rank_1 = rocblas_dgbmv_strided_batched_orig(handle,trans,m,n,kl,ku,alpha,c_loc(A),lda,stride_A,c_loc(x),incx,stride_x,beta,c_loc(y),incy,stride_y,batch_count)
    end function

    function rocblas_cgbmv_strided_batched_full_rank(handle,trans,m,n,kl,ku,alpha,A,lda,stride_A,x,incx,stride_x,beta,y,incy,stride_y,batch_count)
      use iso_c_binding
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocblas_cgbmv_strided_batched_full_rank
      type(c_ptr),value :: handle
      integer(kind(rocblas_operation_none)),value :: trans
      integer(c_int),value :: m
      integer(c_int),value :: n
      integer(c_int),value :: kl
      integer(c_int),value :: ku
      complex(c_float_complex) :: alpha
      complex(c_float_complex),target,dimension(:,:) :: A
      integer(c_int),value :: lda
      integer(c_int64_t),value :: stride_A
      complex(c_float_complex),target,dimension(:) :: x
      integer(c_int),value :: incx
      integer(c_int64_t),value :: stride_x
      complex(c_float_complex) :: beta
      complex(c_float_complex),target,dimension(:) :: y
      integer(c_int),value :: incy
      integer(c_int64_t),value :: stride_y
      integer(c_int),value :: batch_count
      !
      rocblas_cgbmv_strided_batched_full_rank = rocblas_cgbmv_strided_batched_orig(handle,trans,m,n,kl,ku,alpha,c_loc(A),lda,stride_A,c_loc(x),incx,stride_x,beta,c_loc(y),incy,stride_y,batch_count)
    end function

    function rocblas_cgbmv_strided_batched_rank_0(handle,trans,m,n,kl,ku,alpha,A,lda,stride_A,x,incx,stride_x,beta,y,incy,stride_y,batch_count)
      use iso_c_binding
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocblas_cgbmv_strided_batched_rank_0
      type(c_ptr),value :: handle
      integer(kind(rocblas_operation_none)),value :: trans
      integer(c_int),value :: m
      integer(c_int),value :: n
      integer(c_int),value :: kl
      integer(c_int),value :: ku
      complex(c_float_complex) :: alpha
      complex(c_float_complex),target :: A
      integer(c_int),value :: lda
      integer(c_int64_t),value :: stride_A
      complex(c_float_complex),target :: x
      integer(c_int),value :: incx
      integer(c_int64_t),value :: stride_x
      complex(c_float_complex) :: beta
      complex(c_float_complex),target :: y
      integer(c_int),value :: incy
      integer(c_int64_t),value :: stride_y
      integer(c_int),value :: batch_count
      !
      rocblas_cgbmv_strided_batched_rank_0 = rocblas_cgbmv_strided_batched_orig(handle,trans,m,n,kl,ku,alpha,c_loc(A),lda,stride_A,c_loc(x),incx,stride_x,beta,c_loc(y),incy,stride_y,batch_count)
    end function

    function rocblas_cgbmv_strided_batched_rank_1(handle,trans,m,n,kl,ku,alpha,A,lda,stride_A,x,incx,stride_x,beta,y,incy,stride_y,batch_count)
      use iso_c_binding
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocblas_cgbmv_strided_batched_rank_1
      type(c_ptr),value :: handle
      integer(kind(rocblas_operation_none)),value :: trans
      integer(c_int),value :: m
      integer(c_int),value :: n
      integer(c_int),value :: kl
      integer(c_int),value :: ku
      complex(c_float_complex) :: alpha
      complex(c_float_complex),target,dimension(:) :: A
      integer(c_int),value :: lda
      integer(c_int64_t),value :: stride_A
      complex(c_float_complex),target,dimension(:) :: x
      integer(c_int),value :: incx
      integer(c_int64_t),value :: stride_x
      complex(c_float_complex) :: beta
      complex(c_float_complex),target,dimension(:) :: y
      integer(c_int),value :: incy
      integer(c_int64_t),value :: stride_y
      integer(c_int),value :: batch_count
      !
      rocblas_cgbmv_strided_batched_rank_1 = rocblas_cgbmv_strided_batched_orig(handle,trans,m,n,kl,ku,alpha,c_loc(A),lda,stride_A,c_loc(x),incx,stride_x,beta,c_loc(y),incy,stride_y,batch_count)
    end function

    function rocblas_zgbmv_strided_batched_full_rank(handle,trans,m,n,kl,ku,alpha,A,lda,stride_A,x,incx,stride_x,beta,y,incy,stride_y,batch_count)
      use iso_c_binding
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocblas_zgbmv_strided_batched_full_rank
      type(c_ptr),value :: handle
      integer(kind(rocblas_operation_none)),value :: trans
      integer(c_int),value :: m
      integer(c_int),value :: n
      integer(c_int),value :: kl
      integer(c_int),value :: ku
      complex(c_double_complex) :: alpha
      complex(c_double_complex),target,dimension(:,:) :: A
      integer(c_int),value :: lda
      integer(c_int64_t),value :: stride_A
      complex(c_double_complex),target,dimension(:) :: x
      integer(c_int),value :: incx
      integer(c_int64_t),value :: stride_x
      complex(c_double_complex) :: beta
      complex(c_double_complex),target,dimension(:) :: y
      integer(c_int),value :: incy
      integer(c_int64_t),value :: stride_y
      integer(c_int),value :: batch_count
      !
      rocblas_zgbmv_strided_batched_full_rank = rocblas_zgbmv_strided_batched_orig(handle,trans,m,n,kl,ku,alpha,c_loc(A),lda,stride_A,c_loc(x),incx,stride_x,beta,c_loc(y),incy,stride_y,batch_count)
    end function

    function rocblas_zgbmv_strided_batched_rank_0(handle,trans,m,n,kl,ku,alpha,A,lda,stride_A,x,incx,stride_x,beta,y,incy,stride_y,batch_count)
      use iso_c_binding
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocblas_zgbmv_strided_batched_rank_0
      type(c_ptr),value :: handle
      integer(kind(rocblas_operation_none)),value :: trans
      integer(c_int),value :: m
      integer(c_int),value :: n
      integer(c_int),value :: kl
      integer(c_int),value :: ku
      complex(c_double_complex) :: alpha
      complex(c_double_complex),target :: A
      integer(c_int),value :: lda
      integer(c_int64_t),value :: stride_A
      complex(c_double_complex),target :: x
      integer(c_int),value :: incx
      integer(c_int64_t),value :: stride_x
      complex(c_double_complex) :: beta
      complex(c_double_complex),target :: y
      integer(c_int),value :: incy
      integer(c_int64_t),value :: stride_y
      integer(c_int),value :: batch_count
      !
      rocblas_zgbmv_strided_batched_rank_0 = rocblas_zgbmv_strided_batched_orig(handle,trans,m,n,kl,ku,alpha,c_loc(A),lda,stride_A,c_loc(x),incx,stride_x,beta,c_loc(y),incy,stride_y,batch_count)
    end function

    function rocblas_zgbmv_strided_batched_rank_1(handle,trans,m,n,kl,ku,alpha,A,lda,stride_A,x,incx,stride_x,beta,y,incy,stride_y,batch_count)
      use iso_c_binding
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocblas_zgbmv_strided_batched_rank_1
      type(c_ptr),value :: handle
      integer(kind(rocblas_operation_none)),value :: trans
      integer(c_int),value :: m
      integer(c_int),value :: n
      integer(c_int),value :: kl
      integer(c_int),value :: ku
      complex(c_double_complex) :: alpha
      complex(c_double_complex),target,dimension(:) :: A
      integer(c_int),value :: lda
      integer(c_int64_t),value :: stride_A
      complex(c_double_complex),target,dimension(:) :: x
      integer(c_int),value :: incx
      integer(c_int64_t),value :: stride_x
      complex(c_double_complex) :: beta
      complex(c_double_complex),target,dimension(:) :: y
      integer(c_int),value :: incy
      integer(c_int64_t),value :: stride_y
      integer(c_int),value :: batch_count
      !
      rocblas_zgbmv_strided_batched_rank_1 = rocblas_zgbmv_strided_batched_orig(handle,trans,m,n,kl,ku,alpha,c_loc(A),lda,stride_A,c_loc(x),incx,stride_x,beta,c_loc(y),incy,stride_y,batch_count)
    end function

    function rocblas_sgemv_full_rank(handle,trans,m,n,alpha,A,lda,x,incx,beta,y,incy)
      use iso_c_binding
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocblas_sgemv_full_rank
      type(c_ptr),value :: handle
      integer(kind(rocblas_operation_none)),value :: trans
      integer(c_int),value :: m
      integer(c_int),value :: n
      real(c_float) :: alpha
      real(c_float),target,dimension(:,:) :: A
      integer(c_int),value :: lda
      real(c_float),target,dimension(:) :: x
      integer(c_int),value :: incx
      real(c_float) :: beta
      real(c_float),target,dimension(:) :: y
      integer(c_int),value :: incy
      !
      rocblas_sgemv_full_rank = rocblas_sgemv_orig(handle,trans,m,n,alpha,c_loc(A),lda,c_loc(x),incx,beta,c_loc(y),incy)
    end function

    function rocblas_sgemv_rank_0(handle,trans,m,n,alpha,A,lda,x,incx,beta,y,incy)
      use iso_c_binding
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocblas_sgemv_rank_0
      type(c_ptr),value :: handle
      integer(kind(rocblas_operation_none)),value :: trans
      integer(c_int),value :: m
      integer(c_int),value :: n
      real(c_float) :: alpha
      real(c_float),target :: A
      integer(c_int),value :: lda
      real(c_float),target :: x
      integer(c_int),value :: incx
      real(c_float) :: beta
      real(c_float),target :: y
      integer(c_int),value :: incy
      !
      rocblas_sgemv_rank_0 = rocblas_sgemv_orig(handle,trans,m,n,alpha,c_loc(A),lda,c_loc(x),incx,beta,c_loc(y),incy)
    end function

    function rocblas_sgemv_rank_1(handle,trans,m,n,alpha,A,lda,x,incx,beta,y,incy)
      use iso_c_binding
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocblas_sgemv_rank_1
      type(c_ptr),value :: handle
      integer(kind(rocblas_operation_none)),value :: trans
      integer(c_int),value :: m
      integer(c_int),value :: n
      real(c_float) :: alpha
      real(c_float),target,dimension(:) :: A
      integer(c_int),value :: lda
      real(c_float),target,dimension(:) :: x
      integer(c_int),value :: incx
      real(c_float) :: beta
      real(c_float),target,dimension(:) :: y
      integer(c_int),value :: incy
      !
      rocblas_sgemv_rank_1 = rocblas_sgemv_orig(handle,trans,m,n,alpha,c_loc(A),lda,c_loc(x),incx,beta,c_loc(y),incy)
    end function

    function rocblas_dgemv_full_rank(handle,trans,m,n,alpha,A,lda,x,incx,beta,y,incy)
      use iso_c_binding
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocblas_dgemv_full_rank
      type(c_ptr),value :: handle
      integer(kind(rocblas_operation_none)),value :: trans
      integer(c_int),value :: m
      integer(c_int),value :: n
      real(c_double) :: alpha
      real(c_double),target,dimension(:,:) :: A
      integer(c_int),value :: lda
      real(c_double),target,dimension(:) :: x
      integer(c_int),value :: incx
      real(c_double) :: beta
      real(c_double),target,dimension(:) :: y
      integer(c_int),value :: incy
      !
      rocblas_dgemv_full_rank = rocblas_dgemv_orig(handle,trans,m,n,alpha,c_loc(A),lda,c_loc(x),incx,beta,c_loc(y),incy)
    end function

    function rocblas_dgemv_rank_0(handle,trans,m,n,alpha,A,lda,x,incx,beta,y,incy)
      use iso_c_binding
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocblas_dgemv_rank_0
      type(c_ptr),value :: handle
      integer(kind(rocblas_operation_none)),value :: trans
      integer(c_int),value :: m
      integer(c_int),value :: n
      real(c_double) :: alpha
      real(c_double),target :: A
      integer(c_int),value :: lda
      real(c_double),target :: x
      integer(c_int),value :: incx
      real(c_double) :: beta
      real(c_double),target :: y
      integer(c_int),value :: incy
      !
      rocblas_dgemv_rank_0 = rocblas_dgemv_orig(handle,trans,m,n,alpha,c_loc(A),lda,c_loc(x),incx,beta,c_loc(y),incy)
    end function

    function rocblas_dgemv_rank_1(handle,trans,m,n,alpha,A,lda,x,incx,beta,y,incy)
      use iso_c_binding
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocblas_dgemv_rank_1
      type(c_ptr),value :: handle
      integer(kind(rocblas_operation_none)),value :: trans
      integer(c_int),value :: m
      integer(c_int),value :: n
      real(c_double) :: alpha
      real(c_double),target,dimension(:) :: A
      integer(c_int),value :: lda
      real(c_double),target,dimension(:) :: x
      integer(c_int),value :: incx
      real(c_double) :: beta
      real(c_double),target,dimension(:) :: y
      integer(c_int),value :: incy
      !
      rocblas_dgemv_rank_1 = rocblas_dgemv_orig(handle,trans,m,n,alpha,c_loc(A),lda,c_loc(x),incx,beta,c_loc(y),incy)
    end function

    function rocblas_cgemv_full_rank(handle,trans,m,n,alpha,A,lda,x,incx,beta,y,incy)
      use iso_c_binding
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocblas_cgemv_full_rank
      type(c_ptr),value :: handle
      integer(kind(rocblas_operation_none)),value :: trans
      integer(c_int),value :: m
      integer(c_int),value :: n
      complex(c_float_complex) :: alpha
      complex(c_float_complex),target,dimension(:,:) :: A
      integer(c_int),value :: lda
      complex(c_float_complex),target,dimension(:) :: x
      integer(c_int),value :: incx
      complex(c_float_complex) :: beta
      complex(c_float_complex),target,dimension(:) :: y
      integer(c_int),value :: incy
      !
      rocblas_cgemv_full_rank = rocblas_cgemv_orig(handle,trans,m,n,alpha,c_loc(A),lda,c_loc(x),incx,beta,c_loc(y),incy)
    end function

    function rocblas_cgemv_rank_0(handle,trans,m,n,alpha,A,lda,x,incx,beta,y,incy)
      use iso_c_binding
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocblas_cgemv_rank_0
      type(c_ptr),value :: handle
      integer(kind(rocblas_operation_none)),value :: trans
      integer(c_int),value :: m
      integer(c_int),value :: n
      complex(c_float_complex) :: alpha
      complex(c_float_complex),target :: A
      integer(c_int),value :: lda
      complex(c_float_complex),target :: x
      integer(c_int),value :: incx
      complex(c_float_complex) :: beta
      complex(c_float_complex),target :: y
      integer(c_int),value :: incy
      !
      rocblas_cgemv_rank_0 = rocblas_cgemv_orig(handle,trans,m,n,alpha,c_loc(A),lda,c_loc(x),incx,beta,c_loc(y),incy)
    end function

    function rocblas_cgemv_rank_1(handle,trans,m,n,alpha,A,lda,x,incx,beta,y,incy)
      use iso_c_binding
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocblas_cgemv_rank_1
      type(c_ptr),value :: handle
      integer(kind(rocblas_operation_none)),value :: trans
      integer(c_int),value :: m
      integer(c_int),value :: n
      complex(c_float_complex) :: alpha
      complex(c_float_complex),target,dimension(:) :: A
      integer(c_int),value :: lda
      complex(c_float_complex),target,dimension(:) :: x
      integer(c_int),value :: incx
      complex(c_float_complex) :: beta
      complex(c_float_complex),target,dimension(:) :: y
      integer(c_int),value :: incy
      !
      rocblas_cgemv_rank_1 = rocblas_cgemv_orig(handle,trans,m,n,alpha,c_loc(A),lda,c_loc(x),incx,beta,c_loc(y),incy)
    end function

    function rocblas_zgemv_full_rank(handle,trans,m,n,alpha,A,lda,x,incx,beta,y,incy)
      use iso_c_binding
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocblas_zgemv_full_rank
      type(c_ptr),value :: handle
      integer(kind(rocblas_operation_none)),value :: trans
      integer(c_int),value :: m
      integer(c_int),value :: n
      complex(c_double_complex) :: alpha
      complex(c_double_complex),target,dimension(:,:) :: A
      integer(c_int),value :: lda
      complex(c_double_complex),target,dimension(:) :: x
      integer(c_int),value :: incx
      complex(c_double_complex) :: beta
      complex(c_double_complex),target,dimension(:) :: y
      integer(c_int),value :: incy
      !
      rocblas_zgemv_full_rank = rocblas_zgemv_orig(handle,trans,m,n,alpha,c_loc(A),lda,c_loc(x),incx,beta,c_loc(y),incy)
    end function

    function rocblas_zgemv_rank_0(handle,trans,m,n,alpha,A,lda,x,incx,beta,y,incy)
      use iso_c_binding
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocblas_zgemv_rank_0
      type(c_ptr),value :: handle
      integer(kind(rocblas_operation_none)),value :: trans
      integer(c_int),value :: m
      integer(c_int),value :: n
      complex(c_double_complex) :: alpha
      complex(c_double_complex),target :: A
      integer(c_int),value :: lda
      complex(c_double_complex),target :: x
      integer(c_int),value :: incx
      complex(c_double_complex) :: beta
      complex(c_double_complex),target :: y
      integer(c_int),value :: incy
      !
      rocblas_zgemv_rank_0 = rocblas_zgemv_orig(handle,trans,m,n,alpha,c_loc(A),lda,c_loc(x),incx,beta,c_loc(y),incy)
    end function

    function rocblas_zgemv_rank_1(handle,trans,m,n,alpha,A,lda,x,incx,beta,y,incy)
      use iso_c_binding
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocblas_zgemv_rank_1
      type(c_ptr),value :: handle
      integer(kind(rocblas_operation_none)),value :: trans
      integer(c_int),value :: m
      integer(c_int),value :: n
      complex(c_double_complex) :: alpha
      complex(c_double_complex),target,dimension(:) :: A
      integer(c_int),value :: lda
      complex(c_double_complex),target,dimension(:) :: x
      integer(c_int),value :: incx
      complex(c_double_complex) :: beta
      complex(c_double_complex),target,dimension(:) :: y
      integer(c_int),value :: incy
      !
      rocblas_zgemv_rank_1 = rocblas_zgemv_orig(handle,trans,m,n,alpha,c_loc(A),lda,c_loc(x),incx,beta,c_loc(y),incy)
    end function

    function rocblas_sgemv_batched_full_rank(handle,trans,m,n,alpha,A,lda,x,incx,beta,y,incy,batch_count)
      use iso_c_binding
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocblas_sgemv_batched_full_rank
      type(c_ptr),value :: handle
      integer(kind(rocblas_operation_none)),value :: trans
      integer(c_int),value :: m
      integer(c_int),value :: n
      real(c_float) :: alpha
      real(c_float),target,dimension(:,:,:) :: A
      integer(c_int),value :: lda
      real(c_float),target,dimension(:,:) :: x
      integer(c_int),value :: incx
      real(c_float) :: beta
      real(c_float),target,dimension(:,:) :: y
      integer(c_int),value :: incy
      integer(c_int),value :: batch_count
      !
      rocblas_sgemv_batched_full_rank = rocblas_sgemv_batched_orig(handle,trans,m,n,alpha,c_loc(A),lda,c_loc(x),incx,beta,c_loc(y),incy,batch_count)
    end function

    function rocblas_sgemv_batched_rank_0(handle,trans,m,n,alpha,A,lda,x,incx,beta,y,incy,batch_count)
      use iso_c_binding
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocblas_sgemv_batched_rank_0
      type(c_ptr),value :: handle
      integer(kind(rocblas_operation_none)),value :: trans
      integer(c_int),value :: m
      integer(c_int),value :: n
      real(c_float) :: alpha
      real(c_float),target :: A
      integer(c_int),value :: lda
      real(c_float),target :: x
      integer(c_int),value :: incx
      real(c_float) :: beta
      real(c_float),target :: y
      integer(c_int),value :: incy
      integer(c_int),value :: batch_count
      !
      rocblas_sgemv_batched_rank_0 = rocblas_sgemv_batched_orig(handle,trans,m,n,alpha,c_loc(A),lda,c_loc(x),incx,beta,c_loc(y),incy,batch_count)
    end function

    function rocblas_sgemv_batched_rank_1(handle,trans,m,n,alpha,A,lda,x,incx,beta,y,incy,batch_count)
      use iso_c_binding
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocblas_sgemv_batched_rank_1
      type(c_ptr),value :: handle
      integer(kind(rocblas_operation_none)),value :: trans
      integer(c_int),value :: m
      integer(c_int),value :: n
      real(c_float) :: alpha
      real(c_float),target,dimension(:) :: A
      integer(c_int),value :: lda
      real(c_float),target,dimension(:) :: x
      integer(c_int),value :: incx
      real(c_float) :: beta
      real(c_float),target,dimension(:) :: y
      integer(c_int),value :: incy
      integer(c_int),value :: batch_count
      !
      rocblas_sgemv_batched_rank_1 = rocblas_sgemv_batched_orig(handle,trans,m,n,alpha,c_loc(A),lda,c_loc(x),incx,beta,c_loc(y),incy,batch_count)
    end function

    function rocblas_dgemv_batched_full_rank(handle,trans,m,n,alpha,A,lda,x,incx,beta,y,incy,batch_count)
      use iso_c_binding
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocblas_dgemv_batched_full_rank
      type(c_ptr),value :: handle
      integer(kind(rocblas_operation_none)),value :: trans
      integer(c_int),value :: m
      integer(c_int),value :: n
      real(c_double) :: alpha
      real(c_double),target,dimension(:,:,:) :: A
      integer(c_int),value :: lda
      real(c_double),target,dimension(:,:) :: x
      integer(c_int),value :: incx
      real(c_double) :: beta
      real(c_double),target,dimension(:,:) :: y
      integer(c_int),value :: incy
      integer(c_int),value :: batch_count
      !
      rocblas_dgemv_batched_full_rank = rocblas_dgemv_batched_orig(handle,trans,m,n,alpha,c_loc(A),lda,c_loc(x),incx,beta,c_loc(y),incy,batch_count)
    end function

    function rocblas_dgemv_batched_rank_0(handle,trans,m,n,alpha,A,lda,x,incx,beta,y,incy,batch_count)
      use iso_c_binding
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocblas_dgemv_batched_rank_0
      type(c_ptr),value :: handle
      integer(kind(rocblas_operation_none)),value :: trans
      integer(c_int),value :: m
      integer(c_int),value :: n
      real(c_double) :: alpha
      real(c_double),target :: A
      integer(c_int),value :: lda
      real(c_double),target :: x
      integer(c_int),value :: incx
      real(c_double) :: beta
      real(c_double),target :: y
      integer(c_int),value :: incy
      integer(c_int),value :: batch_count
      !
      rocblas_dgemv_batched_rank_0 = rocblas_dgemv_batched_orig(handle,trans,m,n,alpha,c_loc(A),lda,c_loc(x),incx,beta,c_loc(y),incy,batch_count)
    end function

    function rocblas_dgemv_batched_rank_1(handle,trans,m,n,alpha,A,lda,x,incx,beta,y,incy,batch_count)
      use iso_c_binding
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocblas_dgemv_batched_rank_1
      type(c_ptr),value :: handle
      integer(kind(rocblas_operation_none)),value :: trans
      integer(c_int),value :: m
      integer(c_int),value :: n
      real(c_double) :: alpha
      real(c_double),target,dimension(:) :: A
      integer(c_int),value :: lda
      real(c_double),target,dimension(:) :: x
      integer(c_int),value :: incx
      real(c_double) :: beta
      real(c_double),target,dimension(:) :: y
      integer(c_int),value :: incy
      integer(c_int),value :: batch_count
      !
      rocblas_dgemv_batched_rank_1 = rocblas_dgemv_batched_orig(handle,trans,m,n,alpha,c_loc(A),lda,c_loc(x),incx,beta,c_loc(y),incy,batch_count)
    end function

    function rocblas_cgemv_batched_full_rank(handle,trans,m,n,alpha,A,lda,x,incx,beta,y,incy,batch_count)
      use iso_c_binding
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocblas_cgemv_batched_full_rank
      type(c_ptr),value :: handle
      integer(kind(rocblas_operation_none)),value :: trans
      integer(c_int),value :: m
      integer(c_int),value :: n
      complex(c_float_complex) :: alpha
      complex(c_float_complex),target,dimension(:,:,:) :: A
      integer(c_int),value :: lda
      complex(c_float_complex),target,dimension(:,:) :: x
      integer(c_int),value :: incx
      complex(c_float_complex) :: beta
      complex(c_float_complex),target,dimension(:,:) :: y
      integer(c_int),value :: incy
      integer(c_int),value :: batch_count
      !
      rocblas_cgemv_batched_full_rank = rocblas_cgemv_batched_orig(handle,trans,m,n,alpha,c_loc(A),lda,c_loc(x),incx,beta,c_loc(y),incy,batch_count)
    end function

    function rocblas_cgemv_batched_rank_0(handle,trans,m,n,alpha,A,lda,x,incx,beta,y,incy,batch_count)
      use iso_c_binding
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocblas_cgemv_batched_rank_0
      type(c_ptr),value :: handle
      integer(kind(rocblas_operation_none)),value :: trans
      integer(c_int),value :: m
      integer(c_int),value :: n
      complex(c_float_complex) :: alpha
      complex(c_float_complex),target :: A
      integer(c_int),value :: lda
      complex(c_float_complex),target :: x
      integer(c_int),value :: incx
      complex(c_float_complex) :: beta
      complex(c_float_complex),target :: y
      integer(c_int),value :: incy
      integer(c_int),value :: batch_count
      !
      rocblas_cgemv_batched_rank_0 = rocblas_cgemv_batched_orig(handle,trans,m,n,alpha,c_loc(A),lda,c_loc(x),incx,beta,c_loc(y),incy,batch_count)
    end function

    function rocblas_cgemv_batched_rank_1(handle,trans,m,n,alpha,A,lda,x,incx,beta,y,incy,batch_count)
      use iso_c_binding
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocblas_cgemv_batched_rank_1
      type(c_ptr),value :: handle
      integer(kind(rocblas_operation_none)),value :: trans
      integer(c_int),value :: m
      integer(c_int),value :: n
      complex(c_float_complex) :: alpha
      complex(c_float_complex),target,dimension(:) :: A
      integer(c_int),value :: lda
      complex(c_float_complex),target,dimension(:) :: x
      integer(c_int),value :: incx
      complex(c_float_complex) :: beta
      complex(c_float_complex),target,dimension(:) :: y
      integer(c_int),value :: incy
      integer(c_int),value :: batch_count
      !
      rocblas_cgemv_batched_rank_1 = rocblas_cgemv_batched_orig(handle,trans,m,n,alpha,c_loc(A),lda,c_loc(x),incx,beta,c_loc(y),incy,batch_count)
    end function

    function rocblas_zgemv_batched_full_rank(handle,trans,m,n,alpha,A,lda,x,incx,beta,y,incy,batch_count)
      use iso_c_binding
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocblas_zgemv_batched_full_rank
      type(c_ptr),value :: handle
      integer(kind(rocblas_operation_none)),value :: trans
      integer(c_int),value :: m
      integer(c_int),value :: n
      complex(c_double_complex) :: alpha
      complex(c_double_complex),target,dimension(:,:,:) :: A
      integer(c_int),value :: lda
      complex(c_double_complex),target,dimension(:,:) :: x
      integer(c_int),value :: incx
      complex(c_double_complex) :: beta
      complex(c_double_complex),target,dimension(:,:) :: y
      integer(c_int),value :: incy
      integer(c_int),value :: batch_count
      !
      rocblas_zgemv_batched_full_rank = rocblas_zgemv_batched_orig(handle,trans,m,n,alpha,c_loc(A),lda,c_loc(x),incx,beta,c_loc(y),incy,batch_count)
    end function

    function rocblas_zgemv_batched_rank_0(handle,trans,m,n,alpha,A,lda,x,incx,beta,y,incy,batch_count)
      use iso_c_binding
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocblas_zgemv_batched_rank_0
      type(c_ptr),value :: handle
      integer(kind(rocblas_operation_none)),value :: trans
      integer(c_int),value :: m
      integer(c_int),value :: n
      complex(c_double_complex) :: alpha
      complex(c_double_complex),target :: A
      integer(c_int),value :: lda
      complex(c_double_complex),target :: x
      integer(c_int),value :: incx
      complex(c_double_complex) :: beta
      complex(c_double_complex),target :: y
      integer(c_int),value :: incy
      integer(c_int),value :: batch_count
      !
      rocblas_zgemv_batched_rank_0 = rocblas_zgemv_batched_orig(handle,trans,m,n,alpha,c_loc(A),lda,c_loc(x),incx,beta,c_loc(y),incy,batch_count)
    end function

    function rocblas_zgemv_batched_rank_1(handle,trans,m,n,alpha,A,lda,x,incx,beta,y,incy,batch_count)
      use iso_c_binding
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocblas_zgemv_batched_rank_1
      type(c_ptr),value :: handle
      integer(kind(rocblas_operation_none)),value :: trans
      integer(c_int),value :: m
      integer(c_int),value :: n
      complex(c_double_complex) :: alpha
      complex(c_double_complex),target,dimension(:) :: A
      integer(c_int),value :: lda
      complex(c_double_complex),target,dimension(:) :: x
      integer(c_int),value :: incx
      complex(c_double_complex) :: beta
      complex(c_double_complex),target,dimension(:) :: y
      integer(c_int),value :: incy
      integer(c_int),value :: batch_count
      !
      rocblas_zgemv_batched_rank_1 = rocblas_zgemv_batched_orig(handle,trans,m,n,alpha,c_loc(A),lda,c_loc(x),incx,beta,c_loc(y),incy,batch_count)
    end function

    function rocblas_sgemv_strided_batched_full_rank(handle,transA,m,n,alpha,A,lda,strideA,x,incx,stridex,beta,y,incy,stridey,batch_count)
      use iso_c_binding
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocblas_sgemv_strided_batched_full_rank
      type(c_ptr),value :: handle
      integer(kind(rocblas_operation_none)),value :: transA
      integer(c_int),value :: m
      integer(c_int),value :: n
      real(c_float) :: alpha
      real(c_float),target,dimension(:,:) :: A
      integer(c_int),value :: lda
      integer(c_int64_t),value :: strideA
      real(c_float),target,dimension(:) :: x
      integer(c_int),value :: incx
      integer(c_int64_t),value :: stridex
      real(c_float) :: beta
      real(c_float),target,dimension(:) :: y
      integer(c_int),value :: incy
      integer(c_int64_t),value :: stridey
      integer(c_int),value :: batch_count
      !
      rocblas_sgemv_strided_batched_full_rank = rocblas_sgemv_strided_batched_orig(handle,transA,m,n,alpha,c_loc(A),lda,strideA,c_loc(x),incx,stridex,beta,c_loc(y),incy,stridey,batch_count)
    end function

    function rocblas_sgemv_strided_batched_rank_0(handle,transA,m,n,alpha,A,lda,strideA,x,incx,stridex,beta,y,incy,stridey,batch_count)
      use iso_c_binding
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocblas_sgemv_strided_batched_rank_0
      type(c_ptr),value :: handle
      integer(kind(rocblas_operation_none)),value :: transA
      integer(c_int),value :: m
      integer(c_int),value :: n
      real(c_float) :: alpha
      real(c_float),target :: A
      integer(c_int),value :: lda
      integer(c_int64_t),value :: strideA
      real(c_float),target :: x
      integer(c_int),value :: incx
      integer(c_int64_t),value :: stridex
      real(c_float) :: beta
      real(c_float),target :: y
      integer(c_int),value :: incy
      integer(c_int64_t),value :: stridey
      integer(c_int),value :: batch_count
      !
      rocblas_sgemv_strided_batched_rank_0 = rocblas_sgemv_strided_batched_orig(handle,transA,m,n,alpha,c_loc(A),lda,strideA,c_loc(x),incx,stridex,beta,c_loc(y),incy,stridey,batch_count)
    end function

    function rocblas_sgemv_strided_batched_rank_1(handle,transA,m,n,alpha,A,lda,strideA,x,incx,stridex,beta,y,incy,stridey,batch_count)
      use iso_c_binding
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocblas_sgemv_strided_batched_rank_1
      type(c_ptr),value :: handle
      integer(kind(rocblas_operation_none)),value :: transA
      integer(c_int),value :: m
      integer(c_int),value :: n
      real(c_float) :: alpha
      real(c_float),target,dimension(:) :: A
      integer(c_int),value :: lda
      integer(c_int64_t),value :: strideA
      real(c_float),target,dimension(:) :: x
      integer(c_int),value :: incx
      integer(c_int64_t),value :: stridex
      real(c_float) :: beta
      real(c_float),target,dimension(:) :: y
      integer(c_int),value :: incy
      integer(c_int64_t),value :: stridey
      integer(c_int),value :: batch_count
      !
      rocblas_sgemv_strided_batched_rank_1 = rocblas_sgemv_strided_batched_orig(handle,transA,m,n,alpha,c_loc(A),lda,strideA,c_loc(x),incx,stridex,beta,c_loc(y),incy,stridey,batch_count)
    end function

    function rocblas_dgemv_strided_batched_full_rank(handle,transA,m,n,alpha,A,lda,strideA,x,incx,stridex,beta,y,incy,stridey,batch_count)
      use iso_c_binding
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocblas_dgemv_strided_batched_full_rank
      type(c_ptr),value :: handle
      integer(kind(rocblas_operation_none)),value :: transA
      integer(c_int),value :: m
      integer(c_int),value :: n
      real(c_double) :: alpha
      real(c_double),target,dimension(:,:) :: A
      integer(c_int),value :: lda
      integer(c_int64_t),value :: strideA
      real(c_double),target,dimension(:) :: x
      integer(c_int),value :: incx
      integer(c_int64_t),value :: stridex
      real(c_double) :: beta
      real(c_double),target,dimension(:) :: y
      integer(c_int),value :: incy
      integer(c_int64_t),value :: stridey
      integer(c_int),value :: batch_count
      !
      rocblas_dgemv_strided_batched_full_rank = rocblas_dgemv_strided_batched_orig(handle,transA,m,n,alpha,c_loc(A),lda,strideA,c_loc(x),incx,stridex,beta,c_loc(y),incy,stridey,batch_count)
    end function

    function rocblas_dgemv_strided_batched_rank_0(handle,transA,m,n,alpha,A,lda,strideA,x,incx,stridex,beta,y,incy,stridey,batch_count)
      use iso_c_binding
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocblas_dgemv_strided_batched_rank_0
      type(c_ptr),value :: handle
      integer(kind(rocblas_operation_none)),value :: transA
      integer(c_int),value :: m
      integer(c_int),value :: n
      real(c_double) :: alpha
      real(c_double),target :: A
      integer(c_int),value :: lda
      integer(c_int64_t),value :: strideA
      real(c_double),target :: x
      integer(c_int),value :: incx
      integer(c_int64_t),value :: stridex
      real(c_double) :: beta
      real(c_double),target :: y
      integer(c_int),value :: incy
      integer(c_int64_t),value :: stridey
      integer(c_int),value :: batch_count
      !
      rocblas_dgemv_strided_batched_rank_0 = rocblas_dgemv_strided_batched_orig(handle,transA,m,n,alpha,c_loc(A),lda,strideA,c_loc(x),incx,stridex,beta,c_loc(y),incy,stridey,batch_count)
    end function

    function rocblas_dgemv_strided_batched_rank_1(handle,transA,m,n,alpha,A,lda,strideA,x,incx,stridex,beta,y,incy,stridey,batch_count)
      use iso_c_binding
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocblas_dgemv_strided_batched_rank_1
      type(c_ptr),value :: handle
      integer(kind(rocblas_operation_none)),value :: transA
      integer(c_int),value :: m
      integer(c_int),value :: n
      real(c_double) :: alpha
      real(c_double),target,dimension(:) :: A
      integer(c_int),value :: lda
      integer(c_int64_t),value :: strideA
      real(c_double),target,dimension(:) :: x
      integer(c_int),value :: incx
      integer(c_int64_t),value :: stridex
      real(c_double) :: beta
      real(c_double),target,dimension(:) :: y
      integer(c_int),value :: incy
      integer(c_int64_t),value :: stridey
      integer(c_int),value :: batch_count
      !
      rocblas_dgemv_strided_batched_rank_1 = rocblas_dgemv_strided_batched_orig(handle,transA,m,n,alpha,c_loc(A),lda,strideA,c_loc(x),incx,stridex,beta,c_loc(y),incy,stridey,batch_count)
    end function

    function rocblas_cgemv_strided_batched_full_rank(handle,transA,m,n,alpha,A,lda,strideA,x,incx,stridex,beta,y,incy,stridey,batch_count)
      use iso_c_binding
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocblas_cgemv_strided_batched_full_rank
      type(c_ptr),value :: handle
      integer(kind(rocblas_operation_none)),value :: transA
      integer(c_int),value :: m
      integer(c_int),value :: n
      complex(c_float_complex) :: alpha
      complex(c_float_complex),target,dimension(:,:) :: A
      integer(c_int),value :: lda
      integer(c_int64_t),value :: strideA
      complex(c_float_complex),target,dimension(:) :: x
      integer(c_int),value :: incx
      integer(c_int64_t),value :: stridex
      complex(c_float_complex) :: beta
      complex(c_float_complex),target,dimension(:) :: y
      integer(c_int),value :: incy
      integer(c_int64_t),value :: stridey
      integer(c_int),value :: batch_count
      !
      rocblas_cgemv_strided_batched_full_rank = rocblas_cgemv_strided_batched_orig(handle,transA,m,n,alpha,c_loc(A),lda,strideA,c_loc(x),incx,stridex,beta,c_loc(y),incy,stridey,batch_count)
    end function

    function rocblas_cgemv_strided_batched_rank_0(handle,transA,m,n,alpha,A,lda,strideA,x,incx,stridex,beta,y,incy,stridey,batch_count)
      use iso_c_binding
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocblas_cgemv_strided_batched_rank_0
      type(c_ptr),value :: handle
      integer(kind(rocblas_operation_none)),value :: transA
      integer(c_int),value :: m
      integer(c_int),value :: n
      complex(c_float_complex) :: alpha
      complex(c_float_complex),target :: A
      integer(c_int),value :: lda
      integer(c_int64_t),value :: strideA
      complex(c_float_complex),target :: x
      integer(c_int),value :: incx
      integer(c_int64_t),value :: stridex
      complex(c_float_complex) :: beta
      complex(c_float_complex),target :: y
      integer(c_int),value :: incy
      integer(c_int64_t),value :: stridey
      integer(c_int),value :: batch_count
      !
      rocblas_cgemv_strided_batched_rank_0 = rocblas_cgemv_strided_batched_orig(handle,transA,m,n,alpha,c_loc(A),lda,strideA,c_loc(x),incx,stridex,beta,c_loc(y),incy,stridey,batch_count)
    end function

    function rocblas_cgemv_strided_batched_rank_1(handle,transA,m,n,alpha,A,lda,strideA,x,incx,stridex,beta,y,incy,stridey,batch_count)
      use iso_c_binding
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocblas_cgemv_strided_batched_rank_1
      type(c_ptr),value :: handle
      integer(kind(rocblas_operation_none)),value :: transA
      integer(c_int),value :: m
      integer(c_int),value :: n
      complex(c_float_complex) :: alpha
      complex(c_float_complex),target,dimension(:) :: A
      integer(c_int),value :: lda
      integer(c_int64_t),value :: strideA
      complex(c_float_complex),target,dimension(:) :: x
      integer(c_int),value :: incx
      integer(c_int64_t),value :: stridex
      complex(c_float_complex) :: beta
      complex(c_float_complex),target,dimension(:) :: y
      integer(c_int),value :: incy
      integer(c_int64_t),value :: stridey
      integer(c_int),value :: batch_count
      !
      rocblas_cgemv_strided_batched_rank_1 = rocblas_cgemv_strided_batched_orig(handle,transA,m,n,alpha,c_loc(A),lda,strideA,c_loc(x),incx,stridex,beta,c_loc(y),incy,stridey,batch_count)
    end function

    function rocblas_zgemv_strided_batched_full_rank(handle,transA,m,n,alpha,A,lda,strideA,x,incx,stridex,beta,y,incy,stridey,batch_count)
      use iso_c_binding
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocblas_zgemv_strided_batched_full_rank
      type(c_ptr),value :: handle
      integer(kind(rocblas_operation_none)),value :: transA
      integer(c_int),value :: m
      integer(c_int),value :: n
      complex(c_double_complex) :: alpha
      complex(c_double_complex),target,dimension(:,:) :: A
      integer(c_int),value :: lda
      integer(c_int64_t),value :: strideA
      complex(c_double_complex),target,dimension(:) :: x
      integer(c_int),value :: incx
      integer(c_int64_t),value :: stridex
      complex(c_double_complex) :: beta
      complex(c_double_complex),target,dimension(:) :: y
      integer(c_int),value :: incy
      integer(c_int64_t),value :: stridey
      integer(c_int),value :: batch_count
      !
      rocblas_zgemv_strided_batched_full_rank = rocblas_zgemv_strided_batched_orig(handle,transA,m,n,alpha,c_loc(A),lda,strideA,c_loc(x),incx,stridex,beta,c_loc(y),incy,stridey,batch_count)
    end function

    function rocblas_zgemv_strided_batched_rank_0(handle,transA,m,n,alpha,A,lda,strideA,x,incx,stridex,beta,y,incy,stridey,batch_count)
      use iso_c_binding
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocblas_zgemv_strided_batched_rank_0
      type(c_ptr),value :: handle
      integer(kind(rocblas_operation_none)),value :: transA
      integer(c_int),value :: m
      integer(c_int),value :: n
      complex(c_double_complex) :: alpha
      complex(c_double_complex),target :: A
      integer(c_int),value :: lda
      integer(c_int64_t),value :: strideA
      complex(c_double_complex),target :: x
      integer(c_int),value :: incx
      integer(c_int64_t),value :: stridex
      complex(c_double_complex) :: beta
      complex(c_double_complex),target :: y
      integer(c_int),value :: incy
      integer(c_int64_t),value :: stridey
      integer(c_int),value :: batch_count
      !
      rocblas_zgemv_strided_batched_rank_0 = rocblas_zgemv_strided_batched_orig(handle,transA,m,n,alpha,c_loc(A),lda,strideA,c_loc(x),incx,stridex,beta,c_loc(y),incy,stridey,batch_count)
    end function

    function rocblas_zgemv_strided_batched_rank_1(handle,transA,m,n,alpha,A,lda,strideA,x,incx,stridex,beta,y,incy,stridey,batch_count)
      use iso_c_binding
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocblas_zgemv_strided_batched_rank_1
      type(c_ptr),value :: handle
      integer(kind(rocblas_operation_none)),value :: transA
      integer(c_int),value :: m
      integer(c_int),value :: n
      complex(c_double_complex) :: alpha
      complex(c_double_complex),target,dimension(:) :: A
      integer(c_int),value :: lda
      integer(c_int64_t),value :: strideA
      complex(c_double_complex),target,dimension(:) :: x
      integer(c_int),value :: incx
      integer(c_int64_t),value :: stridex
      complex(c_double_complex) :: beta
      complex(c_double_complex),target,dimension(:) :: y
      integer(c_int),value :: incy
      integer(c_int64_t),value :: stridey
      integer(c_int),value :: batch_count
      !
      rocblas_zgemv_strided_batched_rank_1 = rocblas_zgemv_strided_batched_orig(handle,transA,m,n,alpha,c_loc(A),lda,strideA,c_loc(x),incx,stridex,beta,c_loc(y),incy,stridey,batch_count)
    end function

    function rocblas_chbmv_full_rank(handle,uplo,n,k,alpha,A,lda,x,incx,beta,y,incy)
      use iso_c_binding
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocblas_chbmv_full_rank
      type(c_ptr),value :: handle
      integer(kind(rocblas_fill_upper)),value :: uplo
      integer(c_int),value :: n
      integer(c_int),value :: k
      complex(c_float_complex) :: alpha
      complex(c_float_complex),target,dimension(:,:) :: A
      integer(c_int),value :: lda
      complex(c_float_complex),target,dimension(:) :: x
      integer(c_int),value :: incx
      complex(c_float_complex) :: beta
      complex(c_float_complex),target,dimension(:) :: y
      integer(c_int),value :: incy
      !
      rocblas_chbmv_full_rank = rocblas_chbmv_orig(handle,uplo,n,k,alpha,c_loc(A),lda,c_loc(x),incx,beta,c_loc(y),incy)
    end function

    function rocblas_chbmv_rank_0(handle,uplo,n,k,alpha,A,lda,x,incx,beta,y,incy)
      use iso_c_binding
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocblas_chbmv_rank_0
      type(c_ptr),value :: handle
      integer(kind(rocblas_fill_upper)),value :: uplo
      integer(c_int),value :: n
      integer(c_int),value :: k
      complex(c_float_complex) :: alpha
      complex(c_float_complex),target :: A
      integer(c_int),value :: lda
      complex(c_float_complex),target :: x
      integer(c_int),value :: incx
      complex(c_float_complex) :: beta
      complex(c_float_complex),target :: y
      integer(c_int),value :: incy
      !
      rocblas_chbmv_rank_0 = rocblas_chbmv_orig(handle,uplo,n,k,alpha,c_loc(A),lda,c_loc(x),incx,beta,c_loc(y),incy)
    end function

    function rocblas_chbmv_rank_1(handle,uplo,n,k,alpha,A,lda,x,incx,beta,y,incy)
      use iso_c_binding
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocblas_chbmv_rank_1
      type(c_ptr),value :: handle
      integer(kind(rocblas_fill_upper)),value :: uplo
      integer(c_int),value :: n
      integer(c_int),value :: k
      complex(c_float_complex) :: alpha
      complex(c_float_complex),target,dimension(:) :: A
      integer(c_int),value :: lda
      complex(c_float_complex),target,dimension(:) :: x
      integer(c_int),value :: incx
      complex(c_float_complex) :: beta
      complex(c_float_complex),target,dimension(:) :: y
      integer(c_int),value :: incy
      !
      rocblas_chbmv_rank_1 = rocblas_chbmv_orig(handle,uplo,n,k,alpha,c_loc(A),lda,c_loc(x),incx,beta,c_loc(y),incy)
    end function

    function rocblas_zhbmv_full_rank(handle,uplo,n,k,alpha,A,lda,x,incx,beta,y,incy)
      use iso_c_binding
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocblas_zhbmv_full_rank
      type(c_ptr),value :: handle
      integer(kind(rocblas_fill_upper)),value :: uplo
      integer(c_int),value :: n
      integer(c_int),value :: k
      complex(c_double_complex) :: alpha
      complex(c_double_complex),target,dimension(:,:) :: A
      integer(c_int),value :: lda
      complex(c_double_complex),target,dimension(:) :: x
      integer(c_int),value :: incx
      complex(c_double_complex) :: beta
      complex(c_double_complex),target,dimension(:) :: y
      integer(c_int),value :: incy
      !
      rocblas_zhbmv_full_rank = rocblas_zhbmv_orig(handle,uplo,n,k,alpha,c_loc(A),lda,c_loc(x),incx,beta,c_loc(y),incy)
    end function

    function rocblas_zhbmv_rank_0(handle,uplo,n,k,alpha,A,lda,x,incx,beta,y,incy)
      use iso_c_binding
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocblas_zhbmv_rank_0
      type(c_ptr),value :: handle
      integer(kind(rocblas_fill_upper)),value :: uplo
      integer(c_int),value :: n
      integer(c_int),value :: k
      complex(c_double_complex) :: alpha
      complex(c_double_complex),target :: A
      integer(c_int),value :: lda
      complex(c_double_complex),target :: x
      integer(c_int),value :: incx
      complex(c_double_complex) :: beta
      complex(c_double_complex),target :: y
      integer(c_int),value :: incy
      !
      rocblas_zhbmv_rank_0 = rocblas_zhbmv_orig(handle,uplo,n,k,alpha,c_loc(A),lda,c_loc(x),incx,beta,c_loc(y),incy)
    end function

    function rocblas_zhbmv_rank_1(handle,uplo,n,k,alpha,A,lda,x,incx,beta,y,incy)
      use iso_c_binding
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocblas_zhbmv_rank_1
      type(c_ptr),value :: handle
      integer(kind(rocblas_fill_upper)),value :: uplo
      integer(c_int),value :: n
      integer(c_int),value :: k
      complex(c_double_complex) :: alpha
      complex(c_double_complex),target,dimension(:) :: A
      integer(c_int),value :: lda
      complex(c_double_complex),target,dimension(:) :: x
      integer(c_int),value :: incx
      complex(c_double_complex) :: beta
      complex(c_double_complex),target,dimension(:) :: y
      integer(c_int),value :: incy
      !
      rocblas_zhbmv_rank_1 = rocblas_zhbmv_orig(handle,uplo,n,k,alpha,c_loc(A),lda,c_loc(x),incx,beta,c_loc(y),incy)
    end function

    function rocblas_chbmv_batched_full_rank(handle,uplo,n,k,alpha,A,lda,x,incx,beta,y,incy,batch_count)
      use iso_c_binding
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocblas_chbmv_batched_full_rank
      type(c_ptr),value :: handle
      integer(kind(rocblas_fill_upper)),value :: uplo
      integer(c_int),value :: n
      integer(c_int),value :: k
      complex(c_float_complex) :: alpha
      complex(c_float_complex),target,dimension(:,:,:) :: A
      integer(c_int),value :: lda
      complex(c_float_complex),target,dimension(:,:) :: x
      integer(c_int),value :: incx
      complex(c_float_complex) :: beta
      complex(c_float_complex),target,dimension(:,:) :: y
      integer(c_int),value :: incy
      integer(c_int),value :: batch_count
      !
      rocblas_chbmv_batched_full_rank = rocblas_chbmv_batched_orig(handle,uplo,n,k,alpha,c_loc(A),lda,c_loc(x),incx,beta,c_loc(y),incy,batch_count)
    end function

    function rocblas_chbmv_batched_rank_0(handle,uplo,n,k,alpha,A,lda,x,incx,beta,y,incy,batch_count)
      use iso_c_binding
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocblas_chbmv_batched_rank_0
      type(c_ptr),value :: handle
      integer(kind(rocblas_fill_upper)),value :: uplo
      integer(c_int),value :: n
      integer(c_int),value :: k
      complex(c_float_complex) :: alpha
      complex(c_float_complex),target :: A
      integer(c_int),value :: lda
      complex(c_float_complex),target :: x
      integer(c_int),value :: incx
      complex(c_float_complex) :: beta
      complex(c_float_complex),target :: y
      integer(c_int),value :: incy
      integer(c_int),value :: batch_count
      !
      rocblas_chbmv_batched_rank_0 = rocblas_chbmv_batched_orig(handle,uplo,n,k,alpha,c_loc(A),lda,c_loc(x),incx,beta,c_loc(y),incy,batch_count)
    end function

    function rocblas_chbmv_batched_rank_1(handle,uplo,n,k,alpha,A,lda,x,incx,beta,y,incy,batch_count)
      use iso_c_binding
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocblas_chbmv_batched_rank_1
      type(c_ptr),value :: handle
      integer(kind(rocblas_fill_upper)),value :: uplo
      integer(c_int),value :: n
      integer(c_int),value :: k
      complex(c_float_complex) :: alpha
      complex(c_float_complex),target,dimension(:) :: A
      integer(c_int),value :: lda
      complex(c_float_complex),target,dimension(:) :: x
      integer(c_int),value :: incx
      complex(c_float_complex) :: beta
      complex(c_float_complex),target,dimension(:) :: y
      integer(c_int),value :: incy
      integer(c_int),value :: batch_count
      !
      rocblas_chbmv_batched_rank_1 = rocblas_chbmv_batched_orig(handle,uplo,n,k,alpha,c_loc(A),lda,c_loc(x),incx,beta,c_loc(y),incy,batch_count)
    end function

    function rocblas_zhbmv_batched_full_rank(handle,uplo,n,k,alpha,A,lda,x,incx,beta,y,incy,batch_count)
      use iso_c_binding
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocblas_zhbmv_batched_full_rank
      type(c_ptr),value :: handle
      integer(kind(rocblas_fill_upper)),value :: uplo
      integer(c_int),value :: n
      integer(c_int),value :: k
      complex(c_double_complex) :: alpha
      complex(c_double_complex),target,dimension(:,:,:) :: A
      integer(c_int),value :: lda
      complex(c_double_complex),target,dimension(:,:) :: x
      integer(c_int),value :: incx
      complex(c_double_complex) :: beta
      complex(c_double_complex),target,dimension(:,:) :: y
      integer(c_int),value :: incy
      integer(c_int),value :: batch_count
      !
      rocblas_zhbmv_batched_full_rank = rocblas_zhbmv_batched_orig(handle,uplo,n,k,alpha,c_loc(A),lda,c_loc(x),incx,beta,c_loc(y),incy,batch_count)
    end function

    function rocblas_zhbmv_batched_rank_0(handle,uplo,n,k,alpha,A,lda,x,incx,beta,y,incy,batch_count)
      use iso_c_binding
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocblas_zhbmv_batched_rank_0
      type(c_ptr),value :: handle
      integer(kind(rocblas_fill_upper)),value :: uplo
      integer(c_int),value :: n
      integer(c_int),value :: k
      complex(c_double_complex) :: alpha
      complex(c_double_complex),target :: A
      integer(c_int),value :: lda
      complex(c_double_complex),target :: x
      integer(c_int),value :: incx
      complex(c_double_complex) :: beta
      complex(c_double_complex),target :: y
      integer(c_int),value :: incy
      integer(c_int),value :: batch_count
      !
      rocblas_zhbmv_batched_rank_0 = rocblas_zhbmv_batched_orig(handle,uplo,n,k,alpha,c_loc(A),lda,c_loc(x),incx,beta,c_loc(y),incy,batch_count)
    end function

    function rocblas_zhbmv_batched_rank_1(handle,uplo,n,k,alpha,A,lda,x,incx,beta,y,incy,batch_count)
      use iso_c_binding
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocblas_zhbmv_batched_rank_1
      type(c_ptr),value :: handle
      integer(kind(rocblas_fill_upper)),value :: uplo
      integer(c_int),value :: n
      integer(c_int),value :: k
      complex(c_double_complex) :: alpha
      complex(c_double_complex),target,dimension(:) :: A
      integer(c_int),value :: lda
      complex(c_double_complex),target,dimension(:) :: x
      integer(c_int),value :: incx
      complex(c_double_complex) :: beta
      complex(c_double_complex),target,dimension(:) :: y
      integer(c_int),value :: incy
      integer(c_int),value :: batch_count
      !
      rocblas_zhbmv_batched_rank_1 = rocblas_zhbmv_batched_orig(handle,uplo,n,k,alpha,c_loc(A),lda,c_loc(x),incx,beta,c_loc(y),incy,batch_count)
    end function

    function rocblas_chbmv_strided_batched_full_rank(handle,uplo,n,k,alpha,A,lda,stride_A,x,incx,stride_x,beta,y,incy,stride_y,batch_count)
      use iso_c_binding
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocblas_chbmv_strided_batched_full_rank
      type(c_ptr),value :: handle
      integer(kind(rocblas_fill_upper)),value :: uplo
      integer(c_int),value :: n
      integer(c_int),value :: k
      complex(c_float_complex) :: alpha
      complex(c_float_complex),target,dimension(:,:) :: A
      integer(c_int),value :: lda
      integer(c_int64_t),value :: stride_A
      complex(c_float_complex),target,dimension(:) :: x
      integer(c_int),value :: incx
      integer(c_int64_t),value :: stride_x
      complex(c_float_complex) :: beta
      complex(c_float_complex),target,dimension(:) :: y
      integer(c_int),value :: incy
      integer(c_int64_t),value :: stride_y
      integer(c_int),value :: batch_count
      !
      rocblas_chbmv_strided_batched_full_rank = rocblas_chbmv_strided_batched_orig(handle,uplo,n,k,alpha,c_loc(A),lda,stride_A,c_loc(x),incx,stride_x,beta,c_loc(y),incy,stride_y,batch_count)
    end function

    function rocblas_chbmv_strided_batched_rank_0(handle,uplo,n,k,alpha,A,lda,stride_A,x,incx,stride_x,beta,y,incy,stride_y,batch_count)
      use iso_c_binding
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocblas_chbmv_strided_batched_rank_0
      type(c_ptr),value :: handle
      integer(kind(rocblas_fill_upper)),value :: uplo
      integer(c_int),value :: n
      integer(c_int),value :: k
      complex(c_float_complex) :: alpha
      complex(c_float_complex),target :: A
      integer(c_int),value :: lda
      integer(c_int64_t),value :: stride_A
      complex(c_float_complex),target :: x
      integer(c_int),value :: incx
      integer(c_int64_t),value :: stride_x
      complex(c_float_complex) :: beta
      complex(c_float_complex),target :: y
      integer(c_int),value :: incy
      integer(c_int64_t),value :: stride_y
      integer(c_int),value :: batch_count
      !
      rocblas_chbmv_strided_batched_rank_0 = rocblas_chbmv_strided_batched_orig(handle,uplo,n,k,alpha,c_loc(A),lda,stride_A,c_loc(x),incx,stride_x,beta,c_loc(y),incy,stride_y,batch_count)
    end function

    function rocblas_chbmv_strided_batched_rank_1(handle,uplo,n,k,alpha,A,lda,stride_A,x,incx,stride_x,beta,y,incy,stride_y,batch_count)
      use iso_c_binding
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocblas_chbmv_strided_batched_rank_1
      type(c_ptr),value :: handle
      integer(kind(rocblas_fill_upper)),value :: uplo
      integer(c_int),value :: n
      integer(c_int),value :: k
      complex(c_float_complex) :: alpha
      complex(c_float_complex),target,dimension(:) :: A
      integer(c_int),value :: lda
      integer(c_int64_t),value :: stride_A
      complex(c_float_complex),target,dimension(:) :: x
      integer(c_int),value :: incx
      integer(c_int64_t),value :: stride_x
      complex(c_float_complex) :: beta
      complex(c_float_complex),target,dimension(:) :: y
      integer(c_int),value :: incy
      integer(c_int64_t),value :: stride_y
      integer(c_int),value :: batch_count
      !
      rocblas_chbmv_strided_batched_rank_1 = rocblas_chbmv_strided_batched_orig(handle,uplo,n,k,alpha,c_loc(A),lda,stride_A,c_loc(x),incx,stride_x,beta,c_loc(y),incy,stride_y,batch_count)
    end function

    function rocblas_zhbmv_strided_batched_full_rank(handle,uplo,n,k,alpha,A,lda,stride_A,x,incx,stride_x,beta,y,incy,stride_y,batch_count)
      use iso_c_binding
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocblas_zhbmv_strided_batched_full_rank
      type(c_ptr),value :: handle
      integer(kind(rocblas_fill_upper)),value :: uplo
      integer(c_int),value :: n
      integer(c_int),value :: k
      complex(c_double_complex) :: alpha
      complex(c_double_complex),target,dimension(:,:) :: A
      integer(c_int),value :: lda
      integer(c_int64_t),value :: stride_A
      complex(c_double_complex),target,dimension(:) :: x
      integer(c_int),value :: incx
      integer(c_int64_t),value :: stride_x
      complex(c_double_complex) :: beta
      complex(c_double_complex),target,dimension(:) :: y
      integer(c_int),value :: incy
      integer(c_int64_t),value :: stride_y
      integer(c_int),value :: batch_count
      !
      rocblas_zhbmv_strided_batched_full_rank = rocblas_zhbmv_strided_batched_orig(handle,uplo,n,k,alpha,c_loc(A),lda,stride_A,c_loc(x),incx,stride_x,beta,c_loc(y),incy,stride_y,batch_count)
    end function

    function rocblas_zhbmv_strided_batched_rank_0(handle,uplo,n,k,alpha,A,lda,stride_A,x,incx,stride_x,beta,y,incy,stride_y,batch_count)
      use iso_c_binding
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocblas_zhbmv_strided_batched_rank_0
      type(c_ptr),value :: handle
      integer(kind(rocblas_fill_upper)),value :: uplo
      integer(c_int),value :: n
      integer(c_int),value :: k
      complex(c_double_complex) :: alpha
      complex(c_double_complex),target :: A
      integer(c_int),value :: lda
      integer(c_int64_t),value :: stride_A
      complex(c_double_complex),target :: x
      integer(c_int),value :: incx
      integer(c_int64_t),value :: stride_x
      complex(c_double_complex) :: beta
      complex(c_double_complex),target :: y
      integer(c_int),value :: incy
      integer(c_int64_t),value :: stride_y
      integer(c_int),value :: batch_count
      !
      rocblas_zhbmv_strided_batched_rank_0 = rocblas_zhbmv_strided_batched_orig(handle,uplo,n,k,alpha,c_loc(A),lda,stride_A,c_loc(x),incx,stride_x,beta,c_loc(y),incy,stride_y,batch_count)
    end function

    function rocblas_zhbmv_strided_batched_rank_1(handle,uplo,n,k,alpha,A,lda,stride_A,x,incx,stride_x,beta,y,incy,stride_y,batch_count)
      use iso_c_binding
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocblas_zhbmv_strided_batched_rank_1
      type(c_ptr),value :: handle
      integer(kind(rocblas_fill_upper)),value :: uplo
      integer(c_int),value :: n
      integer(c_int),value :: k
      complex(c_double_complex) :: alpha
      complex(c_double_complex),target,dimension(:) :: A
      integer(c_int),value :: lda
      integer(c_int64_t),value :: stride_A
      complex(c_double_complex),target,dimension(:) :: x
      integer(c_int),value :: incx
      integer(c_int64_t),value :: stride_x
      complex(c_double_complex) :: beta
      complex(c_double_complex),target,dimension(:) :: y
      integer(c_int),value :: incy
      integer(c_int64_t),value :: stride_y
      integer(c_int),value :: batch_count
      !
      rocblas_zhbmv_strided_batched_rank_1 = rocblas_zhbmv_strided_batched_orig(handle,uplo,n,k,alpha,c_loc(A),lda,stride_A,c_loc(x),incx,stride_x,beta,c_loc(y),incy,stride_y,batch_count)
    end function

    function rocblas_chemv_full_rank(handle,uplo,n,alpha,A,lda,x,incx,beta,y,incy)
      use iso_c_binding
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocblas_chemv_full_rank
      type(c_ptr),value :: handle
      integer(kind(rocblas_fill_upper)),value :: uplo
      integer(c_int),value :: n
      complex(c_float_complex) :: alpha
      complex(c_float_complex),target,dimension(:,:) :: A
      integer(c_int),value :: lda
      complex(c_float_complex),target,dimension(:) :: x
      integer(c_int),value :: incx
      complex(c_float_complex) :: beta
      complex(c_float_complex),target,dimension(:) :: y
      integer(c_int),value :: incy
      !
      rocblas_chemv_full_rank = rocblas_chemv_orig(handle,uplo,n,alpha,c_loc(A),lda,c_loc(x),incx,beta,c_loc(y),incy)
    end function

    function rocblas_chemv_rank_0(handle,uplo,n,alpha,A,lda,x,incx,beta,y,incy)
      use iso_c_binding
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocblas_chemv_rank_0
      type(c_ptr),value :: handle
      integer(kind(rocblas_fill_upper)),value :: uplo
      integer(c_int),value :: n
      complex(c_float_complex) :: alpha
      complex(c_float_complex),target :: A
      integer(c_int),value :: lda
      complex(c_float_complex),target :: x
      integer(c_int),value :: incx
      complex(c_float_complex) :: beta
      complex(c_float_complex),target :: y
      integer(c_int),value :: incy
      !
      rocblas_chemv_rank_0 = rocblas_chemv_orig(handle,uplo,n,alpha,c_loc(A),lda,c_loc(x),incx,beta,c_loc(y),incy)
    end function

    function rocblas_chemv_rank_1(handle,uplo,n,alpha,A,lda,x,incx,beta,y,incy)
      use iso_c_binding
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocblas_chemv_rank_1
      type(c_ptr),value :: handle
      integer(kind(rocblas_fill_upper)),value :: uplo
      integer(c_int),value :: n
      complex(c_float_complex) :: alpha
      complex(c_float_complex),target,dimension(:) :: A
      integer(c_int),value :: lda
      complex(c_float_complex),target,dimension(:) :: x
      integer(c_int),value :: incx
      complex(c_float_complex) :: beta
      complex(c_float_complex),target,dimension(:) :: y
      integer(c_int),value :: incy
      !
      rocblas_chemv_rank_1 = rocblas_chemv_orig(handle,uplo,n,alpha,c_loc(A),lda,c_loc(x),incx,beta,c_loc(y),incy)
    end function

    function rocblas_zhemv_full_rank(handle,uplo,n,alpha,A,lda,x,incx,beta,y,incy)
      use iso_c_binding
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocblas_zhemv_full_rank
      type(c_ptr),value :: handle
      integer(kind(rocblas_fill_upper)),value :: uplo
      integer(c_int),value :: n
      complex(c_double_complex) :: alpha
      complex(c_double_complex),target,dimension(:,:) :: A
      integer(c_int),value :: lda
      complex(c_double_complex),target,dimension(:) :: x
      integer(c_int),value :: incx
      complex(c_double_complex) :: beta
      complex(c_double_complex),target,dimension(:) :: y
      integer(c_int),value :: incy
      !
      rocblas_zhemv_full_rank = rocblas_zhemv_orig(handle,uplo,n,alpha,c_loc(A),lda,c_loc(x),incx,beta,c_loc(y),incy)
    end function

    function rocblas_zhemv_rank_0(handle,uplo,n,alpha,A,lda,x,incx,beta,y,incy)
      use iso_c_binding
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocblas_zhemv_rank_0
      type(c_ptr),value :: handle
      integer(kind(rocblas_fill_upper)),value :: uplo
      integer(c_int),value :: n
      complex(c_double_complex) :: alpha
      complex(c_double_complex),target :: A
      integer(c_int),value :: lda
      complex(c_double_complex),target :: x
      integer(c_int),value :: incx
      complex(c_double_complex) :: beta
      complex(c_double_complex),target :: y
      integer(c_int),value :: incy
      !
      rocblas_zhemv_rank_0 = rocblas_zhemv_orig(handle,uplo,n,alpha,c_loc(A),lda,c_loc(x),incx,beta,c_loc(y),incy)
    end function

    function rocblas_zhemv_rank_1(handle,uplo,n,alpha,A,lda,x,incx,beta,y,incy)
      use iso_c_binding
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocblas_zhemv_rank_1
      type(c_ptr),value :: handle
      integer(kind(rocblas_fill_upper)),value :: uplo
      integer(c_int),value :: n
      complex(c_double_complex) :: alpha
      complex(c_double_complex),target,dimension(:) :: A
      integer(c_int),value :: lda
      complex(c_double_complex),target,dimension(:) :: x
      integer(c_int),value :: incx
      complex(c_double_complex) :: beta
      complex(c_double_complex),target,dimension(:) :: y
      integer(c_int),value :: incy
      !
      rocblas_zhemv_rank_1 = rocblas_zhemv_orig(handle,uplo,n,alpha,c_loc(A),lda,c_loc(x),incx,beta,c_loc(y),incy)
    end function

    function rocblas_chemv_batched_full_rank(handle,uplo,n,alpha,A,lda,x,incx,beta,y,incy,batch_count)
      use iso_c_binding
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocblas_chemv_batched_full_rank
      type(c_ptr),value :: handle
      integer(kind(rocblas_fill_upper)),value :: uplo
      integer(c_int),value :: n
      complex(c_float_complex) :: alpha
      complex(c_float_complex),target,dimension(:,:,:) :: A
      integer(c_int),value :: lda
      complex(c_float_complex),target,dimension(:,:) :: x
      integer(c_int),value :: incx
      complex(c_float_complex) :: beta
      complex(c_float_complex),target,dimension(:,:) :: y
      integer(c_int),value :: incy
      integer(c_int),value :: batch_count
      !
      rocblas_chemv_batched_full_rank = rocblas_chemv_batched_orig(handle,uplo,n,alpha,c_loc(A),lda,c_loc(x),incx,beta,c_loc(y),incy,batch_count)
    end function

    function rocblas_chemv_batched_rank_0(handle,uplo,n,alpha,A,lda,x,incx,beta,y,incy,batch_count)
      use iso_c_binding
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocblas_chemv_batched_rank_0
      type(c_ptr),value :: handle
      integer(kind(rocblas_fill_upper)),value :: uplo
      integer(c_int),value :: n
      complex(c_float_complex) :: alpha
      complex(c_float_complex),target :: A
      integer(c_int),value :: lda
      complex(c_float_complex),target :: x
      integer(c_int),value :: incx
      complex(c_float_complex) :: beta
      complex(c_float_complex),target :: y
      integer(c_int),value :: incy
      integer(c_int),value :: batch_count
      !
      rocblas_chemv_batched_rank_0 = rocblas_chemv_batched_orig(handle,uplo,n,alpha,c_loc(A),lda,c_loc(x),incx,beta,c_loc(y),incy,batch_count)
    end function

    function rocblas_chemv_batched_rank_1(handle,uplo,n,alpha,A,lda,x,incx,beta,y,incy,batch_count)
      use iso_c_binding
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocblas_chemv_batched_rank_1
      type(c_ptr),value :: handle
      integer(kind(rocblas_fill_upper)),value :: uplo
      integer(c_int),value :: n
      complex(c_float_complex) :: alpha
      complex(c_float_complex),target,dimension(:) :: A
      integer(c_int),value :: lda
      complex(c_float_complex),target,dimension(:) :: x
      integer(c_int),value :: incx
      complex(c_float_complex) :: beta
      complex(c_float_complex),target,dimension(:) :: y
      integer(c_int),value :: incy
      integer(c_int),value :: batch_count
      !
      rocblas_chemv_batched_rank_1 = rocblas_chemv_batched_orig(handle,uplo,n,alpha,c_loc(A),lda,c_loc(x),incx,beta,c_loc(y),incy,batch_count)
    end function

    function rocblas_zhemv_batched_full_rank(handle,uplo,n,alpha,A,lda,x,incx,beta,y,incy,batch_count)
      use iso_c_binding
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocblas_zhemv_batched_full_rank
      type(c_ptr),value :: handle
      integer(kind(rocblas_fill_upper)),value :: uplo
      integer(c_int),value :: n
      complex(c_double_complex) :: alpha
      complex(c_double_complex),target,dimension(:,:,:) :: A
      integer(c_int),value :: lda
      complex(c_double_complex),target,dimension(:,:) :: x
      integer(c_int),value :: incx
      complex(c_double_complex) :: beta
      complex(c_double_complex),target,dimension(:,:) :: y
      integer(c_int),value :: incy
      integer(c_int),value :: batch_count
      !
      rocblas_zhemv_batched_full_rank = rocblas_zhemv_batched_orig(handle,uplo,n,alpha,c_loc(A),lda,c_loc(x),incx,beta,c_loc(y),incy,batch_count)
    end function

    function rocblas_zhemv_batched_rank_0(handle,uplo,n,alpha,A,lda,x,incx,beta,y,incy,batch_count)
      use iso_c_binding
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocblas_zhemv_batched_rank_0
      type(c_ptr),value :: handle
      integer(kind(rocblas_fill_upper)),value :: uplo
      integer(c_int),value :: n
      complex(c_double_complex) :: alpha
      complex(c_double_complex),target :: A
      integer(c_int),value :: lda
      complex(c_double_complex),target :: x
      integer(c_int),value :: incx
      complex(c_double_complex) :: beta
      complex(c_double_complex),target :: y
      integer(c_int),value :: incy
      integer(c_int),value :: batch_count
      !
      rocblas_zhemv_batched_rank_0 = rocblas_zhemv_batched_orig(handle,uplo,n,alpha,c_loc(A),lda,c_loc(x),incx,beta,c_loc(y),incy,batch_count)
    end function

    function rocblas_zhemv_batched_rank_1(handle,uplo,n,alpha,A,lda,x,incx,beta,y,incy,batch_count)
      use iso_c_binding
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocblas_zhemv_batched_rank_1
      type(c_ptr),value :: handle
      integer(kind(rocblas_fill_upper)),value :: uplo
      integer(c_int),value :: n
      complex(c_double_complex) :: alpha
      complex(c_double_complex),target,dimension(:) :: A
      integer(c_int),value :: lda
      complex(c_double_complex),target,dimension(:) :: x
      integer(c_int),value :: incx
      complex(c_double_complex) :: beta
      complex(c_double_complex),target,dimension(:) :: y
      integer(c_int),value :: incy
      integer(c_int),value :: batch_count
      !
      rocblas_zhemv_batched_rank_1 = rocblas_zhemv_batched_orig(handle,uplo,n,alpha,c_loc(A),lda,c_loc(x),incx,beta,c_loc(y),incy,batch_count)
    end function

    function rocblas_chemv_strided_batched_full_rank(handle,uplo,n,alpha,A,lda,stride_A,x,incx,stride_x,beta,y,incy,stride_y,batch_count)
      use iso_c_binding
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocblas_chemv_strided_batched_full_rank
      type(c_ptr),value :: handle
      integer(kind(rocblas_fill_upper)),value :: uplo
      integer(c_int),value :: n
      complex(c_float_complex) :: alpha
      complex(c_float_complex),target,dimension(:,:) :: A
      integer(c_int),value :: lda
      integer(c_int64_t),value :: stride_A
      complex(c_float_complex),target,dimension(:) :: x
      integer(c_int),value :: incx
      integer(c_int64_t),value :: stride_x
      complex(c_float_complex) :: beta
      complex(c_float_complex),target,dimension(:) :: y
      integer(c_int),value :: incy
      integer(c_int64_t),value :: stride_y
      integer(c_int),value :: batch_count
      !
      rocblas_chemv_strided_batched_full_rank = rocblas_chemv_strided_batched_orig(handle,uplo,n,alpha,c_loc(A),lda,stride_A,c_loc(x),incx,stride_x,beta,c_loc(y),incy,stride_y,batch_count)
    end function

    function rocblas_chemv_strided_batched_rank_0(handle,uplo,n,alpha,A,lda,stride_A,x,incx,stride_x,beta,y,incy,stride_y,batch_count)
      use iso_c_binding
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocblas_chemv_strided_batched_rank_0
      type(c_ptr),value :: handle
      integer(kind(rocblas_fill_upper)),value :: uplo
      integer(c_int),value :: n
      complex(c_float_complex) :: alpha
      complex(c_float_complex),target :: A
      integer(c_int),value :: lda
      integer(c_int64_t),value :: stride_A
      complex(c_float_complex),target :: x
      integer(c_int),value :: incx
      integer(c_int64_t),value :: stride_x
      complex(c_float_complex) :: beta
      complex(c_float_complex),target :: y
      integer(c_int),value :: incy
      integer(c_int64_t),value :: stride_y
      integer(c_int),value :: batch_count
      !
      rocblas_chemv_strided_batched_rank_0 = rocblas_chemv_strided_batched_orig(handle,uplo,n,alpha,c_loc(A),lda,stride_A,c_loc(x),incx,stride_x,beta,c_loc(y),incy,stride_y,batch_count)
    end function

    function rocblas_chemv_strided_batched_rank_1(handle,uplo,n,alpha,A,lda,stride_A,x,incx,stride_x,beta,y,incy,stride_y,batch_count)
      use iso_c_binding
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocblas_chemv_strided_batched_rank_1
      type(c_ptr),value :: handle
      integer(kind(rocblas_fill_upper)),value :: uplo
      integer(c_int),value :: n
      complex(c_float_complex) :: alpha
      complex(c_float_complex),target,dimension(:) :: A
      integer(c_int),value :: lda
      integer(c_int64_t),value :: stride_A
      complex(c_float_complex),target,dimension(:) :: x
      integer(c_int),value :: incx
      integer(c_int64_t),value :: stride_x
      complex(c_float_complex) :: beta
      complex(c_float_complex),target,dimension(:) :: y
      integer(c_int),value :: incy
      integer(c_int64_t),value :: stride_y
      integer(c_int),value :: batch_count
      !
      rocblas_chemv_strided_batched_rank_1 = rocblas_chemv_strided_batched_orig(handle,uplo,n,alpha,c_loc(A),lda,stride_A,c_loc(x),incx,stride_x,beta,c_loc(y),incy,stride_y,batch_count)
    end function

    function rocblas_zhemv_strided_batched_full_rank(handle,uplo,n,alpha,A,lda,stride_A,x,incx,stride_x,beta,y,incy,stride_y,batch_count)
      use iso_c_binding
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocblas_zhemv_strided_batched_full_rank
      type(c_ptr),value :: handle
      integer(kind(rocblas_fill_upper)),value :: uplo
      integer(c_int),value :: n
      complex(c_double_complex) :: alpha
      complex(c_double_complex),target,dimension(:,:) :: A
      integer(c_int),value :: lda
      integer(c_int64_t),value :: stride_A
      complex(c_double_complex),target,dimension(:) :: x
      integer(c_int),value :: incx
      integer(c_int64_t),value :: stride_x
      complex(c_double_complex) :: beta
      complex(c_double_complex),target,dimension(:) :: y
      integer(c_int),value :: incy
      integer(c_int64_t),value :: stride_y
      integer(c_int),value :: batch_count
      !
      rocblas_zhemv_strided_batched_full_rank = rocblas_zhemv_strided_batched_orig(handle,uplo,n,alpha,c_loc(A),lda,stride_A,c_loc(x),incx,stride_x,beta,c_loc(y),incy,stride_y,batch_count)
    end function

    function rocblas_zhemv_strided_batched_rank_0(handle,uplo,n,alpha,A,lda,stride_A,x,incx,stride_x,beta,y,incy,stride_y,batch_count)
      use iso_c_binding
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocblas_zhemv_strided_batched_rank_0
      type(c_ptr),value :: handle
      integer(kind(rocblas_fill_upper)),value :: uplo
      integer(c_int),value :: n
      complex(c_double_complex) :: alpha
      complex(c_double_complex),target :: A
      integer(c_int),value :: lda
      integer(c_int64_t),value :: stride_A
      complex(c_double_complex),target :: x
      integer(c_int),value :: incx
      integer(c_int64_t),value :: stride_x
      complex(c_double_complex) :: beta
      complex(c_double_complex),target :: y
      integer(c_int),value :: incy
      integer(c_int64_t),value :: stride_y
      integer(c_int),value :: batch_count
      !
      rocblas_zhemv_strided_batched_rank_0 = rocblas_zhemv_strided_batched_orig(handle,uplo,n,alpha,c_loc(A),lda,stride_A,c_loc(x),incx,stride_x,beta,c_loc(y),incy,stride_y,batch_count)
    end function

    function rocblas_zhemv_strided_batched_rank_1(handle,uplo,n,alpha,A,lda,stride_A,x,incx,stride_x,beta,y,incy,stride_y,batch_count)
      use iso_c_binding
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocblas_zhemv_strided_batched_rank_1
      type(c_ptr),value :: handle
      integer(kind(rocblas_fill_upper)),value :: uplo
      integer(c_int),value :: n
      complex(c_double_complex) :: alpha
      complex(c_double_complex),target,dimension(:) :: A
      integer(c_int),value :: lda
      integer(c_int64_t),value :: stride_A
      complex(c_double_complex),target,dimension(:) :: x
      integer(c_int),value :: incx
      integer(c_int64_t),value :: stride_x
      complex(c_double_complex) :: beta
      complex(c_double_complex),target,dimension(:) :: y
      integer(c_int),value :: incy
      integer(c_int64_t),value :: stride_y
      integer(c_int),value :: batch_count
      !
      rocblas_zhemv_strided_batched_rank_1 = rocblas_zhemv_strided_batched_orig(handle,uplo,n,alpha,c_loc(A),lda,stride_A,c_loc(x),incx,stride_x,beta,c_loc(y),incy,stride_y,batch_count)
    end function

    function rocblas_cher_full_rank(handle,uplo,n,alpha,x,incx,A,lda)
      use iso_c_binding
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocblas_cher_full_rank
      type(c_ptr),value :: handle
      integer(kind(rocblas_fill_upper)),value :: uplo
      integer(c_int),value :: n
      real(c_float) :: alpha
      complex(c_float_complex),target,dimension(:) :: x
      integer(c_int),value :: incx
      complex(c_float_complex),target,dimension(:,:) :: A
      integer(c_int),value :: lda
      !
      rocblas_cher_full_rank = rocblas_cher_orig(handle,uplo,n,alpha,c_loc(x),incx,c_loc(A),lda)
    end function

    function rocblas_cher_rank_0(handle,uplo,n,alpha,x,incx,A,lda)
      use iso_c_binding
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocblas_cher_rank_0
      type(c_ptr),value :: handle
      integer(kind(rocblas_fill_upper)),value :: uplo
      integer(c_int),value :: n
      real(c_float) :: alpha
      complex(c_float_complex),target :: x
      integer(c_int),value :: incx
      complex(c_float_complex),target :: A
      integer(c_int),value :: lda
      !
      rocblas_cher_rank_0 = rocblas_cher_orig(handle,uplo,n,alpha,c_loc(x),incx,c_loc(A),lda)
    end function

    function rocblas_cher_rank_1(handle,uplo,n,alpha,x,incx,A,lda)
      use iso_c_binding
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocblas_cher_rank_1
      type(c_ptr),value :: handle
      integer(kind(rocblas_fill_upper)),value :: uplo
      integer(c_int),value :: n
      real(c_float) :: alpha
      complex(c_float_complex),target,dimension(:) :: x
      integer(c_int),value :: incx
      complex(c_float_complex),target,dimension(:) :: A
      integer(c_int),value :: lda
      !
      rocblas_cher_rank_1 = rocblas_cher_orig(handle,uplo,n,alpha,c_loc(x),incx,c_loc(A),lda)
    end function

    function rocblas_zher_full_rank(handle,uplo,n,alpha,x,incx,A,lda)
      use iso_c_binding
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocblas_zher_full_rank
      type(c_ptr),value :: handle
      integer(kind(rocblas_fill_upper)),value :: uplo
      integer(c_int),value :: n
      real(c_double) :: alpha
      complex(c_double_complex),target,dimension(:) :: x
      integer(c_int),value :: incx
      complex(c_double_complex),target,dimension(:,:) :: A
      integer(c_int),value :: lda
      !
      rocblas_zher_full_rank = rocblas_zher_orig(handle,uplo,n,alpha,c_loc(x),incx,c_loc(A),lda)
    end function

    function rocblas_zher_rank_0(handle,uplo,n,alpha,x,incx,A,lda)
      use iso_c_binding
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocblas_zher_rank_0
      type(c_ptr),value :: handle
      integer(kind(rocblas_fill_upper)),value :: uplo
      integer(c_int),value :: n
      real(c_double) :: alpha
      complex(c_double_complex),target :: x
      integer(c_int),value :: incx
      complex(c_double_complex),target :: A
      integer(c_int),value :: lda
      !
      rocblas_zher_rank_0 = rocblas_zher_orig(handle,uplo,n,alpha,c_loc(x),incx,c_loc(A),lda)
    end function

    function rocblas_zher_rank_1(handle,uplo,n,alpha,x,incx,A,lda)
      use iso_c_binding
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocblas_zher_rank_1
      type(c_ptr),value :: handle
      integer(kind(rocblas_fill_upper)),value :: uplo
      integer(c_int),value :: n
      real(c_double) :: alpha
      complex(c_double_complex),target,dimension(:) :: x
      integer(c_int),value :: incx
      complex(c_double_complex),target,dimension(:) :: A
      integer(c_int),value :: lda
      !
      rocblas_zher_rank_1 = rocblas_zher_orig(handle,uplo,n,alpha,c_loc(x),incx,c_loc(A),lda)
    end function

    function rocblas_cher_batched_full_rank(handle,uplo,n,alpha,x,incx,A,lda,batch_count)
      use iso_c_binding
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocblas_cher_batched_full_rank
      type(c_ptr),value :: handle
      integer(kind(rocblas_fill_upper)),value :: uplo
      integer(c_int),value :: n
      real(c_float) :: alpha
      complex(c_float_complex),target,dimension(:,:) :: x
      integer(c_int),value :: incx
      complex(c_float_complex),target,dimension(:,:,:) :: A
      integer(c_int),value :: lda
      integer(c_int),value :: batch_count
      !
      rocblas_cher_batched_full_rank = rocblas_cher_batched_orig(handle,uplo,n,alpha,c_loc(x),incx,c_loc(A),lda,batch_count)
    end function

    function rocblas_cher_batched_rank_0(handle,uplo,n,alpha,x,incx,A,lda,batch_count)
      use iso_c_binding
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocblas_cher_batched_rank_0
      type(c_ptr),value :: handle
      integer(kind(rocblas_fill_upper)),value :: uplo
      integer(c_int),value :: n
      real(c_float) :: alpha
      complex(c_float_complex),target :: x
      integer(c_int),value :: incx
      complex(c_float_complex),target :: A
      integer(c_int),value :: lda
      integer(c_int),value :: batch_count
      !
      rocblas_cher_batched_rank_0 = rocblas_cher_batched_orig(handle,uplo,n,alpha,c_loc(x),incx,c_loc(A),lda,batch_count)
    end function

    function rocblas_cher_batched_rank_1(handle,uplo,n,alpha,x,incx,A,lda,batch_count)
      use iso_c_binding
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocblas_cher_batched_rank_1
      type(c_ptr),value :: handle
      integer(kind(rocblas_fill_upper)),value :: uplo
      integer(c_int),value :: n
      real(c_float) :: alpha
      complex(c_float_complex),target,dimension(:) :: x
      integer(c_int),value :: incx
      complex(c_float_complex),target,dimension(:) :: A
      integer(c_int),value :: lda
      integer(c_int),value :: batch_count
      !
      rocblas_cher_batched_rank_1 = rocblas_cher_batched_orig(handle,uplo,n,alpha,c_loc(x),incx,c_loc(A),lda,batch_count)
    end function

    function rocblas_zher_batched_full_rank(handle,uplo,n,alpha,x,incx,A,lda,batch_count)
      use iso_c_binding
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocblas_zher_batched_full_rank
      type(c_ptr),value :: handle
      integer(kind(rocblas_fill_upper)),value :: uplo
      integer(c_int),value :: n
      real(c_double) :: alpha
      complex(c_double_complex),target,dimension(:,:) :: x
      integer(c_int),value :: incx
      complex(c_double_complex),target,dimension(:,:,:) :: A
      integer(c_int),value :: lda
      integer(c_int),value :: batch_count
      !
      rocblas_zher_batched_full_rank = rocblas_zher_batched_orig(handle,uplo,n,alpha,c_loc(x),incx,c_loc(A),lda,batch_count)
    end function

    function rocblas_zher_batched_rank_0(handle,uplo,n,alpha,x,incx,A,lda,batch_count)
      use iso_c_binding
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocblas_zher_batched_rank_0
      type(c_ptr),value :: handle
      integer(kind(rocblas_fill_upper)),value :: uplo
      integer(c_int),value :: n
      real(c_double) :: alpha
      complex(c_double_complex),target :: x
      integer(c_int),value :: incx
      complex(c_double_complex),target :: A
      integer(c_int),value :: lda
      integer(c_int),value :: batch_count
      !
      rocblas_zher_batched_rank_0 = rocblas_zher_batched_orig(handle,uplo,n,alpha,c_loc(x),incx,c_loc(A),lda,batch_count)
    end function

    function rocblas_zher_batched_rank_1(handle,uplo,n,alpha,x,incx,A,lda,batch_count)
      use iso_c_binding
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocblas_zher_batched_rank_1
      type(c_ptr),value :: handle
      integer(kind(rocblas_fill_upper)),value :: uplo
      integer(c_int),value :: n
      real(c_double) :: alpha
      complex(c_double_complex),target,dimension(:) :: x
      integer(c_int),value :: incx
      complex(c_double_complex),target,dimension(:) :: A
      integer(c_int),value :: lda
      integer(c_int),value :: batch_count
      !
      rocblas_zher_batched_rank_1 = rocblas_zher_batched_orig(handle,uplo,n,alpha,c_loc(x),incx,c_loc(A),lda,batch_count)
    end function

    function rocblas_cher_strided_batched_full_rank(handle,uplo,n,alpha,x,incx,stride_x,A,lda,stride_A,batch_count)
      use iso_c_binding
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocblas_cher_strided_batched_full_rank
      type(c_ptr),value :: handle
      integer(kind(rocblas_fill_upper)),value :: uplo
      integer(c_int),value :: n
      real(c_float) :: alpha
      complex(c_float_complex),target,dimension(:) :: x
      integer(c_int),value :: incx
      integer(c_int64_t),value :: stride_x
      complex(c_float_complex),target,dimension(:,:) :: A
      integer(c_int),value :: lda
      integer(c_int64_t),value :: stride_A
      integer(c_int),value :: batch_count
      !
      rocblas_cher_strided_batched_full_rank = rocblas_cher_strided_batched_orig(handle,uplo,n,alpha,c_loc(x),incx,stride_x,c_loc(A),lda,stride_A,batch_count)
    end function

    function rocblas_cher_strided_batched_rank_0(handle,uplo,n,alpha,x,incx,stride_x,A,lda,stride_A,batch_count)
      use iso_c_binding
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocblas_cher_strided_batched_rank_0
      type(c_ptr),value :: handle
      integer(kind(rocblas_fill_upper)),value :: uplo
      integer(c_int),value :: n
      real(c_float) :: alpha
      complex(c_float_complex),target :: x
      integer(c_int),value :: incx
      integer(c_int64_t),value :: stride_x
      complex(c_float_complex),target :: A
      integer(c_int),value :: lda
      integer(c_int64_t),value :: stride_A
      integer(c_int),value :: batch_count
      !
      rocblas_cher_strided_batched_rank_0 = rocblas_cher_strided_batched_orig(handle,uplo,n,alpha,c_loc(x),incx,stride_x,c_loc(A),lda,stride_A,batch_count)
    end function

    function rocblas_cher_strided_batched_rank_1(handle,uplo,n,alpha,x,incx,stride_x,A,lda,stride_A,batch_count)
      use iso_c_binding
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocblas_cher_strided_batched_rank_1
      type(c_ptr),value :: handle
      integer(kind(rocblas_fill_upper)),value :: uplo
      integer(c_int),value :: n
      real(c_float) :: alpha
      complex(c_float_complex),target,dimension(:) :: x
      integer(c_int),value :: incx
      integer(c_int64_t),value :: stride_x
      complex(c_float_complex),target,dimension(:) :: A
      integer(c_int),value :: lda
      integer(c_int64_t),value :: stride_A
      integer(c_int),value :: batch_count
      !
      rocblas_cher_strided_batched_rank_1 = rocblas_cher_strided_batched_orig(handle,uplo,n,alpha,c_loc(x),incx,stride_x,c_loc(A),lda,stride_A,batch_count)
    end function

    function rocblas_zher_strided_batched_full_rank(handle,uplo,n,alpha,x,incx,stride_x,A,lda,stride_A,batch_count)
      use iso_c_binding
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocblas_zher_strided_batched_full_rank
      type(c_ptr),value :: handle
      integer(kind(rocblas_fill_upper)),value :: uplo
      integer(c_int),value :: n
      real(c_double) :: alpha
      complex(c_double_complex),target,dimension(:) :: x
      integer(c_int),value :: incx
      integer(c_int64_t),value :: stride_x
      complex(c_double_complex),target,dimension(:,:) :: A
      integer(c_int),value :: lda
      integer(c_int64_t),value :: stride_A
      integer(c_int),value :: batch_count
      !
      rocblas_zher_strided_batched_full_rank = rocblas_zher_strided_batched_orig(handle,uplo,n,alpha,c_loc(x),incx,stride_x,c_loc(A),lda,stride_A,batch_count)
    end function

    function rocblas_zher_strided_batched_rank_0(handle,uplo,n,alpha,x,incx,stride_x,A,lda,stride_A,batch_count)
      use iso_c_binding
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocblas_zher_strided_batched_rank_0
      type(c_ptr),value :: handle
      integer(kind(rocblas_fill_upper)),value :: uplo
      integer(c_int),value :: n
      real(c_double) :: alpha
      complex(c_double_complex),target :: x
      integer(c_int),value :: incx
      integer(c_int64_t),value :: stride_x
      complex(c_double_complex),target :: A
      integer(c_int),value :: lda
      integer(c_int64_t),value :: stride_A
      integer(c_int),value :: batch_count
      !
      rocblas_zher_strided_batched_rank_0 = rocblas_zher_strided_batched_orig(handle,uplo,n,alpha,c_loc(x),incx,stride_x,c_loc(A),lda,stride_A,batch_count)
    end function

    function rocblas_zher_strided_batched_rank_1(handle,uplo,n,alpha,x,incx,stride_x,A,lda,stride_A,batch_count)
      use iso_c_binding
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocblas_zher_strided_batched_rank_1
      type(c_ptr),value :: handle
      integer(kind(rocblas_fill_upper)),value :: uplo
      integer(c_int),value :: n
      real(c_double) :: alpha
      complex(c_double_complex),target,dimension(:) :: x
      integer(c_int),value :: incx
      integer(c_int64_t),value :: stride_x
      complex(c_double_complex),target,dimension(:) :: A
      integer(c_int),value :: lda
      integer(c_int64_t),value :: stride_A
      integer(c_int),value :: batch_count
      !
      rocblas_zher_strided_batched_rank_1 = rocblas_zher_strided_batched_orig(handle,uplo,n,alpha,c_loc(x),incx,stride_x,c_loc(A),lda,stride_A,batch_count)
    end function

    function rocblas_cher2_full_rank(handle,uplo,n,alpha,x,incx,y,incy,A,lda)
      use iso_c_binding
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocblas_cher2_full_rank
      type(c_ptr),value :: handle
      integer(kind(rocblas_fill_upper)),value :: uplo
      integer(c_int),value :: n
      complex(c_float_complex) :: alpha
      complex(c_float_complex),target,dimension(:) :: x
      integer(c_int),value :: incx
      complex(c_float_complex),target,dimension(:) :: y
      integer(c_int),value :: incy
      complex(c_float_complex),target,dimension(:,:) :: A
      integer(c_int),value :: lda
      !
      rocblas_cher2_full_rank = rocblas_cher2_orig(handle,uplo,n,alpha,c_loc(x),incx,c_loc(y),incy,c_loc(A),lda)
    end function

    function rocblas_cher2_rank_0(handle,uplo,n,alpha,x,incx,y,incy,A,lda)
      use iso_c_binding
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocblas_cher2_rank_0
      type(c_ptr),value :: handle
      integer(kind(rocblas_fill_upper)),value :: uplo
      integer(c_int),value :: n
      complex(c_float_complex) :: alpha
      complex(c_float_complex),target :: x
      integer(c_int),value :: incx
      complex(c_float_complex),target :: y
      integer(c_int),value :: incy
      complex(c_float_complex),target :: A
      integer(c_int),value :: lda
      !
      rocblas_cher2_rank_0 = rocblas_cher2_orig(handle,uplo,n,alpha,c_loc(x),incx,c_loc(y),incy,c_loc(A),lda)
    end function

    function rocblas_cher2_rank_1(handle,uplo,n,alpha,x,incx,y,incy,A,lda)
      use iso_c_binding
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocblas_cher2_rank_1
      type(c_ptr),value :: handle
      integer(kind(rocblas_fill_upper)),value :: uplo
      integer(c_int),value :: n
      complex(c_float_complex) :: alpha
      complex(c_float_complex),target,dimension(:) :: x
      integer(c_int),value :: incx
      complex(c_float_complex),target,dimension(:) :: y
      integer(c_int),value :: incy
      complex(c_float_complex),target,dimension(:) :: A
      integer(c_int),value :: lda
      !
      rocblas_cher2_rank_1 = rocblas_cher2_orig(handle,uplo,n,alpha,c_loc(x),incx,c_loc(y),incy,c_loc(A),lda)
    end function

    function rocblas_zher2_full_rank(handle,uplo,n,alpha,x,incx,y,incy,A,lda)
      use iso_c_binding
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocblas_zher2_full_rank
      type(c_ptr),value :: handle
      integer(kind(rocblas_fill_upper)),value :: uplo
      integer(c_int),value :: n
      complex(c_double_complex) :: alpha
      complex(c_double_complex),target,dimension(:) :: x
      integer(c_int),value :: incx
      complex(c_double_complex),target,dimension(:) :: y
      integer(c_int),value :: incy
      complex(c_double_complex),target,dimension(:,:) :: A
      integer(c_int),value :: lda
      !
      rocblas_zher2_full_rank = rocblas_zher2_orig(handle,uplo,n,alpha,c_loc(x),incx,c_loc(y),incy,c_loc(A),lda)
    end function

    function rocblas_zher2_rank_0(handle,uplo,n,alpha,x,incx,y,incy,A,lda)
      use iso_c_binding
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocblas_zher2_rank_0
      type(c_ptr),value :: handle
      integer(kind(rocblas_fill_upper)),value :: uplo
      integer(c_int),value :: n
      complex(c_double_complex) :: alpha
      complex(c_double_complex),target :: x
      integer(c_int),value :: incx
      complex(c_double_complex),target :: y
      integer(c_int),value :: incy
      complex(c_double_complex),target :: A
      integer(c_int),value :: lda
      !
      rocblas_zher2_rank_0 = rocblas_zher2_orig(handle,uplo,n,alpha,c_loc(x),incx,c_loc(y),incy,c_loc(A),lda)
    end function

    function rocblas_zher2_rank_1(handle,uplo,n,alpha,x,incx,y,incy,A,lda)
      use iso_c_binding
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocblas_zher2_rank_1
      type(c_ptr),value :: handle
      integer(kind(rocblas_fill_upper)),value :: uplo
      integer(c_int),value :: n
      complex(c_double_complex) :: alpha
      complex(c_double_complex),target,dimension(:) :: x
      integer(c_int),value :: incx
      complex(c_double_complex),target,dimension(:) :: y
      integer(c_int),value :: incy
      complex(c_double_complex),target,dimension(:) :: A
      integer(c_int),value :: lda
      !
      rocblas_zher2_rank_1 = rocblas_zher2_orig(handle,uplo,n,alpha,c_loc(x),incx,c_loc(y),incy,c_loc(A),lda)
    end function

    function rocblas_cher2_batched_full_rank(handle,uplo,n,alpha,x,incx,y,incy,A,lda,batch_count)
      use iso_c_binding
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocblas_cher2_batched_full_rank
      type(c_ptr),value :: handle
      integer(kind(rocblas_fill_upper)),value :: uplo
      integer(c_int),value :: n
      complex(c_float_complex) :: alpha
      complex(c_float_complex),target,dimension(:,:) :: x
      integer(c_int),value :: incx
      complex(c_float_complex),target,dimension(:,:) :: y
      integer(c_int),value :: incy
      complex(c_float_complex),target,dimension(:,:,:) :: A
      integer(c_int),value :: lda
      integer(c_int),value :: batch_count
      !
      rocblas_cher2_batched_full_rank = rocblas_cher2_batched_orig(handle,uplo,n,alpha,c_loc(x),incx,c_loc(y),incy,c_loc(A),lda,batch_count)
    end function

    function rocblas_cher2_batched_rank_0(handle,uplo,n,alpha,x,incx,y,incy,A,lda,batch_count)
      use iso_c_binding
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocblas_cher2_batched_rank_0
      type(c_ptr),value :: handle
      integer(kind(rocblas_fill_upper)),value :: uplo
      integer(c_int),value :: n
      complex(c_float_complex) :: alpha
      complex(c_float_complex),target :: x
      integer(c_int),value :: incx
      complex(c_float_complex),target :: y
      integer(c_int),value :: incy
      complex(c_float_complex),target :: A
      integer(c_int),value :: lda
      integer(c_int),value :: batch_count
      !
      rocblas_cher2_batched_rank_0 = rocblas_cher2_batched_orig(handle,uplo,n,alpha,c_loc(x),incx,c_loc(y),incy,c_loc(A),lda,batch_count)
    end function

    function rocblas_cher2_batched_rank_1(handle,uplo,n,alpha,x,incx,y,incy,A,lda,batch_count)
      use iso_c_binding
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocblas_cher2_batched_rank_1
      type(c_ptr),value :: handle
      integer(kind(rocblas_fill_upper)),value :: uplo
      integer(c_int),value :: n
      complex(c_float_complex) :: alpha
      complex(c_float_complex),target,dimension(:) :: x
      integer(c_int),value :: incx
      complex(c_float_complex),target,dimension(:) :: y
      integer(c_int),value :: incy
      complex(c_float_complex),target,dimension(:) :: A
      integer(c_int),value :: lda
      integer(c_int),value :: batch_count
      !
      rocblas_cher2_batched_rank_1 = rocblas_cher2_batched_orig(handle,uplo,n,alpha,c_loc(x),incx,c_loc(y),incy,c_loc(A),lda,batch_count)
    end function

    function rocblas_zher2_batched_full_rank(handle,uplo,n,alpha,x,incx,y,incy,A,lda,batch_count)
      use iso_c_binding
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocblas_zher2_batched_full_rank
      type(c_ptr),value :: handle
      integer(kind(rocblas_fill_upper)),value :: uplo
      integer(c_int),value :: n
      complex(c_double_complex) :: alpha
      complex(c_double_complex),target,dimension(:,:) :: x
      integer(c_int),value :: incx
      complex(c_double_complex),target,dimension(:,:) :: y
      integer(c_int),value :: incy
      complex(c_double_complex),target,dimension(:,:,:) :: A
      integer(c_int),value :: lda
      integer(c_int),value :: batch_count
      !
      rocblas_zher2_batched_full_rank = rocblas_zher2_batched_orig(handle,uplo,n,alpha,c_loc(x),incx,c_loc(y),incy,c_loc(A),lda,batch_count)
    end function

    function rocblas_zher2_batched_rank_0(handle,uplo,n,alpha,x,incx,y,incy,A,lda,batch_count)
      use iso_c_binding
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocblas_zher2_batched_rank_0
      type(c_ptr),value :: handle
      integer(kind(rocblas_fill_upper)),value :: uplo
      integer(c_int),value :: n
      complex(c_double_complex) :: alpha
      complex(c_double_complex),target :: x
      integer(c_int),value :: incx
      complex(c_double_complex),target :: y
      integer(c_int),value :: incy
      complex(c_double_complex),target :: A
      integer(c_int),value :: lda
      integer(c_int),value :: batch_count
      !
      rocblas_zher2_batched_rank_0 = rocblas_zher2_batched_orig(handle,uplo,n,alpha,c_loc(x),incx,c_loc(y),incy,c_loc(A),lda,batch_count)
    end function

    function rocblas_zher2_batched_rank_1(handle,uplo,n,alpha,x,incx,y,incy,A,lda,batch_count)
      use iso_c_binding
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocblas_zher2_batched_rank_1
      type(c_ptr),value :: handle
      integer(kind(rocblas_fill_upper)),value :: uplo
      integer(c_int),value :: n
      complex(c_double_complex) :: alpha
      complex(c_double_complex),target,dimension(:) :: x
      integer(c_int),value :: incx
      complex(c_double_complex),target,dimension(:) :: y
      integer(c_int),value :: incy
      complex(c_double_complex),target,dimension(:) :: A
      integer(c_int),value :: lda
      integer(c_int),value :: batch_count
      !
      rocblas_zher2_batched_rank_1 = rocblas_zher2_batched_orig(handle,uplo,n,alpha,c_loc(x),incx,c_loc(y),incy,c_loc(A),lda,batch_count)
    end function

    function rocblas_cher2_strided_batched_full_rank(handle,uplo,n,alpha,x,incx,stride_x,y,incy,stride_y,A,lda,stride_A,batch_count)
      use iso_c_binding
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocblas_cher2_strided_batched_full_rank
      type(c_ptr),value :: handle
      integer(kind(rocblas_fill_upper)),value :: uplo
      integer(c_int),value :: n
      complex(c_float_complex) :: alpha
      complex(c_float_complex),target,dimension(:) :: x
      integer(c_int),value :: incx
      integer(c_int64_t),value :: stride_x
      complex(c_float_complex),target,dimension(:) :: y
      integer(c_int),value :: incy
      integer(c_int64_t),value :: stride_y
      complex(c_float_complex),target,dimension(:,:) :: A
      integer(c_int),value :: lda
      integer(c_int64_t),value :: stride_A
      integer(c_int),value :: batch_count
      !
      rocblas_cher2_strided_batched_full_rank = rocblas_cher2_strided_batched_orig(handle,uplo,n,alpha,c_loc(x),incx,stride_x,c_loc(y),incy,stride_y,c_loc(A),lda,stride_A,batch_count)
    end function

    function rocblas_cher2_strided_batched_rank_0(handle,uplo,n,alpha,x,incx,stride_x,y,incy,stride_y,A,lda,stride_A,batch_count)
      use iso_c_binding
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocblas_cher2_strided_batched_rank_0
      type(c_ptr),value :: handle
      integer(kind(rocblas_fill_upper)),value :: uplo
      integer(c_int),value :: n
      complex(c_float_complex) :: alpha
      complex(c_float_complex),target :: x
      integer(c_int),value :: incx
      integer(c_int64_t),value :: stride_x
      complex(c_float_complex),target :: y
      integer(c_int),value :: incy
      integer(c_int64_t),value :: stride_y
      complex(c_float_complex),target :: A
      integer(c_int),value :: lda
      integer(c_int64_t),value :: stride_A
      integer(c_int),value :: batch_count
      !
      rocblas_cher2_strided_batched_rank_0 = rocblas_cher2_strided_batched_orig(handle,uplo,n,alpha,c_loc(x),incx,stride_x,c_loc(y),incy,stride_y,c_loc(A),lda,stride_A,batch_count)
    end function

    function rocblas_cher2_strided_batched_rank_1(handle,uplo,n,alpha,x,incx,stride_x,y,incy,stride_y,A,lda,stride_A,batch_count)
      use iso_c_binding
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocblas_cher2_strided_batched_rank_1
      type(c_ptr),value :: handle
      integer(kind(rocblas_fill_upper)),value :: uplo
      integer(c_int),value :: n
      complex(c_float_complex) :: alpha
      complex(c_float_complex),target,dimension(:) :: x
      integer(c_int),value :: incx
      integer(c_int64_t),value :: stride_x
      complex(c_float_complex),target,dimension(:) :: y
      integer(c_int),value :: incy
      integer(c_int64_t),value :: stride_y
      complex(c_float_complex),target,dimension(:) :: A
      integer(c_int),value :: lda
      integer(c_int64_t),value :: stride_A
      integer(c_int),value :: batch_count
      !
      rocblas_cher2_strided_batched_rank_1 = rocblas_cher2_strided_batched_orig(handle,uplo,n,alpha,c_loc(x),incx,stride_x,c_loc(y),incy,stride_y,c_loc(A),lda,stride_A,batch_count)
    end function

    function rocblas_zher2_strided_batched_full_rank(handle,uplo,n,alpha,x,incx,stride_x,y,incy,stride_y,A,lda,stride_A,batch_count)
      use iso_c_binding
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocblas_zher2_strided_batched_full_rank
      type(c_ptr),value :: handle
      integer(kind(rocblas_fill_upper)),value :: uplo
      integer(c_int),value :: n
      complex(c_double_complex) :: alpha
      complex(c_double_complex),target,dimension(:) :: x
      integer(c_int),value :: incx
      integer(c_int64_t),value :: stride_x
      complex(c_double_complex),target,dimension(:) :: y
      integer(c_int),value :: incy
      integer(c_int64_t),value :: stride_y
      complex(c_double_complex),target,dimension(:,:) :: A
      integer(c_int),value :: lda
      integer(c_int64_t),value :: stride_A
      integer(c_int),value :: batch_count
      !
      rocblas_zher2_strided_batched_full_rank = rocblas_zher2_strided_batched_orig(handle,uplo,n,alpha,c_loc(x),incx,stride_x,c_loc(y),incy,stride_y,c_loc(A),lda,stride_A,batch_count)
    end function

    function rocblas_zher2_strided_batched_rank_0(handle,uplo,n,alpha,x,incx,stride_x,y,incy,stride_y,A,lda,stride_A,batch_count)
      use iso_c_binding
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocblas_zher2_strided_batched_rank_0
      type(c_ptr),value :: handle
      integer(kind(rocblas_fill_upper)),value :: uplo
      integer(c_int),value :: n
      complex(c_double_complex) :: alpha
      complex(c_double_complex),target :: x
      integer(c_int),value :: incx
      integer(c_int64_t),value :: stride_x
      complex(c_double_complex),target :: y
      integer(c_int),value :: incy
      integer(c_int64_t),value :: stride_y
      complex(c_double_complex),target :: A
      integer(c_int),value :: lda
      integer(c_int64_t),value :: stride_A
      integer(c_int),value :: batch_count
      !
      rocblas_zher2_strided_batched_rank_0 = rocblas_zher2_strided_batched_orig(handle,uplo,n,alpha,c_loc(x),incx,stride_x,c_loc(y),incy,stride_y,c_loc(A),lda,stride_A,batch_count)
    end function

    function rocblas_zher2_strided_batched_rank_1(handle,uplo,n,alpha,x,incx,stride_x,y,incy,stride_y,A,lda,stride_A,batch_count)
      use iso_c_binding
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocblas_zher2_strided_batched_rank_1
      type(c_ptr),value :: handle
      integer(kind(rocblas_fill_upper)),value :: uplo
      integer(c_int),value :: n
      complex(c_double_complex) :: alpha
      complex(c_double_complex),target,dimension(:) :: x
      integer(c_int),value :: incx
      integer(c_int64_t),value :: stride_x
      complex(c_double_complex),target,dimension(:) :: y
      integer(c_int),value :: incy
      integer(c_int64_t),value :: stride_y
      complex(c_double_complex),target,dimension(:) :: A
      integer(c_int),value :: lda
      integer(c_int64_t),value :: stride_A
      integer(c_int),value :: batch_count
      !
      rocblas_zher2_strided_batched_rank_1 = rocblas_zher2_strided_batched_orig(handle,uplo,n,alpha,c_loc(x),incx,stride_x,c_loc(y),incy,stride_y,c_loc(A),lda,stride_A,batch_count)
    end function

    function rocblas_chpmv_rank_0(handle,uplo,n,alpha,AP,x,incx,beta,y,incy)
      use iso_c_binding
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocblas_chpmv_rank_0
      type(c_ptr),value :: handle
      integer(kind(rocblas_fill_upper)),value :: uplo
      integer(c_int),value :: n
      complex(c_float_complex) :: alpha
      type(c_ptr),value :: AP
      complex(c_float_complex),target :: x
      integer(c_int),value :: incx
      complex(c_float_complex) :: beta
      complex(c_float_complex),target :: y
      integer(c_int),value :: incy
      !
      rocblas_chpmv_rank_0 = rocblas_chpmv_orig(handle,uplo,n,alpha,AP,c_loc(x),incx,beta,c_loc(y),incy)
    end function

    function rocblas_chpmv_rank_1(handle,uplo,n,alpha,AP,x,incx,beta,y,incy)
      use iso_c_binding
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocblas_chpmv_rank_1
      type(c_ptr),value :: handle
      integer(kind(rocblas_fill_upper)),value :: uplo
      integer(c_int),value :: n
      complex(c_float_complex) :: alpha
      type(c_ptr),value :: AP
      complex(c_float_complex),target,dimension(:) :: x
      integer(c_int),value :: incx
      complex(c_float_complex) :: beta
      complex(c_float_complex),target,dimension(:) :: y
      integer(c_int),value :: incy
      !
      rocblas_chpmv_rank_1 = rocblas_chpmv_orig(handle,uplo,n,alpha,AP,c_loc(x),incx,beta,c_loc(y),incy)
    end function

    function rocblas_zhpmv_rank_0(handle,uplo,n,alpha,AP,x,incx,beta,y,incy)
      use iso_c_binding
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocblas_zhpmv_rank_0
      type(c_ptr),value :: handle
      integer(kind(rocblas_fill_upper)),value :: uplo
      integer(c_int),value :: n
      complex(c_double_complex) :: alpha
      type(c_ptr),value :: AP
      complex(c_double_complex),target :: x
      integer(c_int),value :: incx
      complex(c_double_complex) :: beta
      complex(c_double_complex),target :: y
      integer(c_int),value :: incy
      !
      rocblas_zhpmv_rank_0 = rocblas_zhpmv_orig(handle,uplo,n,alpha,AP,c_loc(x),incx,beta,c_loc(y),incy)
    end function

    function rocblas_zhpmv_rank_1(handle,uplo,n,alpha,AP,x,incx,beta,y,incy)
      use iso_c_binding
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocblas_zhpmv_rank_1
      type(c_ptr),value :: handle
      integer(kind(rocblas_fill_upper)),value :: uplo
      integer(c_int),value :: n
      complex(c_double_complex) :: alpha
      type(c_ptr),value :: AP
      complex(c_double_complex),target,dimension(:) :: x
      integer(c_int),value :: incx
      complex(c_double_complex) :: beta
      complex(c_double_complex),target,dimension(:) :: y
      integer(c_int),value :: incy
      !
      rocblas_zhpmv_rank_1 = rocblas_zhpmv_orig(handle,uplo,n,alpha,AP,c_loc(x),incx,beta,c_loc(y),incy)
    end function

    function rocblas_chpmv_batched_full_rank(handle,uplo,n,alpha,AP,x,incx,beta,y,incy,batch_count)
      use iso_c_binding
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocblas_chpmv_batched_full_rank
      type(c_ptr),value :: handle
      integer(kind(rocblas_fill_upper)),value :: uplo
      integer(c_int),value :: n
      complex(c_float_complex) :: alpha
      type(c_ptr) :: AP
      complex(c_float_complex),target,dimension(:,:) :: x
      integer(c_int),value :: incx
      complex(c_float_complex) :: beta
      complex(c_float_complex),target,dimension(:,:) :: y
      integer(c_int),value :: incy
      integer(c_int),value :: batch_count
      !
      rocblas_chpmv_batched_full_rank = rocblas_chpmv_batched_orig(handle,uplo,n,alpha,AP,c_loc(x),incx,beta,c_loc(y),incy,batch_count)
    end function

    function rocblas_chpmv_batched_rank_0(handle,uplo,n,alpha,AP,x,incx,beta,y,incy,batch_count)
      use iso_c_binding
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocblas_chpmv_batched_rank_0
      type(c_ptr),value :: handle
      integer(kind(rocblas_fill_upper)),value :: uplo
      integer(c_int),value :: n
      complex(c_float_complex) :: alpha
      type(c_ptr) :: AP
      complex(c_float_complex),target :: x
      integer(c_int),value :: incx
      complex(c_float_complex) :: beta
      complex(c_float_complex),target :: y
      integer(c_int),value :: incy
      integer(c_int),value :: batch_count
      !
      rocblas_chpmv_batched_rank_0 = rocblas_chpmv_batched_orig(handle,uplo,n,alpha,AP,c_loc(x),incx,beta,c_loc(y),incy,batch_count)
    end function

    function rocblas_chpmv_batched_rank_1(handle,uplo,n,alpha,AP,x,incx,beta,y,incy,batch_count)
      use iso_c_binding
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocblas_chpmv_batched_rank_1
      type(c_ptr),value :: handle
      integer(kind(rocblas_fill_upper)),value :: uplo
      integer(c_int),value :: n
      complex(c_float_complex) :: alpha
      type(c_ptr) :: AP
      complex(c_float_complex),target,dimension(:) :: x
      integer(c_int),value :: incx
      complex(c_float_complex) :: beta
      complex(c_float_complex),target,dimension(:) :: y
      integer(c_int),value :: incy
      integer(c_int),value :: batch_count
      !
      rocblas_chpmv_batched_rank_1 = rocblas_chpmv_batched_orig(handle,uplo,n,alpha,AP,c_loc(x),incx,beta,c_loc(y),incy,batch_count)
    end function

    function rocblas_zhpmv_batched_full_rank(handle,uplo,n,alpha,AP,x,incx,beta,y,incy,batch_count)
      use iso_c_binding
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocblas_zhpmv_batched_full_rank
      type(c_ptr),value :: handle
      integer(kind(rocblas_fill_upper)),value :: uplo
      integer(c_int),value :: n
      complex(c_double_complex) :: alpha
      type(c_ptr) :: AP
      complex(c_double_complex),target,dimension(:,:) :: x
      integer(c_int),value :: incx
      complex(c_double_complex) :: beta
      complex(c_double_complex),target,dimension(:,:) :: y
      integer(c_int),value :: incy
      integer(c_int),value :: batch_count
      !
      rocblas_zhpmv_batched_full_rank = rocblas_zhpmv_batched_orig(handle,uplo,n,alpha,AP,c_loc(x),incx,beta,c_loc(y),incy,batch_count)
    end function

    function rocblas_zhpmv_batched_rank_0(handle,uplo,n,alpha,AP,x,incx,beta,y,incy,batch_count)
      use iso_c_binding
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocblas_zhpmv_batched_rank_0
      type(c_ptr),value :: handle
      integer(kind(rocblas_fill_upper)),value :: uplo
      integer(c_int),value :: n
      complex(c_double_complex) :: alpha
      type(c_ptr) :: AP
      complex(c_double_complex),target :: x
      integer(c_int),value :: incx
      complex(c_double_complex) :: beta
      complex(c_double_complex),target :: y
      integer(c_int),value :: incy
      integer(c_int),value :: batch_count
      !
      rocblas_zhpmv_batched_rank_0 = rocblas_zhpmv_batched_orig(handle,uplo,n,alpha,AP,c_loc(x),incx,beta,c_loc(y),incy,batch_count)
    end function

    function rocblas_zhpmv_batched_rank_1(handle,uplo,n,alpha,AP,x,incx,beta,y,incy,batch_count)
      use iso_c_binding
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocblas_zhpmv_batched_rank_1
      type(c_ptr),value :: handle
      integer(kind(rocblas_fill_upper)),value :: uplo
      integer(c_int),value :: n
      complex(c_double_complex) :: alpha
      type(c_ptr) :: AP
      complex(c_double_complex),target,dimension(:) :: x
      integer(c_int),value :: incx
      complex(c_double_complex) :: beta
      complex(c_double_complex),target,dimension(:) :: y
      integer(c_int),value :: incy
      integer(c_int),value :: batch_count
      !
      rocblas_zhpmv_batched_rank_1 = rocblas_zhpmv_batched_orig(handle,uplo,n,alpha,AP,c_loc(x),incx,beta,c_loc(y),incy,batch_count)
    end function

    function rocblas_chpmv_strided_batched_rank_0(handle,uplo,n,alpha,AP,stride_A,x,incx,stride_x,beta,y,incy,stride_y,batch_count)
      use iso_c_binding
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocblas_chpmv_strided_batched_rank_0
      type(c_ptr),value :: handle
      integer(kind(rocblas_fill_upper)),value :: uplo
      integer(c_int),value :: n
      complex(c_float_complex) :: alpha
      type(c_ptr),value :: AP
      integer(c_int64_t),value :: stride_A
      complex(c_float_complex),target :: x
      integer(c_int),value :: incx
      integer(c_int64_t),value :: stride_x
      complex(c_float_complex) :: beta
      complex(c_float_complex),target :: y
      integer(c_int),value :: incy
      integer(c_int64_t),value :: stride_y
      integer(c_int),value :: batch_count
      !
      rocblas_chpmv_strided_batched_rank_0 = rocblas_chpmv_strided_batched_orig(handle,uplo,n,alpha,AP,stride_A,c_loc(x),incx,stride_x,beta,c_loc(y),incy,stride_y,batch_count)
    end function

    function rocblas_chpmv_strided_batched_rank_1(handle,uplo,n,alpha,AP,stride_A,x,incx,stride_x,beta,y,incy,stride_y,batch_count)
      use iso_c_binding
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocblas_chpmv_strided_batched_rank_1
      type(c_ptr),value :: handle
      integer(kind(rocblas_fill_upper)),value :: uplo
      integer(c_int),value :: n
      complex(c_float_complex) :: alpha
      type(c_ptr),value :: AP
      integer(c_int64_t),value :: stride_A
      complex(c_float_complex),target,dimension(:) :: x
      integer(c_int),value :: incx
      integer(c_int64_t),value :: stride_x
      complex(c_float_complex) :: beta
      complex(c_float_complex),target,dimension(:) :: y
      integer(c_int),value :: incy
      integer(c_int64_t),value :: stride_y
      integer(c_int),value :: batch_count
      !
      rocblas_chpmv_strided_batched_rank_1 = rocblas_chpmv_strided_batched_orig(handle,uplo,n,alpha,AP,stride_A,c_loc(x),incx,stride_x,beta,c_loc(y),incy,stride_y,batch_count)
    end function

    function rocblas_zhpmv_strided_batched_rank_0(handle,uplo,n,alpha,AP,stride_A,x,incx,stride_x,beta,y,incy,stride_y,batch_count)
      use iso_c_binding
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocblas_zhpmv_strided_batched_rank_0
      type(c_ptr),value :: handle
      integer(kind(rocblas_fill_upper)),value :: uplo
      integer(c_int),value :: n
      complex(c_double_complex) :: alpha
      type(c_ptr),value :: AP
      integer(c_int64_t),value :: stride_A
      complex(c_double_complex),target :: x
      integer(c_int),value :: incx
      integer(c_int64_t),value :: stride_x
      complex(c_double_complex) :: beta
      complex(c_double_complex),target :: y
      integer(c_int),value :: incy
      integer(c_int64_t),value :: stride_y
      integer(c_int),value :: batch_count
      !
      rocblas_zhpmv_strided_batched_rank_0 = rocblas_zhpmv_strided_batched_orig(handle,uplo,n,alpha,AP,stride_A,c_loc(x),incx,stride_x,beta,c_loc(y),incy,stride_y,batch_count)
    end function

    function rocblas_zhpmv_strided_batched_rank_1(handle,uplo,n,alpha,AP,stride_A,x,incx,stride_x,beta,y,incy,stride_y,batch_count)
      use iso_c_binding
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocblas_zhpmv_strided_batched_rank_1
      type(c_ptr),value :: handle
      integer(kind(rocblas_fill_upper)),value :: uplo
      integer(c_int),value :: n
      complex(c_double_complex) :: alpha
      type(c_ptr),value :: AP
      integer(c_int64_t),value :: stride_A
      complex(c_double_complex),target,dimension(:) :: x
      integer(c_int),value :: incx
      integer(c_int64_t),value :: stride_x
      complex(c_double_complex) :: beta
      complex(c_double_complex),target,dimension(:) :: y
      integer(c_int),value :: incy
      integer(c_int64_t),value :: stride_y
      integer(c_int),value :: batch_count
      !
      rocblas_zhpmv_strided_batched_rank_1 = rocblas_zhpmv_strided_batched_orig(handle,uplo,n,alpha,AP,stride_A,c_loc(x),incx,stride_x,beta,c_loc(y),incy,stride_y,batch_count)
    end function

    function rocblas_chpr_rank_0(handle,uplo,n,alpha,x,incx,AP)
      use iso_c_binding
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocblas_chpr_rank_0
      type(c_ptr),value :: handle
      integer(kind(rocblas_fill_upper)),value :: uplo
      integer(c_int),value :: n
      real(c_float) :: alpha
      complex(c_float_complex),target :: x
      integer(c_int),value :: incx
      type(c_ptr),value :: AP
      !
      rocblas_chpr_rank_0 = rocblas_chpr_orig(handle,uplo,n,alpha,c_loc(x),incx,AP)
    end function

    function rocblas_chpr_rank_1(handle,uplo,n,alpha,x,incx,AP)
      use iso_c_binding
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocblas_chpr_rank_1
      type(c_ptr),value :: handle
      integer(kind(rocblas_fill_upper)),value :: uplo
      integer(c_int),value :: n
      real(c_float) :: alpha
      complex(c_float_complex),target,dimension(:) :: x
      integer(c_int),value :: incx
      type(c_ptr),value :: AP
      !
      rocblas_chpr_rank_1 = rocblas_chpr_orig(handle,uplo,n,alpha,c_loc(x),incx,AP)
    end function

    function rocblas_zhpr_rank_0(handle,uplo,n,alpha,x,incx,AP)
      use iso_c_binding
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocblas_zhpr_rank_0
      type(c_ptr),value :: handle
      integer(kind(rocblas_fill_upper)),value :: uplo
      integer(c_int),value :: n
      real(c_double) :: alpha
      complex(c_double_complex),target :: x
      integer(c_int),value :: incx
      type(c_ptr),value :: AP
      !
      rocblas_zhpr_rank_0 = rocblas_zhpr_orig(handle,uplo,n,alpha,c_loc(x),incx,AP)
    end function

    function rocblas_zhpr_rank_1(handle,uplo,n,alpha,x,incx,AP)
      use iso_c_binding
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocblas_zhpr_rank_1
      type(c_ptr),value :: handle
      integer(kind(rocblas_fill_upper)),value :: uplo
      integer(c_int),value :: n
      real(c_double) :: alpha
      complex(c_double_complex),target,dimension(:) :: x
      integer(c_int),value :: incx
      type(c_ptr),value :: AP
      !
      rocblas_zhpr_rank_1 = rocblas_zhpr_orig(handle,uplo,n,alpha,c_loc(x),incx,AP)
    end function

    function rocblas_chpr_batched_full_rank(handle,uplo,n,alpha,x,incx,AP,batch_count)
      use iso_c_binding
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocblas_chpr_batched_full_rank
      type(c_ptr),value :: handle
      integer(kind(rocblas_fill_upper)),value :: uplo
      integer(c_int),value :: n
      real(c_float) :: alpha
      complex(c_float_complex),target,dimension(:,:) :: x
      integer(c_int),value :: incx
      type(c_ptr) :: AP
      integer(c_int),value :: batch_count
      !
      rocblas_chpr_batched_full_rank = rocblas_chpr_batched_orig(handle,uplo,n,alpha,c_loc(x),incx,AP,batch_count)
    end function

    function rocblas_chpr_batched_rank_0(handle,uplo,n,alpha,x,incx,AP,batch_count)
      use iso_c_binding
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocblas_chpr_batched_rank_0
      type(c_ptr),value :: handle
      integer(kind(rocblas_fill_upper)),value :: uplo
      integer(c_int),value :: n
      real(c_float) :: alpha
      complex(c_float_complex),target :: x
      integer(c_int),value :: incx
      type(c_ptr) :: AP
      integer(c_int),value :: batch_count
      !
      rocblas_chpr_batched_rank_0 = rocblas_chpr_batched_orig(handle,uplo,n,alpha,c_loc(x),incx,AP,batch_count)
    end function

    function rocblas_chpr_batched_rank_1(handle,uplo,n,alpha,x,incx,AP,batch_count)
      use iso_c_binding
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocblas_chpr_batched_rank_1
      type(c_ptr),value :: handle
      integer(kind(rocblas_fill_upper)),value :: uplo
      integer(c_int),value :: n
      real(c_float) :: alpha
      complex(c_float_complex),target,dimension(:) :: x
      integer(c_int),value :: incx
      type(c_ptr) :: AP
      integer(c_int),value :: batch_count
      !
      rocblas_chpr_batched_rank_1 = rocblas_chpr_batched_orig(handle,uplo,n,alpha,c_loc(x),incx,AP,batch_count)
    end function

    function rocblas_zhpr_batched_full_rank(handle,uplo,n,alpha,x,incx,AP,batch_count)
      use iso_c_binding
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocblas_zhpr_batched_full_rank
      type(c_ptr),value :: handle
      integer(kind(rocblas_fill_upper)),value :: uplo
      integer(c_int),value :: n
      real(c_double) :: alpha
      complex(c_double_complex),target,dimension(:,:) :: x
      integer(c_int),value :: incx
      type(c_ptr) :: AP
      integer(c_int),value :: batch_count
      !
      rocblas_zhpr_batched_full_rank = rocblas_zhpr_batched_orig(handle,uplo,n,alpha,c_loc(x),incx,AP,batch_count)
    end function

    function rocblas_zhpr_batched_rank_0(handle,uplo,n,alpha,x,incx,AP,batch_count)
      use iso_c_binding
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocblas_zhpr_batched_rank_0
      type(c_ptr),value :: handle
      integer(kind(rocblas_fill_upper)),value :: uplo
      integer(c_int),value :: n
      real(c_double) :: alpha
      complex(c_double_complex),target :: x
      integer(c_int),value :: incx
      type(c_ptr) :: AP
      integer(c_int),value :: batch_count
      !
      rocblas_zhpr_batched_rank_0 = rocblas_zhpr_batched_orig(handle,uplo,n,alpha,c_loc(x),incx,AP,batch_count)
    end function

    function rocblas_zhpr_batched_rank_1(handle,uplo,n,alpha,x,incx,AP,batch_count)
      use iso_c_binding
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocblas_zhpr_batched_rank_1
      type(c_ptr),value :: handle
      integer(kind(rocblas_fill_upper)),value :: uplo
      integer(c_int),value :: n
      real(c_double) :: alpha
      complex(c_double_complex),target,dimension(:) :: x
      integer(c_int),value :: incx
      type(c_ptr) :: AP
      integer(c_int),value :: batch_count
      !
      rocblas_zhpr_batched_rank_1 = rocblas_zhpr_batched_orig(handle,uplo,n,alpha,c_loc(x),incx,AP,batch_count)
    end function

    function rocblas_chpr_strided_batched_rank_0(handle,uplo,n,alpha,x,incx,stride_x,AP,stride_A,batch_count)
      use iso_c_binding
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocblas_chpr_strided_batched_rank_0
      type(c_ptr),value :: handle
      integer(kind(rocblas_fill_upper)),value :: uplo
      integer(c_int),value :: n
      real(c_float) :: alpha
      complex(c_float_complex),target :: x
      integer(c_int),value :: incx
      integer(c_int64_t),value :: stride_x
      type(c_ptr),value :: AP
      integer(c_int64_t),value :: stride_A
      integer(c_int),value :: batch_count
      !
      rocblas_chpr_strided_batched_rank_0 = rocblas_chpr_strided_batched_orig(handle,uplo,n,alpha,c_loc(x),incx,stride_x,AP,stride_A,batch_count)
    end function

    function rocblas_chpr_strided_batched_rank_1(handle,uplo,n,alpha,x,incx,stride_x,AP,stride_A,batch_count)
      use iso_c_binding
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocblas_chpr_strided_batched_rank_1
      type(c_ptr),value :: handle
      integer(kind(rocblas_fill_upper)),value :: uplo
      integer(c_int),value :: n
      real(c_float) :: alpha
      complex(c_float_complex),target,dimension(:) :: x
      integer(c_int),value :: incx
      integer(c_int64_t),value :: stride_x
      type(c_ptr),value :: AP
      integer(c_int64_t),value :: stride_A
      integer(c_int),value :: batch_count
      !
      rocblas_chpr_strided_batched_rank_1 = rocblas_chpr_strided_batched_orig(handle,uplo,n,alpha,c_loc(x),incx,stride_x,AP,stride_A,batch_count)
    end function

    function rocblas_zhpr_strided_batched_rank_0(handle,uplo,n,alpha,x,incx,stride_x,AP,stride_A,batch_count)
      use iso_c_binding
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocblas_zhpr_strided_batched_rank_0
      type(c_ptr),value :: handle
      integer(kind(rocblas_fill_upper)),value :: uplo
      integer(c_int),value :: n
      real(c_double) :: alpha
      complex(c_double_complex),target :: x
      integer(c_int),value :: incx
      integer(c_int64_t),value :: stride_x
      type(c_ptr),value :: AP
      integer(c_int64_t),value :: stride_A
      integer(c_int),value :: batch_count
      !
      rocblas_zhpr_strided_batched_rank_0 = rocblas_zhpr_strided_batched_orig(handle,uplo,n,alpha,c_loc(x),incx,stride_x,AP,stride_A,batch_count)
    end function

    function rocblas_zhpr_strided_batched_rank_1(handle,uplo,n,alpha,x,incx,stride_x,AP,stride_A,batch_count)
      use iso_c_binding
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocblas_zhpr_strided_batched_rank_1
      type(c_ptr),value :: handle
      integer(kind(rocblas_fill_upper)),value :: uplo
      integer(c_int),value :: n
      real(c_double) :: alpha
      complex(c_double_complex),target,dimension(:) :: x
      integer(c_int),value :: incx
      integer(c_int64_t),value :: stride_x
      type(c_ptr),value :: AP
      integer(c_int64_t),value :: stride_A
      integer(c_int),value :: batch_count
      !
      rocblas_zhpr_strided_batched_rank_1 = rocblas_zhpr_strided_batched_orig(handle,uplo,n,alpha,c_loc(x),incx,stride_x,AP,stride_A,batch_count)
    end function

    function rocblas_chpr2_rank_0(handle,uplo,n,alpha,x,incx,y,incy,AP)
      use iso_c_binding
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocblas_chpr2_rank_0
      type(c_ptr),value :: handle
      integer(kind(rocblas_fill_upper)),value :: uplo
      integer(c_int),value :: n
      complex(c_float_complex) :: alpha
      complex(c_float_complex),target :: x
      integer(c_int),value :: incx
      complex(c_float_complex),target :: y
      integer(c_int),value :: incy
      type(c_ptr),value :: AP
      !
      rocblas_chpr2_rank_0 = rocblas_chpr2_orig(handle,uplo,n,alpha,c_loc(x),incx,c_loc(y),incy,AP)
    end function

    function rocblas_chpr2_rank_1(handle,uplo,n,alpha,x,incx,y,incy,AP)
      use iso_c_binding
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocblas_chpr2_rank_1
      type(c_ptr),value :: handle
      integer(kind(rocblas_fill_upper)),value :: uplo
      integer(c_int),value :: n
      complex(c_float_complex) :: alpha
      complex(c_float_complex),target,dimension(:) :: x
      integer(c_int),value :: incx
      complex(c_float_complex),target,dimension(:) :: y
      integer(c_int),value :: incy
      type(c_ptr),value :: AP
      !
      rocblas_chpr2_rank_1 = rocblas_chpr2_orig(handle,uplo,n,alpha,c_loc(x),incx,c_loc(y),incy,AP)
    end function

    function rocblas_zhpr2_rank_0(handle,uplo,n,alpha,x,incx,y,incy,AP)
      use iso_c_binding
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocblas_zhpr2_rank_0
      type(c_ptr),value :: handle
      integer(kind(rocblas_fill_upper)),value :: uplo
      integer(c_int),value :: n
      complex(c_double_complex) :: alpha
      complex(c_double_complex),target :: x
      integer(c_int),value :: incx
      complex(c_double_complex),target :: y
      integer(c_int),value :: incy
      type(c_ptr),value :: AP
      !
      rocblas_zhpr2_rank_0 = rocblas_zhpr2_orig(handle,uplo,n,alpha,c_loc(x),incx,c_loc(y),incy,AP)
    end function

    function rocblas_zhpr2_rank_1(handle,uplo,n,alpha,x,incx,y,incy,AP)
      use iso_c_binding
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocblas_zhpr2_rank_1
      type(c_ptr),value :: handle
      integer(kind(rocblas_fill_upper)),value :: uplo
      integer(c_int),value :: n
      complex(c_double_complex) :: alpha
      complex(c_double_complex),target,dimension(:) :: x
      integer(c_int),value :: incx
      complex(c_double_complex),target,dimension(:) :: y
      integer(c_int),value :: incy
      type(c_ptr),value :: AP
      !
      rocblas_zhpr2_rank_1 = rocblas_zhpr2_orig(handle,uplo,n,alpha,c_loc(x),incx,c_loc(y),incy,AP)
    end function

    function rocblas_chpr2_batched_full_rank(handle,uplo,n,alpha,x,incx,y,incy,AP,batch_count)
      use iso_c_binding
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocblas_chpr2_batched_full_rank
      type(c_ptr),value :: handle
      integer(kind(rocblas_fill_upper)),value :: uplo
      integer(c_int),value :: n
      complex(c_float_complex) :: alpha
      complex(c_float_complex),target,dimension(:,:) :: x
      integer(c_int),value :: incx
      complex(c_float_complex),target,dimension(:,:) :: y
      integer(c_int),value :: incy
      type(c_ptr) :: AP
      integer(c_int),value :: batch_count
      !
      rocblas_chpr2_batched_full_rank = rocblas_chpr2_batched_orig(handle,uplo,n,alpha,c_loc(x),incx,c_loc(y),incy,AP,batch_count)
    end function

    function rocblas_chpr2_batched_rank_0(handle,uplo,n,alpha,x,incx,y,incy,AP,batch_count)
      use iso_c_binding
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocblas_chpr2_batched_rank_0
      type(c_ptr),value :: handle
      integer(kind(rocblas_fill_upper)),value :: uplo
      integer(c_int),value :: n
      complex(c_float_complex) :: alpha
      complex(c_float_complex),target :: x
      integer(c_int),value :: incx
      complex(c_float_complex),target :: y
      integer(c_int),value :: incy
      type(c_ptr) :: AP
      integer(c_int),value :: batch_count
      !
      rocblas_chpr2_batched_rank_0 = rocblas_chpr2_batched_orig(handle,uplo,n,alpha,c_loc(x),incx,c_loc(y),incy,AP,batch_count)
    end function

    function rocblas_chpr2_batched_rank_1(handle,uplo,n,alpha,x,incx,y,incy,AP,batch_count)
      use iso_c_binding
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocblas_chpr2_batched_rank_1
      type(c_ptr),value :: handle
      integer(kind(rocblas_fill_upper)),value :: uplo
      integer(c_int),value :: n
      complex(c_float_complex) :: alpha
      complex(c_float_complex),target,dimension(:) :: x
      integer(c_int),value :: incx
      complex(c_float_complex),target,dimension(:) :: y
      integer(c_int),value :: incy
      type(c_ptr) :: AP
      integer(c_int),value :: batch_count
      !
      rocblas_chpr2_batched_rank_1 = rocblas_chpr2_batched_orig(handle,uplo,n,alpha,c_loc(x),incx,c_loc(y),incy,AP,batch_count)
    end function

    function rocblas_zhpr2_batched_full_rank(handle,uplo,n,alpha,x,incx,y,incy,AP,batch_count)
      use iso_c_binding
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocblas_zhpr2_batched_full_rank
      type(c_ptr),value :: handle
      integer(kind(rocblas_fill_upper)),value :: uplo
      integer(c_int),value :: n
      complex(c_double_complex) :: alpha
      complex(c_double_complex),target,dimension(:,:) :: x
      integer(c_int),value :: incx
      complex(c_double_complex),target,dimension(:,:) :: y
      integer(c_int),value :: incy
      type(c_ptr) :: AP
      integer(c_int),value :: batch_count
      !
      rocblas_zhpr2_batched_full_rank = rocblas_zhpr2_batched_orig(handle,uplo,n,alpha,c_loc(x),incx,c_loc(y),incy,AP,batch_count)
    end function

    function rocblas_zhpr2_batched_rank_0(handle,uplo,n,alpha,x,incx,y,incy,AP,batch_count)
      use iso_c_binding
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocblas_zhpr2_batched_rank_0
      type(c_ptr),value :: handle
      integer(kind(rocblas_fill_upper)),value :: uplo
      integer(c_int),value :: n
      complex(c_double_complex) :: alpha
      complex(c_double_complex),target :: x
      integer(c_int),value :: incx
      complex(c_double_complex),target :: y
      integer(c_int),value :: incy
      type(c_ptr) :: AP
      integer(c_int),value :: batch_count
      !
      rocblas_zhpr2_batched_rank_0 = rocblas_zhpr2_batched_orig(handle,uplo,n,alpha,c_loc(x),incx,c_loc(y),incy,AP,batch_count)
    end function

    function rocblas_zhpr2_batched_rank_1(handle,uplo,n,alpha,x,incx,y,incy,AP,batch_count)
      use iso_c_binding
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocblas_zhpr2_batched_rank_1
      type(c_ptr),value :: handle
      integer(kind(rocblas_fill_upper)),value :: uplo
      integer(c_int),value :: n
      complex(c_double_complex) :: alpha
      complex(c_double_complex),target,dimension(:) :: x
      integer(c_int),value :: incx
      complex(c_double_complex),target,dimension(:) :: y
      integer(c_int),value :: incy
      type(c_ptr) :: AP
      integer(c_int),value :: batch_count
      !
      rocblas_zhpr2_batched_rank_1 = rocblas_zhpr2_batched_orig(handle,uplo,n,alpha,c_loc(x),incx,c_loc(y),incy,AP,batch_count)
    end function

    function rocblas_chpr2_strided_batched_rank_0(handle,uplo,n,alpha,x,incx,stride_x,y,incy,stride_y,AP,stride_A,batch_count)
      use iso_c_binding
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocblas_chpr2_strided_batched_rank_0
      type(c_ptr),value :: handle
      integer(kind(rocblas_fill_upper)),value :: uplo
      integer(c_int),value :: n
      complex(c_float_complex) :: alpha
      complex(c_float_complex),target :: x
      integer(c_int),value :: incx
      integer(c_int64_t),value :: stride_x
      complex(c_float_complex),target :: y
      integer(c_int),value :: incy
      integer(c_int64_t),value :: stride_y
      type(c_ptr),value :: AP
      integer(c_int64_t),value :: stride_A
      integer(c_int),value :: batch_count
      !
      rocblas_chpr2_strided_batched_rank_0 = rocblas_chpr2_strided_batched_orig(handle,uplo,n,alpha,c_loc(x),incx,stride_x,c_loc(y),incy,stride_y,AP,stride_A,batch_count)
    end function

    function rocblas_chpr2_strided_batched_rank_1(handle,uplo,n,alpha,x,incx,stride_x,y,incy,stride_y,AP,stride_A,batch_count)
      use iso_c_binding
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocblas_chpr2_strided_batched_rank_1
      type(c_ptr),value :: handle
      integer(kind(rocblas_fill_upper)),value :: uplo
      integer(c_int),value :: n
      complex(c_float_complex) :: alpha
      complex(c_float_complex),target,dimension(:) :: x
      integer(c_int),value :: incx
      integer(c_int64_t),value :: stride_x
      complex(c_float_complex),target,dimension(:) :: y
      integer(c_int),value :: incy
      integer(c_int64_t),value :: stride_y
      type(c_ptr),value :: AP
      integer(c_int64_t),value :: stride_A
      integer(c_int),value :: batch_count
      !
      rocblas_chpr2_strided_batched_rank_1 = rocblas_chpr2_strided_batched_orig(handle,uplo,n,alpha,c_loc(x),incx,stride_x,c_loc(y),incy,stride_y,AP,stride_A,batch_count)
    end function

    function rocblas_zhpr2_strided_batched_rank_0(handle,uplo,n,alpha,x,incx,stride_x,y,incy,stride_y,AP,stride_A,batch_count)
      use iso_c_binding
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocblas_zhpr2_strided_batched_rank_0
      type(c_ptr),value :: handle
      integer(kind(rocblas_fill_upper)),value :: uplo
      integer(c_int),value :: n
      complex(c_double_complex) :: alpha
      complex(c_double_complex),target :: x
      integer(c_int),value :: incx
      integer(c_int64_t),value :: stride_x
      complex(c_double_complex),target :: y
      integer(c_int),value :: incy
      integer(c_int64_t),value :: stride_y
      type(c_ptr),value :: AP
      integer(c_int64_t),value :: stride_A
      integer(c_int),value :: batch_count
      !
      rocblas_zhpr2_strided_batched_rank_0 = rocblas_zhpr2_strided_batched_orig(handle,uplo,n,alpha,c_loc(x),incx,stride_x,c_loc(y),incy,stride_y,AP,stride_A,batch_count)
    end function

    function rocblas_zhpr2_strided_batched_rank_1(handle,uplo,n,alpha,x,incx,stride_x,y,incy,stride_y,AP,stride_A,batch_count)
      use iso_c_binding
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocblas_zhpr2_strided_batched_rank_1
      type(c_ptr),value :: handle
      integer(kind(rocblas_fill_upper)),value :: uplo
      integer(c_int),value :: n
      complex(c_double_complex) :: alpha
      complex(c_double_complex),target,dimension(:) :: x
      integer(c_int),value :: incx
      integer(c_int64_t),value :: stride_x
      complex(c_double_complex),target,dimension(:) :: y
      integer(c_int),value :: incy
      integer(c_int64_t),value :: stride_y
      type(c_ptr),value :: AP
      integer(c_int64_t),value :: stride_A
      integer(c_int),value :: batch_count
      !
      rocblas_zhpr2_strided_batched_rank_1 = rocblas_zhpr2_strided_batched_orig(handle,uplo,n,alpha,c_loc(x),incx,stride_x,c_loc(y),incy,stride_y,AP,stride_A,batch_count)
    end function

    function rocblas_strmv_full_rank(handle,uplo,transA,diag,m,A,lda,x,incx)
      use iso_c_binding
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocblas_strmv_full_rank
      type(c_ptr),value :: handle
      integer(kind(rocblas_fill_upper)),value :: uplo
      integer(kind(rocblas_operation_none)),value :: transA
      integer(kind(rocblas_diagonal_non_unit)),value :: diag
      integer(c_int),value :: m
      real(c_float),target,dimension(:,:) :: A
      integer(c_int),value :: lda
      real(c_float),target,dimension(:) :: x
      integer(c_int),value :: incx
      !
      rocblas_strmv_full_rank = rocblas_strmv_orig(handle,uplo,transA,diag,m,c_loc(A),lda,c_loc(x),incx)
    end function

    function rocblas_strmv_rank_0(handle,uplo,transA,diag,m,A,lda,x,incx)
      use iso_c_binding
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocblas_strmv_rank_0
      type(c_ptr),value :: handle
      integer(kind(rocblas_fill_upper)),value :: uplo
      integer(kind(rocblas_operation_none)),value :: transA
      integer(kind(rocblas_diagonal_non_unit)),value :: diag
      integer(c_int),value :: m
      real(c_float),target :: A
      integer(c_int),value :: lda
      real(c_float),target :: x
      integer(c_int),value :: incx
      !
      rocblas_strmv_rank_0 = rocblas_strmv_orig(handle,uplo,transA,diag,m,c_loc(A),lda,c_loc(x),incx)
    end function

    function rocblas_strmv_rank_1(handle,uplo,transA,diag,m,A,lda,x,incx)
      use iso_c_binding
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocblas_strmv_rank_1
      type(c_ptr),value :: handle
      integer(kind(rocblas_fill_upper)),value :: uplo
      integer(kind(rocblas_operation_none)),value :: transA
      integer(kind(rocblas_diagonal_non_unit)),value :: diag
      integer(c_int),value :: m
      real(c_float),target,dimension(:) :: A
      integer(c_int),value :: lda
      real(c_float),target,dimension(:) :: x
      integer(c_int),value :: incx
      !
      rocblas_strmv_rank_1 = rocblas_strmv_orig(handle,uplo,transA,diag,m,c_loc(A),lda,c_loc(x),incx)
    end function

    function rocblas_dtrmv_full_rank(handle,uplo,transA,diag,m,A,lda,x,incx)
      use iso_c_binding
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocblas_dtrmv_full_rank
      type(c_ptr),value :: handle
      integer(kind(rocblas_fill_upper)),value :: uplo
      integer(kind(rocblas_operation_none)),value :: transA
      integer(kind(rocblas_diagonal_non_unit)),value :: diag
      integer(c_int),value :: m
      real(c_double),target,dimension(:,:) :: A
      integer(c_int),value :: lda
      real(c_double),target,dimension(:) :: x
      integer(c_int),value :: incx
      !
      rocblas_dtrmv_full_rank = rocblas_dtrmv_orig(handle,uplo,transA,diag,m,c_loc(A),lda,c_loc(x),incx)
    end function

    function rocblas_dtrmv_rank_0(handle,uplo,transA,diag,m,A,lda,x,incx)
      use iso_c_binding
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocblas_dtrmv_rank_0
      type(c_ptr),value :: handle
      integer(kind(rocblas_fill_upper)),value :: uplo
      integer(kind(rocblas_operation_none)),value :: transA
      integer(kind(rocblas_diagonal_non_unit)),value :: diag
      integer(c_int),value :: m
      real(c_double),target :: A
      integer(c_int),value :: lda
      real(c_double),target :: x
      integer(c_int),value :: incx
      !
      rocblas_dtrmv_rank_0 = rocblas_dtrmv_orig(handle,uplo,transA,diag,m,c_loc(A),lda,c_loc(x),incx)
    end function

    function rocblas_dtrmv_rank_1(handle,uplo,transA,diag,m,A,lda,x,incx)
      use iso_c_binding
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocblas_dtrmv_rank_1
      type(c_ptr),value :: handle
      integer(kind(rocblas_fill_upper)),value :: uplo
      integer(kind(rocblas_operation_none)),value :: transA
      integer(kind(rocblas_diagonal_non_unit)),value :: diag
      integer(c_int),value :: m
      real(c_double),target,dimension(:) :: A
      integer(c_int),value :: lda
      real(c_double),target,dimension(:) :: x
      integer(c_int),value :: incx
      !
      rocblas_dtrmv_rank_1 = rocblas_dtrmv_orig(handle,uplo,transA,diag,m,c_loc(A),lda,c_loc(x),incx)
    end function

    function rocblas_ctrmv_full_rank(handle,uplo,transA,diag,m,A,lda,x,incx)
      use iso_c_binding
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocblas_ctrmv_full_rank
      type(c_ptr),value :: handle
      integer(kind(rocblas_fill_upper)),value :: uplo
      integer(kind(rocblas_operation_none)),value :: transA
      integer(kind(rocblas_diagonal_non_unit)),value :: diag
      integer(c_int),value :: m
      complex(c_float_complex),target,dimension(:,:) :: A
      integer(c_int),value :: lda
      complex(c_float_complex),target,dimension(:) :: x
      integer(c_int),value :: incx
      !
      rocblas_ctrmv_full_rank = rocblas_ctrmv_orig(handle,uplo,transA,diag,m,c_loc(A),lda,c_loc(x),incx)
    end function

    function rocblas_ctrmv_rank_0(handle,uplo,transA,diag,m,A,lda,x,incx)
      use iso_c_binding
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocblas_ctrmv_rank_0
      type(c_ptr),value :: handle
      integer(kind(rocblas_fill_upper)),value :: uplo
      integer(kind(rocblas_operation_none)),value :: transA
      integer(kind(rocblas_diagonal_non_unit)),value :: diag
      integer(c_int),value :: m
      complex(c_float_complex),target :: A
      integer(c_int),value :: lda
      complex(c_float_complex),target :: x
      integer(c_int),value :: incx
      !
      rocblas_ctrmv_rank_0 = rocblas_ctrmv_orig(handle,uplo,transA,diag,m,c_loc(A),lda,c_loc(x),incx)
    end function

    function rocblas_ctrmv_rank_1(handle,uplo,transA,diag,m,A,lda,x,incx)
      use iso_c_binding
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocblas_ctrmv_rank_1
      type(c_ptr),value :: handle
      integer(kind(rocblas_fill_upper)),value :: uplo
      integer(kind(rocblas_operation_none)),value :: transA
      integer(kind(rocblas_diagonal_non_unit)),value :: diag
      integer(c_int),value :: m
      complex(c_float_complex),target,dimension(:) :: A
      integer(c_int),value :: lda
      complex(c_float_complex),target,dimension(:) :: x
      integer(c_int),value :: incx
      !
      rocblas_ctrmv_rank_1 = rocblas_ctrmv_orig(handle,uplo,transA,diag,m,c_loc(A),lda,c_loc(x),incx)
    end function

    function rocblas_ztrmv_full_rank(handle,uplo,transA,diag,m,A,lda,x,incx)
      use iso_c_binding
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocblas_ztrmv_full_rank
      type(c_ptr),value :: handle
      integer(kind(rocblas_fill_upper)),value :: uplo
      integer(kind(rocblas_operation_none)),value :: transA
      integer(kind(rocblas_diagonal_non_unit)),value :: diag
      integer(c_int),value :: m
      complex(c_double_complex),target,dimension(:,:) :: A
      integer(c_int),value :: lda
      complex(c_double_complex),target,dimension(:) :: x
      integer(c_int),value :: incx
      !
      rocblas_ztrmv_full_rank = rocblas_ztrmv_orig(handle,uplo,transA,diag,m,c_loc(A),lda,c_loc(x),incx)
    end function

    function rocblas_ztrmv_rank_0(handle,uplo,transA,diag,m,A,lda,x,incx)
      use iso_c_binding
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocblas_ztrmv_rank_0
      type(c_ptr),value :: handle
      integer(kind(rocblas_fill_upper)),value :: uplo
      integer(kind(rocblas_operation_none)),value :: transA
      integer(kind(rocblas_diagonal_non_unit)),value :: diag
      integer(c_int),value :: m
      complex(c_double_complex),target :: A
      integer(c_int),value :: lda
      complex(c_double_complex),target :: x
      integer(c_int),value :: incx
      !
      rocblas_ztrmv_rank_0 = rocblas_ztrmv_orig(handle,uplo,transA,diag,m,c_loc(A),lda,c_loc(x),incx)
    end function

    function rocblas_ztrmv_rank_1(handle,uplo,transA,diag,m,A,lda,x,incx)
      use iso_c_binding
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocblas_ztrmv_rank_1
      type(c_ptr),value :: handle
      integer(kind(rocblas_fill_upper)),value :: uplo
      integer(kind(rocblas_operation_none)),value :: transA
      integer(kind(rocblas_diagonal_non_unit)),value :: diag
      integer(c_int),value :: m
      complex(c_double_complex),target,dimension(:) :: A
      integer(c_int),value :: lda
      complex(c_double_complex),target,dimension(:) :: x
      integer(c_int),value :: incx
      !
      rocblas_ztrmv_rank_1 = rocblas_ztrmv_orig(handle,uplo,transA,diag,m,c_loc(A),lda,c_loc(x),incx)
    end function

    function rocblas_strmv_strided_batched_full_rank(handle,uplo,transA,diag,m,A,lda,stridea,x,incx,stridex,batch_count)
      use iso_c_binding
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocblas_strmv_strided_batched_full_rank
      type(c_ptr),value :: handle
      integer(kind(rocblas_fill_upper)),value :: uplo
      integer(kind(rocblas_operation_none)),value :: transA
      integer(kind(rocblas_diagonal_non_unit)),value :: diag
      integer(c_int),value :: m
      real(c_float),target,dimension(:,:) :: A
      integer(c_int),value :: lda
      integer(c_int64_t),value :: stridea
      real(c_float),target,dimension(:) :: x
      integer(c_int),value :: incx
      integer(c_int64_t),value :: stridex
      integer(c_int),value :: batch_count
      !
      rocblas_strmv_strided_batched_full_rank = rocblas_strmv_strided_batched_orig(handle,uplo,transA,diag,m,c_loc(A),lda,stridea,c_loc(x),incx,stridex,batch_count)
    end function

    function rocblas_strmv_strided_batched_rank_0(handle,uplo,transA,diag,m,A,lda,stridea,x,incx,stridex,batch_count)
      use iso_c_binding
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocblas_strmv_strided_batched_rank_0
      type(c_ptr),value :: handle
      integer(kind(rocblas_fill_upper)),value :: uplo
      integer(kind(rocblas_operation_none)),value :: transA
      integer(kind(rocblas_diagonal_non_unit)),value :: diag
      integer(c_int),value :: m
      real(c_float),target :: A
      integer(c_int),value :: lda
      integer(c_int64_t),value :: stridea
      real(c_float),target :: x
      integer(c_int),value :: incx
      integer(c_int64_t),value :: stridex
      integer(c_int),value :: batch_count
      !
      rocblas_strmv_strided_batched_rank_0 = rocblas_strmv_strided_batched_orig(handle,uplo,transA,diag,m,c_loc(A),lda,stridea,c_loc(x),incx,stridex,batch_count)
    end function

    function rocblas_strmv_strided_batched_rank_1(handle,uplo,transA,diag,m,A,lda,stridea,x,incx,stridex,batch_count)
      use iso_c_binding
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocblas_strmv_strided_batched_rank_1
      type(c_ptr),value :: handle
      integer(kind(rocblas_fill_upper)),value :: uplo
      integer(kind(rocblas_operation_none)),value :: transA
      integer(kind(rocblas_diagonal_non_unit)),value :: diag
      integer(c_int),value :: m
      real(c_float),target,dimension(:) :: A
      integer(c_int),value :: lda
      integer(c_int64_t),value :: stridea
      real(c_float),target,dimension(:) :: x
      integer(c_int),value :: incx
      integer(c_int64_t),value :: stridex
      integer(c_int),value :: batch_count
      !
      rocblas_strmv_strided_batched_rank_1 = rocblas_strmv_strided_batched_orig(handle,uplo,transA,diag,m,c_loc(A),lda,stridea,c_loc(x),incx,stridex,batch_count)
    end function

    function rocblas_dtrmv_strided_batched_full_rank(handle,uplo,transA,diag,m,A,lda,stridea,x,incx,stridex,batch_count)
      use iso_c_binding
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocblas_dtrmv_strided_batched_full_rank
      type(c_ptr),value :: handle
      integer(kind(rocblas_fill_upper)),value :: uplo
      integer(kind(rocblas_operation_none)),value :: transA
      integer(kind(rocblas_diagonal_non_unit)),value :: diag
      integer(c_int),value :: m
      real(c_double),target,dimension(:,:) :: A
      integer(c_int),value :: lda
      integer(c_int64_t),value :: stridea
      real(c_double),target,dimension(:) :: x
      integer(c_int),value :: incx
      integer(c_int64_t),value :: stridex
      integer(c_int),value :: batch_count
      !
      rocblas_dtrmv_strided_batched_full_rank = rocblas_dtrmv_strided_batched_orig(handle,uplo,transA,diag,m,c_loc(A),lda,stridea,c_loc(x),incx,stridex,batch_count)
    end function

    function rocblas_dtrmv_strided_batched_rank_0(handle,uplo,transA,diag,m,A,lda,stridea,x,incx,stridex,batch_count)
      use iso_c_binding
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocblas_dtrmv_strided_batched_rank_0
      type(c_ptr),value :: handle
      integer(kind(rocblas_fill_upper)),value :: uplo
      integer(kind(rocblas_operation_none)),value :: transA
      integer(kind(rocblas_diagonal_non_unit)),value :: diag
      integer(c_int),value :: m
      real(c_double),target :: A
      integer(c_int),value :: lda
      integer(c_int64_t),value :: stridea
      real(c_double),target :: x
      integer(c_int),value :: incx
      integer(c_int64_t),value :: stridex
      integer(c_int),value :: batch_count
      !
      rocblas_dtrmv_strided_batched_rank_0 = rocblas_dtrmv_strided_batched_orig(handle,uplo,transA,diag,m,c_loc(A),lda,stridea,c_loc(x),incx,stridex,batch_count)
    end function

    function rocblas_dtrmv_strided_batched_rank_1(handle,uplo,transA,diag,m,A,lda,stridea,x,incx,stridex,batch_count)
      use iso_c_binding
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocblas_dtrmv_strided_batched_rank_1
      type(c_ptr),value :: handle
      integer(kind(rocblas_fill_upper)),value :: uplo
      integer(kind(rocblas_operation_none)),value :: transA
      integer(kind(rocblas_diagonal_non_unit)),value :: diag
      integer(c_int),value :: m
      real(c_double),target,dimension(:) :: A
      integer(c_int),value :: lda
      integer(c_int64_t),value :: stridea
      real(c_double),target,dimension(:) :: x
      integer(c_int),value :: incx
      integer(c_int64_t),value :: stridex
      integer(c_int),value :: batch_count
      !
      rocblas_dtrmv_strided_batched_rank_1 = rocblas_dtrmv_strided_batched_orig(handle,uplo,transA,diag,m,c_loc(A),lda,stridea,c_loc(x),incx,stridex,batch_count)
    end function

    function rocblas_ctrmv_strided_batched_full_rank(handle,uplo,transA,diag,m,A,lda,stridea,x,incx,stridex,batch_count)
      use iso_c_binding
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocblas_ctrmv_strided_batched_full_rank
      type(c_ptr),value :: handle
      integer(kind(rocblas_fill_upper)),value :: uplo
      integer(kind(rocblas_operation_none)),value :: transA
      integer(kind(rocblas_diagonal_non_unit)),value :: diag
      integer(c_int),value :: m
      complex(c_float_complex),target,dimension(:,:) :: A
      integer(c_int),value :: lda
      integer(c_int64_t),value :: stridea
      complex(c_float_complex),target,dimension(:) :: x
      integer(c_int),value :: incx
      integer(c_int64_t),value :: stridex
      integer(c_int),value :: batch_count
      !
      rocblas_ctrmv_strided_batched_full_rank = rocblas_ctrmv_strided_batched_orig(handle,uplo,transA,diag,m,c_loc(A),lda,stridea,c_loc(x),incx,stridex,batch_count)
    end function

    function rocblas_ctrmv_strided_batched_rank_0(handle,uplo,transA,diag,m,A,lda,stridea,x,incx,stridex,batch_count)
      use iso_c_binding
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocblas_ctrmv_strided_batched_rank_0
      type(c_ptr),value :: handle
      integer(kind(rocblas_fill_upper)),value :: uplo
      integer(kind(rocblas_operation_none)),value :: transA
      integer(kind(rocblas_diagonal_non_unit)),value :: diag
      integer(c_int),value :: m
      complex(c_float_complex),target :: A
      integer(c_int),value :: lda
      integer(c_int64_t),value :: stridea
      complex(c_float_complex),target :: x
      integer(c_int),value :: incx
      integer(c_int64_t),value :: stridex
      integer(c_int),value :: batch_count
      !
      rocblas_ctrmv_strided_batched_rank_0 = rocblas_ctrmv_strided_batched_orig(handle,uplo,transA,diag,m,c_loc(A),lda,stridea,c_loc(x),incx,stridex,batch_count)
    end function

    function rocblas_ctrmv_strided_batched_rank_1(handle,uplo,transA,diag,m,A,lda,stridea,x,incx,stridex,batch_count)
      use iso_c_binding
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocblas_ctrmv_strided_batched_rank_1
      type(c_ptr),value :: handle
      integer(kind(rocblas_fill_upper)),value :: uplo
      integer(kind(rocblas_operation_none)),value :: transA
      integer(kind(rocblas_diagonal_non_unit)),value :: diag
      integer(c_int),value :: m
      complex(c_float_complex),target,dimension(:) :: A
      integer(c_int),value :: lda
      integer(c_int64_t),value :: stridea
      complex(c_float_complex),target,dimension(:) :: x
      integer(c_int),value :: incx
      integer(c_int64_t),value :: stridex
      integer(c_int),value :: batch_count
      !
      rocblas_ctrmv_strided_batched_rank_1 = rocblas_ctrmv_strided_batched_orig(handle,uplo,transA,diag,m,c_loc(A),lda,stridea,c_loc(x),incx,stridex,batch_count)
    end function

    function rocblas_ztrmv_strided_batched_full_rank(handle,uplo,transA,diag,m,A,lda,stridea,x,incx,stridex,batch_count)
      use iso_c_binding
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocblas_ztrmv_strided_batched_full_rank
      type(c_ptr),value :: handle
      integer(kind(rocblas_fill_upper)),value :: uplo
      integer(kind(rocblas_operation_none)),value :: transA
      integer(kind(rocblas_diagonal_non_unit)),value :: diag
      integer(c_int),value :: m
      complex(c_double_complex),target,dimension(:,:) :: A
      integer(c_int),value :: lda
      integer(c_int64_t),value :: stridea
      complex(c_double_complex),target,dimension(:) :: x
      integer(c_int),value :: incx
      integer(c_int64_t),value :: stridex
      integer(c_int),value :: batch_count
      !
      rocblas_ztrmv_strided_batched_full_rank = rocblas_ztrmv_strided_batched_orig(handle,uplo,transA,diag,m,c_loc(A),lda,stridea,c_loc(x),incx,stridex,batch_count)
    end function

    function rocblas_ztrmv_strided_batched_rank_0(handle,uplo,transA,diag,m,A,lda,stridea,x,incx,stridex,batch_count)
      use iso_c_binding
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocblas_ztrmv_strided_batched_rank_0
      type(c_ptr),value :: handle
      integer(kind(rocblas_fill_upper)),value :: uplo
      integer(kind(rocblas_operation_none)),value :: transA
      integer(kind(rocblas_diagonal_non_unit)),value :: diag
      integer(c_int),value :: m
      complex(c_double_complex),target :: A
      integer(c_int),value :: lda
      integer(c_int64_t),value :: stridea
      complex(c_double_complex),target :: x
      integer(c_int),value :: incx
      integer(c_int64_t),value :: stridex
      integer(c_int),value :: batch_count
      !
      rocblas_ztrmv_strided_batched_rank_0 = rocblas_ztrmv_strided_batched_orig(handle,uplo,transA,diag,m,c_loc(A),lda,stridea,c_loc(x),incx,stridex,batch_count)
    end function

    function rocblas_ztrmv_strided_batched_rank_1(handle,uplo,transA,diag,m,A,lda,stridea,x,incx,stridex,batch_count)
      use iso_c_binding
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocblas_ztrmv_strided_batched_rank_1
      type(c_ptr),value :: handle
      integer(kind(rocblas_fill_upper)),value :: uplo
      integer(kind(rocblas_operation_none)),value :: transA
      integer(kind(rocblas_diagonal_non_unit)),value :: diag
      integer(c_int),value :: m
      complex(c_double_complex),target,dimension(:) :: A
      integer(c_int),value :: lda
      integer(c_int64_t),value :: stridea
      complex(c_double_complex),target,dimension(:) :: x
      integer(c_int),value :: incx
      integer(c_int64_t),value :: stridex
      integer(c_int),value :: batch_count
      !
      rocblas_ztrmv_strided_batched_rank_1 = rocblas_ztrmv_strided_batched_orig(handle,uplo,transA,diag,m,c_loc(A),lda,stridea,c_loc(x),incx,stridex,batch_count)
    end function

    function rocblas_stpmv_full_rank(handle,uplo,transA,diag,m,A,x,incx)
      use iso_c_binding
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocblas_stpmv_full_rank
      type(c_ptr),value :: handle
      integer(kind(rocblas_fill_upper)),value :: uplo
      integer(kind(rocblas_operation_none)),value :: transA
      integer(kind(rocblas_diagonal_non_unit)),value :: diag
      integer(c_int),value :: m
      real(c_float),target,dimension(:,:) :: A
      real(c_float),target,dimension(:) :: x
      integer(c_int),value :: incx
      !
      rocblas_stpmv_full_rank = rocblas_stpmv_orig(handle,uplo,transA,diag,m,c_loc(A),c_loc(x),incx)
    end function

    function rocblas_stpmv_rank_0(handle,uplo,transA,diag,m,A,x,incx)
      use iso_c_binding
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocblas_stpmv_rank_0
      type(c_ptr),value :: handle
      integer(kind(rocblas_fill_upper)),value :: uplo
      integer(kind(rocblas_operation_none)),value :: transA
      integer(kind(rocblas_diagonal_non_unit)),value :: diag
      integer(c_int),value :: m
      real(c_float),target :: A
      real(c_float),target :: x
      integer(c_int),value :: incx
      !
      rocblas_stpmv_rank_0 = rocblas_stpmv_orig(handle,uplo,transA,diag,m,c_loc(A),c_loc(x),incx)
    end function

    function rocblas_stpmv_rank_1(handle,uplo,transA,diag,m,A,x,incx)
      use iso_c_binding
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocblas_stpmv_rank_1
      type(c_ptr),value :: handle
      integer(kind(rocblas_fill_upper)),value :: uplo
      integer(kind(rocblas_operation_none)),value :: transA
      integer(kind(rocblas_diagonal_non_unit)),value :: diag
      integer(c_int),value :: m
      real(c_float),target,dimension(:) :: A
      real(c_float),target,dimension(:) :: x
      integer(c_int),value :: incx
      !
      rocblas_stpmv_rank_1 = rocblas_stpmv_orig(handle,uplo,transA,diag,m,c_loc(A),c_loc(x),incx)
    end function

    function rocblas_dtpmv_full_rank(handle,uplo,transA,diag,m,A,x,incx)
      use iso_c_binding
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocblas_dtpmv_full_rank
      type(c_ptr),value :: handle
      integer(kind(rocblas_fill_upper)),value :: uplo
      integer(kind(rocblas_operation_none)),value :: transA
      integer(kind(rocblas_diagonal_non_unit)),value :: diag
      integer(c_int),value :: m
      real(c_double),target,dimension(:,:) :: A
      real(c_double),target,dimension(:) :: x
      integer(c_int),value :: incx
      !
      rocblas_dtpmv_full_rank = rocblas_dtpmv_orig(handle,uplo,transA,diag,m,c_loc(A),c_loc(x),incx)
    end function

    function rocblas_dtpmv_rank_0(handle,uplo,transA,diag,m,A,x,incx)
      use iso_c_binding
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocblas_dtpmv_rank_0
      type(c_ptr),value :: handle
      integer(kind(rocblas_fill_upper)),value :: uplo
      integer(kind(rocblas_operation_none)),value :: transA
      integer(kind(rocblas_diagonal_non_unit)),value :: diag
      integer(c_int),value :: m
      real(c_double),target :: A
      real(c_double),target :: x
      integer(c_int),value :: incx
      !
      rocblas_dtpmv_rank_0 = rocblas_dtpmv_orig(handle,uplo,transA,diag,m,c_loc(A),c_loc(x),incx)
    end function

    function rocblas_dtpmv_rank_1(handle,uplo,transA,diag,m,A,x,incx)
      use iso_c_binding
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocblas_dtpmv_rank_1
      type(c_ptr),value :: handle
      integer(kind(rocblas_fill_upper)),value :: uplo
      integer(kind(rocblas_operation_none)),value :: transA
      integer(kind(rocblas_diagonal_non_unit)),value :: diag
      integer(c_int),value :: m
      real(c_double),target,dimension(:) :: A
      real(c_double),target,dimension(:) :: x
      integer(c_int),value :: incx
      !
      rocblas_dtpmv_rank_1 = rocblas_dtpmv_orig(handle,uplo,transA,diag,m,c_loc(A),c_loc(x),incx)
    end function

    function rocblas_ctpmv_full_rank(handle,uplo,transA,diag,m,A,x,incx)
      use iso_c_binding
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocblas_ctpmv_full_rank
      type(c_ptr),value :: handle
      integer(kind(rocblas_fill_upper)),value :: uplo
      integer(kind(rocblas_operation_none)),value :: transA
      integer(kind(rocblas_diagonal_non_unit)),value :: diag
      integer(c_int),value :: m
      complex(c_float_complex),target,dimension(:,:) :: A
      complex(c_float_complex),target,dimension(:) :: x
      integer(c_int),value :: incx
      !
      rocblas_ctpmv_full_rank = rocblas_ctpmv_orig(handle,uplo,transA,diag,m,c_loc(A),c_loc(x),incx)
    end function

    function rocblas_ctpmv_rank_0(handle,uplo,transA,diag,m,A,x,incx)
      use iso_c_binding
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocblas_ctpmv_rank_0
      type(c_ptr),value :: handle
      integer(kind(rocblas_fill_upper)),value :: uplo
      integer(kind(rocblas_operation_none)),value :: transA
      integer(kind(rocblas_diagonal_non_unit)),value :: diag
      integer(c_int),value :: m
      complex(c_float_complex),target :: A
      complex(c_float_complex),target :: x
      integer(c_int),value :: incx
      !
      rocblas_ctpmv_rank_0 = rocblas_ctpmv_orig(handle,uplo,transA,diag,m,c_loc(A),c_loc(x),incx)
    end function

    function rocblas_ctpmv_rank_1(handle,uplo,transA,diag,m,A,x,incx)
      use iso_c_binding
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocblas_ctpmv_rank_1
      type(c_ptr),value :: handle
      integer(kind(rocblas_fill_upper)),value :: uplo
      integer(kind(rocblas_operation_none)),value :: transA
      integer(kind(rocblas_diagonal_non_unit)),value :: diag
      integer(c_int),value :: m
      complex(c_float_complex),target,dimension(:) :: A
      complex(c_float_complex),target,dimension(:) :: x
      integer(c_int),value :: incx
      !
      rocblas_ctpmv_rank_1 = rocblas_ctpmv_orig(handle,uplo,transA,diag,m,c_loc(A),c_loc(x),incx)
    end function

    function rocblas_ztpmv_full_rank(handle,uplo,transA,diag,m,A,x,incx)
      use iso_c_binding
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocblas_ztpmv_full_rank
      type(c_ptr),value :: handle
      integer(kind(rocblas_fill_upper)),value :: uplo
      integer(kind(rocblas_operation_none)),value :: transA
      integer(kind(rocblas_diagonal_non_unit)),value :: diag
      integer(c_int),value :: m
      complex(c_double_complex),target,dimension(:,:) :: A
      complex(c_double_complex),target,dimension(:) :: x
      integer(c_int),value :: incx
      !
      rocblas_ztpmv_full_rank = rocblas_ztpmv_orig(handle,uplo,transA,diag,m,c_loc(A),c_loc(x),incx)
    end function

    function rocblas_ztpmv_rank_0(handle,uplo,transA,diag,m,A,x,incx)
      use iso_c_binding
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocblas_ztpmv_rank_0
      type(c_ptr),value :: handle
      integer(kind(rocblas_fill_upper)),value :: uplo
      integer(kind(rocblas_operation_none)),value :: transA
      integer(kind(rocblas_diagonal_non_unit)),value :: diag
      integer(c_int),value :: m
      complex(c_double_complex),target :: A
      complex(c_double_complex),target :: x
      integer(c_int),value :: incx
      !
      rocblas_ztpmv_rank_0 = rocblas_ztpmv_orig(handle,uplo,transA,diag,m,c_loc(A),c_loc(x),incx)
    end function

    function rocblas_ztpmv_rank_1(handle,uplo,transA,diag,m,A,x,incx)
      use iso_c_binding
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocblas_ztpmv_rank_1
      type(c_ptr),value :: handle
      integer(kind(rocblas_fill_upper)),value :: uplo
      integer(kind(rocblas_operation_none)),value :: transA
      integer(kind(rocblas_diagonal_non_unit)),value :: diag
      integer(c_int),value :: m
      complex(c_double_complex),target,dimension(:) :: A
      complex(c_double_complex),target,dimension(:) :: x
      integer(c_int),value :: incx
      !
      rocblas_ztpmv_rank_1 = rocblas_ztpmv_orig(handle,uplo,transA,diag,m,c_loc(A),c_loc(x),incx)
    end function

    function rocblas_stpmv_strided_batched_full_rank(handle,uplo,transA,diag,m,A,stridea,x,incx,stridex,batch_count)
      use iso_c_binding
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocblas_stpmv_strided_batched_full_rank
      type(c_ptr),value :: handle
      integer(kind(rocblas_fill_upper)),value :: uplo
      integer(kind(rocblas_operation_none)),value :: transA
      integer(kind(rocblas_diagonal_non_unit)),value :: diag
      integer(c_int),value :: m
      real(c_float),target,dimension(:,:) :: A
      integer(c_int64_t),value :: stridea
      real(c_float),target,dimension(:) :: x
      integer(c_int),value :: incx
      integer(c_int64_t),value :: stridex
      integer(c_int),value :: batch_count
      !
      rocblas_stpmv_strided_batched_full_rank = rocblas_stpmv_strided_batched_orig(handle,uplo,transA,diag,m,c_loc(A),stridea,c_loc(x),incx,stridex,batch_count)
    end function

    function rocblas_stpmv_strided_batched_rank_0(handle,uplo,transA,diag,m,A,stridea,x,incx,stridex,batch_count)
      use iso_c_binding
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocblas_stpmv_strided_batched_rank_0
      type(c_ptr),value :: handle
      integer(kind(rocblas_fill_upper)),value :: uplo
      integer(kind(rocblas_operation_none)),value :: transA
      integer(kind(rocblas_diagonal_non_unit)),value :: diag
      integer(c_int),value :: m
      real(c_float),target :: A
      integer(c_int64_t),value :: stridea
      real(c_float),target :: x
      integer(c_int),value :: incx
      integer(c_int64_t),value :: stridex
      integer(c_int),value :: batch_count
      !
      rocblas_stpmv_strided_batched_rank_0 = rocblas_stpmv_strided_batched_orig(handle,uplo,transA,diag,m,c_loc(A),stridea,c_loc(x),incx,stridex,batch_count)
    end function

    function rocblas_stpmv_strided_batched_rank_1(handle,uplo,transA,diag,m,A,stridea,x,incx,stridex,batch_count)
      use iso_c_binding
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocblas_stpmv_strided_batched_rank_1
      type(c_ptr),value :: handle
      integer(kind(rocblas_fill_upper)),value :: uplo
      integer(kind(rocblas_operation_none)),value :: transA
      integer(kind(rocblas_diagonal_non_unit)),value :: diag
      integer(c_int),value :: m
      real(c_float),target,dimension(:) :: A
      integer(c_int64_t),value :: stridea
      real(c_float),target,dimension(:) :: x
      integer(c_int),value :: incx
      integer(c_int64_t),value :: stridex
      integer(c_int),value :: batch_count
      !
      rocblas_stpmv_strided_batched_rank_1 = rocblas_stpmv_strided_batched_orig(handle,uplo,transA,diag,m,c_loc(A),stridea,c_loc(x),incx,stridex,batch_count)
    end function

    function rocblas_dtpmv_strided_batched_full_rank(handle,uplo,transA,diag,m,A,stridea,x,incx,stridex,batch_count)
      use iso_c_binding
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocblas_dtpmv_strided_batched_full_rank
      type(c_ptr),value :: handle
      integer(kind(rocblas_fill_upper)),value :: uplo
      integer(kind(rocblas_operation_none)),value :: transA
      integer(kind(rocblas_diagonal_non_unit)),value :: diag
      integer(c_int),value :: m
      real(c_double),target,dimension(:,:) :: A
      integer(c_int64_t),value :: stridea
      real(c_double),target,dimension(:) :: x
      integer(c_int),value :: incx
      integer(c_int64_t),value :: stridex
      integer(c_int),value :: batch_count
      !
      rocblas_dtpmv_strided_batched_full_rank = rocblas_dtpmv_strided_batched_orig(handle,uplo,transA,diag,m,c_loc(A),stridea,c_loc(x),incx,stridex,batch_count)
    end function

    function rocblas_dtpmv_strided_batched_rank_0(handle,uplo,transA,diag,m,A,stridea,x,incx,stridex,batch_count)
      use iso_c_binding
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocblas_dtpmv_strided_batched_rank_0
      type(c_ptr),value :: handle
      integer(kind(rocblas_fill_upper)),value :: uplo
      integer(kind(rocblas_operation_none)),value :: transA
      integer(kind(rocblas_diagonal_non_unit)),value :: diag
      integer(c_int),value :: m
      real(c_double),target :: A
      integer(c_int64_t),value :: stridea
      real(c_double),target :: x
      integer(c_int),value :: incx
      integer(c_int64_t),value :: stridex
      integer(c_int),value :: batch_count
      !
      rocblas_dtpmv_strided_batched_rank_0 = rocblas_dtpmv_strided_batched_orig(handle,uplo,transA,diag,m,c_loc(A),stridea,c_loc(x),incx,stridex,batch_count)
    end function

    function rocblas_dtpmv_strided_batched_rank_1(handle,uplo,transA,diag,m,A,stridea,x,incx,stridex,batch_count)
      use iso_c_binding
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocblas_dtpmv_strided_batched_rank_1
      type(c_ptr),value :: handle
      integer(kind(rocblas_fill_upper)),value :: uplo
      integer(kind(rocblas_operation_none)),value :: transA
      integer(kind(rocblas_diagonal_non_unit)),value :: diag
      integer(c_int),value :: m
      real(c_double),target,dimension(:) :: A
      integer(c_int64_t),value :: stridea
      real(c_double),target,dimension(:) :: x
      integer(c_int),value :: incx
      integer(c_int64_t),value :: stridex
      integer(c_int),value :: batch_count
      !
      rocblas_dtpmv_strided_batched_rank_1 = rocblas_dtpmv_strided_batched_orig(handle,uplo,transA,diag,m,c_loc(A),stridea,c_loc(x),incx,stridex,batch_count)
    end function

    function rocblas_ctpmv_strided_batched_full_rank(handle,uplo,transA,diag,m,A,stridea,x,incx,stridex,batch_count)
      use iso_c_binding
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocblas_ctpmv_strided_batched_full_rank
      type(c_ptr),value :: handle
      integer(kind(rocblas_fill_upper)),value :: uplo
      integer(kind(rocblas_operation_none)),value :: transA
      integer(kind(rocblas_diagonal_non_unit)),value :: diag
      integer(c_int),value :: m
      complex(c_float_complex),target,dimension(:,:) :: A
      integer(c_int64_t),value :: stridea
      complex(c_float_complex),target,dimension(:) :: x
      integer(c_int),value :: incx
      integer(c_int64_t),value :: stridex
      integer(c_int),value :: batch_count
      !
      rocblas_ctpmv_strided_batched_full_rank = rocblas_ctpmv_strided_batched_orig(handle,uplo,transA,diag,m,c_loc(A),stridea,c_loc(x),incx,stridex,batch_count)
    end function

    function rocblas_ctpmv_strided_batched_rank_0(handle,uplo,transA,diag,m,A,stridea,x,incx,stridex,batch_count)
      use iso_c_binding
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocblas_ctpmv_strided_batched_rank_0
      type(c_ptr),value :: handle
      integer(kind(rocblas_fill_upper)),value :: uplo
      integer(kind(rocblas_operation_none)),value :: transA
      integer(kind(rocblas_diagonal_non_unit)),value :: diag
      integer(c_int),value :: m
      complex(c_float_complex),target :: A
      integer(c_int64_t),value :: stridea
      complex(c_float_complex),target :: x
      integer(c_int),value :: incx
      integer(c_int64_t),value :: stridex
      integer(c_int),value :: batch_count
      !
      rocblas_ctpmv_strided_batched_rank_0 = rocblas_ctpmv_strided_batched_orig(handle,uplo,transA,diag,m,c_loc(A),stridea,c_loc(x),incx,stridex,batch_count)
    end function

    function rocblas_ctpmv_strided_batched_rank_1(handle,uplo,transA,diag,m,A,stridea,x,incx,stridex,batch_count)
      use iso_c_binding
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocblas_ctpmv_strided_batched_rank_1
      type(c_ptr),value :: handle
      integer(kind(rocblas_fill_upper)),value :: uplo
      integer(kind(rocblas_operation_none)),value :: transA
      integer(kind(rocblas_diagonal_non_unit)),value :: diag
      integer(c_int),value :: m
      complex(c_float_complex),target,dimension(:) :: A
      integer(c_int64_t),value :: stridea
      complex(c_float_complex),target,dimension(:) :: x
      integer(c_int),value :: incx
      integer(c_int64_t),value :: stridex
      integer(c_int),value :: batch_count
      !
      rocblas_ctpmv_strided_batched_rank_1 = rocblas_ctpmv_strided_batched_orig(handle,uplo,transA,diag,m,c_loc(A),stridea,c_loc(x),incx,stridex,batch_count)
    end function

    function rocblas_ztpmv_strided_batched_full_rank(handle,uplo,transA,diag,m,A,stridea,x,incx,stridex,batch_count)
      use iso_c_binding
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocblas_ztpmv_strided_batched_full_rank
      type(c_ptr),value :: handle
      integer(kind(rocblas_fill_upper)),value :: uplo
      integer(kind(rocblas_operation_none)),value :: transA
      integer(kind(rocblas_diagonal_non_unit)),value :: diag
      integer(c_int),value :: m
      complex(c_double_complex),target,dimension(:,:) :: A
      integer(c_int64_t),value :: stridea
      complex(c_double_complex),target,dimension(:) :: x
      integer(c_int),value :: incx
      integer(c_int64_t),value :: stridex
      integer(c_int),value :: batch_count
      !
      rocblas_ztpmv_strided_batched_full_rank = rocblas_ztpmv_strided_batched_orig(handle,uplo,transA,diag,m,c_loc(A),stridea,c_loc(x),incx,stridex,batch_count)
    end function

    function rocblas_ztpmv_strided_batched_rank_0(handle,uplo,transA,diag,m,A,stridea,x,incx,stridex,batch_count)
      use iso_c_binding
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocblas_ztpmv_strided_batched_rank_0
      type(c_ptr),value :: handle
      integer(kind(rocblas_fill_upper)),value :: uplo
      integer(kind(rocblas_operation_none)),value :: transA
      integer(kind(rocblas_diagonal_non_unit)),value :: diag
      integer(c_int),value :: m
      complex(c_double_complex),target :: A
      integer(c_int64_t),value :: stridea
      complex(c_double_complex),target :: x
      integer(c_int),value :: incx
      integer(c_int64_t),value :: stridex
      integer(c_int),value :: batch_count
      !
      rocblas_ztpmv_strided_batched_rank_0 = rocblas_ztpmv_strided_batched_orig(handle,uplo,transA,diag,m,c_loc(A),stridea,c_loc(x),incx,stridex,batch_count)
    end function

    function rocblas_ztpmv_strided_batched_rank_1(handle,uplo,transA,diag,m,A,stridea,x,incx,stridex,batch_count)
      use iso_c_binding
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocblas_ztpmv_strided_batched_rank_1
      type(c_ptr),value :: handle
      integer(kind(rocblas_fill_upper)),value :: uplo
      integer(kind(rocblas_operation_none)),value :: transA
      integer(kind(rocblas_diagonal_non_unit)),value :: diag
      integer(c_int),value :: m
      complex(c_double_complex),target,dimension(:) :: A
      integer(c_int64_t),value :: stridea
      complex(c_double_complex),target,dimension(:) :: x
      integer(c_int),value :: incx
      integer(c_int64_t),value :: stridex
      integer(c_int),value :: batch_count
      !
      rocblas_ztpmv_strided_batched_rank_1 = rocblas_ztpmv_strided_batched_orig(handle,uplo,transA,diag,m,c_loc(A),stridea,c_loc(x),incx,stridex,batch_count)
    end function

    function rocblas_stbmv_full_rank(handle,uplo,trans,diag,m,k,A,lda,x,incx)
      use iso_c_binding
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocblas_stbmv_full_rank
      type(c_ptr),value :: handle
      integer(kind(rocblas_fill_upper)),value :: uplo
      integer(kind(rocblas_operation_none)),value :: trans
      integer(kind(rocblas_diagonal_non_unit)),value :: diag
      integer(c_int),value :: m
      integer(c_int),value :: k
      real(c_float),target,dimension(:,:) :: A
      integer(c_int),value :: lda
      real(c_float),target,dimension(:) :: x
      integer(c_int),value :: incx
      !
      rocblas_stbmv_full_rank = rocblas_stbmv_orig(handle,uplo,trans,diag,m,k,c_loc(A),lda,c_loc(x),incx)
    end function

    function rocblas_stbmv_rank_0(handle,uplo,trans,diag,m,k,A,lda,x,incx)
      use iso_c_binding
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocblas_stbmv_rank_0
      type(c_ptr),value :: handle
      integer(kind(rocblas_fill_upper)),value :: uplo
      integer(kind(rocblas_operation_none)),value :: trans
      integer(kind(rocblas_diagonal_non_unit)),value :: diag
      integer(c_int),value :: m
      integer(c_int),value :: k
      real(c_float),target :: A
      integer(c_int),value :: lda
      real(c_float),target :: x
      integer(c_int),value :: incx
      !
      rocblas_stbmv_rank_0 = rocblas_stbmv_orig(handle,uplo,trans,diag,m,k,c_loc(A),lda,c_loc(x),incx)
    end function

    function rocblas_stbmv_rank_1(handle,uplo,trans,diag,m,k,A,lda,x,incx)
      use iso_c_binding
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocblas_stbmv_rank_1
      type(c_ptr),value :: handle
      integer(kind(rocblas_fill_upper)),value :: uplo
      integer(kind(rocblas_operation_none)),value :: trans
      integer(kind(rocblas_diagonal_non_unit)),value :: diag
      integer(c_int),value :: m
      integer(c_int),value :: k
      real(c_float),target,dimension(:) :: A
      integer(c_int),value :: lda
      real(c_float),target,dimension(:) :: x
      integer(c_int),value :: incx
      !
      rocblas_stbmv_rank_1 = rocblas_stbmv_orig(handle,uplo,trans,diag,m,k,c_loc(A),lda,c_loc(x),incx)
    end function

    function rocblas_dtbmv_full_rank(handle,uplo,trans,diag,m,k,A,lda,x,incx)
      use iso_c_binding
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocblas_dtbmv_full_rank
      type(c_ptr),value :: handle
      integer(kind(rocblas_fill_upper)),value :: uplo
      integer(kind(rocblas_operation_none)),value :: trans
      integer(kind(rocblas_diagonal_non_unit)),value :: diag
      integer(c_int),value :: m
      integer(c_int),value :: k
      real(c_double),target,dimension(:,:) :: A
      integer(c_int),value :: lda
      real(c_double),target,dimension(:) :: x
      integer(c_int),value :: incx
      !
      rocblas_dtbmv_full_rank = rocblas_dtbmv_orig(handle,uplo,trans,diag,m,k,c_loc(A),lda,c_loc(x),incx)
    end function

    function rocblas_dtbmv_rank_0(handle,uplo,trans,diag,m,k,A,lda,x,incx)
      use iso_c_binding
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocblas_dtbmv_rank_0
      type(c_ptr),value :: handle
      integer(kind(rocblas_fill_upper)),value :: uplo
      integer(kind(rocblas_operation_none)),value :: trans
      integer(kind(rocblas_diagonal_non_unit)),value :: diag
      integer(c_int),value :: m
      integer(c_int),value :: k
      real(c_double),target :: A
      integer(c_int),value :: lda
      real(c_double),target :: x
      integer(c_int),value :: incx
      !
      rocblas_dtbmv_rank_0 = rocblas_dtbmv_orig(handle,uplo,trans,diag,m,k,c_loc(A),lda,c_loc(x),incx)
    end function

    function rocblas_dtbmv_rank_1(handle,uplo,trans,diag,m,k,A,lda,x,incx)
      use iso_c_binding
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocblas_dtbmv_rank_1
      type(c_ptr),value :: handle
      integer(kind(rocblas_fill_upper)),value :: uplo
      integer(kind(rocblas_operation_none)),value :: trans
      integer(kind(rocblas_diagonal_non_unit)),value :: diag
      integer(c_int),value :: m
      integer(c_int),value :: k
      real(c_double),target,dimension(:) :: A
      integer(c_int),value :: lda
      real(c_double),target,dimension(:) :: x
      integer(c_int),value :: incx
      !
      rocblas_dtbmv_rank_1 = rocblas_dtbmv_orig(handle,uplo,trans,diag,m,k,c_loc(A),lda,c_loc(x),incx)
    end function

    function rocblas_ctbmv_full_rank(handle,uplo,trans,diag,m,k,A,lda,x,incx)
      use iso_c_binding
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocblas_ctbmv_full_rank
      type(c_ptr),value :: handle
      integer(kind(rocblas_fill_upper)),value :: uplo
      integer(kind(rocblas_operation_none)),value :: trans
      integer(kind(rocblas_diagonal_non_unit)),value :: diag
      integer(c_int),value :: m
      integer(c_int),value :: k
      complex(c_float_complex),target,dimension(:,:) :: A
      integer(c_int),value :: lda
      complex(c_float_complex),target,dimension(:) :: x
      integer(c_int),value :: incx
      !
      rocblas_ctbmv_full_rank = rocblas_ctbmv_orig(handle,uplo,trans,diag,m,k,c_loc(A),lda,c_loc(x),incx)
    end function

    function rocblas_ctbmv_rank_0(handle,uplo,trans,diag,m,k,A,lda,x,incx)
      use iso_c_binding
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocblas_ctbmv_rank_0
      type(c_ptr),value :: handle
      integer(kind(rocblas_fill_upper)),value :: uplo
      integer(kind(rocblas_operation_none)),value :: trans
      integer(kind(rocblas_diagonal_non_unit)),value :: diag
      integer(c_int),value :: m
      integer(c_int),value :: k
      complex(c_float_complex),target :: A
      integer(c_int),value :: lda
      complex(c_float_complex),target :: x
      integer(c_int),value :: incx
      !
      rocblas_ctbmv_rank_0 = rocblas_ctbmv_orig(handle,uplo,trans,diag,m,k,c_loc(A),lda,c_loc(x),incx)
    end function

    function rocblas_ctbmv_rank_1(handle,uplo,trans,diag,m,k,A,lda,x,incx)
      use iso_c_binding
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocblas_ctbmv_rank_1
      type(c_ptr),value :: handle
      integer(kind(rocblas_fill_upper)),value :: uplo
      integer(kind(rocblas_operation_none)),value :: trans
      integer(kind(rocblas_diagonal_non_unit)),value :: diag
      integer(c_int),value :: m
      integer(c_int),value :: k
      complex(c_float_complex),target,dimension(:) :: A
      integer(c_int),value :: lda
      complex(c_float_complex),target,dimension(:) :: x
      integer(c_int),value :: incx
      !
      rocblas_ctbmv_rank_1 = rocblas_ctbmv_orig(handle,uplo,trans,diag,m,k,c_loc(A),lda,c_loc(x),incx)
    end function

    function rocblas_ztbmv_full_rank(handle,uplo,trans,diag,m,k,A,lda,x,incx)
      use iso_c_binding
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocblas_ztbmv_full_rank
      type(c_ptr),value :: handle
      integer(kind(rocblas_fill_upper)),value :: uplo
      integer(kind(rocblas_operation_none)),value :: trans
      integer(kind(rocblas_diagonal_non_unit)),value :: diag
      integer(c_int),value :: m
      integer(c_int),value :: k
      complex(c_double_complex),target,dimension(:,:) :: A
      integer(c_int),value :: lda
      complex(c_double_complex),target,dimension(:) :: x
      integer(c_int),value :: incx
      !
      rocblas_ztbmv_full_rank = rocblas_ztbmv_orig(handle,uplo,trans,diag,m,k,c_loc(A),lda,c_loc(x),incx)
    end function

    function rocblas_ztbmv_rank_0(handle,uplo,trans,diag,m,k,A,lda,x,incx)
      use iso_c_binding
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocblas_ztbmv_rank_0
      type(c_ptr),value :: handle
      integer(kind(rocblas_fill_upper)),value :: uplo
      integer(kind(rocblas_operation_none)),value :: trans
      integer(kind(rocblas_diagonal_non_unit)),value :: diag
      integer(c_int),value :: m
      integer(c_int),value :: k
      complex(c_double_complex),target :: A
      integer(c_int),value :: lda
      complex(c_double_complex),target :: x
      integer(c_int),value :: incx
      !
      rocblas_ztbmv_rank_0 = rocblas_ztbmv_orig(handle,uplo,trans,diag,m,k,c_loc(A),lda,c_loc(x),incx)
    end function

    function rocblas_ztbmv_rank_1(handle,uplo,trans,diag,m,k,A,lda,x,incx)
      use iso_c_binding
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocblas_ztbmv_rank_1
      type(c_ptr),value :: handle
      integer(kind(rocblas_fill_upper)),value :: uplo
      integer(kind(rocblas_operation_none)),value :: trans
      integer(kind(rocblas_diagonal_non_unit)),value :: diag
      integer(c_int),value :: m
      integer(c_int),value :: k
      complex(c_double_complex),target,dimension(:) :: A
      integer(c_int),value :: lda
      complex(c_double_complex),target,dimension(:) :: x
      integer(c_int),value :: incx
      !
      rocblas_ztbmv_rank_1 = rocblas_ztbmv_orig(handle,uplo,trans,diag,m,k,c_loc(A),lda,c_loc(x),incx)
    end function

    function rocblas_stbmv_batched_full_rank(handle,uplo,trans,diag,m,k,A,lda,x,incx,batch_count)
      use iso_c_binding
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocblas_stbmv_batched_full_rank
      type(c_ptr),value :: handle
      integer(kind(rocblas_fill_upper)),value :: uplo
      integer(kind(rocblas_operation_none)),value :: trans
      integer(kind(rocblas_diagonal_non_unit)),value :: diag
      integer(c_int),value :: m
      integer(c_int),value :: k
      real(c_float),target,dimension(:,:,:) :: A
      integer(c_int),value :: lda
      real(c_float),target,dimension(:,:) :: x
      integer(c_int),value :: incx
      integer(c_int),value :: batch_count
      !
      rocblas_stbmv_batched_full_rank = rocblas_stbmv_batched_orig(handle,uplo,trans,diag,m,k,c_loc(A),lda,c_loc(x),incx,batch_count)
    end function

    function rocblas_stbmv_batched_rank_0(handle,uplo,trans,diag,m,k,A,lda,x,incx,batch_count)
      use iso_c_binding
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocblas_stbmv_batched_rank_0
      type(c_ptr),value :: handle
      integer(kind(rocblas_fill_upper)),value :: uplo
      integer(kind(rocblas_operation_none)),value :: trans
      integer(kind(rocblas_diagonal_non_unit)),value :: diag
      integer(c_int),value :: m
      integer(c_int),value :: k
      real(c_float),target :: A
      integer(c_int),value :: lda
      real(c_float),target :: x
      integer(c_int),value :: incx
      integer(c_int),value :: batch_count
      !
      rocblas_stbmv_batched_rank_0 = rocblas_stbmv_batched_orig(handle,uplo,trans,diag,m,k,c_loc(A),lda,c_loc(x),incx,batch_count)
    end function

    function rocblas_stbmv_batched_rank_1(handle,uplo,trans,diag,m,k,A,lda,x,incx,batch_count)
      use iso_c_binding
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocblas_stbmv_batched_rank_1
      type(c_ptr),value :: handle
      integer(kind(rocblas_fill_upper)),value :: uplo
      integer(kind(rocblas_operation_none)),value :: trans
      integer(kind(rocblas_diagonal_non_unit)),value :: diag
      integer(c_int),value :: m
      integer(c_int),value :: k
      real(c_float),target,dimension(:) :: A
      integer(c_int),value :: lda
      real(c_float),target,dimension(:) :: x
      integer(c_int),value :: incx
      integer(c_int),value :: batch_count
      !
      rocblas_stbmv_batched_rank_1 = rocblas_stbmv_batched_orig(handle,uplo,trans,diag,m,k,c_loc(A),lda,c_loc(x),incx,batch_count)
    end function

    function rocblas_dtbmv_batched_full_rank(handle,uplo,trans,diag,m,k,A,lda,x,incx,batch_count)
      use iso_c_binding
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocblas_dtbmv_batched_full_rank
      type(c_ptr),value :: handle
      integer(kind(rocblas_fill_upper)),value :: uplo
      integer(kind(rocblas_operation_none)),value :: trans
      integer(kind(rocblas_diagonal_non_unit)),value :: diag
      integer(c_int),value :: m
      integer(c_int),value :: k
      real(c_double),target,dimension(:,:,:) :: A
      integer(c_int),value :: lda
      real(c_double),target,dimension(:,:) :: x
      integer(c_int),value :: incx
      integer(c_int),value :: batch_count
      !
      rocblas_dtbmv_batched_full_rank = rocblas_dtbmv_batched_orig(handle,uplo,trans,diag,m,k,c_loc(A),lda,c_loc(x),incx,batch_count)
    end function

    function rocblas_dtbmv_batched_rank_0(handle,uplo,trans,diag,m,k,A,lda,x,incx,batch_count)
      use iso_c_binding
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocblas_dtbmv_batched_rank_0
      type(c_ptr),value :: handle
      integer(kind(rocblas_fill_upper)),value :: uplo
      integer(kind(rocblas_operation_none)),value :: trans
      integer(kind(rocblas_diagonal_non_unit)),value :: diag
      integer(c_int),value :: m
      integer(c_int),value :: k
      real(c_double),target :: A
      integer(c_int),value :: lda
      real(c_double),target :: x
      integer(c_int),value :: incx
      integer(c_int),value :: batch_count
      !
      rocblas_dtbmv_batched_rank_0 = rocblas_dtbmv_batched_orig(handle,uplo,trans,diag,m,k,c_loc(A),lda,c_loc(x),incx,batch_count)
    end function

    function rocblas_dtbmv_batched_rank_1(handle,uplo,trans,diag,m,k,A,lda,x,incx,batch_count)
      use iso_c_binding
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocblas_dtbmv_batched_rank_1
      type(c_ptr),value :: handle
      integer(kind(rocblas_fill_upper)),value :: uplo
      integer(kind(rocblas_operation_none)),value :: trans
      integer(kind(rocblas_diagonal_non_unit)),value :: diag
      integer(c_int),value :: m
      integer(c_int),value :: k
      real(c_double),target,dimension(:) :: A
      integer(c_int),value :: lda
      real(c_double),target,dimension(:) :: x
      integer(c_int),value :: incx
      integer(c_int),value :: batch_count
      !
      rocblas_dtbmv_batched_rank_1 = rocblas_dtbmv_batched_orig(handle,uplo,trans,diag,m,k,c_loc(A),lda,c_loc(x),incx,batch_count)
    end function

    function rocblas_ctbmv_batched_full_rank(handle,uplo,trans,diag,m,k,A,da,x,incx,batch_count)
      use iso_c_binding
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocblas_ctbmv_batched_full_rank
      type(c_ptr),value :: handle
      integer(kind(rocblas_fill_upper)),value :: uplo
      integer(kind(rocblas_operation_none)),value :: trans
      integer(kind(rocblas_diagonal_non_unit)),value :: diag
      integer(c_int),value :: m
      integer(c_int),value :: k
      complex(c_float_complex),target,dimension(:,:,:) :: A
      integer(c_int),value :: da
      complex(c_float_complex),target,dimension(:,:) :: x
      integer(c_int),value :: incx
      integer(c_int),value :: batch_count
      !
      rocblas_ctbmv_batched_full_rank = rocblas_ctbmv_batched_orig(handle,uplo,trans,diag,m,k,c_loc(A),da,c_loc(x),incx,batch_count)
    end function

    function rocblas_ctbmv_batched_rank_0(handle,uplo,trans,diag,m,k,A,da,x,incx,batch_count)
      use iso_c_binding
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocblas_ctbmv_batched_rank_0
      type(c_ptr),value :: handle
      integer(kind(rocblas_fill_upper)),value :: uplo
      integer(kind(rocblas_operation_none)),value :: trans
      integer(kind(rocblas_diagonal_non_unit)),value :: diag
      integer(c_int),value :: m
      integer(c_int),value :: k
      complex(c_float_complex),target :: A
      integer(c_int),value :: da
      complex(c_float_complex),target :: x
      integer(c_int),value :: incx
      integer(c_int),value :: batch_count
      !
      rocblas_ctbmv_batched_rank_0 = rocblas_ctbmv_batched_orig(handle,uplo,trans,diag,m,k,c_loc(A),da,c_loc(x),incx,batch_count)
    end function

    function rocblas_ctbmv_batched_rank_1(handle,uplo,trans,diag,m,k,A,da,x,incx,batch_count)
      use iso_c_binding
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocblas_ctbmv_batched_rank_1
      type(c_ptr),value :: handle
      integer(kind(rocblas_fill_upper)),value :: uplo
      integer(kind(rocblas_operation_none)),value :: trans
      integer(kind(rocblas_diagonal_non_unit)),value :: diag
      integer(c_int),value :: m
      integer(c_int),value :: k
      complex(c_float_complex),target,dimension(:) :: A
      integer(c_int),value :: da
      complex(c_float_complex),target,dimension(:) :: x
      integer(c_int),value :: incx
      integer(c_int),value :: batch_count
      !
      rocblas_ctbmv_batched_rank_1 = rocblas_ctbmv_batched_orig(handle,uplo,trans,diag,m,k,c_loc(A),da,c_loc(x),incx,batch_count)
    end function

    function rocblas_ztbmv_batched_full_rank(handle,uplo,trans,diag,m,k,A,lda,x,incx,batch_count)
      use iso_c_binding
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocblas_ztbmv_batched_full_rank
      type(c_ptr),value :: handle
      integer(kind(rocblas_fill_upper)),value :: uplo
      integer(kind(rocblas_operation_none)),value :: trans
      integer(kind(rocblas_diagonal_non_unit)),value :: diag
      integer(c_int),value :: m
      integer(c_int),value :: k
      complex(c_double_complex),target,dimension(:,:,:) :: A
      integer(c_int),value :: lda
      complex(c_double_complex),target,dimension(:,:) :: x
      integer(c_int),value :: incx
      integer(c_int),value :: batch_count
      !
      rocblas_ztbmv_batched_full_rank = rocblas_ztbmv_batched_orig(handle,uplo,trans,diag,m,k,c_loc(A),lda,c_loc(x),incx,batch_count)
    end function

    function rocblas_ztbmv_batched_rank_0(handle,uplo,trans,diag,m,k,A,lda,x,incx,batch_count)
      use iso_c_binding
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocblas_ztbmv_batched_rank_0
      type(c_ptr),value :: handle
      integer(kind(rocblas_fill_upper)),value :: uplo
      integer(kind(rocblas_operation_none)),value :: trans
      integer(kind(rocblas_diagonal_non_unit)),value :: diag
      integer(c_int),value :: m
      integer(c_int),value :: k
      complex(c_double_complex),target :: A
      integer(c_int),value :: lda
      complex(c_double_complex),target :: x
      integer(c_int),value :: incx
      integer(c_int),value :: batch_count
      !
      rocblas_ztbmv_batched_rank_0 = rocblas_ztbmv_batched_orig(handle,uplo,trans,diag,m,k,c_loc(A),lda,c_loc(x),incx,batch_count)
    end function

    function rocblas_ztbmv_batched_rank_1(handle,uplo,trans,diag,m,k,A,lda,x,incx,batch_count)
      use iso_c_binding
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocblas_ztbmv_batched_rank_1
      type(c_ptr),value :: handle
      integer(kind(rocblas_fill_upper)),value :: uplo
      integer(kind(rocblas_operation_none)),value :: trans
      integer(kind(rocblas_diagonal_non_unit)),value :: diag
      integer(c_int),value :: m
      integer(c_int),value :: k
      complex(c_double_complex),target,dimension(:) :: A
      integer(c_int),value :: lda
      complex(c_double_complex),target,dimension(:) :: x
      integer(c_int),value :: incx
      integer(c_int),value :: batch_count
      !
      rocblas_ztbmv_batched_rank_1 = rocblas_ztbmv_batched_orig(handle,uplo,trans,diag,m,k,c_loc(A),lda,c_loc(x),incx,batch_count)
    end function

    function rocblas_stbmv_strided_batched_full_rank(handle,uplo,trans,diag,m,k,A,lda,stride_A,x,incx,stride_x,batch_count)
      use iso_c_binding
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocblas_stbmv_strided_batched_full_rank
      type(c_ptr),value :: handle
      integer(kind(rocblas_fill_upper)),value :: uplo
      integer(kind(rocblas_operation_none)),value :: trans
      integer(kind(rocblas_diagonal_non_unit)),value :: diag
      integer(c_int),value :: m
      integer(c_int),value :: k
      real(c_float),target,dimension(:,:) :: A
      integer(c_int),value :: lda
      integer(c_int64_t),value :: stride_A
      real(c_float),target,dimension(:) :: x
      integer(c_int),value :: incx
      integer(c_int64_t),value :: stride_x
      integer(c_int),value :: batch_count
      !
      rocblas_stbmv_strided_batched_full_rank = rocblas_stbmv_strided_batched_orig(handle,uplo,trans,diag,m,k,c_loc(A),lda,stride_A,c_loc(x),incx,stride_x,batch_count)
    end function

    function rocblas_stbmv_strided_batched_rank_0(handle,uplo,trans,diag,m,k,A,lda,stride_A,x,incx,stride_x,batch_count)
      use iso_c_binding
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocblas_stbmv_strided_batched_rank_0
      type(c_ptr),value :: handle
      integer(kind(rocblas_fill_upper)),value :: uplo
      integer(kind(rocblas_operation_none)),value :: trans
      integer(kind(rocblas_diagonal_non_unit)),value :: diag
      integer(c_int),value :: m
      integer(c_int),value :: k
      real(c_float),target :: A
      integer(c_int),value :: lda
      integer(c_int64_t),value :: stride_A
      real(c_float),target :: x
      integer(c_int),value :: incx
      integer(c_int64_t),value :: stride_x
      integer(c_int),value :: batch_count
      !
      rocblas_stbmv_strided_batched_rank_0 = rocblas_stbmv_strided_batched_orig(handle,uplo,trans,diag,m,k,c_loc(A),lda,stride_A,c_loc(x),incx,stride_x,batch_count)
    end function

    function rocblas_stbmv_strided_batched_rank_1(handle,uplo,trans,diag,m,k,A,lda,stride_A,x,incx,stride_x,batch_count)
      use iso_c_binding
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocblas_stbmv_strided_batched_rank_1
      type(c_ptr),value :: handle
      integer(kind(rocblas_fill_upper)),value :: uplo
      integer(kind(rocblas_operation_none)),value :: trans
      integer(kind(rocblas_diagonal_non_unit)),value :: diag
      integer(c_int),value :: m
      integer(c_int),value :: k
      real(c_float),target,dimension(:) :: A
      integer(c_int),value :: lda
      integer(c_int64_t),value :: stride_A
      real(c_float),target,dimension(:) :: x
      integer(c_int),value :: incx
      integer(c_int64_t),value :: stride_x
      integer(c_int),value :: batch_count
      !
      rocblas_stbmv_strided_batched_rank_1 = rocblas_stbmv_strided_batched_orig(handle,uplo,trans,diag,m,k,c_loc(A),lda,stride_A,c_loc(x),incx,stride_x,batch_count)
    end function

    function rocblas_dtbmv_strided_batched_full_rank(handle,uplo,trans,diag,m,k,A,lda,stride_A,x,incx,stride_x,batch_count)
      use iso_c_binding
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocblas_dtbmv_strided_batched_full_rank
      type(c_ptr),value :: handle
      integer(kind(rocblas_fill_upper)),value :: uplo
      integer(kind(rocblas_operation_none)),value :: trans
      integer(kind(rocblas_diagonal_non_unit)),value :: diag
      integer(c_int),value :: m
      integer(c_int),value :: k
      real(c_double),target,dimension(:,:) :: A
      integer(c_int),value :: lda
      integer(c_int64_t),value :: stride_A
      real(c_double),target,dimension(:) :: x
      integer(c_int),value :: incx
      integer(c_int64_t),value :: stride_x
      integer(c_int),value :: batch_count
      !
      rocblas_dtbmv_strided_batched_full_rank = rocblas_dtbmv_strided_batched_orig(handle,uplo,trans,diag,m,k,c_loc(A),lda,stride_A,c_loc(x),incx,stride_x,batch_count)
    end function

    function rocblas_dtbmv_strided_batched_rank_0(handle,uplo,trans,diag,m,k,A,lda,stride_A,x,incx,stride_x,batch_count)
      use iso_c_binding
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocblas_dtbmv_strided_batched_rank_0
      type(c_ptr),value :: handle
      integer(kind(rocblas_fill_upper)),value :: uplo
      integer(kind(rocblas_operation_none)),value :: trans
      integer(kind(rocblas_diagonal_non_unit)),value :: diag
      integer(c_int),value :: m
      integer(c_int),value :: k
      real(c_double),target :: A
      integer(c_int),value :: lda
      integer(c_int64_t),value :: stride_A
      real(c_double),target :: x
      integer(c_int),value :: incx
      integer(c_int64_t),value :: stride_x
      integer(c_int),value :: batch_count
      !
      rocblas_dtbmv_strided_batched_rank_0 = rocblas_dtbmv_strided_batched_orig(handle,uplo,trans,diag,m,k,c_loc(A),lda,stride_A,c_loc(x),incx,stride_x,batch_count)
    end function

    function rocblas_dtbmv_strided_batched_rank_1(handle,uplo,trans,diag,m,k,A,lda,stride_A,x,incx,stride_x,batch_count)
      use iso_c_binding
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocblas_dtbmv_strided_batched_rank_1
      type(c_ptr),value :: handle
      integer(kind(rocblas_fill_upper)),value :: uplo
      integer(kind(rocblas_operation_none)),value :: trans
      integer(kind(rocblas_diagonal_non_unit)),value :: diag
      integer(c_int),value :: m
      integer(c_int),value :: k
      real(c_double),target,dimension(:) :: A
      integer(c_int),value :: lda
      integer(c_int64_t),value :: stride_A
      real(c_double),target,dimension(:) :: x
      integer(c_int),value :: incx
      integer(c_int64_t),value :: stride_x
      integer(c_int),value :: batch_count
      !
      rocblas_dtbmv_strided_batched_rank_1 = rocblas_dtbmv_strided_batched_orig(handle,uplo,trans,diag,m,k,c_loc(A),lda,stride_A,c_loc(x),incx,stride_x,batch_count)
    end function

    function rocblas_ctbmv_strided_batched_full_rank(handle,uplo,trans,diag,m,k,A,lda,stride_A,x,incx,stride_x,batch_count)
      use iso_c_binding
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocblas_ctbmv_strided_batched_full_rank
      type(c_ptr),value :: handle
      integer(kind(rocblas_fill_upper)),value :: uplo
      integer(kind(rocblas_operation_none)),value :: trans
      integer(kind(rocblas_diagonal_non_unit)),value :: diag
      integer(c_int),value :: m
      integer(c_int),value :: k
      complex(c_float_complex),target,dimension(:,:) :: A
      integer(c_int),value :: lda
      integer(c_int64_t),value :: stride_A
      complex(c_float_complex),target,dimension(:) :: x
      integer(c_int),value :: incx
      integer(c_int64_t),value :: stride_x
      integer(c_int),value :: batch_count
      !
      rocblas_ctbmv_strided_batched_full_rank = rocblas_ctbmv_strided_batched_orig(handle,uplo,trans,diag,m,k,c_loc(A),lda,stride_A,c_loc(x),incx,stride_x,batch_count)
    end function

    function rocblas_ctbmv_strided_batched_rank_0(handle,uplo,trans,diag,m,k,A,lda,stride_A,x,incx,stride_x,batch_count)
      use iso_c_binding
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocblas_ctbmv_strided_batched_rank_0
      type(c_ptr),value :: handle
      integer(kind(rocblas_fill_upper)),value :: uplo
      integer(kind(rocblas_operation_none)),value :: trans
      integer(kind(rocblas_diagonal_non_unit)),value :: diag
      integer(c_int),value :: m
      integer(c_int),value :: k
      complex(c_float_complex),target :: A
      integer(c_int),value :: lda
      integer(c_int64_t),value :: stride_A
      complex(c_float_complex),target :: x
      integer(c_int),value :: incx
      integer(c_int64_t),value :: stride_x
      integer(c_int),value :: batch_count
      !
      rocblas_ctbmv_strided_batched_rank_0 = rocblas_ctbmv_strided_batched_orig(handle,uplo,trans,diag,m,k,c_loc(A),lda,stride_A,c_loc(x),incx,stride_x,batch_count)
    end function

    function rocblas_ctbmv_strided_batched_rank_1(handle,uplo,trans,diag,m,k,A,lda,stride_A,x,incx,stride_x,batch_count)
      use iso_c_binding
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocblas_ctbmv_strided_batched_rank_1
      type(c_ptr),value :: handle
      integer(kind(rocblas_fill_upper)),value :: uplo
      integer(kind(rocblas_operation_none)),value :: trans
      integer(kind(rocblas_diagonal_non_unit)),value :: diag
      integer(c_int),value :: m
      integer(c_int),value :: k
      complex(c_float_complex),target,dimension(:) :: A
      integer(c_int),value :: lda
      integer(c_int64_t),value :: stride_A
      complex(c_float_complex),target,dimension(:) :: x
      integer(c_int),value :: incx
      integer(c_int64_t),value :: stride_x
      integer(c_int),value :: batch_count
      !
      rocblas_ctbmv_strided_batched_rank_1 = rocblas_ctbmv_strided_batched_orig(handle,uplo,trans,diag,m,k,c_loc(A),lda,stride_A,c_loc(x),incx,stride_x,batch_count)
    end function

    function rocblas_ztbmv_strided_batched_full_rank(handle,uplo,trans,diag,m,k,A,lda,stride_A,x,incx,stride_x,batch_count)
      use iso_c_binding
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocblas_ztbmv_strided_batched_full_rank
      type(c_ptr),value :: handle
      integer(kind(rocblas_fill_upper)),value :: uplo
      integer(kind(rocblas_operation_none)),value :: trans
      integer(kind(rocblas_diagonal_non_unit)),value :: diag
      integer(c_int),value :: m
      integer(c_int),value :: k
      complex(c_double_complex),target,dimension(:,:) :: A
      integer(c_int),value :: lda
      integer(c_int64_t),value :: stride_A
      complex(c_double_complex),target,dimension(:) :: x
      integer(c_int),value :: incx
      integer(c_int64_t),value :: stride_x
      integer(c_int),value :: batch_count
      !
      rocblas_ztbmv_strided_batched_full_rank = rocblas_ztbmv_strided_batched_orig(handle,uplo,trans,diag,m,k,c_loc(A),lda,stride_A,c_loc(x),incx,stride_x,batch_count)
    end function

    function rocblas_ztbmv_strided_batched_rank_0(handle,uplo,trans,diag,m,k,A,lda,stride_A,x,incx,stride_x,batch_count)
      use iso_c_binding
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocblas_ztbmv_strided_batched_rank_0
      type(c_ptr),value :: handle
      integer(kind(rocblas_fill_upper)),value :: uplo
      integer(kind(rocblas_operation_none)),value :: trans
      integer(kind(rocblas_diagonal_non_unit)),value :: diag
      integer(c_int),value :: m
      integer(c_int),value :: k
      complex(c_double_complex),target :: A
      integer(c_int),value :: lda
      integer(c_int64_t),value :: stride_A
      complex(c_double_complex),target :: x
      integer(c_int),value :: incx
      integer(c_int64_t),value :: stride_x
      integer(c_int),value :: batch_count
      !
      rocblas_ztbmv_strided_batched_rank_0 = rocblas_ztbmv_strided_batched_orig(handle,uplo,trans,diag,m,k,c_loc(A),lda,stride_A,c_loc(x),incx,stride_x,batch_count)
    end function

    function rocblas_ztbmv_strided_batched_rank_1(handle,uplo,trans,diag,m,k,A,lda,stride_A,x,incx,stride_x,batch_count)
      use iso_c_binding
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocblas_ztbmv_strided_batched_rank_1
      type(c_ptr),value :: handle
      integer(kind(rocblas_fill_upper)),value :: uplo
      integer(kind(rocblas_operation_none)),value :: trans
      integer(kind(rocblas_diagonal_non_unit)),value :: diag
      integer(c_int),value :: m
      integer(c_int),value :: k
      complex(c_double_complex),target,dimension(:) :: A
      integer(c_int),value :: lda
      integer(c_int64_t),value :: stride_A
      complex(c_double_complex),target,dimension(:) :: x
      integer(c_int),value :: incx
      integer(c_int64_t),value :: stride_x
      integer(c_int),value :: batch_count
      !
      rocblas_ztbmv_strided_batched_rank_1 = rocblas_ztbmv_strided_batched_orig(handle,uplo,trans,diag,m,k,c_loc(A),lda,stride_A,c_loc(x),incx,stride_x,batch_count)
    end function

    function rocblas_stbsv_full_rank(handle,uplo,transA,diag,n,k,A,lda,x,incx)
      use iso_c_binding
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocblas_stbsv_full_rank
      type(c_ptr),value :: handle
      integer(kind(rocblas_fill_upper)),value :: uplo
      integer(kind(rocblas_operation_none)),value :: transA
      integer(kind(rocblas_diagonal_non_unit)),value :: diag
      integer(c_int),value :: n
      integer(c_int),value :: k
      real(c_float),target,dimension(:,:) :: A
      integer(c_int),value :: lda
      real(c_float),target,dimension(:) :: x
      integer(c_int),value :: incx
      !
      rocblas_stbsv_full_rank = rocblas_stbsv_orig(handle,uplo,transA,diag,n,k,c_loc(A),lda,c_loc(x),incx)
    end function

    function rocblas_stbsv_rank_0(handle,uplo,transA,diag,n,k,A,lda,x,incx)
      use iso_c_binding
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocblas_stbsv_rank_0
      type(c_ptr),value :: handle
      integer(kind(rocblas_fill_upper)),value :: uplo
      integer(kind(rocblas_operation_none)),value :: transA
      integer(kind(rocblas_diagonal_non_unit)),value :: diag
      integer(c_int),value :: n
      integer(c_int),value :: k
      real(c_float),target :: A
      integer(c_int),value :: lda
      real(c_float),target :: x
      integer(c_int),value :: incx
      !
      rocblas_stbsv_rank_0 = rocblas_stbsv_orig(handle,uplo,transA,diag,n,k,c_loc(A),lda,c_loc(x),incx)
    end function

    function rocblas_stbsv_rank_1(handle,uplo,transA,diag,n,k,A,lda,x,incx)
      use iso_c_binding
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocblas_stbsv_rank_1
      type(c_ptr),value :: handle
      integer(kind(rocblas_fill_upper)),value :: uplo
      integer(kind(rocblas_operation_none)),value :: transA
      integer(kind(rocblas_diagonal_non_unit)),value :: diag
      integer(c_int),value :: n
      integer(c_int),value :: k
      real(c_float),target,dimension(:) :: A
      integer(c_int),value :: lda
      real(c_float),target,dimension(:) :: x
      integer(c_int),value :: incx
      !
      rocblas_stbsv_rank_1 = rocblas_stbsv_orig(handle,uplo,transA,diag,n,k,c_loc(A),lda,c_loc(x),incx)
    end function

    function rocblas_dtbsv_full_rank(handle,uplo,transA,diag,n,k,A,lda,x,incx)
      use iso_c_binding
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocblas_dtbsv_full_rank
      type(c_ptr),value :: handle
      integer(kind(rocblas_fill_upper)),value :: uplo
      integer(kind(rocblas_operation_none)),value :: transA
      integer(kind(rocblas_diagonal_non_unit)),value :: diag
      integer(c_int),value :: n
      integer(c_int),value :: k
      real(c_double),target,dimension(:,:) :: A
      integer(c_int),value :: lda
      real(c_double),target,dimension(:) :: x
      integer(c_int),value :: incx
      !
      rocblas_dtbsv_full_rank = rocblas_dtbsv_orig(handle,uplo,transA,diag,n,k,c_loc(A),lda,c_loc(x),incx)
    end function

    function rocblas_dtbsv_rank_0(handle,uplo,transA,diag,n,k,A,lda,x,incx)
      use iso_c_binding
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocblas_dtbsv_rank_0
      type(c_ptr),value :: handle
      integer(kind(rocblas_fill_upper)),value :: uplo
      integer(kind(rocblas_operation_none)),value :: transA
      integer(kind(rocblas_diagonal_non_unit)),value :: diag
      integer(c_int),value :: n
      integer(c_int),value :: k
      real(c_double),target :: A
      integer(c_int),value :: lda
      real(c_double),target :: x
      integer(c_int),value :: incx
      !
      rocblas_dtbsv_rank_0 = rocblas_dtbsv_orig(handle,uplo,transA,diag,n,k,c_loc(A),lda,c_loc(x),incx)
    end function

    function rocblas_dtbsv_rank_1(handle,uplo,transA,diag,n,k,A,lda,x,incx)
      use iso_c_binding
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocblas_dtbsv_rank_1
      type(c_ptr),value :: handle
      integer(kind(rocblas_fill_upper)),value :: uplo
      integer(kind(rocblas_operation_none)),value :: transA
      integer(kind(rocblas_diagonal_non_unit)),value :: diag
      integer(c_int),value :: n
      integer(c_int),value :: k
      real(c_double),target,dimension(:) :: A
      integer(c_int),value :: lda
      real(c_double),target,dimension(:) :: x
      integer(c_int),value :: incx
      !
      rocblas_dtbsv_rank_1 = rocblas_dtbsv_orig(handle,uplo,transA,diag,n,k,c_loc(A),lda,c_loc(x),incx)
    end function

    function rocblas_ctbsv_full_rank(handle,uplo,transA,diag,n,k,A,lda,x,incx)
      use iso_c_binding
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocblas_ctbsv_full_rank
      type(c_ptr),value :: handle
      integer(kind(rocblas_fill_upper)),value :: uplo
      integer(kind(rocblas_operation_none)),value :: transA
      integer(kind(rocblas_diagonal_non_unit)),value :: diag
      integer(c_int),value :: n
      integer(c_int),value :: k
      complex(c_float_complex),target,dimension(:,:) :: A
      integer(c_int),value :: lda
      complex(c_float_complex),target,dimension(:) :: x
      integer(c_int),value :: incx
      !
      rocblas_ctbsv_full_rank = rocblas_ctbsv_orig(handle,uplo,transA,diag,n,k,c_loc(A),lda,c_loc(x),incx)
    end function

    function rocblas_ctbsv_rank_0(handle,uplo,transA,diag,n,k,A,lda,x,incx)
      use iso_c_binding
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocblas_ctbsv_rank_0
      type(c_ptr),value :: handle
      integer(kind(rocblas_fill_upper)),value :: uplo
      integer(kind(rocblas_operation_none)),value :: transA
      integer(kind(rocblas_diagonal_non_unit)),value :: diag
      integer(c_int),value :: n
      integer(c_int),value :: k
      complex(c_float_complex),target :: A
      integer(c_int),value :: lda
      complex(c_float_complex),target :: x
      integer(c_int),value :: incx
      !
      rocblas_ctbsv_rank_0 = rocblas_ctbsv_orig(handle,uplo,transA,diag,n,k,c_loc(A),lda,c_loc(x),incx)
    end function

    function rocblas_ctbsv_rank_1(handle,uplo,transA,diag,n,k,A,lda,x,incx)
      use iso_c_binding
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocblas_ctbsv_rank_1
      type(c_ptr),value :: handle
      integer(kind(rocblas_fill_upper)),value :: uplo
      integer(kind(rocblas_operation_none)),value :: transA
      integer(kind(rocblas_diagonal_non_unit)),value :: diag
      integer(c_int),value :: n
      integer(c_int),value :: k
      complex(c_float_complex),target,dimension(:) :: A
      integer(c_int),value :: lda
      complex(c_float_complex),target,dimension(:) :: x
      integer(c_int),value :: incx
      !
      rocblas_ctbsv_rank_1 = rocblas_ctbsv_orig(handle,uplo,transA,diag,n,k,c_loc(A),lda,c_loc(x),incx)
    end function

    function rocblas_ztbsv_full_rank(handle,uplo,transA,diag,n,k,A,lda,x,incx)
      use iso_c_binding
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocblas_ztbsv_full_rank
      type(c_ptr),value :: handle
      integer(kind(rocblas_fill_upper)),value :: uplo
      integer(kind(rocblas_operation_none)),value :: transA
      integer(kind(rocblas_diagonal_non_unit)),value :: diag
      integer(c_int),value :: n
      integer(c_int),value :: k
      complex(c_double_complex),target,dimension(:,:) :: A
      integer(c_int),value :: lda
      complex(c_double_complex),target,dimension(:) :: x
      integer(c_int),value :: incx
      !
      rocblas_ztbsv_full_rank = rocblas_ztbsv_orig(handle,uplo,transA,diag,n,k,c_loc(A),lda,c_loc(x),incx)
    end function

    function rocblas_ztbsv_rank_0(handle,uplo,transA,diag,n,k,A,lda,x,incx)
      use iso_c_binding
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocblas_ztbsv_rank_0
      type(c_ptr),value :: handle
      integer(kind(rocblas_fill_upper)),value :: uplo
      integer(kind(rocblas_operation_none)),value :: transA
      integer(kind(rocblas_diagonal_non_unit)),value :: diag
      integer(c_int),value :: n
      integer(c_int),value :: k
      complex(c_double_complex),target :: A
      integer(c_int),value :: lda
      complex(c_double_complex),target :: x
      integer(c_int),value :: incx
      !
      rocblas_ztbsv_rank_0 = rocblas_ztbsv_orig(handle,uplo,transA,diag,n,k,c_loc(A),lda,c_loc(x),incx)
    end function

    function rocblas_ztbsv_rank_1(handle,uplo,transA,diag,n,k,A,lda,x,incx)
      use iso_c_binding
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocblas_ztbsv_rank_1
      type(c_ptr),value :: handle
      integer(kind(rocblas_fill_upper)),value :: uplo
      integer(kind(rocblas_operation_none)),value :: transA
      integer(kind(rocblas_diagonal_non_unit)),value :: diag
      integer(c_int),value :: n
      integer(c_int),value :: k
      complex(c_double_complex),target,dimension(:) :: A
      integer(c_int),value :: lda
      complex(c_double_complex),target,dimension(:) :: x
      integer(c_int),value :: incx
      !
      rocblas_ztbsv_rank_1 = rocblas_ztbsv_orig(handle,uplo,transA,diag,n,k,c_loc(A),lda,c_loc(x),incx)
    end function

    function rocblas_stbsv_batched_full_rank(handle,uplo,transA,diag,n,k,A,lda,x,incx,batch_count)
      use iso_c_binding
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocblas_stbsv_batched_full_rank
      type(c_ptr),value :: handle
      integer(kind(rocblas_fill_upper)),value :: uplo
      integer(kind(rocblas_operation_none)),value :: transA
      integer(kind(rocblas_diagonal_non_unit)),value :: diag
      integer(c_int),value :: n
      integer(c_int),value :: k
      real(c_float),target,dimension(:,:,:) :: A
      integer(c_int),value :: lda
      real(c_float),target,dimension(:,:) :: x
      integer(c_int),value :: incx
      integer(c_int),value :: batch_count
      !
      rocblas_stbsv_batched_full_rank = rocblas_stbsv_batched_orig(handle,uplo,transA,diag,n,k,c_loc(A),lda,c_loc(x),incx,batch_count)
    end function

    function rocblas_stbsv_batched_rank_0(handle,uplo,transA,diag,n,k,A,lda,x,incx,batch_count)
      use iso_c_binding
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocblas_stbsv_batched_rank_0
      type(c_ptr),value :: handle
      integer(kind(rocblas_fill_upper)),value :: uplo
      integer(kind(rocblas_operation_none)),value :: transA
      integer(kind(rocblas_diagonal_non_unit)),value :: diag
      integer(c_int),value :: n
      integer(c_int),value :: k
      real(c_float),target :: A
      integer(c_int),value :: lda
      real(c_float),target :: x
      integer(c_int),value :: incx
      integer(c_int),value :: batch_count
      !
      rocblas_stbsv_batched_rank_0 = rocblas_stbsv_batched_orig(handle,uplo,transA,diag,n,k,c_loc(A),lda,c_loc(x),incx,batch_count)
    end function

    function rocblas_stbsv_batched_rank_1(handle,uplo,transA,diag,n,k,A,lda,x,incx,batch_count)
      use iso_c_binding
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocblas_stbsv_batched_rank_1
      type(c_ptr),value :: handle
      integer(kind(rocblas_fill_upper)),value :: uplo
      integer(kind(rocblas_operation_none)),value :: transA
      integer(kind(rocblas_diagonal_non_unit)),value :: diag
      integer(c_int),value :: n
      integer(c_int),value :: k
      real(c_float),target,dimension(:) :: A
      integer(c_int),value :: lda
      real(c_float),target,dimension(:) :: x
      integer(c_int),value :: incx
      integer(c_int),value :: batch_count
      !
      rocblas_stbsv_batched_rank_1 = rocblas_stbsv_batched_orig(handle,uplo,transA,diag,n,k,c_loc(A),lda,c_loc(x),incx,batch_count)
    end function

    function rocblas_dtbsv_batched_full_rank(handle,uplo,transA,diag,n,k,A,lda,x,incx,batch_count)
      use iso_c_binding
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocblas_dtbsv_batched_full_rank
      type(c_ptr),value :: handle
      integer(kind(rocblas_fill_upper)),value :: uplo
      integer(kind(rocblas_operation_none)),value :: transA
      integer(kind(rocblas_diagonal_non_unit)),value :: diag
      integer(c_int),value :: n
      integer(c_int),value :: k
      real(c_double),target,dimension(:,:,:) :: A
      integer(c_int),value :: lda
      real(c_double),target,dimension(:,:) :: x
      integer(c_int),value :: incx
      integer(c_int),value :: batch_count
      !
      rocblas_dtbsv_batched_full_rank = rocblas_dtbsv_batched_orig(handle,uplo,transA,diag,n,k,c_loc(A),lda,c_loc(x),incx,batch_count)
    end function

    function rocblas_dtbsv_batched_rank_0(handle,uplo,transA,diag,n,k,A,lda,x,incx,batch_count)
      use iso_c_binding
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocblas_dtbsv_batched_rank_0
      type(c_ptr),value :: handle
      integer(kind(rocblas_fill_upper)),value :: uplo
      integer(kind(rocblas_operation_none)),value :: transA
      integer(kind(rocblas_diagonal_non_unit)),value :: diag
      integer(c_int),value :: n
      integer(c_int),value :: k
      real(c_double),target :: A
      integer(c_int),value :: lda
      real(c_double),target :: x
      integer(c_int),value :: incx
      integer(c_int),value :: batch_count
      !
      rocblas_dtbsv_batched_rank_0 = rocblas_dtbsv_batched_orig(handle,uplo,transA,diag,n,k,c_loc(A),lda,c_loc(x),incx,batch_count)
    end function

    function rocblas_dtbsv_batched_rank_1(handle,uplo,transA,diag,n,k,A,lda,x,incx,batch_count)
      use iso_c_binding
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocblas_dtbsv_batched_rank_1
      type(c_ptr),value :: handle
      integer(kind(rocblas_fill_upper)),value :: uplo
      integer(kind(rocblas_operation_none)),value :: transA
      integer(kind(rocblas_diagonal_non_unit)),value :: diag
      integer(c_int),value :: n
      integer(c_int),value :: k
      real(c_double),target,dimension(:) :: A
      integer(c_int),value :: lda
      real(c_double),target,dimension(:) :: x
      integer(c_int),value :: incx
      integer(c_int),value :: batch_count
      !
      rocblas_dtbsv_batched_rank_1 = rocblas_dtbsv_batched_orig(handle,uplo,transA,diag,n,k,c_loc(A),lda,c_loc(x),incx,batch_count)
    end function

    function rocblas_ctbsv_batched_full_rank(handle,uplo,transA,diag,n,k,A,lda,x,incx,batch_count)
      use iso_c_binding
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocblas_ctbsv_batched_full_rank
      type(c_ptr),value :: handle
      integer(kind(rocblas_fill_upper)),value :: uplo
      integer(kind(rocblas_operation_none)),value :: transA
      integer(kind(rocblas_diagonal_non_unit)),value :: diag
      integer(c_int),value :: n
      integer(c_int),value :: k
      complex(c_float_complex),target,dimension(:,:,:) :: A
      integer(c_int),value :: lda
      complex(c_float_complex),target,dimension(:,:) :: x
      integer(c_int),value :: incx
      integer(c_int),value :: batch_count
      !
      rocblas_ctbsv_batched_full_rank = rocblas_ctbsv_batched_orig(handle,uplo,transA,diag,n,k,c_loc(A),lda,c_loc(x),incx,batch_count)
    end function

    function rocblas_ctbsv_batched_rank_0(handle,uplo,transA,diag,n,k,A,lda,x,incx,batch_count)
      use iso_c_binding
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocblas_ctbsv_batched_rank_0
      type(c_ptr),value :: handle
      integer(kind(rocblas_fill_upper)),value :: uplo
      integer(kind(rocblas_operation_none)),value :: transA
      integer(kind(rocblas_diagonal_non_unit)),value :: diag
      integer(c_int),value :: n
      integer(c_int),value :: k
      complex(c_float_complex),target :: A
      integer(c_int),value :: lda
      complex(c_float_complex),target :: x
      integer(c_int),value :: incx
      integer(c_int),value :: batch_count
      !
      rocblas_ctbsv_batched_rank_0 = rocblas_ctbsv_batched_orig(handle,uplo,transA,diag,n,k,c_loc(A),lda,c_loc(x),incx,batch_count)
    end function

    function rocblas_ctbsv_batched_rank_1(handle,uplo,transA,diag,n,k,A,lda,x,incx,batch_count)
      use iso_c_binding
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocblas_ctbsv_batched_rank_1
      type(c_ptr),value :: handle
      integer(kind(rocblas_fill_upper)),value :: uplo
      integer(kind(rocblas_operation_none)),value :: transA
      integer(kind(rocblas_diagonal_non_unit)),value :: diag
      integer(c_int),value :: n
      integer(c_int),value :: k
      complex(c_float_complex),target,dimension(:) :: A
      integer(c_int),value :: lda
      complex(c_float_complex),target,dimension(:) :: x
      integer(c_int),value :: incx
      integer(c_int),value :: batch_count
      !
      rocblas_ctbsv_batched_rank_1 = rocblas_ctbsv_batched_orig(handle,uplo,transA,diag,n,k,c_loc(A),lda,c_loc(x),incx,batch_count)
    end function

    function rocblas_ztbsv_batched_full_rank(handle,uplo,transA,diag,n,k,A,lda,x,incx,batch_count)
      use iso_c_binding
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocblas_ztbsv_batched_full_rank
      type(c_ptr),value :: handle
      integer(kind(rocblas_fill_upper)),value :: uplo
      integer(kind(rocblas_operation_none)),value :: transA
      integer(kind(rocblas_diagonal_non_unit)),value :: diag
      integer(c_int),value :: n
      integer(c_int),value :: k
      complex(c_double_complex),target,dimension(:,:,:) :: A
      integer(c_int),value :: lda
      complex(c_double_complex),target,dimension(:,:) :: x
      integer(c_int),value :: incx
      integer(c_int),value :: batch_count
      !
      rocblas_ztbsv_batched_full_rank = rocblas_ztbsv_batched_orig(handle,uplo,transA,diag,n,k,c_loc(A),lda,c_loc(x),incx,batch_count)
    end function

    function rocblas_ztbsv_batched_rank_0(handle,uplo,transA,diag,n,k,A,lda,x,incx,batch_count)
      use iso_c_binding
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocblas_ztbsv_batched_rank_0
      type(c_ptr),value :: handle
      integer(kind(rocblas_fill_upper)),value :: uplo
      integer(kind(rocblas_operation_none)),value :: transA
      integer(kind(rocblas_diagonal_non_unit)),value :: diag
      integer(c_int),value :: n
      integer(c_int),value :: k
      complex(c_double_complex),target :: A
      integer(c_int),value :: lda
      complex(c_double_complex),target :: x
      integer(c_int),value :: incx
      integer(c_int),value :: batch_count
      !
      rocblas_ztbsv_batched_rank_0 = rocblas_ztbsv_batched_orig(handle,uplo,transA,diag,n,k,c_loc(A),lda,c_loc(x),incx,batch_count)
    end function

    function rocblas_ztbsv_batched_rank_1(handle,uplo,transA,diag,n,k,A,lda,x,incx,batch_count)
      use iso_c_binding
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocblas_ztbsv_batched_rank_1
      type(c_ptr),value :: handle
      integer(kind(rocblas_fill_upper)),value :: uplo
      integer(kind(rocblas_operation_none)),value :: transA
      integer(kind(rocblas_diagonal_non_unit)),value :: diag
      integer(c_int),value :: n
      integer(c_int),value :: k
      complex(c_double_complex),target,dimension(:) :: A
      integer(c_int),value :: lda
      complex(c_double_complex),target,dimension(:) :: x
      integer(c_int),value :: incx
      integer(c_int),value :: batch_count
      !
      rocblas_ztbsv_batched_rank_1 = rocblas_ztbsv_batched_orig(handle,uplo,transA,diag,n,k,c_loc(A),lda,c_loc(x),incx,batch_count)
    end function

    function rocblas_stbsv_strided_batched_full_rank(handle,uplo,transA,diag,n,k,A,lda,stride_A,x,incx,stride_x,batch_count)
      use iso_c_binding
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocblas_stbsv_strided_batched_full_rank
      type(c_ptr),value :: handle
      integer(kind(rocblas_fill_upper)),value :: uplo
      integer(kind(rocblas_operation_none)),value :: transA
      integer(kind(rocblas_diagonal_non_unit)),value :: diag
      integer(c_int),value :: n
      integer(c_int),value :: k
      real(c_float),target,dimension(:,:) :: A
      integer(c_int),value :: lda
      integer(c_int64_t),value :: stride_A
      real(c_float),target,dimension(:) :: x
      integer(c_int),value :: incx
      integer(c_int64_t),value :: stride_x
      integer(c_int),value :: batch_count
      !
      rocblas_stbsv_strided_batched_full_rank = rocblas_stbsv_strided_batched_orig(handle,uplo,transA,diag,n,k,c_loc(A),lda,stride_A,c_loc(x),incx,stride_x,batch_count)
    end function

    function rocblas_stbsv_strided_batched_rank_0(handle,uplo,transA,diag,n,k,A,lda,stride_A,x,incx,stride_x,batch_count)
      use iso_c_binding
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocblas_stbsv_strided_batched_rank_0
      type(c_ptr),value :: handle
      integer(kind(rocblas_fill_upper)),value :: uplo
      integer(kind(rocblas_operation_none)),value :: transA
      integer(kind(rocblas_diagonal_non_unit)),value :: diag
      integer(c_int),value :: n
      integer(c_int),value :: k
      real(c_float),target :: A
      integer(c_int),value :: lda
      integer(c_int64_t),value :: stride_A
      real(c_float),target :: x
      integer(c_int),value :: incx
      integer(c_int64_t),value :: stride_x
      integer(c_int),value :: batch_count
      !
      rocblas_stbsv_strided_batched_rank_0 = rocblas_stbsv_strided_batched_orig(handle,uplo,transA,diag,n,k,c_loc(A),lda,stride_A,c_loc(x),incx,stride_x,batch_count)
    end function

    function rocblas_stbsv_strided_batched_rank_1(handle,uplo,transA,diag,n,k,A,lda,stride_A,x,incx,stride_x,batch_count)
      use iso_c_binding
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocblas_stbsv_strided_batched_rank_1
      type(c_ptr),value :: handle
      integer(kind(rocblas_fill_upper)),value :: uplo
      integer(kind(rocblas_operation_none)),value :: transA
      integer(kind(rocblas_diagonal_non_unit)),value :: diag
      integer(c_int),value :: n
      integer(c_int),value :: k
      real(c_float),target,dimension(:) :: A
      integer(c_int),value :: lda
      integer(c_int64_t),value :: stride_A
      real(c_float),target,dimension(:) :: x
      integer(c_int),value :: incx
      integer(c_int64_t),value :: stride_x
      integer(c_int),value :: batch_count
      !
      rocblas_stbsv_strided_batched_rank_1 = rocblas_stbsv_strided_batched_orig(handle,uplo,transA,diag,n,k,c_loc(A),lda,stride_A,c_loc(x),incx,stride_x,batch_count)
    end function

    function rocblas_dtbsv_strided_batched_full_rank(handle,uplo,transA,diag,n,k,A,lda,stride_A,x,incx,stride_x,batch_count)
      use iso_c_binding
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocblas_dtbsv_strided_batched_full_rank
      type(c_ptr),value :: handle
      integer(kind(rocblas_fill_upper)),value :: uplo
      integer(kind(rocblas_operation_none)),value :: transA
      integer(kind(rocblas_diagonal_non_unit)),value :: diag
      integer(c_int),value :: n
      integer(c_int),value :: k
      real(c_double),target,dimension(:,:) :: A
      integer(c_int),value :: lda
      integer(c_int64_t),value :: stride_A
      real(c_double),target,dimension(:) :: x
      integer(c_int),value :: incx
      integer(c_int64_t),value :: stride_x
      integer(c_int),value :: batch_count
      !
      rocblas_dtbsv_strided_batched_full_rank = rocblas_dtbsv_strided_batched_orig(handle,uplo,transA,diag,n,k,c_loc(A),lda,stride_A,c_loc(x),incx,stride_x,batch_count)
    end function

    function rocblas_dtbsv_strided_batched_rank_0(handle,uplo,transA,diag,n,k,A,lda,stride_A,x,incx,stride_x,batch_count)
      use iso_c_binding
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocblas_dtbsv_strided_batched_rank_0
      type(c_ptr),value :: handle
      integer(kind(rocblas_fill_upper)),value :: uplo
      integer(kind(rocblas_operation_none)),value :: transA
      integer(kind(rocblas_diagonal_non_unit)),value :: diag
      integer(c_int),value :: n
      integer(c_int),value :: k
      real(c_double),target :: A
      integer(c_int),value :: lda
      integer(c_int64_t),value :: stride_A
      real(c_double),target :: x
      integer(c_int),value :: incx
      integer(c_int64_t),value :: stride_x
      integer(c_int),value :: batch_count
      !
      rocblas_dtbsv_strided_batched_rank_0 = rocblas_dtbsv_strided_batched_orig(handle,uplo,transA,diag,n,k,c_loc(A),lda,stride_A,c_loc(x),incx,stride_x,batch_count)
    end function

    function rocblas_dtbsv_strided_batched_rank_1(handle,uplo,transA,diag,n,k,A,lda,stride_A,x,incx,stride_x,batch_count)
      use iso_c_binding
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocblas_dtbsv_strided_batched_rank_1
      type(c_ptr),value :: handle
      integer(kind(rocblas_fill_upper)),value :: uplo
      integer(kind(rocblas_operation_none)),value :: transA
      integer(kind(rocblas_diagonal_non_unit)),value :: diag
      integer(c_int),value :: n
      integer(c_int),value :: k
      real(c_double),target,dimension(:) :: A
      integer(c_int),value :: lda
      integer(c_int64_t),value :: stride_A
      real(c_double),target,dimension(:) :: x
      integer(c_int),value :: incx
      integer(c_int64_t),value :: stride_x
      integer(c_int),value :: batch_count
      !
      rocblas_dtbsv_strided_batched_rank_1 = rocblas_dtbsv_strided_batched_orig(handle,uplo,transA,diag,n,k,c_loc(A),lda,stride_A,c_loc(x),incx,stride_x,batch_count)
    end function

    function rocblas_ctbsv_strided_batched_full_rank(handle,uplo,transA,diag,n,k,A,lda,stride_A,x,incx,stride_x,batch_count)
      use iso_c_binding
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocblas_ctbsv_strided_batched_full_rank
      type(c_ptr),value :: handle
      integer(kind(rocblas_fill_upper)),value :: uplo
      integer(kind(rocblas_operation_none)),value :: transA
      integer(kind(rocblas_diagonal_non_unit)),value :: diag
      integer(c_int),value :: n
      integer(c_int),value :: k
      complex(c_float_complex),target,dimension(:,:) :: A
      integer(c_int),value :: lda
      integer(c_int64_t),value :: stride_A
      complex(c_float_complex),target,dimension(:) :: x
      integer(c_int),value :: incx
      integer(c_int64_t),value :: stride_x
      integer(c_int),value :: batch_count
      !
      rocblas_ctbsv_strided_batched_full_rank = rocblas_ctbsv_strided_batched_orig(handle,uplo,transA,diag,n,k,c_loc(A),lda,stride_A,c_loc(x),incx,stride_x,batch_count)
    end function

    function rocblas_ctbsv_strided_batched_rank_0(handle,uplo,transA,diag,n,k,A,lda,stride_A,x,incx,stride_x,batch_count)
      use iso_c_binding
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocblas_ctbsv_strided_batched_rank_0
      type(c_ptr),value :: handle
      integer(kind(rocblas_fill_upper)),value :: uplo
      integer(kind(rocblas_operation_none)),value :: transA
      integer(kind(rocblas_diagonal_non_unit)),value :: diag
      integer(c_int),value :: n
      integer(c_int),value :: k
      complex(c_float_complex),target :: A
      integer(c_int),value :: lda
      integer(c_int64_t),value :: stride_A
      complex(c_float_complex),target :: x
      integer(c_int),value :: incx
      integer(c_int64_t),value :: stride_x
      integer(c_int),value :: batch_count
      !
      rocblas_ctbsv_strided_batched_rank_0 = rocblas_ctbsv_strided_batched_orig(handle,uplo,transA,diag,n,k,c_loc(A),lda,stride_A,c_loc(x),incx,stride_x,batch_count)
    end function

    function rocblas_ctbsv_strided_batched_rank_1(handle,uplo,transA,diag,n,k,A,lda,stride_A,x,incx,stride_x,batch_count)
      use iso_c_binding
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocblas_ctbsv_strided_batched_rank_1
      type(c_ptr),value :: handle
      integer(kind(rocblas_fill_upper)),value :: uplo
      integer(kind(rocblas_operation_none)),value :: transA
      integer(kind(rocblas_diagonal_non_unit)),value :: diag
      integer(c_int),value :: n
      integer(c_int),value :: k
      complex(c_float_complex),target,dimension(:) :: A
      integer(c_int),value :: lda
      integer(c_int64_t),value :: stride_A
      complex(c_float_complex),target,dimension(:) :: x
      integer(c_int),value :: incx
      integer(c_int64_t),value :: stride_x
      integer(c_int),value :: batch_count
      !
      rocblas_ctbsv_strided_batched_rank_1 = rocblas_ctbsv_strided_batched_orig(handle,uplo,transA,diag,n,k,c_loc(A),lda,stride_A,c_loc(x),incx,stride_x,batch_count)
    end function

    function rocblas_ztbsv_strided_batched_full_rank(handle,uplo,transA,diag,n,k,A,lda,stride_A,x,incx,stride_x,batch_count)
      use iso_c_binding
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocblas_ztbsv_strided_batched_full_rank
      type(c_ptr),value :: handle
      integer(kind(rocblas_fill_upper)),value :: uplo
      integer(kind(rocblas_operation_none)),value :: transA
      integer(kind(rocblas_diagonal_non_unit)),value :: diag
      integer(c_int),value :: n
      integer(c_int),value :: k
      complex(c_double_complex),target,dimension(:,:) :: A
      integer(c_int),value :: lda
      integer(c_int64_t),value :: stride_A
      complex(c_double_complex),target,dimension(:) :: x
      integer(c_int),value :: incx
      integer(c_int64_t),value :: stride_x
      integer(c_int),value :: batch_count
      !
      rocblas_ztbsv_strided_batched_full_rank = rocblas_ztbsv_strided_batched_orig(handle,uplo,transA,diag,n,k,c_loc(A),lda,stride_A,c_loc(x),incx,stride_x,batch_count)
    end function

    function rocblas_ztbsv_strided_batched_rank_0(handle,uplo,transA,diag,n,k,A,lda,stride_A,x,incx,stride_x,batch_count)
      use iso_c_binding
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocblas_ztbsv_strided_batched_rank_0
      type(c_ptr),value :: handle
      integer(kind(rocblas_fill_upper)),value :: uplo
      integer(kind(rocblas_operation_none)),value :: transA
      integer(kind(rocblas_diagonal_non_unit)),value :: diag
      integer(c_int),value :: n
      integer(c_int),value :: k
      complex(c_double_complex),target :: A
      integer(c_int),value :: lda
      integer(c_int64_t),value :: stride_A
      complex(c_double_complex),target :: x
      integer(c_int),value :: incx
      integer(c_int64_t),value :: stride_x
      integer(c_int),value :: batch_count
      !
      rocblas_ztbsv_strided_batched_rank_0 = rocblas_ztbsv_strided_batched_orig(handle,uplo,transA,diag,n,k,c_loc(A),lda,stride_A,c_loc(x),incx,stride_x,batch_count)
    end function

    function rocblas_ztbsv_strided_batched_rank_1(handle,uplo,transA,diag,n,k,A,lda,stride_A,x,incx,stride_x,batch_count)
      use iso_c_binding
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocblas_ztbsv_strided_batched_rank_1
      type(c_ptr),value :: handle
      integer(kind(rocblas_fill_upper)),value :: uplo
      integer(kind(rocblas_operation_none)),value :: transA
      integer(kind(rocblas_diagonal_non_unit)),value :: diag
      integer(c_int),value :: n
      integer(c_int),value :: k
      complex(c_double_complex),target,dimension(:) :: A
      integer(c_int),value :: lda
      integer(c_int64_t),value :: stride_A
      complex(c_double_complex),target,dimension(:) :: x
      integer(c_int),value :: incx
      integer(c_int64_t),value :: stride_x
      integer(c_int),value :: batch_count
      !
      rocblas_ztbsv_strided_batched_rank_1 = rocblas_ztbsv_strided_batched_orig(handle,uplo,transA,diag,n,k,c_loc(A),lda,stride_A,c_loc(x),incx,stride_x,batch_count)
    end function

    function rocblas_strsv_full_rank(handle,uplo,transA,diag,m,A,lda,x,incx)
      use iso_c_binding
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocblas_strsv_full_rank
      type(c_ptr),value :: handle
      integer(kind(rocblas_fill_upper)),value :: uplo
      integer(kind(rocblas_operation_none)),value :: transA
      integer(kind(rocblas_diagonal_non_unit)),value :: diag
      integer(c_int),value :: m
      real(c_float),target,dimension(:,:) :: A
      integer(c_int),value :: lda
      real(c_float),target,dimension(:) :: x
      integer(c_int),value :: incx
      !
      rocblas_strsv_full_rank = rocblas_strsv_orig(handle,uplo,transA,diag,m,c_loc(A),lda,c_loc(x),incx)
    end function

    function rocblas_strsv_rank_0(handle,uplo,transA,diag,m,A,lda,x,incx)
      use iso_c_binding
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocblas_strsv_rank_0
      type(c_ptr),value :: handle
      integer(kind(rocblas_fill_upper)),value :: uplo
      integer(kind(rocblas_operation_none)),value :: transA
      integer(kind(rocblas_diagonal_non_unit)),value :: diag
      integer(c_int),value :: m
      real(c_float),target :: A
      integer(c_int),value :: lda
      real(c_float),target :: x
      integer(c_int),value :: incx
      !
      rocblas_strsv_rank_0 = rocblas_strsv_orig(handle,uplo,transA,diag,m,c_loc(A),lda,c_loc(x),incx)
    end function

    function rocblas_strsv_rank_1(handle,uplo,transA,diag,m,A,lda,x,incx)
      use iso_c_binding
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocblas_strsv_rank_1
      type(c_ptr),value :: handle
      integer(kind(rocblas_fill_upper)),value :: uplo
      integer(kind(rocblas_operation_none)),value :: transA
      integer(kind(rocblas_diagonal_non_unit)),value :: diag
      integer(c_int),value :: m
      real(c_float),target,dimension(:) :: A
      integer(c_int),value :: lda
      real(c_float),target,dimension(:) :: x
      integer(c_int),value :: incx
      !
      rocblas_strsv_rank_1 = rocblas_strsv_orig(handle,uplo,transA,diag,m,c_loc(A),lda,c_loc(x),incx)
    end function

    function rocblas_dtrsv_full_rank(handle,uplo,transA,diag,m,A,lda,x,incx)
      use iso_c_binding
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocblas_dtrsv_full_rank
      type(c_ptr),value :: handle
      integer(kind(rocblas_fill_upper)),value :: uplo
      integer(kind(rocblas_operation_none)),value :: transA
      integer(kind(rocblas_diagonal_non_unit)),value :: diag
      integer(c_int),value :: m
      real(c_double),target,dimension(:,:) :: A
      integer(c_int),value :: lda
      real(c_double),target,dimension(:) :: x
      integer(c_int),value :: incx
      !
      rocblas_dtrsv_full_rank = rocblas_dtrsv_orig(handle,uplo,transA,diag,m,c_loc(A),lda,c_loc(x),incx)
    end function

    function rocblas_dtrsv_rank_0(handle,uplo,transA,diag,m,A,lda,x,incx)
      use iso_c_binding
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocblas_dtrsv_rank_0
      type(c_ptr),value :: handle
      integer(kind(rocblas_fill_upper)),value :: uplo
      integer(kind(rocblas_operation_none)),value :: transA
      integer(kind(rocblas_diagonal_non_unit)),value :: diag
      integer(c_int),value :: m
      real(c_double),target :: A
      integer(c_int),value :: lda
      real(c_double),target :: x
      integer(c_int),value :: incx
      !
      rocblas_dtrsv_rank_0 = rocblas_dtrsv_orig(handle,uplo,transA,diag,m,c_loc(A),lda,c_loc(x),incx)
    end function

    function rocblas_dtrsv_rank_1(handle,uplo,transA,diag,m,A,lda,x,incx)
      use iso_c_binding
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocblas_dtrsv_rank_1
      type(c_ptr),value :: handle
      integer(kind(rocblas_fill_upper)),value :: uplo
      integer(kind(rocblas_operation_none)),value :: transA
      integer(kind(rocblas_diagonal_non_unit)),value :: diag
      integer(c_int),value :: m
      real(c_double),target,dimension(:) :: A
      integer(c_int),value :: lda
      real(c_double),target,dimension(:) :: x
      integer(c_int),value :: incx
      !
      rocblas_dtrsv_rank_1 = rocblas_dtrsv_orig(handle,uplo,transA,diag,m,c_loc(A),lda,c_loc(x),incx)
    end function

    function rocblas_ctrsv_full_rank(handle,uplo,transA,diag,m,A,lda,x,incx)
      use iso_c_binding
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocblas_ctrsv_full_rank
      type(c_ptr),value :: handle
      integer(kind(rocblas_fill_upper)),value :: uplo
      integer(kind(rocblas_operation_none)),value :: transA
      integer(kind(rocblas_diagonal_non_unit)),value :: diag
      integer(c_int),value :: m
      complex(c_float_complex),target,dimension(:,:) :: A
      integer(c_int),value :: lda
      complex(c_float_complex),target,dimension(:) :: x
      integer(c_int),value :: incx
      !
      rocblas_ctrsv_full_rank = rocblas_ctrsv_orig(handle,uplo,transA,diag,m,c_loc(A),lda,c_loc(x),incx)
    end function

    function rocblas_ctrsv_rank_0(handle,uplo,transA,diag,m,A,lda,x,incx)
      use iso_c_binding
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocblas_ctrsv_rank_0
      type(c_ptr),value :: handle
      integer(kind(rocblas_fill_upper)),value :: uplo
      integer(kind(rocblas_operation_none)),value :: transA
      integer(kind(rocblas_diagonal_non_unit)),value :: diag
      integer(c_int),value :: m
      complex(c_float_complex),target :: A
      integer(c_int),value :: lda
      complex(c_float_complex),target :: x
      integer(c_int),value :: incx
      !
      rocblas_ctrsv_rank_0 = rocblas_ctrsv_orig(handle,uplo,transA,diag,m,c_loc(A),lda,c_loc(x),incx)
    end function

    function rocblas_ctrsv_rank_1(handle,uplo,transA,diag,m,A,lda,x,incx)
      use iso_c_binding
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocblas_ctrsv_rank_1
      type(c_ptr),value :: handle
      integer(kind(rocblas_fill_upper)),value :: uplo
      integer(kind(rocblas_operation_none)),value :: transA
      integer(kind(rocblas_diagonal_non_unit)),value :: diag
      integer(c_int),value :: m
      complex(c_float_complex),target,dimension(:) :: A
      integer(c_int),value :: lda
      complex(c_float_complex),target,dimension(:) :: x
      integer(c_int),value :: incx
      !
      rocblas_ctrsv_rank_1 = rocblas_ctrsv_orig(handle,uplo,transA,diag,m,c_loc(A),lda,c_loc(x),incx)
    end function

    function rocblas_ztrsv_full_rank(handle,uplo,transA,diag,m,A,lda,x,incx)
      use iso_c_binding
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocblas_ztrsv_full_rank
      type(c_ptr),value :: handle
      integer(kind(rocblas_fill_upper)),value :: uplo
      integer(kind(rocblas_operation_none)),value :: transA
      integer(kind(rocblas_diagonal_non_unit)),value :: diag
      integer(c_int),value :: m
      complex(c_double_complex),target,dimension(:,:) :: A
      integer(c_int),value :: lda
      complex(c_double_complex),target,dimension(:) :: x
      integer(c_int),value :: incx
      !
      rocblas_ztrsv_full_rank = rocblas_ztrsv_orig(handle,uplo,transA,diag,m,c_loc(A),lda,c_loc(x),incx)
    end function

    function rocblas_ztrsv_rank_0(handle,uplo,transA,diag,m,A,lda,x,incx)
      use iso_c_binding
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocblas_ztrsv_rank_0
      type(c_ptr),value :: handle
      integer(kind(rocblas_fill_upper)),value :: uplo
      integer(kind(rocblas_operation_none)),value :: transA
      integer(kind(rocblas_diagonal_non_unit)),value :: diag
      integer(c_int),value :: m
      complex(c_double_complex),target :: A
      integer(c_int),value :: lda
      complex(c_double_complex),target :: x
      integer(c_int),value :: incx
      !
      rocblas_ztrsv_rank_0 = rocblas_ztrsv_orig(handle,uplo,transA,diag,m,c_loc(A),lda,c_loc(x),incx)
    end function

    function rocblas_ztrsv_rank_1(handle,uplo,transA,diag,m,A,lda,x,incx)
      use iso_c_binding
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocblas_ztrsv_rank_1
      type(c_ptr),value :: handle
      integer(kind(rocblas_fill_upper)),value :: uplo
      integer(kind(rocblas_operation_none)),value :: transA
      integer(kind(rocblas_diagonal_non_unit)),value :: diag
      integer(c_int),value :: m
      complex(c_double_complex),target,dimension(:) :: A
      integer(c_int),value :: lda
      complex(c_double_complex),target,dimension(:) :: x
      integer(c_int),value :: incx
      !
      rocblas_ztrsv_rank_1 = rocblas_ztrsv_orig(handle,uplo,transA,diag,m,c_loc(A),lda,c_loc(x),incx)
    end function

    function rocblas_strsv_batched_full_rank(handle,uplo,transA,diag,m,A,lda,x,incx,batch_count)
      use iso_c_binding
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocblas_strsv_batched_full_rank
      type(c_ptr),value :: handle
      integer(kind(rocblas_fill_upper)),value :: uplo
      integer(kind(rocblas_operation_none)),value :: transA
      integer(kind(rocblas_diagonal_non_unit)),value :: diag
      integer(c_int),value :: m
      real(c_float),target,dimension(:,:,:) :: A
      integer(c_int),value :: lda
      real(c_float),target,dimension(:,:) :: x
      integer(c_int),value :: incx
      integer(c_int),value :: batch_count
      !
      rocblas_strsv_batched_full_rank = rocblas_strsv_batched_orig(handle,uplo,transA,diag,m,c_loc(A),lda,c_loc(x),incx,batch_count)
    end function

    function rocblas_strsv_batched_rank_0(handle,uplo,transA,diag,m,A,lda,x,incx,batch_count)
      use iso_c_binding
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocblas_strsv_batched_rank_0
      type(c_ptr),value :: handle
      integer(kind(rocblas_fill_upper)),value :: uplo
      integer(kind(rocblas_operation_none)),value :: transA
      integer(kind(rocblas_diagonal_non_unit)),value :: diag
      integer(c_int),value :: m
      real(c_float),target :: A
      integer(c_int),value :: lda
      real(c_float),target :: x
      integer(c_int),value :: incx
      integer(c_int),value :: batch_count
      !
      rocblas_strsv_batched_rank_0 = rocblas_strsv_batched_orig(handle,uplo,transA,diag,m,c_loc(A),lda,c_loc(x),incx,batch_count)
    end function

    function rocblas_strsv_batched_rank_1(handle,uplo,transA,diag,m,A,lda,x,incx,batch_count)
      use iso_c_binding
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocblas_strsv_batched_rank_1
      type(c_ptr),value :: handle
      integer(kind(rocblas_fill_upper)),value :: uplo
      integer(kind(rocblas_operation_none)),value :: transA
      integer(kind(rocblas_diagonal_non_unit)),value :: diag
      integer(c_int),value :: m
      real(c_float),target,dimension(:) :: A
      integer(c_int),value :: lda
      real(c_float),target,dimension(:) :: x
      integer(c_int),value :: incx
      integer(c_int),value :: batch_count
      !
      rocblas_strsv_batched_rank_1 = rocblas_strsv_batched_orig(handle,uplo,transA,diag,m,c_loc(A),lda,c_loc(x),incx,batch_count)
    end function

    function rocblas_dtrsv_batched_full_rank(handle,uplo,transA,diag,m,A,lda,x,incx,batch_count)
      use iso_c_binding
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocblas_dtrsv_batched_full_rank
      type(c_ptr),value :: handle
      integer(kind(rocblas_fill_upper)),value :: uplo
      integer(kind(rocblas_operation_none)),value :: transA
      integer(kind(rocblas_diagonal_non_unit)),value :: diag
      integer(c_int),value :: m
      real(c_double),target,dimension(:,:,:) :: A
      integer(c_int),value :: lda
      real(c_double),target,dimension(:,:) :: x
      integer(c_int),value :: incx
      integer(c_int),value :: batch_count
      !
      rocblas_dtrsv_batched_full_rank = rocblas_dtrsv_batched_orig(handle,uplo,transA,diag,m,c_loc(A),lda,c_loc(x),incx,batch_count)
    end function

    function rocblas_dtrsv_batched_rank_0(handle,uplo,transA,diag,m,A,lda,x,incx,batch_count)
      use iso_c_binding
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocblas_dtrsv_batched_rank_0
      type(c_ptr),value :: handle
      integer(kind(rocblas_fill_upper)),value :: uplo
      integer(kind(rocblas_operation_none)),value :: transA
      integer(kind(rocblas_diagonal_non_unit)),value :: diag
      integer(c_int),value :: m
      real(c_double),target :: A
      integer(c_int),value :: lda
      real(c_double),target :: x
      integer(c_int),value :: incx
      integer(c_int),value :: batch_count
      !
      rocblas_dtrsv_batched_rank_0 = rocblas_dtrsv_batched_orig(handle,uplo,transA,diag,m,c_loc(A),lda,c_loc(x),incx,batch_count)
    end function

    function rocblas_dtrsv_batched_rank_1(handle,uplo,transA,diag,m,A,lda,x,incx,batch_count)
      use iso_c_binding
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocblas_dtrsv_batched_rank_1
      type(c_ptr),value :: handle
      integer(kind(rocblas_fill_upper)),value :: uplo
      integer(kind(rocblas_operation_none)),value :: transA
      integer(kind(rocblas_diagonal_non_unit)),value :: diag
      integer(c_int),value :: m
      real(c_double),target,dimension(:) :: A
      integer(c_int),value :: lda
      real(c_double),target,dimension(:) :: x
      integer(c_int),value :: incx
      integer(c_int),value :: batch_count
      !
      rocblas_dtrsv_batched_rank_1 = rocblas_dtrsv_batched_orig(handle,uplo,transA,diag,m,c_loc(A),lda,c_loc(x),incx,batch_count)
    end function

    function rocblas_ctrsv_batched_full_rank(handle,uplo,transA,diag,m,A,lda,x,incx,batch_count)
      use iso_c_binding
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocblas_ctrsv_batched_full_rank
      type(c_ptr),value :: handle
      integer(kind(rocblas_fill_upper)),value :: uplo
      integer(kind(rocblas_operation_none)),value :: transA
      integer(kind(rocblas_diagonal_non_unit)),value :: diag
      integer(c_int),value :: m
      complex(c_float_complex),target,dimension(:,:,:) :: A
      integer(c_int),value :: lda
      complex(c_float_complex),target,dimension(:,:) :: x
      integer(c_int),value :: incx
      integer(c_int),value :: batch_count
      !
      rocblas_ctrsv_batched_full_rank = rocblas_ctrsv_batched_orig(handle,uplo,transA,diag,m,c_loc(A),lda,c_loc(x),incx,batch_count)
    end function

    function rocblas_ctrsv_batched_rank_0(handle,uplo,transA,diag,m,A,lda,x,incx,batch_count)
      use iso_c_binding
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocblas_ctrsv_batched_rank_0
      type(c_ptr),value :: handle
      integer(kind(rocblas_fill_upper)),value :: uplo
      integer(kind(rocblas_operation_none)),value :: transA
      integer(kind(rocblas_diagonal_non_unit)),value :: diag
      integer(c_int),value :: m
      complex(c_float_complex),target :: A
      integer(c_int),value :: lda
      complex(c_float_complex),target :: x
      integer(c_int),value :: incx
      integer(c_int),value :: batch_count
      !
      rocblas_ctrsv_batched_rank_0 = rocblas_ctrsv_batched_orig(handle,uplo,transA,diag,m,c_loc(A),lda,c_loc(x),incx,batch_count)
    end function

    function rocblas_ctrsv_batched_rank_1(handle,uplo,transA,diag,m,A,lda,x,incx,batch_count)
      use iso_c_binding
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocblas_ctrsv_batched_rank_1
      type(c_ptr),value :: handle
      integer(kind(rocblas_fill_upper)),value :: uplo
      integer(kind(rocblas_operation_none)),value :: transA
      integer(kind(rocblas_diagonal_non_unit)),value :: diag
      integer(c_int),value :: m
      complex(c_float_complex),target,dimension(:) :: A
      integer(c_int),value :: lda
      complex(c_float_complex),target,dimension(:) :: x
      integer(c_int),value :: incx
      integer(c_int),value :: batch_count
      !
      rocblas_ctrsv_batched_rank_1 = rocblas_ctrsv_batched_orig(handle,uplo,transA,diag,m,c_loc(A),lda,c_loc(x),incx,batch_count)
    end function

    function rocblas_ztrsv_batched_full_rank(handle,uplo,transA,diag,m,A,lda,x,incx,batch_count)
      use iso_c_binding
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocblas_ztrsv_batched_full_rank
      type(c_ptr),value :: handle
      integer(kind(rocblas_fill_upper)),value :: uplo
      integer(kind(rocblas_operation_none)),value :: transA
      integer(kind(rocblas_diagonal_non_unit)),value :: diag
      integer(c_int),value :: m
      complex(c_double_complex),target,dimension(:,:,:) :: A
      integer(c_int),value :: lda
      complex(c_double_complex),target,dimension(:,:) :: x
      integer(c_int),value :: incx
      integer(c_int),value :: batch_count
      !
      rocblas_ztrsv_batched_full_rank = rocblas_ztrsv_batched_orig(handle,uplo,transA,diag,m,c_loc(A),lda,c_loc(x),incx,batch_count)
    end function

    function rocblas_ztrsv_batched_rank_0(handle,uplo,transA,diag,m,A,lda,x,incx,batch_count)
      use iso_c_binding
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocblas_ztrsv_batched_rank_0
      type(c_ptr),value :: handle
      integer(kind(rocblas_fill_upper)),value :: uplo
      integer(kind(rocblas_operation_none)),value :: transA
      integer(kind(rocblas_diagonal_non_unit)),value :: diag
      integer(c_int),value :: m
      complex(c_double_complex),target :: A
      integer(c_int),value :: lda
      complex(c_double_complex),target :: x
      integer(c_int),value :: incx
      integer(c_int),value :: batch_count
      !
      rocblas_ztrsv_batched_rank_0 = rocblas_ztrsv_batched_orig(handle,uplo,transA,diag,m,c_loc(A),lda,c_loc(x),incx,batch_count)
    end function

    function rocblas_ztrsv_batched_rank_1(handle,uplo,transA,diag,m,A,lda,x,incx,batch_count)
      use iso_c_binding
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocblas_ztrsv_batched_rank_1
      type(c_ptr),value :: handle
      integer(kind(rocblas_fill_upper)),value :: uplo
      integer(kind(rocblas_operation_none)),value :: transA
      integer(kind(rocblas_diagonal_non_unit)),value :: diag
      integer(c_int),value :: m
      complex(c_double_complex),target,dimension(:) :: A
      integer(c_int),value :: lda
      complex(c_double_complex),target,dimension(:) :: x
      integer(c_int),value :: incx
      integer(c_int),value :: batch_count
      !
      rocblas_ztrsv_batched_rank_1 = rocblas_ztrsv_batched_orig(handle,uplo,transA,diag,m,c_loc(A),lda,c_loc(x),incx,batch_count)
    end function

    function rocblas_strsv_strided_batched_full_rank(handle,uplo,transA,diag,m,A,lda,stride_A,x,incx,stride_x,batch_count)
      use iso_c_binding
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocblas_strsv_strided_batched_full_rank
      type(c_ptr),value :: handle
      integer(kind(rocblas_fill_upper)),value :: uplo
      integer(kind(rocblas_operation_none)),value :: transA
      integer(kind(rocblas_diagonal_non_unit)),value :: diag
      integer(c_int),value :: m
      real(c_float),target,dimension(:,:) :: A
      integer(c_int),value :: lda
      integer(c_int64_t),value :: stride_A
      real(c_float),target,dimension(:) :: x
      integer(c_int),value :: incx
      integer(c_int64_t),value :: stride_x
      integer(c_int),value :: batch_count
      !
      rocblas_strsv_strided_batched_full_rank = rocblas_strsv_strided_batched_orig(handle,uplo,transA,diag,m,c_loc(A),lda,stride_A,c_loc(x),incx,stride_x,batch_count)
    end function

    function rocblas_strsv_strided_batched_rank_0(handle,uplo,transA,diag,m,A,lda,stride_A,x,incx,stride_x,batch_count)
      use iso_c_binding
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocblas_strsv_strided_batched_rank_0
      type(c_ptr),value :: handle
      integer(kind(rocblas_fill_upper)),value :: uplo
      integer(kind(rocblas_operation_none)),value :: transA
      integer(kind(rocblas_diagonal_non_unit)),value :: diag
      integer(c_int),value :: m
      real(c_float),target :: A
      integer(c_int),value :: lda
      integer(c_int64_t),value :: stride_A
      real(c_float),target :: x
      integer(c_int),value :: incx
      integer(c_int64_t),value :: stride_x
      integer(c_int),value :: batch_count
      !
      rocblas_strsv_strided_batched_rank_0 = rocblas_strsv_strided_batched_orig(handle,uplo,transA,diag,m,c_loc(A),lda,stride_A,c_loc(x),incx,stride_x,batch_count)
    end function

    function rocblas_strsv_strided_batched_rank_1(handle,uplo,transA,diag,m,A,lda,stride_A,x,incx,stride_x,batch_count)
      use iso_c_binding
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocblas_strsv_strided_batched_rank_1
      type(c_ptr),value :: handle
      integer(kind(rocblas_fill_upper)),value :: uplo
      integer(kind(rocblas_operation_none)),value :: transA
      integer(kind(rocblas_diagonal_non_unit)),value :: diag
      integer(c_int),value :: m
      real(c_float),target,dimension(:) :: A
      integer(c_int),value :: lda
      integer(c_int64_t),value :: stride_A
      real(c_float),target,dimension(:) :: x
      integer(c_int),value :: incx
      integer(c_int64_t),value :: stride_x
      integer(c_int),value :: batch_count
      !
      rocblas_strsv_strided_batched_rank_1 = rocblas_strsv_strided_batched_orig(handle,uplo,transA,diag,m,c_loc(A),lda,stride_A,c_loc(x),incx,stride_x,batch_count)
    end function

    function rocblas_dtrsv_strided_batched_full_rank(handle,uplo,transA,diag,m,A,lda,stride_A,x,incx,stride_x,batch_count)
      use iso_c_binding
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocblas_dtrsv_strided_batched_full_rank
      type(c_ptr),value :: handle
      integer(kind(rocblas_fill_upper)),value :: uplo
      integer(kind(rocblas_operation_none)),value :: transA
      integer(kind(rocblas_diagonal_non_unit)),value :: diag
      integer(c_int),value :: m
      real(c_double),target,dimension(:,:) :: A
      integer(c_int),value :: lda
      integer(c_int64_t),value :: stride_A
      real(c_double),target,dimension(:) :: x
      integer(c_int),value :: incx
      integer(c_int64_t),value :: stride_x
      integer(c_int),value :: batch_count
      !
      rocblas_dtrsv_strided_batched_full_rank = rocblas_dtrsv_strided_batched_orig(handle,uplo,transA,diag,m,c_loc(A),lda,stride_A,c_loc(x),incx,stride_x,batch_count)
    end function

    function rocblas_dtrsv_strided_batched_rank_0(handle,uplo,transA,diag,m,A,lda,stride_A,x,incx,stride_x,batch_count)
      use iso_c_binding
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocblas_dtrsv_strided_batched_rank_0
      type(c_ptr),value :: handle
      integer(kind(rocblas_fill_upper)),value :: uplo
      integer(kind(rocblas_operation_none)),value :: transA
      integer(kind(rocblas_diagonal_non_unit)),value :: diag
      integer(c_int),value :: m
      real(c_double),target :: A
      integer(c_int),value :: lda
      integer(c_int64_t),value :: stride_A
      real(c_double),target :: x
      integer(c_int),value :: incx
      integer(c_int64_t),value :: stride_x
      integer(c_int),value :: batch_count
      !
      rocblas_dtrsv_strided_batched_rank_0 = rocblas_dtrsv_strided_batched_orig(handle,uplo,transA,diag,m,c_loc(A),lda,stride_A,c_loc(x),incx,stride_x,batch_count)
    end function

    function rocblas_dtrsv_strided_batched_rank_1(handle,uplo,transA,diag,m,A,lda,stride_A,x,incx,stride_x,batch_count)
      use iso_c_binding
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocblas_dtrsv_strided_batched_rank_1
      type(c_ptr),value :: handle
      integer(kind(rocblas_fill_upper)),value :: uplo
      integer(kind(rocblas_operation_none)),value :: transA
      integer(kind(rocblas_diagonal_non_unit)),value :: diag
      integer(c_int),value :: m
      real(c_double),target,dimension(:) :: A
      integer(c_int),value :: lda
      integer(c_int64_t),value :: stride_A
      real(c_double),target,dimension(:) :: x
      integer(c_int),value :: incx
      integer(c_int64_t),value :: stride_x
      integer(c_int),value :: batch_count
      !
      rocblas_dtrsv_strided_batched_rank_1 = rocblas_dtrsv_strided_batched_orig(handle,uplo,transA,diag,m,c_loc(A),lda,stride_A,c_loc(x),incx,stride_x,batch_count)
    end function

    function rocblas_ctrsv_strided_batched_full_rank(handle,uplo,transA,diag,m,A,lda,stride_A,x,incx,stride_x,batch_count)
      use iso_c_binding
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocblas_ctrsv_strided_batched_full_rank
      type(c_ptr),value :: handle
      integer(kind(rocblas_fill_upper)),value :: uplo
      integer(kind(rocblas_operation_none)),value :: transA
      integer(kind(rocblas_diagonal_non_unit)),value :: diag
      integer(c_int),value :: m
      complex(c_float_complex),target,dimension(:,:) :: A
      integer(c_int),value :: lda
      integer(c_int64_t),value :: stride_A
      complex(c_float_complex),target,dimension(:) :: x
      integer(c_int),value :: incx
      integer(c_int64_t),value :: stride_x
      integer(c_int),value :: batch_count
      !
      rocblas_ctrsv_strided_batched_full_rank = rocblas_ctrsv_strided_batched_orig(handle,uplo,transA,diag,m,c_loc(A),lda,stride_A,c_loc(x),incx,stride_x,batch_count)
    end function

    function rocblas_ctrsv_strided_batched_rank_0(handle,uplo,transA,diag,m,A,lda,stride_A,x,incx,stride_x,batch_count)
      use iso_c_binding
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocblas_ctrsv_strided_batched_rank_0
      type(c_ptr),value :: handle
      integer(kind(rocblas_fill_upper)),value :: uplo
      integer(kind(rocblas_operation_none)),value :: transA
      integer(kind(rocblas_diagonal_non_unit)),value :: diag
      integer(c_int),value :: m
      complex(c_float_complex),target :: A
      integer(c_int),value :: lda
      integer(c_int64_t),value :: stride_A
      complex(c_float_complex),target :: x
      integer(c_int),value :: incx
      integer(c_int64_t),value :: stride_x
      integer(c_int),value :: batch_count
      !
      rocblas_ctrsv_strided_batched_rank_0 = rocblas_ctrsv_strided_batched_orig(handle,uplo,transA,diag,m,c_loc(A),lda,stride_A,c_loc(x),incx,stride_x,batch_count)
    end function

    function rocblas_ctrsv_strided_batched_rank_1(handle,uplo,transA,diag,m,A,lda,stride_A,x,incx,stride_x,batch_count)
      use iso_c_binding
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocblas_ctrsv_strided_batched_rank_1
      type(c_ptr),value :: handle
      integer(kind(rocblas_fill_upper)),value :: uplo
      integer(kind(rocblas_operation_none)),value :: transA
      integer(kind(rocblas_diagonal_non_unit)),value :: diag
      integer(c_int),value :: m
      complex(c_float_complex),target,dimension(:) :: A
      integer(c_int),value :: lda
      integer(c_int64_t),value :: stride_A
      complex(c_float_complex),target,dimension(:) :: x
      integer(c_int),value :: incx
      integer(c_int64_t),value :: stride_x
      integer(c_int),value :: batch_count
      !
      rocblas_ctrsv_strided_batched_rank_1 = rocblas_ctrsv_strided_batched_orig(handle,uplo,transA,diag,m,c_loc(A),lda,stride_A,c_loc(x),incx,stride_x,batch_count)
    end function

    function rocblas_ztrsv_strided_batched_full_rank(handle,uplo,transA,diag,m,A,lda,stride_A,x,incx,stride_x,batch_count)
      use iso_c_binding
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocblas_ztrsv_strided_batched_full_rank
      type(c_ptr),value :: handle
      integer(kind(rocblas_fill_upper)),value :: uplo
      integer(kind(rocblas_operation_none)),value :: transA
      integer(kind(rocblas_diagonal_non_unit)),value :: diag
      integer(c_int),value :: m
      complex(c_double_complex),target,dimension(:,:) :: A
      integer(c_int),value :: lda
      integer(c_int64_t),value :: stride_A
      complex(c_double_complex),target,dimension(:) :: x
      integer(c_int),value :: incx
      integer(c_int64_t),value :: stride_x
      integer(c_int),value :: batch_count
      !
      rocblas_ztrsv_strided_batched_full_rank = rocblas_ztrsv_strided_batched_orig(handle,uplo,transA,diag,m,c_loc(A),lda,stride_A,c_loc(x),incx,stride_x,batch_count)
    end function

    function rocblas_ztrsv_strided_batched_rank_0(handle,uplo,transA,diag,m,A,lda,stride_A,x,incx,stride_x,batch_count)
      use iso_c_binding
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocblas_ztrsv_strided_batched_rank_0
      type(c_ptr),value :: handle
      integer(kind(rocblas_fill_upper)),value :: uplo
      integer(kind(rocblas_operation_none)),value :: transA
      integer(kind(rocblas_diagonal_non_unit)),value :: diag
      integer(c_int),value :: m
      complex(c_double_complex),target :: A
      integer(c_int),value :: lda
      integer(c_int64_t),value :: stride_A
      complex(c_double_complex),target :: x
      integer(c_int),value :: incx
      integer(c_int64_t),value :: stride_x
      integer(c_int),value :: batch_count
      !
      rocblas_ztrsv_strided_batched_rank_0 = rocblas_ztrsv_strided_batched_orig(handle,uplo,transA,diag,m,c_loc(A),lda,stride_A,c_loc(x),incx,stride_x,batch_count)
    end function

    function rocblas_ztrsv_strided_batched_rank_1(handle,uplo,transA,diag,m,A,lda,stride_A,x,incx,stride_x,batch_count)
      use iso_c_binding
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocblas_ztrsv_strided_batched_rank_1
      type(c_ptr),value :: handle
      integer(kind(rocblas_fill_upper)),value :: uplo
      integer(kind(rocblas_operation_none)),value :: transA
      integer(kind(rocblas_diagonal_non_unit)),value :: diag
      integer(c_int),value :: m
      complex(c_double_complex),target,dimension(:) :: A
      integer(c_int),value :: lda
      integer(c_int64_t),value :: stride_A
      complex(c_double_complex),target,dimension(:) :: x
      integer(c_int),value :: incx
      integer(c_int64_t),value :: stride_x
      integer(c_int),value :: batch_count
      !
      rocblas_ztrsv_strided_batched_rank_1 = rocblas_ztrsv_strided_batched_orig(handle,uplo,transA,diag,m,c_loc(A),lda,stride_A,c_loc(x),incx,stride_x,batch_count)
    end function

    function rocblas_stpsv_rank_0(handle,uplo,transA,diag,n,AP,x,incx)
      use iso_c_binding
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocblas_stpsv_rank_0
      type(c_ptr),value :: handle
      integer(kind(rocblas_fill_upper)),value :: uplo
      integer(kind(rocblas_operation_none)),value :: transA
      integer(kind(rocblas_diagonal_non_unit)),value :: diag
      integer(c_int),value :: n
      type(c_ptr),value :: AP
      real(c_float),target :: x
      integer(c_int),value :: incx
      !
      rocblas_stpsv_rank_0 = rocblas_stpsv_orig(handle,uplo,transA,diag,n,AP,c_loc(x),incx)
    end function

    function rocblas_stpsv_rank_1(handle,uplo,transA,diag,n,AP,x,incx)
      use iso_c_binding
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocblas_stpsv_rank_1
      type(c_ptr),value :: handle
      integer(kind(rocblas_fill_upper)),value :: uplo
      integer(kind(rocblas_operation_none)),value :: transA
      integer(kind(rocblas_diagonal_non_unit)),value :: diag
      integer(c_int),value :: n
      type(c_ptr),value :: AP
      real(c_float),target,dimension(:) :: x
      integer(c_int),value :: incx
      !
      rocblas_stpsv_rank_1 = rocblas_stpsv_orig(handle,uplo,transA,diag,n,AP,c_loc(x),incx)
    end function

    function rocblas_dtpsv_rank_0(handle,uplo,transA,diag,n,AP,x,incx)
      use iso_c_binding
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocblas_dtpsv_rank_0
      type(c_ptr),value :: handle
      integer(kind(rocblas_fill_upper)),value :: uplo
      integer(kind(rocblas_operation_none)),value :: transA
      integer(kind(rocblas_diagonal_non_unit)),value :: diag
      integer(c_int),value :: n
      type(c_ptr),value :: AP
      real(c_double),target :: x
      integer(c_int),value :: incx
      !
      rocblas_dtpsv_rank_0 = rocblas_dtpsv_orig(handle,uplo,transA,diag,n,AP,c_loc(x),incx)
    end function

    function rocblas_dtpsv_rank_1(handle,uplo,transA,diag,n,AP,x,incx)
      use iso_c_binding
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocblas_dtpsv_rank_1
      type(c_ptr),value :: handle
      integer(kind(rocblas_fill_upper)),value :: uplo
      integer(kind(rocblas_operation_none)),value :: transA
      integer(kind(rocblas_diagonal_non_unit)),value :: diag
      integer(c_int),value :: n
      type(c_ptr),value :: AP
      real(c_double),target,dimension(:) :: x
      integer(c_int),value :: incx
      !
      rocblas_dtpsv_rank_1 = rocblas_dtpsv_orig(handle,uplo,transA,diag,n,AP,c_loc(x),incx)
    end function

    function rocblas_ctpsv_rank_0(handle,uplo,transA,diag,n,AP,x,incx)
      use iso_c_binding
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocblas_ctpsv_rank_0
      type(c_ptr),value :: handle
      integer(kind(rocblas_fill_upper)),value :: uplo
      integer(kind(rocblas_operation_none)),value :: transA
      integer(kind(rocblas_diagonal_non_unit)),value :: diag
      integer(c_int),value :: n
      type(c_ptr),value :: AP
      complex(c_float_complex),target :: x
      integer(c_int),value :: incx
      !
      rocblas_ctpsv_rank_0 = rocblas_ctpsv_orig(handle,uplo,transA,diag,n,AP,c_loc(x),incx)
    end function

    function rocblas_ctpsv_rank_1(handle,uplo,transA,diag,n,AP,x,incx)
      use iso_c_binding
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocblas_ctpsv_rank_1
      type(c_ptr),value :: handle
      integer(kind(rocblas_fill_upper)),value :: uplo
      integer(kind(rocblas_operation_none)),value :: transA
      integer(kind(rocblas_diagonal_non_unit)),value :: diag
      integer(c_int),value :: n
      type(c_ptr),value :: AP
      complex(c_float_complex),target,dimension(:) :: x
      integer(c_int),value :: incx
      !
      rocblas_ctpsv_rank_1 = rocblas_ctpsv_orig(handle,uplo,transA,diag,n,AP,c_loc(x),incx)
    end function

    function rocblas_ztpsv_rank_0(handle,uplo,transA,diag,n,AP,x,incx)
      use iso_c_binding
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocblas_ztpsv_rank_0
      type(c_ptr),value :: handle
      integer(kind(rocblas_fill_upper)),value :: uplo
      integer(kind(rocblas_operation_none)),value :: transA
      integer(kind(rocblas_diagonal_non_unit)),value :: diag
      integer(c_int),value :: n
      type(c_ptr),value :: AP
      complex(c_double_complex),target :: x
      integer(c_int),value :: incx
      !
      rocblas_ztpsv_rank_0 = rocblas_ztpsv_orig(handle,uplo,transA,diag,n,AP,c_loc(x),incx)
    end function

    function rocblas_ztpsv_rank_1(handle,uplo,transA,diag,n,AP,x,incx)
      use iso_c_binding
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocblas_ztpsv_rank_1
      type(c_ptr),value :: handle
      integer(kind(rocblas_fill_upper)),value :: uplo
      integer(kind(rocblas_operation_none)),value :: transA
      integer(kind(rocblas_diagonal_non_unit)),value :: diag
      integer(c_int),value :: n
      type(c_ptr),value :: AP
      complex(c_double_complex),target,dimension(:) :: x
      integer(c_int),value :: incx
      !
      rocblas_ztpsv_rank_1 = rocblas_ztpsv_orig(handle,uplo,transA,diag,n,AP,c_loc(x),incx)
    end function

    function rocblas_stpsv_batched_full_rank(handle,uplo,transA,diag,n,AP,x,incx,batch_count)
      use iso_c_binding
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocblas_stpsv_batched_full_rank
      type(c_ptr),value :: handle
      integer(kind(rocblas_fill_upper)),value :: uplo
      integer(kind(rocblas_operation_none)),value :: transA
      integer(kind(rocblas_diagonal_non_unit)),value :: diag
      integer(c_int),value :: n
      type(c_ptr) :: AP
      real(c_float),target,dimension(:,:) :: x
      integer(c_int),value :: incx
      integer(c_int),value :: batch_count
      !
      rocblas_stpsv_batched_full_rank = rocblas_stpsv_batched_orig(handle,uplo,transA,diag,n,AP,c_loc(x),incx,batch_count)
    end function

    function rocblas_stpsv_batched_rank_0(handle,uplo,transA,diag,n,AP,x,incx,batch_count)
      use iso_c_binding
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocblas_stpsv_batched_rank_0
      type(c_ptr),value :: handle
      integer(kind(rocblas_fill_upper)),value :: uplo
      integer(kind(rocblas_operation_none)),value :: transA
      integer(kind(rocblas_diagonal_non_unit)),value :: diag
      integer(c_int),value :: n
      type(c_ptr) :: AP
      real(c_float),target :: x
      integer(c_int),value :: incx
      integer(c_int),value :: batch_count
      !
      rocblas_stpsv_batched_rank_0 = rocblas_stpsv_batched_orig(handle,uplo,transA,diag,n,AP,c_loc(x),incx,batch_count)
    end function

    function rocblas_stpsv_batched_rank_1(handle,uplo,transA,diag,n,AP,x,incx,batch_count)
      use iso_c_binding
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocblas_stpsv_batched_rank_1
      type(c_ptr),value :: handle
      integer(kind(rocblas_fill_upper)),value :: uplo
      integer(kind(rocblas_operation_none)),value :: transA
      integer(kind(rocblas_diagonal_non_unit)),value :: diag
      integer(c_int),value :: n
      type(c_ptr) :: AP
      real(c_float),target,dimension(:) :: x
      integer(c_int),value :: incx
      integer(c_int),value :: batch_count
      !
      rocblas_stpsv_batched_rank_1 = rocblas_stpsv_batched_orig(handle,uplo,transA,diag,n,AP,c_loc(x),incx,batch_count)
    end function

    function rocblas_dtpsv_batched_full_rank(handle,uplo,transA,diag,n,AP,x,incx,batch_count)
      use iso_c_binding
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocblas_dtpsv_batched_full_rank
      type(c_ptr),value :: handle
      integer(kind(rocblas_fill_upper)),value :: uplo
      integer(kind(rocblas_operation_none)),value :: transA
      integer(kind(rocblas_diagonal_non_unit)),value :: diag
      integer(c_int),value :: n
      type(c_ptr) :: AP
      real(c_double),target,dimension(:,:) :: x
      integer(c_int),value :: incx
      integer(c_int),value :: batch_count
      !
      rocblas_dtpsv_batched_full_rank = rocblas_dtpsv_batched_orig(handle,uplo,transA,diag,n,AP,c_loc(x),incx,batch_count)
    end function

    function rocblas_dtpsv_batched_rank_0(handle,uplo,transA,diag,n,AP,x,incx,batch_count)
      use iso_c_binding
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocblas_dtpsv_batched_rank_0
      type(c_ptr),value :: handle
      integer(kind(rocblas_fill_upper)),value :: uplo
      integer(kind(rocblas_operation_none)),value :: transA
      integer(kind(rocblas_diagonal_non_unit)),value :: diag
      integer(c_int),value :: n
      type(c_ptr) :: AP
      real(c_double),target :: x
      integer(c_int),value :: incx
      integer(c_int),value :: batch_count
      !
      rocblas_dtpsv_batched_rank_0 = rocblas_dtpsv_batched_orig(handle,uplo,transA,diag,n,AP,c_loc(x),incx,batch_count)
    end function

    function rocblas_dtpsv_batched_rank_1(handle,uplo,transA,diag,n,AP,x,incx,batch_count)
      use iso_c_binding
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocblas_dtpsv_batched_rank_1
      type(c_ptr),value :: handle
      integer(kind(rocblas_fill_upper)),value :: uplo
      integer(kind(rocblas_operation_none)),value :: transA
      integer(kind(rocblas_diagonal_non_unit)),value :: diag
      integer(c_int),value :: n
      type(c_ptr) :: AP
      real(c_double),target,dimension(:) :: x
      integer(c_int),value :: incx
      integer(c_int),value :: batch_count
      !
      rocblas_dtpsv_batched_rank_1 = rocblas_dtpsv_batched_orig(handle,uplo,transA,diag,n,AP,c_loc(x),incx,batch_count)
    end function

    function rocblas_ctpsv_batched_full_rank(handle,uplo,transA,diag,n,AP,x,incx,batch_count)
      use iso_c_binding
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocblas_ctpsv_batched_full_rank
      type(c_ptr),value :: handle
      integer(kind(rocblas_fill_upper)),value :: uplo
      integer(kind(rocblas_operation_none)),value :: transA
      integer(kind(rocblas_diagonal_non_unit)),value :: diag
      integer(c_int),value :: n
      type(c_ptr) :: AP
      complex(c_float_complex),target,dimension(:,:) :: x
      integer(c_int),value :: incx
      integer(c_int),value :: batch_count
      !
      rocblas_ctpsv_batched_full_rank = rocblas_ctpsv_batched_orig(handle,uplo,transA,diag,n,AP,c_loc(x),incx,batch_count)
    end function

    function rocblas_ctpsv_batched_rank_0(handle,uplo,transA,diag,n,AP,x,incx,batch_count)
      use iso_c_binding
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocblas_ctpsv_batched_rank_0
      type(c_ptr),value :: handle
      integer(kind(rocblas_fill_upper)),value :: uplo
      integer(kind(rocblas_operation_none)),value :: transA
      integer(kind(rocblas_diagonal_non_unit)),value :: diag
      integer(c_int),value :: n
      type(c_ptr) :: AP
      complex(c_float_complex),target :: x
      integer(c_int),value :: incx
      integer(c_int),value :: batch_count
      !
      rocblas_ctpsv_batched_rank_0 = rocblas_ctpsv_batched_orig(handle,uplo,transA,diag,n,AP,c_loc(x),incx,batch_count)
    end function

    function rocblas_ctpsv_batched_rank_1(handle,uplo,transA,diag,n,AP,x,incx,batch_count)
      use iso_c_binding
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocblas_ctpsv_batched_rank_1
      type(c_ptr),value :: handle
      integer(kind(rocblas_fill_upper)),value :: uplo
      integer(kind(rocblas_operation_none)),value :: transA
      integer(kind(rocblas_diagonal_non_unit)),value :: diag
      integer(c_int),value :: n
      type(c_ptr) :: AP
      complex(c_float_complex),target,dimension(:) :: x
      integer(c_int),value :: incx
      integer(c_int),value :: batch_count
      !
      rocblas_ctpsv_batched_rank_1 = rocblas_ctpsv_batched_orig(handle,uplo,transA,diag,n,AP,c_loc(x),incx,batch_count)
    end function

    function rocblas_ztpsv_batched_full_rank(handle,uplo,transA,diag,n,AP,x,incx,batch_count)
      use iso_c_binding
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocblas_ztpsv_batched_full_rank
      type(c_ptr),value :: handle
      integer(kind(rocblas_fill_upper)),value :: uplo
      integer(kind(rocblas_operation_none)),value :: transA
      integer(kind(rocblas_diagonal_non_unit)),value :: diag
      integer(c_int),value :: n
      type(c_ptr) :: AP
      complex(c_double_complex),target,dimension(:,:) :: x
      integer(c_int),value :: incx
      integer(c_int),value :: batch_count
      !
      rocblas_ztpsv_batched_full_rank = rocblas_ztpsv_batched_orig(handle,uplo,transA,diag,n,AP,c_loc(x),incx,batch_count)
    end function

    function rocblas_ztpsv_batched_rank_0(handle,uplo,transA,diag,n,AP,x,incx,batch_count)
      use iso_c_binding
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocblas_ztpsv_batched_rank_0
      type(c_ptr),value :: handle
      integer(kind(rocblas_fill_upper)),value :: uplo
      integer(kind(rocblas_operation_none)),value :: transA
      integer(kind(rocblas_diagonal_non_unit)),value :: diag
      integer(c_int),value :: n
      type(c_ptr) :: AP
      complex(c_double_complex),target :: x
      integer(c_int),value :: incx
      integer(c_int),value :: batch_count
      !
      rocblas_ztpsv_batched_rank_0 = rocblas_ztpsv_batched_orig(handle,uplo,transA,diag,n,AP,c_loc(x),incx,batch_count)
    end function

    function rocblas_ztpsv_batched_rank_1(handle,uplo,transA,diag,n,AP,x,incx,batch_count)
      use iso_c_binding
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocblas_ztpsv_batched_rank_1
      type(c_ptr),value :: handle
      integer(kind(rocblas_fill_upper)),value :: uplo
      integer(kind(rocblas_operation_none)),value :: transA
      integer(kind(rocblas_diagonal_non_unit)),value :: diag
      integer(c_int),value :: n
      type(c_ptr) :: AP
      complex(c_double_complex),target,dimension(:) :: x
      integer(c_int),value :: incx
      integer(c_int),value :: batch_count
      !
      rocblas_ztpsv_batched_rank_1 = rocblas_ztpsv_batched_orig(handle,uplo,transA,diag,n,AP,c_loc(x),incx,batch_count)
    end function

    function rocblas_stpsv_strided_batched_rank_0(handle,uplo,transA,diag,n,AP,stride_A,x,incx,stride_x,batch_count)
      use iso_c_binding
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocblas_stpsv_strided_batched_rank_0
      type(c_ptr),value :: handle
      integer(kind(rocblas_fill_upper)),value :: uplo
      integer(kind(rocblas_operation_none)),value :: transA
      integer(kind(rocblas_diagonal_non_unit)),value :: diag
      integer(c_int),value :: n
      type(c_ptr),value :: AP
      integer(c_int64_t),value :: stride_A
      real(c_float),target :: x
      integer(c_int),value :: incx
      integer(c_int64_t),value :: stride_x
      integer(c_int),value :: batch_count
      !
      rocblas_stpsv_strided_batched_rank_0 = rocblas_stpsv_strided_batched_orig(handle,uplo,transA,diag,n,AP,stride_A,c_loc(x),incx,stride_x,batch_count)
    end function

    function rocblas_stpsv_strided_batched_rank_1(handle,uplo,transA,diag,n,AP,stride_A,x,incx,stride_x,batch_count)
      use iso_c_binding
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocblas_stpsv_strided_batched_rank_1
      type(c_ptr),value :: handle
      integer(kind(rocblas_fill_upper)),value :: uplo
      integer(kind(rocblas_operation_none)),value :: transA
      integer(kind(rocblas_diagonal_non_unit)),value :: diag
      integer(c_int),value :: n
      type(c_ptr),value :: AP
      integer(c_int64_t),value :: stride_A
      real(c_float),target,dimension(:) :: x
      integer(c_int),value :: incx
      integer(c_int64_t),value :: stride_x
      integer(c_int),value :: batch_count
      !
      rocblas_stpsv_strided_batched_rank_1 = rocblas_stpsv_strided_batched_orig(handle,uplo,transA,diag,n,AP,stride_A,c_loc(x),incx,stride_x,batch_count)
    end function

    function rocblas_dtpsv_strided_batched_rank_0(handle,uplo,transA,diag,n,AP,stride_A,x,incx,stride_x,batch_count)
      use iso_c_binding
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocblas_dtpsv_strided_batched_rank_0
      type(c_ptr),value :: handle
      integer(kind(rocblas_fill_upper)),value :: uplo
      integer(kind(rocblas_operation_none)),value :: transA
      integer(kind(rocblas_diagonal_non_unit)),value :: diag
      integer(c_int),value :: n
      type(c_ptr),value :: AP
      integer(c_int64_t),value :: stride_A
      real(c_double),target :: x
      integer(c_int),value :: incx
      integer(c_int64_t),value :: stride_x
      integer(c_int),value :: batch_count
      !
      rocblas_dtpsv_strided_batched_rank_0 = rocblas_dtpsv_strided_batched_orig(handle,uplo,transA,diag,n,AP,stride_A,c_loc(x),incx,stride_x,batch_count)
    end function

    function rocblas_dtpsv_strided_batched_rank_1(handle,uplo,transA,diag,n,AP,stride_A,x,incx,stride_x,batch_count)
      use iso_c_binding
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocblas_dtpsv_strided_batched_rank_1
      type(c_ptr),value :: handle
      integer(kind(rocblas_fill_upper)),value :: uplo
      integer(kind(rocblas_operation_none)),value :: transA
      integer(kind(rocblas_diagonal_non_unit)),value :: diag
      integer(c_int),value :: n
      type(c_ptr),value :: AP
      integer(c_int64_t),value :: stride_A
      real(c_double),target,dimension(:) :: x
      integer(c_int),value :: incx
      integer(c_int64_t),value :: stride_x
      integer(c_int),value :: batch_count
      !
      rocblas_dtpsv_strided_batched_rank_1 = rocblas_dtpsv_strided_batched_orig(handle,uplo,transA,diag,n,AP,stride_A,c_loc(x),incx,stride_x,batch_count)
    end function

    function rocblas_ctpsv_strided_batched_rank_0(handle,uplo,transA,diag,n,AP,stride_A,x,incx,stride_x,batch_count)
      use iso_c_binding
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocblas_ctpsv_strided_batched_rank_0
      type(c_ptr),value :: handle
      integer(kind(rocblas_fill_upper)),value :: uplo
      integer(kind(rocblas_operation_none)),value :: transA
      integer(kind(rocblas_diagonal_non_unit)),value :: diag
      integer(c_int),value :: n
      type(c_ptr),value :: AP
      integer(c_int64_t),value :: stride_A
      complex(c_float_complex),target :: x
      integer(c_int),value :: incx
      integer(c_int64_t),value :: stride_x
      integer(c_int),value :: batch_count
      !
      rocblas_ctpsv_strided_batched_rank_0 = rocblas_ctpsv_strided_batched_orig(handle,uplo,transA,diag,n,AP,stride_A,c_loc(x),incx,stride_x,batch_count)
    end function

    function rocblas_ctpsv_strided_batched_rank_1(handle,uplo,transA,diag,n,AP,stride_A,x,incx,stride_x,batch_count)
      use iso_c_binding
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocblas_ctpsv_strided_batched_rank_1
      type(c_ptr),value :: handle
      integer(kind(rocblas_fill_upper)),value :: uplo
      integer(kind(rocblas_operation_none)),value :: transA
      integer(kind(rocblas_diagonal_non_unit)),value :: diag
      integer(c_int),value :: n
      type(c_ptr),value :: AP
      integer(c_int64_t),value :: stride_A
      complex(c_float_complex),target,dimension(:) :: x
      integer(c_int),value :: incx
      integer(c_int64_t),value :: stride_x
      integer(c_int),value :: batch_count
      !
      rocblas_ctpsv_strided_batched_rank_1 = rocblas_ctpsv_strided_batched_orig(handle,uplo,transA,diag,n,AP,stride_A,c_loc(x),incx,stride_x,batch_count)
    end function

    function rocblas_ztpsv_strided_batched_rank_0(handle,uplo,transA,diag,n,AP,stride_A,x,incx,stride_x,batch_count)
      use iso_c_binding
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocblas_ztpsv_strided_batched_rank_0
      type(c_ptr),value :: handle
      integer(kind(rocblas_fill_upper)),value :: uplo
      integer(kind(rocblas_operation_none)),value :: transA
      integer(kind(rocblas_diagonal_non_unit)),value :: diag
      integer(c_int),value :: n
      type(c_ptr),value :: AP
      integer(c_int64_t),value :: stride_A
      complex(c_double_complex),target :: x
      integer(c_int),value :: incx
      integer(c_int64_t),value :: stride_x
      integer(c_int),value :: batch_count
      !
      rocblas_ztpsv_strided_batched_rank_0 = rocblas_ztpsv_strided_batched_orig(handle,uplo,transA,diag,n,AP,stride_A,c_loc(x),incx,stride_x,batch_count)
    end function

    function rocblas_ztpsv_strided_batched_rank_1(handle,uplo,transA,diag,n,AP,stride_A,x,incx,stride_x,batch_count)
      use iso_c_binding
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocblas_ztpsv_strided_batched_rank_1
      type(c_ptr),value :: handle
      integer(kind(rocblas_fill_upper)),value :: uplo
      integer(kind(rocblas_operation_none)),value :: transA
      integer(kind(rocblas_diagonal_non_unit)),value :: diag
      integer(c_int),value :: n
      type(c_ptr),value :: AP
      integer(c_int64_t),value :: stride_A
      complex(c_double_complex),target,dimension(:) :: x
      integer(c_int),value :: incx
      integer(c_int64_t),value :: stride_x
      integer(c_int),value :: batch_count
      !
      rocblas_ztpsv_strided_batched_rank_1 = rocblas_ztpsv_strided_batched_orig(handle,uplo,transA,diag,n,AP,stride_A,c_loc(x),incx,stride_x,batch_count)
    end function

    function rocblas_ssymv_full_rank(handle,uplo,n,alpha,A,lda,x,incx,beta,y,incy)
      use iso_c_binding
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocblas_ssymv_full_rank
      type(c_ptr),value :: handle
      integer(kind(rocblas_fill_upper)),value :: uplo
      integer(c_int),value :: n
      real(c_float) :: alpha
      real(c_float),target,dimension(:,:) :: A
      integer(c_int),value :: lda
      real(c_float),target,dimension(:) :: x
      integer(c_int),value :: incx
      real(c_float) :: beta
      real(c_float),target,dimension(:) :: y
      integer(c_int),value :: incy
      !
      rocblas_ssymv_full_rank = rocblas_ssymv_orig(handle,uplo,n,alpha,c_loc(A),lda,c_loc(x),incx,beta,c_loc(y),incy)
    end function

    function rocblas_ssymv_rank_0(handle,uplo,n,alpha,A,lda,x,incx,beta,y,incy)
      use iso_c_binding
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocblas_ssymv_rank_0
      type(c_ptr),value :: handle
      integer(kind(rocblas_fill_upper)),value :: uplo
      integer(c_int),value :: n
      real(c_float) :: alpha
      real(c_float),target :: A
      integer(c_int),value :: lda
      real(c_float),target :: x
      integer(c_int),value :: incx
      real(c_float) :: beta
      real(c_float),target :: y
      integer(c_int),value :: incy
      !
      rocblas_ssymv_rank_0 = rocblas_ssymv_orig(handle,uplo,n,alpha,c_loc(A),lda,c_loc(x),incx,beta,c_loc(y),incy)
    end function

    function rocblas_ssymv_rank_1(handle,uplo,n,alpha,A,lda,x,incx,beta,y,incy)
      use iso_c_binding
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocblas_ssymv_rank_1
      type(c_ptr),value :: handle
      integer(kind(rocblas_fill_upper)),value :: uplo
      integer(c_int),value :: n
      real(c_float) :: alpha
      real(c_float),target,dimension(:) :: A
      integer(c_int),value :: lda
      real(c_float),target,dimension(:) :: x
      integer(c_int),value :: incx
      real(c_float) :: beta
      real(c_float),target,dimension(:) :: y
      integer(c_int),value :: incy
      !
      rocblas_ssymv_rank_1 = rocblas_ssymv_orig(handle,uplo,n,alpha,c_loc(A),lda,c_loc(x),incx,beta,c_loc(y),incy)
    end function

    function rocblas_dsymv_full_rank(handle,uplo,n,alpha,A,lda,x,incx,beta,y,incy)
      use iso_c_binding
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocblas_dsymv_full_rank
      type(c_ptr),value :: handle
      integer(kind(rocblas_fill_upper)),value :: uplo
      integer(c_int),value :: n
      real(c_double) :: alpha
      real(c_double),target,dimension(:,:) :: A
      integer(c_int),value :: lda
      real(c_double),target,dimension(:) :: x
      integer(c_int),value :: incx
      real(c_double) :: beta
      real(c_double),target,dimension(:) :: y
      integer(c_int),value :: incy
      !
      rocblas_dsymv_full_rank = rocblas_dsymv_orig(handle,uplo,n,alpha,c_loc(A),lda,c_loc(x),incx,beta,c_loc(y),incy)
    end function

    function rocblas_dsymv_rank_0(handle,uplo,n,alpha,A,lda,x,incx,beta,y,incy)
      use iso_c_binding
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocblas_dsymv_rank_0
      type(c_ptr),value :: handle
      integer(kind(rocblas_fill_upper)),value :: uplo
      integer(c_int),value :: n
      real(c_double) :: alpha
      real(c_double),target :: A
      integer(c_int),value :: lda
      real(c_double),target :: x
      integer(c_int),value :: incx
      real(c_double) :: beta
      real(c_double),target :: y
      integer(c_int),value :: incy
      !
      rocblas_dsymv_rank_0 = rocblas_dsymv_orig(handle,uplo,n,alpha,c_loc(A),lda,c_loc(x),incx,beta,c_loc(y),incy)
    end function

    function rocblas_dsymv_rank_1(handle,uplo,n,alpha,A,lda,x,incx,beta,y,incy)
      use iso_c_binding
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocblas_dsymv_rank_1
      type(c_ptr),value :: handle
      integer(kind(rocblas_fill_upper)),value :: uplo
      integer(c_int),value :: n
      real(c_double) :: alpha
      real(c_double),target,dimension(:) :: A
      integer(c_int),value :: lda
      real(c_double),target,dimension(:) :: x
      integer(c_int),value :: incx
      real(c_double) :: beta
      real(c_double),target,dimension(:) :: y
      integer(c_int),value :: incy
      !
      rocblas_dsymv_rank_1 = rocblas_dsymv_orig(handle,uplo,n,alpha,c_loc(A),lda,c_loc(x),incx,beta,c_loc(y),incy)
    end function

    function rocblas_csymv_full_rank(handle,uplo,n,alpha,A,lda,x,incx,beta,y,incy)
      use iso_c_binding
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocblas_csymv_full_rank
      type(c_ptr),value :: handle
      integer(kind(rocblas_fill_upper)),value :: uplo
      integer(c_int),value :: n
      complex(c_float_complex) :: alpha
      complex(c_float_complex),target,dimension(:,:) :: A
      integer(c_int),value :: lda
      complex(c_float_complex),target,dimension(:) :: x
      integer(c_int),value :: incx
      complex(c_float_complex) :: beta
      complex(c_float_complex),target,dimension(:) :: y
      integer(c_int),value :: incy
      !
      rocblas_csymv_full_rank = rocblas_csymv_orig(handle,uplo,n,alpha,c_loc(A),lda,c_loc(x),incx,beta,c_loc(y),incy)
    end function

    function rocblas_csymv_rank_0(handle,uplo,n,alpha,A,lda,x,incx,beta,y,incy)
      use iso_c_binding
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocblas_csymv_rank_0
      type(c_ptr),value :: handle
      integer(kind(rocblas_fill_upper)),value :: uplo
      integer(c_int),value :: n
      complex(c_float_complex) :: alpha
      complex(c_float_complex),target :: A
      integer(c_int),value :: lda
      complex(c_float_complex),target :: x
      integer(c_int),value :: incx
      complex(c_float_complex) :: beta
      complex(c_float_complex),target :: y
      integer(c_int),value :: incy
      !
      rocblas_csymv_rank_0 = rocblas_csymv_orig(handle,uplo,n,alpha,c_loc(A),lda,c_loc(x),incx,beta,c_loc(y),incy)
    end function

    function rocblas_csymv_rank_1(handle,uplo,n,alpha,A,lda,x,incx,beta,y,incy)
      use iso_c_binding
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocblas_csymv_rank_1
      type(c_ptr),value :: handle
      integer(kind(rocblas_fill_upper)),value :: uplo
      integer(c_int),value :: n
      complex(c_float_complex) :: alpha
      complex(c_float_complex),target,dimension(:) :: A
      integer(c_int),value :: lda
      complex(c_float_complex),target,dimension(:) :: x
      integer(c_int),value :: incx
      complex(c_float_complex) :: beta
      complex(c_float_complex),target,dimension(:) :: y
      integer(c_int),value :: incy
      !
      rocblas_csymv_rank_1 = rocblas_csymv_orig(handle,uplo,n,alpha,c_loc(A),lda,c_loc(x),incx,beta,c_loc(y),incy)
    end function

    function rocblas_zsymv_full_rank(handle,uplo,n,alpha,A,lda,x,incx,beta,y,incy)
      use iso_c_binding
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocblas_zsymv_full_rank
      type(c_ptr),value :: handle
      integer(kind(rocblas_fill_upper)),value :: uplo
      integer(c_int),value :: n
      complex(c_double_complex) :: alpha
      complex(c_double_complex),target,dimension(:,:) :: A
      integer(c_int),value :: lda
      complex(c_double_complex),target,dimension(:) :: x
      integer(c_int),value :: incx
      complex(c_double_complex) :: beta
      complex(c_double_complex),target,dimension(:) :: y
      integer(c_int),value :: incy
      !
      rocblas_zsymv_full_rank = rocblas_zsymv_orig(handle,uplo,n,alpha,c_loc(A),lda,c_loc(x),incx,beta,c_loc(y),incy)
    end function

    function rocblas_zsymv_rank_0(handle,uplo,n,alpha,A,lda,x,incx,beta,y,incy)
      use iso_c_binding
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocblas_zsymv_rank_0
      type(c_ptr),value :: handle
      integer(kind(rocblas_fill_upper)),value :: uplo
      integer(c_int),value :: n
      complex(c_double_complex) :: alpha
      complex(c_double_complex),target :: A
      integer(c_int),value :: lda
      complex(c_double_complex),target :: x
      integer(c_int),value :: incx
      complex(c_double_complex) :: beta
      complex(c_double_complex),target :: y
      integer(c_int),value :: incy
      !
      rocblas_zsymv_rank_0 = rocblas_zsymv_orig(handle,uplo,n,alpha,c_loc(A),lda,c_loc(x),incx,beta,c_loc(y),incy)
    end function

    function rocblas_zsymv_rank_1(handle,uplo,n,alpha,A,lda,x,incx,beta,y,incy)
      use iso_c_binding
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocblas_zsymv_rank_1
      type(c_ptr),value :: handle
      integer(kind(rocblas_fill_upper)),value :: uplo
      integer(c_int),value :: n
      complex(c_double_complex) :: alpha
      complex(c_double_complex),target,dimension(:) :: A
      integer(c_int),value :: lda
      complex(c_double_complex),target,dimension(:) :: x
      integer(c_int),value :: incx
      complex(c_double_complex) :: beta
      complex(c_double_complex),target,dimension(:) :: y
      integer(c_int),value :: incy
      !
      rocblas_zsymv_rank_1 = rocblas_zsymv_orig(handle,uplo,n,alpha,c_loc(A),lda,c_loc(x),incx,beta,c_loc(y),incy)
    end function

    function rocblas_ssymv_batched_full_rank(handle,uplo,n,alpha,A,lda,x,incx,beta,y,incy,batch_count)
      use iso_c_binding
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocblas_ssymv_batched_full_rank
      type(c_ptr),value :: handle
      integer(kind(rocblas_fill_upper)),value :: uplo
      integer(c_int),value :: n
      real(c_float) :: alpha
      real(c_float),target,dimension(:,:,:) :: A
      integer(c_int),value :: lda
      real(c_float),target,dimension(:,:) :: x
      integer(c_int),value :: incx
      real(c_float) :: beta
      real(c_float),target,dimension(:,:) :: y
      integer(c_int),value :: incy
      integer(c_int),value :: batch_count
      !
      rocblas_ssymv_batched_full_rank = rocblas_ssymv_batched_orig(handle,uplo,n,alpha,c_loc(A),lda,c_loc(x),incx,beta,c_loc(y),incy,batch_count)
    end function

    function rocblas_ssymv_batched_rank_0(handle,uplo,n,alpha,A,lda,x,incx,beta,y,incy,batch_count)
      use iso_c_binding
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocblas_ssymv_batched_rank_0
      type(c_ptr),value :: handle
      integer(kind(rocblas_fill_upper)),value :: uplo
      integer(c_int),value :: n
      real(c_float) :: alpha
      real(c_float),target :: A
      integer(c_int),value :: lda
      real(c_float),target :: x
      integer(c_int),value :: incx
      real(c_float) :: beta
      real(c_float),target :: y
      integer(c_int),value :: incy
      integer(c_int),value :: batch_count
      !
      rocblas_ssymv_batched_rank_0 = rocblas_ssymv_batched_orig(handle,uplo,n,alpha,c_loc(A),lda,c_loc(x),incx,beta,c_loc(y),incy,batch_count)
    end function

    function rocblas_ssymv_batched_rank_1(handle,uplo,n,alpha,A,lda,x,incx,beta,y,incy,batch_count)
      use iso_c_binding
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocblas_ssymv_batched_rank_1
      type(c_ptr),value :: handle
      integer(kind(rocblas_fill_upper)),value :: uplo
      integer(c_int),value :: n
      real(c_float) :: alpha
      real(c_float),target,dimension(:) :: A
      integer(c_int),value :: lda
      real(c_float),target,dimension(:) :: x
      integer(c_int),value :: incx
      real(c_float) :: beta
      real(c_float),target,dimension(:) :: y
      integer(c_int),value :: incy
      integer(c_int),value :: batch_count
      !
      rocblas_ssymv_batched_rank_1 = rocblas_ssymv_batched_orig(handle,uplo,n,alpha,c_loc(A),lda,c_loc(x),incx,beta,c_loc(y),incy,batch_count)
    end function

    function rocblas_dsymv_batched_full_rank(handle,uplo,n,alpha,A,lda,x,incx,beta,y,incy,batch_count)
      use iso_c_binding
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocblas_dsymv_batched_full_rank
      type(c_ptr),value :: handle
      integer(kind(rocblas_fill_upper)),value :: uplo
      integer(c_int),value :: n
      real(c_double) :: alpha
      real(c_double),target,dimension(:,:,:) :: A
      integer(c_int),value :: lda
      real(c_double),target,dimension(:,:) :: x
      integer(c_int),value :: incx
      real(c_double) :: beta
      real(c_double),target,dimension(:,:) :: y
      integer(c_int),value :: incy
      integer(c_int),value :: batch_count
      !
      rocblas_dsymv_batched_full_rank = rocblas_dsymv_batched_orig(handle,uplo,n,alpha,c_loc(A),lda,c_loc(x),incx,beta,c_loc(y),incy,batch_count)
    end function

    function rocblas_dsymv_batched_rank_0(handle,uplo,n,alpha,A,lda,x,incx,beta,y,incy,batch_count)
      use iso_c_binding
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocblas_dsymv_batched_rank_0
      type(c_ptr),value :: handle
      integer(kind(rocblas_fill_upper)),value :: uplo
      integer(c_int),value :: n
      real(c_double) :: alpha
      real(c_double),target :: A
      integer(c_int),value :: lda
      real(c_double),target :: x
      integer(c_int),value :: incx
      real(c_double) :: beta
      real(c_double),target :: y
      integer(c_int),value :: incy
      integer(c_int),value :: batch_count
      !
      rocblas_dsymv_batched_rank_0 = rocblas_dsymv_batched_orig(handle,uplo,n,alpha,c_loc(A),lda,c_loc(x),incx,beta,c_loc(y),incy,batch_count)
    end function

    function rocblas_dsymv_batched_rank_1(handle,uplo,n,alpha,A,lda,x,incx,beta,y,incy,batch_count)
      use iso_c_binding
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocblas_dsymv_batched_rank_1
      type(c_ptr),value :: handle
      integer(kind(rocblas_fill_upper)),value :: uplo
      integer(c_int),value :: n
      real(c_double) :: alpha
      real(c_double),target,dimension(:) :: A
      integer(c_int),value :: lda
      real(c_double),target,dimension(:) :: x
      integer(c_int),value :: incx
      real(c_double) :: beta
      real(c_double),target,dimension(:) :: y
      integer(c_int),value :: incy
      integer(c_int),value :: batch_count
      !
      rocblas_dsymv_batched_rank_1 = rocblas_dsymv_batched_orig(handle,uplo,n,alpha,c_loc(A),lda,c_loc(x),incx,beta,c_loc(y),incy,batch_count)
    end function

    function rocblas_csymv_batched_full_rank(handle,uplo,n,alpha,A,lda,x,incx,beta,y,incy,batch_count)
      use iso_c_binding
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocblas_csymv_batched_full_rank
      type(c_ptr),value :: handle
      integer(kind(rocblas_fill_upper)),value :: uplo
      integer(c_int),value :: n
      complex(c_float_complex) :: alpha
      complex(c_float_complex),target,dimension(:,:,:) :: A
      integer(c_int),value :: lda
      complex(c_float_complex),target,dimension(:,:) :: x
      integer(c_int),value :: incx
      complex(c_float_complex) :: beta
      complex(c_float_complex),target,dimension(:,:) :: y
      integer(c_int),value :: incy
      integer(c_int),value :: batch_count
      !
      rocblas_csymv_batched_full_rank = rocblas_csymv_batched_orig(handle,uplo,n,alpha,c_loc(A),lda,c_loc(x),incx,beta,c_loc(y),incy,batch_count)
    end function

    function rocblas_csymv_batched_rank_0(handle,uplo,n,alpha,A,lda,x,incx,beta,y,incy,batch_count)
      use iso_c_binding
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocblas_csymv_batched_rank_0
      type(c_ptr),value :: handle
      integer(kind(rocblas_fill_upper)),value :: uplo
      integer(c_int),value :: n
      complex(c_float_complex) :: alpha
      complex(c_float_complex),target :: A
      integer(c_int),value :: lda
      complex(c_float_complex),target :: x
      integer(c_int),value :: incx
      complex(c_float_complex) :: beta
      complex(c_float_complex),target :: y
      integer(c_int),value :: incy
      integer(c_int),value :: batch_count
      !
      rocblas_csymv_batched_rank_0 = rocblas_csymv_batched_orig(handle,uplo,n,alpha,c_loc(A),lda,c_loc(x),incx,beta,c_loc(y),incy,batch_count)
    end function

    function rocblas_csymv_batched_rank_1(handle,uplo,n,alpha,A,lda,x,incx,beta,y,incy,batch_count)
      use iso_c_binding
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocblas_csymv_batched_rank_1
      type(c_ptr),value :: handle
      integer(kind(rocblas_fill_upper)),value :: uplo
      integer(c_int),value :: n
      complex(c_float_complex) :: alpha
      complex(c_float_complex),target,dimension(:) :: A
      integer(c_int),value :: lda
      complex(c_float_complex),target,dimension(:) :: x
      integer(c_int),value :: incx
      complex(c_float_complex) :: beta
      complex(c_float_complex),target,dimension(:) :: y
      integer(c_int),value :: incy
      integer(c_int),value :: batch_count
      !
      rocblas_csymv_batched_rank_1 = rocblas_csymv_batched_orig(handle,uplo,n,alpha,c_loc(A),lda,c_loc(x),incx,beta,c_loc(y),incy,batch_count)
    end function

    function rocblas_zsymv_batched_full_rank(handle,uplo,n,alpha,A,lda,x,incx,beta,y,incy,batch_count)
      use iso_c_binding
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocblas_zsymv_batched_full_rank
      type(c_ptr),value :: handle
      integer(kind(rocblas_fill_upper)),value :: uplo
      integer(c_int),value :: n
      complex(c_double_complex) :: alpha
      complex(c_double_complex),target,dimension(:,:,:) :: A
      integer(c_int),value :: lda
      complex(c_double_complex),target,dimension(:,:) :: x
      integer(c_int),value :: incx
      complex(c_double_complex) :: beta
      complex(c_double_complex),target,dimension(:,:) :: y
      integer(c_int),value :: incy
      integer(c_int),value :: batch_count
      !
      rocblas_zsymv_batched_full_rank = rocblas_zsymv_batched_orig(handle,uplo,n,alpha,c_loc(A),lda,c_loc(x),incx,beta,c_loc(y),incy,batch_count)
    end function

    function rocblas_zsymv_batched_rank_0(handle,uplo,n,alpha,A,lda,x,incx,beta,y,incy,batch_count)
      use iso_c_binding
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocblas_zsymv_batched_rank_0
      type(c_ptr),value :: handle
      integer(kind(rocblas_fill_upper)),value :: uplo
      integer(c_int),value :: n
      complex(c_double_complex) :: alpha
      complex(c_double_complex),target :: A
      integer(c_int),value :: lda
      complex(c_double_complex),target :: x
      integer(c_int),value :: incx
      complex(c_double_complex) :: beta
      complex(c_double_complex),target :: y
      integer(c_int),value :: incy
      integer(c_int),value :: batch_count
      !
      rocblas_zsymv_batched_rank_0 = rocblas_zsymv_batched_orig(handle,uplo,n,alpha,c_loc(A),lda,c_loc(x),incx,beta,c_loc(y),incy,batch_count)
    end function

    function rocblas_zsymv_batched_rank_1(handle,uplo,n,alpha,A,lda,x,incx,beta,y,incy,batch_count)
      use iso_c_binding
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocblas_zsymv_batched_rank_1
      type(c_ptr),value :: handle
      integer(kind(rocblas_fill_upper)),value :: uplo
      integer(c_int),value :: n
      complex(c_double_complex) :: alpha
      complex(c_double_complex),target,dimension(:) :: A
      integer(c_int),value :: lda
      complex(c_double_complex),target,dimension(:) :: x
      integer(c_int),value :: incx
      complex(c_double_complex) :: beta
      complex(c_double_complex),target,dimension(:) :: y
      integer(c_int),value :: incy
      integer(c_int),value :: batch_count
      !
      rocblas_zsymv_batched_rank_1 = rocblas_zsymv_batched_orig(handle,uplo,n,alpha,c_loc(A),lda,c_loc(x),incx,beta,c_loc(y),incy,batch_count)
    end function

    function rocblas_ssymv_strided_batched_full_rank(handle,uplo,n,alpha,A,lda,strideA,x,incx,stridex,beta,y,incy,stridey,batch_count)
      use iso_c_binding
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocblas_ssymv_strided_batched_full_rank
      type(c_ptr),value :: handle
      integer(kind(rocblas_fill_upper)),value :: uplo
      integer(c_int),value :: n
      real(c_float) :: alpha
      real(c_float),target,dimension(:,:) :: A
      integer(c_int),value :: lda
      integer(c_int64_t),value :: strideA
      real(c_float),target,dimension(:) :: x
      integer(c_int),value :: incx
      integer(c_int64_t),value :: stridex
      real(c_float) :: beta
      real(c_float),target,dimension(:) :: y
      integer(c_int),value :: incy
      integer(c_int64_t),value :: stridey
      integer(c_int),value :: batch_count
      !
      rocblas_ssymv_strided_batched_full_rank = rocblas_ssymv_strided_batched_orig(handle,uplo,n,alpha,c_loc(A),lda,strideA,c_loc(x),incx,stridex,beta,c_loc(y),incy,stridey,batch_count)
    end function

    function rocblas_ssymv_strided_batched_rank_0(handle,uplo,n,alpha,A,lda,strideA,x,incx,stridex,beta,y,incy,stridey,batch_count)
      use iso_c_binding
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocblas_ssymv_strided_batched_rank_0
      type(c_ptr),value :: handle
      integer(kind(rocblas_fill_upper)),value :: uplo
      integer(c_int),value :: n
      real(c_float) :: alpha
      real(c_float),target :: A
      integer(c_int),value :: lda
      integer(c_int64_t),value :: strideA
      real(c_float),target :: x
      integer(c_int),value :: incx
      integer(c_int64_t),value :: stridex
      real(c_float) :: beta
      real(c_float),target :: y
      integer(c_int),value :: incy
      integer(c_int64_t),value :: stridey
      integer(c_int),value :: batch_count
      !
      rocblas_ssymv_strided_batched_rank_0 = rocblas_ssymv_strided_batched_orig(handle,uplo,n,alpha,c_loc(A),lda,strideA,c_loc(x),incx,stridex,beta,c_loc(y),incy,stridey,batch_count)
    end function

    function rocblas_ssymv_strided_batched_rank_1(handle,uplo,n,alpha,A,lda,strideA,x,incx,stridex,beta,y,incy,stridey,batch_count)
      use iso_c_binding
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocblas_ssymv_strided_batched_rank_1
      type(c_ptr),value :: handle
      integer(kind(rocblas_fill_upper)),value :: uplo
      integer(c_int),value :: n
      real(c_float) :: alpha
      real(c_float),target,dimension(:) :: A
      integer(c_int),value :: lda
      integer(c_int64_t),value :: strideA
      real(c_float),target,dimension(:) :: x
      integer(c_int),value :: incx
      integer(c_int64_t),value :: stridex
      real(c_float) :: beta
      real(c_float),target,dimension(:) :: y
      integer(c_int),value :: incy
      integer(c_int64_t),value :: stridey
      integer(c_int),value :: batch_count
      !
      rocblas_ssymv_strided_batched_rank_1 = rocblas_ssymv_strided_batched_orig(handle,uplo,n,alpha,c_loc(A),lda,strideA,c_loc(x),incx,stridex,beta,c_loc(y),incy,stridey,batch_count)
    end function

    function rocblas_dsymv_strided_batched_full_rank(handle,uplo,n,alpha,A,lda,strideA,x,incx,stridex,beta,y,incy,stridey,batch_count)
      use iso_c_binding
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocblas_dsymv_strided_batched_full_rank
      type(c_ptr),value :: handle
      integer(kind(rocblas_fill_upper)),value :: uplo
      integer(c_int),value :: n
      real(c_double) :: alpha
      real(c_double),target,dimension(:,:) :: A
      integer(c_int),value :: lda
      integer(c_int64_t),value :: strideA
      real(c_double),target,dimension(:) :: x
      integer(c_int),value :: incx
      integer(c_int64_t),value :: stridex
      real(c_double) :: beta
      real(c_double),target,dimension(:) :: y
      integer(c_int),value :: incy
      integer(c_int64_t),value :: stridey
      integer(c_int),value :: batch_count
      !
      rocblas_dsymv_strided_batched_full_rank = rocblas_dsymv_strided_batched_orig(handle,uplo,n,alpha,c_loc(A),lda,strideA,c_loc(x),incx,stridex,beta,c_loc(y),incy,stridey,batch_count)
    end function

    function rocblas_dsymv_strided_batched_rank_0(handle,uplo,n,alpha,A,lda,strideA,x,incx,stridex,beta,y,incy,stridey,batch_count)
      use iso_c_binding
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocblas_dsymv_strided_batched_rank_0
      type(c_ptr),value :: handle
      integer(kind(rocblas_fill_upper)),value :: uplo
      integer(c_int),value :: n
      real(c_double) :: alpha
      real(c_double),target :: A
      integer(c_int),value :: lda
      integer(c_int64_t),value :: strideA
      real(c_double),target :: x
      integer(c_int),value :: incx
      integer(c_int64_t),value :: stridex
      real(c_double) :: beta
      real(c_double),target :: y
      integer(c_int),value :: incy
      integer(c_int64_t),value :: stridey
      integer(c_int),value :: batch_count
      !
      rocblas_dsymv_strided_batched_rank_0 = rocblas_dsymv_strided_batched_orig(handle,uplo,n,alpha,c_loc(A),lda,strideA,c_loc(x),incx,stridex,beta,c_loc(y),incy,stridey,batch_count)
    end function

    function rocblas_dsymv_strided_batched_rank_1(handle,uplo,n,alpha,A,lda,strideA,x,incx,stridex,beta,y,incy,stridey,batch_count)
      use iso_c_binding
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocblas_dsymv_strided_batched_rank_1
      type(c_ptr),value :: handle
      integer(kind(rocblas_fill_upper)),value :: uplo
      integer(c_int),value :: n
      real(c_double) :: alpha
      real(c_double),target,dimension(:) :: A
      integer(c_int),value :: lda
      integer(c_int64_t),value :: strideA
      real(c_double),target,dimension(:) :: x
      integer(c_int),value :: incx
      integer(c_int64_t),value :: stridex
      real(c_double) :: beta
      real(c_double),target,dimension(:) :: y
      integer(c_int),value :: incy
      integer(c_int64_t),value :: stridey
      integer(c_int),value :: batch_count
      !
      rocblas_dsymv_strided_batched_rank_1 = rocblas_dsymv_strided_batched_orig(handle,uplo,n,alpha,c_loc(A),lda,strideA,c_loc(x),incx,stridex,beta,c_loc(y),incy,stridey,batch_count)
    end function

    function rocblas_csymv_strided_batched_full_rank(handle,uplo,n,alpha,A,lda,strideA,x,incx,stridex,beta,y,incy,stridey,batch_count)
      use iso_c_binding
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocblas_csymv_strided_batched_full_rank
      type(c_ptr),value :: handle
      integer(kind(rocblas_fill_upper)),value :: uplo
      integer(c_int),value :: n
      complex(c_float_complex) :: alpha
      complex(c_float_complex),target,dimension(:,:) :: A
      integer(c_int),value :: lda
      integer(c_int64_t),value :: strideA
      complex(c_float_complex),target,dimension(:) :: x
      integer(c_int),value :: incx
      integer(c_int64_t),value :: stridex
      complex(c_float_complex) :: beta
      complex(c_float_complex),target,dimension(:) :: y
      integer(c_int),value :: incy
      integer(c_int64_t),value :: stridey
      integer(c_int),value :: batch_count
      !
      rocblas_csymv_strided_batched_full_rank = rocblas_csymv_strided_batched_orig(handle,uplo,n,alpha,c_loc(A),lda,strideA,c_loc(x),incx,stridex,beta,c_loc(y),incy,stridey,batch_count)
    end function

    function rocblas_csymv_strided_batched_rank_0(handle,uplo,n,alpha,A,lda,strideA,x,incx,stridex,beta,y,incy,stridey,batch_count)
      use iso_c_binding
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocblas_csymv_strided_batched_rank_0
      type(c_ptr),value :: handle
      integer(kind(rocblas_fill_upper)),value :: uplo
      integer(c_int),value :: n
      complex(c_float_complex) :: alpha
      complex(c_float_complex),target :: A
      integer(c_int),value :: lda
      integer(c_int64_t),value :: strideA
      complex(c_float_complex),target :: x
      integer(c_int),value :: incx
      integer(c_int64_t),value :: stridex
      complex(c_float_complex) :: beta
      complex(c_float_complex),target :: y
      integer(c_int),value :: incy
      integer(c_int64_t),value :: stridey
      integer(c_int),value :: batch_count
      !
      rocblas_csymv_strided_batched_rank_0 = rocblas_csymv_strided_batched_orig(handle,uplo,n,alpha,c_loc(A),lda,strideA,c_loc(x),incx,stridex,beta,c_loc(y),incy,stridey,batch_count)
    end function

    function rocblas_csymv_strided_batched_rank_1(handle,uplo,n,alpha,A,lda,strideA,x,incx,stridex,beta,y,incy,stridey,batch_count)
      use iso_c_binding
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocblas_csymv_strided_batched_rank_1
      type(c_ptr),value :: handle
      integer(kind(rocblas_fill_upper)),value :: uplo
      integer(c_int),value :: n
      complex(c_float_complex) :: alpha
      complex(c_float_complex),target,dimension(:) :: A
      integer(c_int),value :: lda
      integer(c_int64_t),value :: strideA
      complex(c_float_complex),target,dimension(:) :: x
      integer(c_int),value :: incx
      integer(c_int64_t),value :: stridex
      complex(c_float_complex) :: beta
      complex(c_float_complex),target,dimension(:) :: y
      integer(c_int),value :: incy
      integer(c_int64_t),value :: stridey
      integer(c_int),value :: batch_count
      !
      rocblas_csymv_strided_batched_rank_1 = rocblas_csymv_strided_batched_orig(handle,uplo,n,alpha,c_loc(A),lda,strideA,c_loc(x),incx,stridex,beta,c_loc(y),incy,stridey,batch_count)
    end function

    function rocblas_zsymv_strided_batched_full_rank(handle,uplo,n,alpha,A,lda,strideA,x,incx,stridex,beta,y,incy,stridey,batch_count)
      use iso_c_binding
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocblas_zsymv_strided_batched_full_rank
      type(c_ptr),value :: handle
      integer(kind(rocblas_fill_upper)),value :: uplo
      integer(c_int),value :: n
      complex(c_double_complex) :: alpha
      complex(c_double_complex),target,dimension(:,:) :: A
      integer(c_int),value :: lda
      integer(c_int64_t),value :: strideA
      complex(c_double_complex),target,dimension(:) :: x
      integer(c_int),value :: incx
      integer(c_int64_t),value :: stridex
      complex(c_double_complex) :: beta
      complex(c_double_complex),target,dimension(:) :: y
      integer(c_int),value :: incy
      integer(c_int64_t),value :: stridey
      integer(c_int),value :: batch_count
      !
      rocblas_zsymv_strided_batched_full_rank = rocblas_zsymv_strided_batched_orig(handle,uplo,n,alpha,c_loc(A),lda,strideA,c_loc(x),incx,stridex,beta,c_loc(y),incy,stridey,batch_count)
    end function

    function rocblas_zsymv_strided_batched_rank_0(handle,uplo,n,alpha,A,lda,strideA,x,incx,stridex,beta,y,incy,stridey,batch_count)
      use iso_c_binding
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocblas_zsymv_strided_batched_rank_0
      type(c_ptr),value :: handle
      integer(kind(rocblas_fill_upper)),value :: uplo
      integer(c_int),value :: n
      complex(c_double_complex) :: alpha
      complex(c_double_complex),target :: A
      integer(c_int),value :: lda
      integer(c_int64_t),value :: strideA
      complex(c_double_complex),target :: x
      integer(c_int),value :: incx
      integer(c_int64_t),value :: stridex
      complex(c_double_complex) :: beta
      complex(c_double_complex),target :: y
      integer(c_int),value :: incy
      integer(c_int64_t),value :: stridey
      integer(c_int),value :: batch_count
      !
      rocblas_zsymv_strided_batched_rank_0 = rocblas_zsymv_strided_batched_orig(handle,uplo,n,alpha,c_loc(A),lda,strideA,c_loc(x),incx,stridex,beta,c_loc(y),incy,stridey,batch_count)
    end function

    function rocblas_zsymv_strided_batched_rank_1(handle,uplo,n,alpha,A,lda,strideA,x,incx,stridex,beta,y,incy,stridey,batch_count)
      use iso_c_binding
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocblas_zsymv_strided_batched_rank_1
      type(c_ptr),value :: handle
      integer(kind(rocblas_fill_upper)),value :: uplo
      integer(c_int),value :: n
      complex(c_double_complex) :: alpha
      complex(c_double_complex),target,dimension(:) :: A
      integer(c_int),value :: lda
      integer(c_int64_t),value :: strideA
      complex(c_double_complex),target,dimension(:) :: x
      integer(c_int),value :: incx
      integer(c_int64_t),value :: stridex
      complex(c_double_complex) :: beta
      complex(c_double_complex),target,dimension(:) :: y
      integer(c_int),value :: incy
      integer(c_int64_t),value :: stridey
      integer(c_int),value :: batch_count
      !
      rocblas_zsymv_strided_batched_rank_1 = rocblas_zsymv_strided_batched_orig(handle,uplo,n,alpha,c_loc(A),lda,strideA,c_loc(x),incx,stridex,beta,c_loc(y),incy,stridey,batch_count)
    end function

    function rocblas_sspmv_full_rank(handle,uplo,n,alpha,A,x,incx,beta,y,incy)
      use iso_c_binding
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocblas_sspmv_full_rank
      type(c_ptr),value :: handle
      integer(kind(rocblas_fill_upper)),value :: uplo
      integer(c_int),value :: n
      real(c_float) :: alpha
      real(c_float),target,dimension(:,:) :: A
      real(c_float),target,dimension(:) :: x
      integer(c_int),value :: incx
      real(c_float) :: beta
      real(c_float),target,dimension(:) :: y
      integer(c_int),value :: incy
      !
      rocblas_sspmv_full_rank = rocblas_sspmv_orig(handle,uplo,n,alpha,c_loc(A),c_loc(x),incx,beta,c_loc(y),incy)
    end function

    function rocblas_sspmv_rank_0(handle,uplo,n,alpha,A,x,incx,beta,y,incy)
      use iso_c_binding
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocblas_sspmv_rank_0
      type(c_ptr),value :: handle
      integer(kind(rocblas_fill_upper)),value :: uplo
      integer(c_int),value :: n
      real(c_float) :: alpha
      real(c_float),target :: A
      real(c_float),target :: x
      integer(c_int),value :: incx
      real(c_float) :: beta
      real(c_float),target :: y
      integer(c_int),value :: incy
      !
      rocblas_sspmv_rank_0 = rocblas_sspmv_orig(handle,uplo,n,alpha,c_loc(A),c_loc(x),incx,beta,c_loc(y),incy)
    end function

    function rocblas_sspmv_rank_1(handle,uplo,n,alpha,A,x,incx,beta,y,incy)
      use iso_c_binding
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocblas_sspmv_rank_1
      type(c_ptr),value :: handle
      integer(kind(rocblas_fill_upper)),value :: uplo
      integer(c_int),value :: n
      real(c_float) :: alpha
      real(c_float),target,dimension(:) :: A
      real(c_float),target,dimension(:) :: x
      integer(c_int),value :: incx
      real(c_float) :: beta
      real(c_float),target,dimension(:) :: y
      integer(c_int),value :: incy
      !
      rocblas_sspmv_rank_1 = rocblas_sspmv_orig(handle,uplo,n,alpha,c_loc(A),c_loc(x),incx,beta,c_loc(y),incy)
    end function

    function rocblas_dspmv_full_rank(handle,uplo,n,alpha,A,x,incx,beta,y,incy)
      use iso_c_binding
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocblas_dspmv_full_rank
      type(c_ptr),value :: handle
      integer(kind(rocblas_fill_upper)),value :: uplo
      integer(c_int),value :: n
      real(c_double) :: alpha
      real(c_double),target,dimension(:,:) :: A
      real(c_double),target,dimension(:) :: x
      integer(c_int),value :: incx
      real(c_double) :: beta
      real(c_double),target,dimension(:) :: y
      integer(c_int),value :: incy
      !
      rocblas_dspmv_full_rank = rocblas_dspmv_orig(handle,uplo,n,alpha,c_loc(A),c_loc(x),incx,beta,c_loc(y),incy)
    end function

    function rocblas_dspmv_rank_0(handle,uplo,n,alpha,A,x,incx,beta,y,incy)
      use iso_c_binding
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocblas_dspmv_rank_0
      type(c_ptr),value :: handle
      integer(kind(rocblas_fill_upper)),value :: uplo
      integer(c_int),value :: n
      real(c_double) :: alpha
      real(c_double),target :: A
      real(c_double),target :: x
      integer(c_int),value :: incx
      real(c_double) :: beta
      real(c_double),target :: y
      integer(c_int),value :: incy
      !
      rocblas_dspmv_rank_0 = rocblas_dspmv_orig(handle,uplo,n,alpha,c_loc(A),c_loc(x),incx,beta,c_loc(y),incy)
    end function

    function rocblas_dspmv_rank_1(handle,uplo,n,alpha,A,x,incx,beta,y,incy)
      use iso_c_binding
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocblas_dspmv_rank_1
      type(c_ptr),value :: handle
      integer(kind(rocblas_fill_upper)),value :: uplo
      integer(c_int),value :: n
      real(c_double) :: alpha
      real(c_double),target,dimension(:) :: A
      real(c_double),target,dimension(:) :: x
      integer(c_int),value :: incx
      real(c_double) :: beta
      real(c_double),target,dimension(:) :: y
      integer(c_int),value :: incy
      !
      rocblas_dspmv_rank_1 = rocblas_dspmv_orig(handle,uplo,n,alpha,c_loc(A),c_loc(x),incx,beta,c_loc(y),incy)
    end function

    function rocblas_sspmv_batched_full_rank(handle,uplo,n,alpha,A,x,incx,beta,y,incy,batch_count)
      use iso_c_binding
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocblas_sspmv_batched_full_rank
      type(c_ptr),value :: handle
      integer(kind(rocblas_fill_upper)),value :: uplo
      integer(c_int),value :: n
      real(c_float) :: alpha
      real(c_float),target,dimension(:,:,:) :: A
      real(c_float),target,dimension(:,:) :: x
      integer(c_int),value :: incx
      real(c_float) :: beta
      real(c_float),target,dimension(:,:) :: y
      integer(c_int),value :: incy
      integer(c_int),value :: batch_count
      !
      rocblas_sspmv_batched_full_rank = rocblas_sspmv_batched_orig(handle,uplo,n,alpha,c_loc(A),c_loc(x),incx,beta,c_loc(y),incy,batch_count)
    end function

    function rocblas_sspmv_batched_rank_0(handle,uplo,n,alpha,A,x,incx,beta,y,incy,batch_count)
      use iso_c_binding
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocblas_sspmv_batched_rank_0
      type(c_ptr),value :: handle
      integer(kind(rocblas_fill_upper)),value :: uplo
      integer(c_int),value :: n
      real(c_float) :: alpha
      real(c_float),target :: A
      real(c_float),target :: x
      integer(c_int),value :: incx
      real(c_float) :: beta
      real(c_float),target :: y
      integer(c_int),value :: incy
      integer(c_int),value :: batch_count
      !
      rocblas_sspmv_batched_rank_0 = rocblas_sspmv_batched_orig(handle,uplo,n,alpha,c_loc(A),c_loc(x),incx,beta,c_loc(y),incy,batch_count)
    end function

    function rocblas_sspmv_batched_rank_1(handle,uplo,n,alpha,A,x,incx,beta,y,incy,batch_count)
      use iso_c_binding
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocblas_sspmv_batched_rank_1
      type(c_ptr),value :: handle
      integer(kind(rocblas_fill_upper)),value :: uplo
      integer(c_int),value :: n
      real(c_float) :: alpha
      real(c_float),target,dimension(:) :: A
      real(c_float),target,dimension(:) :: x
      integer(c_int),value :: incx
      real(c_float) :: beta
      real(c_float),target,dimension(:) :: y
      integer(c_int),value :: incy
      integer(c_int),value :: batch_count
      !
      rocblas_sspmv_batched_rank_1 = rocblas_sspmv_batched_orig(handle,uplo,n,alpha,c_loc(A),c_loc(x),incx,beta,c_loc(y),incy,batch_count)
    end function

    function rocblas_dspmv_batched_full_rank(handle,uplo,n,alpha,A,x,incx,beta,y,incy,batch_count)
      use iso_c_binding
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocblas_dspmv_batched_full_rank
      type(c_ptr),value :: handle
      integer(kind(rocblas_fill_upper)),value :: uplo
      integer(c_int),value :: n
      real(c_double) :: alpha
      real(c_double),target,dimension(:,:,:) :: A
      real(c_double),target,dimension(:,:) :: x
      integer(c_int),value :: incx
      real(c_double) :: beta
      real(c_double),target,dimension(:,:) :: y
      integer(c_int),value :: incy
      integer(c_int),value :: batch_count
      !
      rocblas_dspmv_batched_full_rank = rocblas_dspmv_batched_orig(handle,uplo,n,alpha,c_loc(A),c_loc(x),incx,beta,c_loc(y),incy,batch_count)
    end function

    function rocblas_dspmv_batched_rank_0(handle,uplo,n,alpha,A,x,incx,beta,y,incy,batch_count)
      use iso_c_binding
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocblas_dspmv_batched_rank_0
      type(c_ptr),value :: handle
      integer(kind(rocblas_fill_upper)),value :: uplo
      integer(c_int),value :: n
      real(c_double) :: alpha
      real(c_double),target :: A
      real(c_double),target :: x
      integer(c_int),value :: incx
      real(c_double) :: beta
      real(c_double),target :: y
      integer(c_int),value :: incy
      integer(c_int),value :: batch_count
      !
      rocblas_dspmv_batched_rank_0 = rocblas_dspmv_batched_orig(handle,uplo,n,alpha,c_loc(A),c_loc(x),incx,beta,c_loc(y),incy,batch_count)
    end function

    function rocblas_dspmv_batched_rank_1(handle,uplo,n,alpha,A,x,incx,beta,y,incy,batch_count)
      use iso_c_binding
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocblas_dspmv_batched_rank_1
      type(c_ptr),value :: handle
      integer(kind(rocblas_fill_upper)),value :: uplo
      integer(c_int),value :: n
      real(c_double) :: alpha
      real(c_double),target,dimension(:) :: A
      real(c_double),target,dimension(:) :: x
      integer(c_int),value :: incx
      real(c_double) :: beta
      real(c_double),target,dimension(:) :: y
      integer(c_int),value :: incy
      integer(c_int),value :: batch_count
      !
      rocblas_dspmv_batched_rank_1 = rocblas_dspmv_batched_orig(handle,uplo,n,alpha,c_loc(A),c_loc(x),incx,beta,c_loc(y),incy,batch_count)
    end function

    function rocblas_sspmv_strided_batched_full_rank(handle,uplo,n,alpha,A,strideA,x,incx,stridex,beta,y,incy,stridey,batch_count)
      use iso_c_binding
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocblas_sspmv_strided_batched_full_rank
      type(c_ptr),value :: handle
      integer(kind(rocblas_fill_upper)),value :: uplo
      integer(c_int),value :: n
      real(c_float) :: alpha
      real(c_float),target,dimension(:,:) :: A
      integer(c_int64_t),value :: strideA
      real(c_float),target,dimension(:) :: x
      integer(c_int),value :: incx
      integer(c_int64_t),value :: stridex
      real(c_float) :: beta
      real(c_float),target,dimension(:) :: y
      integer(c_int),value :: incy
      integer(c_int64_t),value :: stridey
      integer(c_int),value :: batch_count
      !
      rocblas_sspmv_strided_batched_full_rank = rocblas_sspmv_strided_batched_orig(handle,uplo,n,alpha,c_loc(A),strideA,c_loc(x),incx,stridex,beta,c_loc(y),incy,stridey,batch_count)
    end function

    function rocblas_sspmv_strided_batched_rank_0(handle,uplo,n,alpha,A,strideA,x,incx,stridex,beta,y,incy,stridey,batch_count)
      use iso_c_binding
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocblas_sspmv_strided_batched_rank_0
      type(c_ptr),value :: handle
      integer(kind(rocblas_fill_upper)),value :: uplo
      integer(c_int),value :: n
      real(c_float) :: alpha
      real(c_float),target :: A
      integer(c_int64_t),value :: strideA
      real(c_float),target :: x
      integer(c_int),value :: incx
      integer(c_int64_t),value :: stridex
      real(c_float) :: beta
      real(c_float),target :: y
      integer(c_int),value :: incy
      integer(c_int64_t),value :: stridey
      integer(c_int),value :: batch_count
      !
      rocblas_sspmv_strided_batched_rank_0 = rocblas_sspmv_strided_batched_orig(handle,uplo,n,alpha,c_loc(A),strideA,c_loc(x),incx,stridex,beta,c_loc(y),incy,stridey,batch_count)
    end function

    function rocblas_sspmv_strided_batched_rank_1(handle,uplo,n,alpha,A,strideA,x,incx,stridex,beta,y,incy,stridey,batch_count)
      use iso_c_binding
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocblas_sspmv_strided_batched_rank_1
      type(c_ptr),value :: handle
      integer(kind(rocblas_fill_upper)),value :: uplo
      integer(c_int),value :: n
      real(c_float) :: alpha
      real(c_float),target,dimension(:) :: A
      integer(c_int64_t),value :: strideA
      real(c_float),target,dimension(:) :: x
      integer(c_int),value :: incx
      integer(c_int64_t),value :: stridex
      real(c_float) :: beta
      real(c_float),target,dimension(:) :: y
      integer(c_int),value :: incy
      integer(c_int64_t),value :: stridey
      integer(c_int),value :: batch_count
      !
      rocblas_sspmv_strided_batched_rank_1 = rocblas_sspmv_strided_batched_orig(handle,uplo,n,alpha,c_loc(A),strideA,c_loc(x),incx,stridex,beta,c_loc(y),incy,stridey,batch_count)
    end function

    function rocblas_dspmv_strided_batched_full_rank(handle,uplo,n,alpha,A,strideA,x,incx,stridex,beta,y,incy,stridey,batch_count)
      use iso_c_binding
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocblas_dspmv_strided_batched_full_rank
      type(c_ptr),value :: handle
      integer(kind(rocblas_fill_upper)),value :: uplo
      integer(c_int),value :: n
      real(c_double) :: alpha
      real(c_double),target,dimension(:,:) :: A
      integer(c_int64_t),value :: strideA
      real(c_double),target,dimension(:) :: x
      integer(c_int),value :: incx
      integer(c_int64_t),value :: stridex
      real(c_double) :: beta
      real(c_double),target,dimension(:) :: y
      integer(c_int),value :: incy
      integer(c_int64_t),value :: stridey
      integer(c_int),value :: batch_count
      !
      rocblas_dspmv_strided_batched_full_rank = rocblas_dspmv_strided_batched_orig(handle,uplo,n,alpha,c_loc(A),strideA,c_loc(x),incx,stridex,beta,c_loc(y),incy,stridey,batch_count)
    end function

    function rocblas_dspmv_strided_batched_rank_0(handle,uplo,n,alpha,A,strideA,x,incx,stridex,beta,y,incy,stridey,batch_count)
      use iso_c_binding
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocblas_dspmv_strided_batched_rank_0
      type(c_ptr),value :: handle
      integer(kind(rocblas_fill_upper)),value :: uplo
      integer(c_int),value :: n
      real(c_double) :: alpha
      real(c_double),target :: A
      integer(c_int64_t),value :: strideA
      real(c_double),target :: x
      integer(c_int),value :: incx
      integer(c_int64_t),value :: stridex
      real(c_double) :: beta
      real(c_double),target :: y
      integer(c_int),value :: incy
      integer(c_int64_t),value :: stridey
      integer(c_int),value :: batch_count
      !
      rocblas_dspmv_strided_batched_rank_0 = rocblas_dspmv_strided_batched_orig(handle,uplo,n,alpha,c_loc(A),strideA,c_loc(x),incx,stridex,beta,c_loc(y),incy,stridey,batch_count)
    end function

    function rocblas_dspmv_strided_batched_rank_1(handle,uplo,n,alpha,A,strideA,x,incx,stridex,beta,y,incy,stridey,batch_count)
      use iso_c_binding
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocblas_dspmv_strided_batched_rank_1
      type(c_ptr),value :: handle
      integer(kind(rocblas_fill_upper)),value :: uplo
      integer(c_int),value :: n
      real(c_double) :: alpha
      real(c_double),target,dimension(:) :: A
      integer(c_int64_t),value :: strideA
      real(c_double),target,dimension(:) :: x
      integer(c_int),value :: incx
      integer(c_int64_t),value :: stridex
      real(c_double) :: beta
      real(c_double),target,dimension(:) :: y
      integer(c_int),value :: incy
      integer(c_int64_t),value :: stridey
      integer(c_int),value :: batch_count
      !
      rocblas_dspmv_strided_batched_rank_1 = rocblas_dspmv_strided_batched_orig(handle,uplo,n,alpha,c_loc(A),strideA,c_loc(x),incx,stridex,beta,c_loc(y),incy,stridey,batch_count)
    end function

    function rocblas_ssbmv_full_rank(handle,uplo,n,k,alpha,A,lda,x,incx,beta,y,incy)
      use iso_c_binding
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocblas_ssbmv_full_rank
      type(c_ptr),value :: handle
      integer(kind(rocblas_fill_upper)),value :: uplo
      integer(c_int),value :: n
      integer(c_int),value :: k
      real(c_float) :: alpha
      real(c_float),target,dimension(:,:) :: A
      integer(c_int),value :: lda
      real(c_float),target,dimension(:) :: x
      integer(c_int),value :: incx
      real(c_float) :: beta
      real(c_float),target,dimension(:) :: y
      integer(c_int),value :: incy
      !
      rocblas_ssbmv_full_rank = rocblas_ssbmv_orig(handle,uplo,n,k,alpha,c_loc(A),lda,c_loc(x),incx,beta,c_loc(y),incy)
    end function

    function rocblas_ssbmv_rank_0(handle,uplo,n,k,alpha,A,lda,x,incx,beta,y,incy)
      use iso_c_binding
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocblas_ssbmv_rank_0
      type(c_ptr),value :: handle
      integer(kind(rocblas_fill_upper)),value :: uplo
      integer(c_int),value :: n
      integer(c_int),value :: k
      real(c_float) :: alpha
      real(c_float),target :: A
      integer(c_int),value :: lda
      real(c_float),target :: x
      integer(c_int),value :: incx
      real(c_float) :: beta
      real(c_float),target :: y
      integer(c_int),value :: incy
      !
      rocblas_ssbmv_rank_0 = rocblas_ssbmv_orig(handle,uplo,n,k,alpha,c_loc(A),lda,c_loc(x),incx,beta,c_loc(y),incy)
    end function

    function rocblas_ssbmv_rank_1(handle,uplo,n,k,alpha,A,lda,x,incx,beta,y,incy)
      use iso_c_binding
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocblas_ssbmv_rank_1
      type(c_ptr),value :: handle
      integer(kind(rocblas_fill_upper)),value :: uplo
      integer(c_int),value :: n
      integer(c_int),value :: k
      real(c_float) :: alpha
      real(c_float),target,dimension(:) :: A
      integer(c_int),value :: lda
      real(c_float),target,dimension(:) :: x
      integer(c_int),value :: incx
      real(c_float) :: beta
      real(c_float),target,dimension(:) :: y
      integer(c_int),value :: incy
      !
      rocblas_ssbmv_rank_1 = rocblas_ssbmv_orig(handle,uplo,n,k,alpha,c_loc(A),lda,c_loc(x),incx,beta,c_loc(y),incy)
    end function

    function rocblas_dsbmv_full_rank(handle,uplo,n,k,alpha,A,lda,x,incx,beta,y,incy)
      use iso_c_binding
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocblas_dsbmv_full_rank
      type(c_ptr),value :: handle
      integer(kind(rocblas_fill_upper)),value :: uplo
      integer(c_int),value :: n
      integer(c_int),value :: k
      real(c_double) :: alpha
      real(c_double),target,dimension(:,:) :: A
      integer(c_int),value :: lda
      real(c_double),target,dimension(:) :: x
      integer(c_int),value :: incx
      real(c_double) :: beta
      real(c_double),target,dimension(:) :: y
      integer(c_int),value :: incy
      !
      rocblas_dsbmv_full_rank = rocblas_dsbmv_orig(handle,uplo,n,k,alpha,c_loc(A),lda,c_loc(x),incx,beta,c_loc(y),incy)
    end function

    function rocblas_dsbmv_rank_0(handle,uplo,n,k,alpha,A,lda,x,incx,beta,y,incy)
      use iso_c_binding
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocblas_dsbmv_rank_0
      type(c_ptr),value :: handle
      integer(kind(rocblas_fill_upper)),value :: uplo
      integer(c_int),value :: n
      integer(c_int),value :: k
      real(c_double) :: alpha
      real(c_double),target :: A
      integer(c_int),value :: lda
      real(c_double),target :: x
      integer(c_int),value :: incx
      real(c_double) :: beta
      real(c_double),target :: y
      integer(c_int),value :: incy
      !
      rocblas_dsbmv_rank_0 = rocblas_dsbmv_orig(handle,uplo,n,k,alpha,c_loc(A),lda,c_loc(x),incx,beta,c_loc(y),incy)
    end function

    function rocblas_dsbmv_rank_1(handle,uplo,n,k,alpha,A,lda,x,incx,beta,y,incy)
      use iso_c_binding
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocblas_dsbmv_rank_1
      type(c_ptr),value :: handle
      integer(kind(rocblas_fill_upper)),value :: uplo
      integer(c_int),value :: n
      integer(c_int),value :: k
      real(c_double) :: alpha
      real(c_double),target,dimension(:) :: A
      integer(c_int),value :: lda
      real(c_double),target,dimension(:) :: x
      integer(c_int),value :: incx
      real(c_double) :: beta
      real(c_double),target,dimension(:) :: y
      integer(c_int),value :: incy
      !
      rocblas_dsbmv_rank_1 = rocblas_dsbmv_orig(handle,uplo,n,k,alpha,c_loc(A),lda,c_loc(x),incx,beta,c_loc(y),incy)
    end function

    function rocblas_dsbmv_batched_full_rank(handle,uplo,n,k,alpha,A,lda,x,incx,beta,y,incy,batch_count)
      use iso_c_binding
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocblas_dsbmv_batched_full_rank
      type(c_ptr),value :: handle
      integer(kind(rocblas_fill_upper)),value :: uplo
      integer(c_int),value :: n
      integer(c_int),value :: k
      real(c_double) :: alpha
      real(c_double),target,dimension(:,:,:) :: A
      integer(c_int),value :: lda
      real(c_double),target,dimension(:,:) :: x
      integer(c_int),value :: incx
      real(c_double) :: beta
      real(c_double),target,dimension(:,:) :: y
      integer(c_int),value :: incy
      integer(c_int),value :: batch_count
      !
      rocblas_dsbmv_batched_full_rank = rocblas_dsbmv_batched_orig(handle,uplo,n,k,alpha,c_loc(A),lda,c_loc(x),incx,beta,c_loc(y),incy,batch_count)
    end function

    function rocblas_dsbmv_batched_rank_0(handle,uplo,n,k,alpha,A,lda,x,incx,beta,y,incy,batch_count)
      use iso_c_binding
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocblas_dsbmv_batched_rank_0
      type(c_ptr),value :: handle
      integer(kind(rocblas_fill_upper)),value :: uplo
      integer(c_int),value :: n
      integer(c_int),value :: k
      real(c_double) :: alpha
      real(c_double),target :: A
      integer(c_int),value :: lda
      real(c_double),target :: x
      integer(c_int),value :: incx
      real(c_double) :: beta
      real(c_double),target :: y
      integer(c_int),value :: incy
      integer(c_int),value :: batch_count
      !
      rocblas_dsbmv_batched_rank_0 = rocblas_dsbmv_batched_orig(handle,uplo,n,k,alpha,c_loc(A),lda,c_loc(x),incx,beta,c_loc(y),incy,batch_count)
    end function

    function rocblas_dsbmv_batched_rank_1(handle,uplo,n,k,alpha,A,lda,x,incx,beta,y,incy,batch_count)
      use iso_c_binding
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocblas_dsbmv_batched_rank_1
      type(c_ptr),value :: handle
      integer(kind(rocblas_fill_upper)),value :: uplo
      integer(c_int),value :: n
      integer(c_int),value :: k
      real(c_double) :: alpha
      real(c_double),target,dimension(:) :: A
      integer(c_int),value :: lda
      real(c_double),target,dimension(:) :: x
      integer(c_int),value :: incx
      real(c_double) :: beta
      real(c_double),target,dimension(:) :: y
      integer(c_int),value :: incy
      integer(c_int),value :: batch_count
      !
      rocblas_dsbmv_batched_rank_1 = rocblas_dsbmv_batched_orig(handle,uplo,n,k,alpha,c_loc(A),lda,c_loc(x),incx,beta,c_loc(y),incy,batch_count)
    end function

    function rocblas_ssbmv_batched_full_rank(handle,uplo,n,k,alpha,A,lda,x,incx,beta,y,incy,batch_count)
      use iso_c_binding
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocblas_ssbmv_batched_full_rank
      type(c_ptr),value :: handle
      integer(kind(rocblas_fill_upper)),value :: uplo
      integer(c_int),value :: n
      integer(c_int),value :: k
      real(c_float) :: alpha
      real(c_float),target,dimension(:,:,:) :: A
      integer(c_int),value :: lda
      real(c_float),target,dimension(:,:) :: x
      integer(c_int),value :: incx
      real(c_float) :: beta
      real(c_float),target,dimension(:,:) :: y
      integer(c_int),value :: incy
      integer(c_int),value :: batch_count
      !
      rocblas_ssbmv_batched_full_rank = rocblas_ssbmv_batched_orig(handle,uplo,n,k,alpha,c_loc(A),lda,c_loc(x),incx,beta,c_loc(y),incy,batch_count)
    end function

    function rocblas_ssbmv_batched_rank_0(handle,uplo,n,k,alpha,A,lda,x,incx,beta,y,incy,batch_count)
      use iso_c_binding
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocblas_ssbmv_batched_rank_0
      type(c_ptr),value :: handle
      integer(kind(rocblas_fill_upper)),value :: uplo
      integer(c_int),value :: n
      integer(c_int),value :: k
      real(c_float) :: alpha
      real(c_float),target :: A
      integer(c_int),value :: lda
      real(c_float),target :: x
      integer(c_int),value :: incx
      real(c_float) :: beta
      real(c_float),target :: y
      integer(c_int),value :: incy
      integer(c_int),value :: batch_count
      !
      rocblas_ssbmv_batched_rank_0 = rocblas_ssbmv_batched_orig(handle,uplo,n,k,alpha,c_loc(A),lda,c_loc(x),incx,beta,c_loc(y),incy,batch_count)
    end function

    function rocblas_ssbmv_batched_rank_1(handle,uplo,n,k,alpha,A,lda,x,incx,beta,y,incy,batch_count)
      use iso_c_binding
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocblas_ssbmv_batched_rank_1
      type(c_ptr),value :: handle
      integer(kind(rocblas_fill_upper)),value :: uplo
      integer(c_int),value :: n
      integer(c_int),value :: k
      real(c_float) :: alpha
      real(c_float),target,dimension(:) :: A
      integer(c_int),value :: lda
      real(c_float),target,dimension(:) :: x
      integer(c_int),value :: incx
      real(c_float) :: beta
      real(c_float),target,dimension(:) :: y
      integer(c_int),value :: incy
      integer(c_int),value :: batch_count
      !
      rocblas_ssbmv_batched_rank_1 = rocblas_ssbmv_batched_orig(handle,uplo,n,k,alpha,c_loc(A),lda,c_loc(x),incx,beta,c_loc(y),incy,batch_count)
    end function

    function rocblas_ssbmv_strided_batched_full_rank(handle,uplo,n,k,alpha,A,lda,strideA,x,incx,stridex,beta,y,incy,stridey,batch_count)
      use iso_c_binding
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocblas_ssbmv_strided_batched_full_rank
      type(c_ptr),value :: handle
      integer(kind(rocblas_fill_upper)),value :: uplo
      integer(c_int),value :: n
      integer(c_int),value :: k
      real(c_float) :: alpha
      real(c_float),target,dimension(:,:) :: A
      integer(c_int),value :: lda
      integer(c_int64_t),value :: strideA
      real(c_float),target,dimension(:) :: x
      integer(c_int),value :: incx
      integer(c_int64_t),value :: stridex
      real(c_float) :: beta
      real(c_float),target,dimension(:) :: y
      integer(c_int),value :: incy
      integer(c_int64_t),value :: stridey
      integer(c_int),value :: batch_count
      !
      rocblas_ssbmv_strided_batched_full_rank = rocblas_ssbmv_strided_batched_orig(handle,uplo,n,k,alpha,c_loc(A),lda,strideA,c_loc(x),incx,stridex,beta,c_loc(y),incy,stridey,batch_count)
    end function

    function rocblas_ssbmv_strided_batched_rank_0(handle,uplo,n,k,alpha,A,lda,strideA,x,incx,stridex,beta,y,incy,stridey,batch_count)
      use iso_c_binding
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocblas_ssbmv_strided_batched_rank_0
      type(c_ptr),value :: handle
      integer(kind(rocblas_fill_upper)),value :: uplo
      integer(c_int),value :: n
      integer(c_int),value :: k
      real(c_float) :: alpha
      real(c_float),target :: A
      integer(c_int),value :: lda
      integer(c_int64_t),value :: strideA
      real(c_float),target :: x
      integer(c_int),value :: incx
      integer(c_int64_t),value :: stridex
      real(c_float) :: beta
      real(c_float),target :: y
      integer(c_int),value :: incy
      integer(c_int64_t),value :: stridey
      integer(c_int),value :: batch_count
      !
      rocblas_ssbmv_strided_batched_rank_0 = rocblas_ssbmv_strided_batched_orig(handle,uplo,n,k,alpha,c_loc(A),lda,strideA,c_loc(x),incx,stridex,beta,c_loc(y),incy,stridey,batch_count)
    end function

    function rocblas_ssbmv_strided_batched_rank_1(handle,uplo,n,k,alpha,A,lda,strideA,x,incx,stridex,beta,y,incy,stridey,batch_count)
      use iso_c_binding
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocblas_ssbmv_strided_batched_rank_1
      type(c_ptr),value :: handle
      integer(kind(rocblas_fill_upper)),value :: uplo
      integer(c_int),value :: n
      integer(c_int),value :: k
      real(c_float) :: alpha
      real(c_float),target,dimension(:) :: A
      integer(c_int),value :: lda
      integer(c_int64_t),value :: strideA
      real(c_float),target,dimension(:) :: x
      integer(c_int),value :: incx
      integer(c_int64_t),value :: stridex
      real(c_float) :: beta
      real(c_float),target,dimension(:) :: y
      integer(c_int),value :: incy
      integer(c_int64_t),value :: stridey
      integer(c_int),value :: batch_count
      !
      rocblas_ssbmv_strided_batched_rank_1 = rocblas_ssbmv_strided_batched_orig(handle,uplo,n,k,alpha,c_loc(A),lda,strideA,c_loc(x),incx,stridex,beta,c_loc(y),incy,stridey,batch_count)
    end function

    function rocblas_dsbmv_strided_batched_full_rank(handle,uplo,n,k,alpha,A,lda,strideA,x,incx,stridex,beta,y,incy,stridey,batch_count)
      use iso_c_binding
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocblas_dsbmv_strided_batched_full_rank
      type(c_ptr),value :: handle
      integer(kind(rocblas_fill_upper)),value :: uplo
      integer(c_int),value :: n
      integer(c_int),value :: k
      real(c_double) :: alpha
      real(c_double),target,dimension(:,:) :: A
      integer(c_int),value :: lda
      integer(c_int64_t),value :: strideA
      real(c_double),target,dimension(:) :: x
      integer(c_int),value :: incx
      integer(c_int64_t),value :: stridex
      real(c_double) :: beta
      real(c_double),target,dimension(:) :: y
      integer(c_int),value :: incy
      integer(c_int64_t),value :: stridey
      integer(c_int),value :: batch_count
      !
      rocblas_dsbmv_strided_batched_full_rank = rocblas_dsbmv_strided_batched_orig(handle,uplo,n,k,alpha,c_loc(A),lda,strideA,c_loc(x),incx,stridex,beta,c_loc(y),incy,stridey,batch_count)
    end function

    function rocblas_dsbmv_strided_batched_rank_0(handle,uplo,n,k,alpha,A,lda,strideA,x,incx,stridex,beta,y,incy,stridey,batch_count)
      use iso_c_binding
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocblas_dsbmv_strided_batched_rank_0
      type(c_ptr),value :: handle
      integer(kind(rocblas_fill_upper)),value :: uplo
      integer(c_int),value :: n
      integer(c_int),value :: k
      real(c_double) :: alpha
      real(c_double),target :: A
      integer(c_int),value :: lda
      integer(c_int64_t),value :: strideA
      real(c_double),target :: x
      integer(c_int),value :: incx
      integer(c_int64_t),value :: stridex
      real(c_double) :: beta
      real(c_double),target :: y
      integer(c_int),value :: incy
      integer(c_int64_t),value :: stridey
      integer(c_int),value :: batch_count
      !
      rocblas_dsbmv_strided_batched_rank_0 = rocblas_dsbmv_strided_batched_orig(handle,uplo,n,k,alpha,c_loc(A),lda,strideA,c_loc(x),incx,stridex,beta,c_loc(y),incy,stridey,batch_count)
    end function

    function rocblas_dsbmv_strided_batched_rank_1(handle,uplo,n,k,alpha,A,lda,strideA,x,incx,stridex,beta,y,incy,stridey,batch_count)
      use iso_c_binding
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocblas_dsbmv_strided_batched_rank_1
      type(c_ptr),value :: handle
      integer(kind(rocblas_fill_upper)),value :: uplo
      integer(c_int),value :: n
      integer(c_int),value :: k
      real(c_double) :: alpha
      real(c_double),target,dimension(:) :: A
      integer(c_int),value :: lda
      integer(c_int64_t),value :: strideA
      real(c_double),target,dimension(:) :: x
      integer(c_int),value :: incx
      integer(c_int64_t),value :: stridex
      real(c_double) :: beta
      real(c_double),target,dimension(:) :: y
      integer(c_int),value :: incy
      integer(c_int64_t),value :: stridey
      integer(c_int),value :: batch_count
      !
      rocblas_dsbmv_strided_batched_rank_1 = rocblas_dsbmv_strided_batched_orig(handle,uplo,n,k,alpha,c_loc(A),lda,strideA,c_loc(x),incx,stridex,beta,c_loc(y),incy,stridey,batch_count)
    end function

    function rocblas_sger_full_rank(handle,m,n,alpha,x,incx,y,incy,A,lda)
      use iso_c_binding
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocblas_sger_full_rank
      type(c_ptr),value :: handle
      integer(c_int),value :: m
      integer(c_int),value :: n
      real(c_float) :: alpha
      real(c_float),target,dimension(:) :: x
      integer(c_int),value :: incx
      real(c_float),target,dimension(:) :: y
      integer(c_int),value :: incy
      real(c_float),target,dimension(:,:) :: A
      integer(c_int),value :: lda
      !
      rocblas_sger_full_rank = rocblas_sger_orig(handle,m,n,alpha,c_loc(x),incx,c_loc(y),incy,c_loc(A),lda)
    end function

    function rocblas_sger_rank_0(handle,m,n,alpha,x,incx,y,incy,A,lda)
      use iso_c_binding
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocblas_sger_rank_0
      type(c_ptr),value :: handle
      integer(c_int),value :: m
      integer(c_int),value :: n
      real(c_float) :: alpha
      real(c_float),target :: x
      integer(c_int),value :: incx
      real(c_float),target :: y
      integer(c_int),value :: incy
      real(c_float),target :: A
      integer(c_int),value :: lda
      !
      rocblas_sger_rank_0 = rocblas_sger_orig(handle,m,n,alpha,c_loc(x),incx,c_loc(y),incy,c_loc(A),lda)
    end function

    function rocblas_sger_rank_1(handle,m,n,alpha,x,incx,y,incy,A,lda)
      use iso_c_binding
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocblas_sger_rank_1
      type(c_ptr),value :: handle
      integer(c_int),value :: m
      integer(c_int),value :: n
      real(c_float) :: alpha
      real(c_float),target,dimension(:) :: x
      integer(c_int),value :: incx
      real(c_float),target,dimension(:) :: y
      integer(c_int),value :: incy
      real(c_float),target,dimension(:) :: A
      integer(c_int),value :: lda
      !
      rocblas_sger_rank_1 = rocblas_sger_orig(handle,m,n,alpha,c_loc(x),incx,c_loc(y),incy,c_loc(A),lda)
    end function

    function rocblas_dger_full_rank(handle,m,n,alpha,x,incx,y,incy,A,lda)
      use iso_c_binding
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocblas_dger_full_rank
      type(c_ptr),value :: handle
      integer(c_int),value :: m
      integer(c_int),value :: n
      real(c_double) :: alpha
      real(c_double),target,dimension(:) :: x
      integer(c_int),value :: incx
      real(c_double),target,dimension(:) :: y
      integer(c_int),value :: incy
      real(c_double),target,dimension(:,:) :: A
      integer(c_int),value :: lda
      !
      rocblas_dger_full_rank = rocblas_dger_orig(handle,m,n,alpha,c_loc(x),incx,c_loc(y),incy,c_loc(A),lda)
    end function

    function rocblas_dger_rank_0(handle,m,n,alpha,x,incx,y,incy,A,lda)
      use iso_c_binding
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocblas_dger_rank_0
      type(c_ptr),value :: handle
      integer(c_int),value :: m
      integer(c_int),value :: n
      real(c_double) :: alpha
      real(c_double),target :: x
      integer(c_int),value :: incx
      real(c_double),target :: y
      integer(c_int),value :: incy
      real(c_double),target :: A
      integer(c_int),value :: lda
      !
      rocblas_dger_rank_0 = rocblas_dger_orig(handle,m,n,alpha,c_loc(x),incx,c_loc(y),incy,c_loc(A),lda)
    end function

    function rocblas_dger_rank_1(handle,m,n,alpha,x,incx,y,incy,A,lda)
      use iso_c_binding
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocblas_dger_rank_1
      type(c_ptr),value :: handle
      integer(c_int),value :: m
      integer(c_int),value :: n
      real(c_double) :: alpha
      real(c_double),target,dimension(:) :: x
      integer(c_int),value :: incx
      real(c_double),target,dimension(:) :: y
      integer(c_int),value :: incy
      real(c_double),target,dimension(:) :: A
      integer(c_int),value :: lda
      !
      rocblas_dger_rank_1 = rocblas_dger_orig(handle,m,n,alpha,c_loc(x),incx,c_loc(y),incy,c_loc(A),lda)
    end function

    function rocblas_cgeru_full_rank(handle,m,n,alpha,x,incx,y,incy,A,lda)
      use iso_c_binding
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocblas_cgeru_full_rank
      type(c_ptr),value :: handle
      integer(c_int),value :: m
      integer(c_int),value :: n
      complex(c_float_complex) :: alpha
      complex(c_float_complex),target,dimension(:) :: x
      integer(c_int),value :: incx
      complex(c_float_complex),target,dimension(:) :: y
      integer(c_int),value :: incy
      complex(c_float_complex),target,dimension(:,:) :: A
      integer(c_int),value :: lda
      !
      rocblas_cgeru_full_rank = rocblas_cgeru_orig(handle,m,n,alpha,c_loc(x),incx,c_loc(y),incy,c_loc(A),lda)
    end function

    function rocblas_cgeru_rank_0(handle,m,n,alpha,x,incx,y,incy,A,lda)
      use iso_c_binding
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocblas_cgeru_rank_0
      type(c_ptr),value :: handle
      integer(c_int),value :: m
      integer(c_int),value :: n
      complex(c_float_complex) :: alpha
      complex(c_float_complex),target :: x
      integer(c_int),value :: incx
      complex(c_float_complex),target :: y
      integer(c_int),value :: incy
      complex(c_float_complex),target :: A
      integer(c_int),value :: lda
      !
      rocblas_cgeru_rank_0 = rocblas_cgeru_orig(handle,m,n,alpha,c_loc(x),incx,c_loc(y),incy,c_loc(A),lda)
    end function

    function rocblas_cgeru_rank_1(handle,m,n,alpha,x,incx,y,incy,A,lda)
      use iso_c_binding
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocblas_cgeru_rank_1
      type(c_ptr),value :: handle
      integer(c_int),value :: m
      integer(c_int),value :: n
      complex(c_float_complex) :: alpha
      complex(c_float_complex),target,dimension(:) :: x
      integer(c_int),value :: incx
      complex(c_float_complex),target,dimension(:) :: y
      integer(c_int),value :: incy
      complex(c_float_complex),target,dimension(:) :: A
      integer(c_int),value :: lda
      !
      rocblas_cgeru_rank_1 = rocblas_cgeru_orig(handle,m,n,alpha,c_loc(x),incx,c_loc(y),incy,c_loc(A),lda)
    end function

    function rocblas_zgeru_full_rank(handle,m,n,alpha,x,incx,y,incy,A,lda)
      use iso_c_binding
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocblas_zgeru_full_rank
      type(c_ptr),value :: handle
      integer(c_int),value :: m
      integer(c_int),value :: n
      complex(c_double_complex) :: alpha
      complex(c_double_complex),target,dimension(:) :: x
      integer(c_int),value :: incx
      complex(c_double_complex),target,dimension(:) :: y
      integer(c_int),value :: incy
      complex(c_double_complex),target,dimension(:,:) :: A
      integer(c_int),value :: lda
      !
      rocblas_zgeru_full_rank = rocblas_zgeru_orig(handle,m,n,alpha,c_loc(x),incx,c_loc(y),incy,c_loc(A),lda)
    end function

    function rocblas_zgeru_rank_0(handle,m,n,alpha,x,incx,y,incy,A,lda)
      use iso_c_binding
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocblas_zgeru_rank_0
      type(c_ptr),value :: handle
      integer(c_int),value :: m
      integer(c_int),value :: n
      complex(c_double_complex) :: alpha
      complex(c_double_complex),target :: x
      integer(c_int),value :: incx
      complex(c_double_complex),target :: y
      integer(c_int),value :: incy
      complex(c_double_complex),target :: A
      integer(c_int),value :: lda
      !
      rocblas_zgeru_rank_0 = rocblas_zgeru_orig(handle,m,n,alpha,c_loc(x),incx,c_loc(y),incy,c_loc(A),lda)
    end function

    function rocblas_zgeru_rank_1(handle,m,n,alpha,x,incx,y,incy,A,lda)
      use iso_c_binding
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocblas_zgeru_rank_1
      type(c_ptr),value :: handle
      integer(c_int),value :: m
      integer(c_int),value :: n
      complex(c_double_complex) :: alpha
      complex(c_double_complex),target,dimension(:) :: x
      integer(c_int),value :: incx
      complex(c_double_complex),target,dimension(:) :: y
      integer(c_int),value :: incy
      complex(c_double_complex),target,dimension(:) :: A
      integer(c_int),value :: lda
      !
      rocblas_zgeru_rank_1 = rocblas_zgeru_orig(handle,m,n,alpha,c_loc(x),incx,c_loc(y),incy,c_loc(A),lda)
    end function

    function rocblas_cgerc_full_rank(handle,m,n,alpha,x,incx,y,incy,A,lda)
      use iso_c_binding
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocblas_cgerc_full_rank
      type(c_ptr),value :: handle
      integer(c_int),value :: m
      integer(c_int),value :: n
      complex(c_float_complex) :: alpha
      complex(c_float_complex),target,dimension(:) :: x
      integer(c_int),value :: incx
      complex(c_float_complex),target,dimension(:) :: y
      integer(c_int),value :: incy
      complex(c_float_complex),target,dimension(:,:) :: A
      integer(c_int),value :: lda
      !
      rocblas_cgerc_full_rank = rocblas_cgerc_orig(handle,m,n,alpha,c_loc(x),incx,c_loc(y),incy,c_loc(A),lda)
    end function

    function rocblas_cgerc_rank_0(handle,m,n,alpha,x,incx,y,incy,A,lda)
      use iso_c_binding
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocblas_cgerc_rank_0
      type(c_ptr),value :: handle
      integer(c_int),value :: m
      integer(c_int),value :: n
      complex(c_float_complex) :: alpha
      complex(c_float_complex),target :: x
      integer(c_int),value :: incx
      complex(c_float_complex),target :: y
      integer(c_int),value :: incy
      complex(c_float_complex),target :: A
      integer(c_int),value :: lda
      !
      rocblas_cgerc_rank_0 = rocblas_cgerc_orig(handle,m,n,alpha,c_loc(x),incx,c_loc(y),incy,c_loc(A),lda)
    end function

    function rocblas_cgerc_rank_1(handle,m,n,alpha,x,incx,y,incy,A,lda)
      use iso_c_binding
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocblas_cgerc_rank_1
      type(c_ptr),value :: handle
      integer(c_int),value :: m
      integer(c_int),value :: n
      complex(c_float_complex) :: alpha
      complex(c_float_complex),target,dimension(:) :: x
      integer(c_int),value :: incx
      complex(c_float_complex),target,dimension(:) :: y
      integer(c_int),value :: incy
      complex(c_float_complex),target,dimension(:) :: A
      integer(c_int),value :: lda
      !
      rocblas_cgerc_rank_1 = rocblas_cgerc_orig(handle,m,n,alpha,c_loc(x),incx,c_loc(y),incy,c_loc(A),lda)
    end function

    function rocblas_zgerc_full_rank(handle,m,n,alpha,x,incx,y,incy,A,lda)
      use iso_c_binding
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocblas_zgerc_full_rank
      type(c_ptr),value :: handle
      integer(c_int),value :: m
      integer(c_int),value :: n
      complex(c_double_complex) :: alpha
      complex(c_double_complex),target,dimension(:) :: x
      integer(c_int),value :: incx
      complex(c_double_complex),target,dimension(:) :: y
      integer(c_int),value :: incy
      complex(c_double_complex),target,dimension(:,:) :: A
      integer(c_int),value :: lda
      !
      rocblas_zgerc_full_rank = rocblas_zgerc_orig(handle,m,n,alpha,c_loc(x),incx,c_loc(y),incy,c_loc(A),lda)
    end function

    function rocblas_zgerc_rank_0(handle,m,n,alpha,x,incx,y,incy,A,lda)
      use iso_c_binding
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocblas_zgerc_rank_0
      type(c_ptr),value :: handle
      integer(c_int),value :: m
      integer(c_int),value :: n
      complex(c_double_complex) :: alpha
      complex(c_double_complex),target :: x
      integer(c_int),value :: incx
      complex(c_double_complex),target :: y
      integer(c_int),value :: incy
      complex(c_double_complex),target :: A
      integer(c_int),value :: lda
      !
      rocblas_zgerc_rank_0 = rocblas_zgerc_orig(handle,m,n,alpha,c_loc(x),incx,c_loc(y),incy,c_loc(A),lda)
    end function

    function rocblas_zgerc_rank_1(handle,m,n,alpha,x,incx,y,incy,A,lda)
      use iso_c_binding
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocblas_zgerc_rank_1
      type(c_ptr),value :: handle
      integer(c_int),value :: m
      integer(c_int),value :: n
      complex(c_double_complex) :: alpha
      complex(c_double_complex),target,dimension(:) :: x
      integer(c_int),value :: incx
      complex(c_double_complex),target,dimension(:) :: y
      integer(c_int),value :: incy
      complex(c_double_complex),target,dimension(:) :: A
      integer(c_int),value :: lda
      !
      rocblas_zgerc_rank_1 = rocblas_zgerc_orig(handle,m,n,alpha,c_loc(x),incx,c_loc(y),incy,c_loc(A),lda)
    end function

    function rocblas_sger_batched_full_rank(handle,m,n,alpha,x,incx,y,incy,A,lda,batch_count)
      use iso_c_binding
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocblas_sger_batched_full_rank
      type(c_ptr),value :: handle
      integer(c_int),value :: m
      integer(c_int),value :: n
      real(c_float) :: alpha
      real(c_float),target,dimension(:,:) :: x
      integer(c_int),value :: incx
      real(c_float),target,dimension(:,:) :: y
      integer(c_int),value :: incy
      real(c_float),target,dimension(:,:,:) :: A
      integer(c_int),value :: lda
      integer(c_int),value :: batch_count
      !
      rocblas_sger_batched_full_rank = rocblas_sger_batched_orig(handle,m,n,alpha,c_loc(x),incx,c_loc(y),incy,c_loc(A),lda,batch_count)
    end function

    function rocblas_sger_batched_rank_0(handle,m,n,alpha,x,incx,y,incy,A,lda,batch_count)
      use iso_c_binding
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocblas_sger_batched_rank_0
      type(c_ptr),value :: handle
      integer(c_int),value :: m
      integer(c_int),value :: n
      real(c_float) :: alpha
      real(c_float),target :: x
      integer(c_int),value :: incx
      real(c_float),target :: y
      integer(c_int),value :: incy
      real(c_float),target :: A
      integer(c_int),value :: lda
      integer(c_int),value :: batch_count
      !
      rocblas_sger_batched_rank_0 = rocblas_sger_batched_orig(handle,m,n,alpha,c_loc(x),incx,c_loc(y),incy,c_loc(A),lda,batch_count)
    end function

    function rocblas_sger_batched_rank_1(handle,m,n,alpha,x,incx,y,incy,A,lda,batch_count)
      use iso_c_binding
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocblas_sger_batched_rank_1
      type(c_ptr),value :: handle
      integer(c_int),value :: m
      integer(c_int),value :: n
      real(c_float) :: alpha
      real(c_float),target,dimension(:) :: x
      integer(c_int),value :: incx
      real(c_float),target,dimension(:) :: y
      integer(c_int),value :: incy
      real(c_float),target,dimension(:) :: A
      integer(c_int),value :: lda
      integer(c_int),value :: batch_count
      !
      rocblas_sger_batched_rank_1 = rocblas_sger_batched_orig(handle,m,n,alpha,c_loc(x),incx,c_loc(y),incy,c_loc(A),lda,batch_count)
    end function

    function rocblas_dger_batched_full_rank(handle,m,n,alpha,x,incx,y,incy,A,lda,batch_count)
      use iso_c_binding
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocblas_dger_batched_full_rank
      type(c_ptr),value :: handle
      integer(c_int),value :: m
      integer(c_int),value :: n
      real(c_double) :: alpha
      real(c_double),target,dimension(:,:) :: x
      integer(c_int),value :: incx
      real(c_double),target,dimension(:,:) :: y
      integer(c_int),value :: incy
      real(c_double),target,dimension(:,:,:) :: A
      integer(c_int),value :: lda
      integer(c_int),value :: batch_count
      !
      rocblas_dger_batched_full_rank = rocblas_dger_batched_orig(handle,m,n,alpha,c_loc(x),incx,c_loc(y),incy,c_loc(A),lda,batch_count)
    end function

    function rocblas_dger_batched_rank_0(handle,m,n,alpha,x,incx,y,incy,A,lda,batch_count)
      use iso_c_binding
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocblas_dger_batched_rank_0
      type(c_ptr),value :: handle
      integer(c_int),value :: m
      integer(c_int),value :: n
      real(c_double) :: alpha
      real(c_double),target :: x
      integer(c_int),value :: incx
      real(c_double),target :: y
      integer(c_int),value :: incy
      real(c_double),target :: A
      integer(c_int),value :: lda
      integer(c_int),value :: batch_count
      !
      rocblas_dger_batched_rank_0 = rocblas_dger_batched_orig(handle,m,n,alpha,c_loc(x),incx,c_loc(y),incy,c_loc(A),lda,batch_count)
    end function

    function rocblas_dger_batched_rank_1(handle,m,n,alpha,x,incx,y,incy,A,lda,batch_count)
      use iso_c_binding
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocblas_dger_batched_rank_1
      type(c_ptr),value :: handle
      integer(c_int),value :: m
      integer(c_int),value :: n
      real(c_double) :: alpha
      real(c_double),target,dimension(:) :: x
      integer(c_int),value :: incx
      real(c_double),target,dimension(:) :: y
      integer(c_int),value :: incy
      real(c_double),target,dimension(:) :: A
      integer(c_int),value :: lda
      integer(c_int),value :: batch_count
      !
      rocblas_dger_batched_rank_1 = rocblas_dger_batched_orig(handle,m,n,alpha,c_loc(x),incx,c_loc(y),incy,c_loc(A),lda,batch_count)
    end function

    function rocblas_cgeru_batched_full_rank(handle,m,n,alpha,x,incx,y,incy,A,lda,batch_count)
      use iso_c_binding
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocblas_cgeru_batched_full_rank
      type(c_ptr),value :: handle
      integer(c_int),value :: m
      integer(c_int),value :: n
      complex(c_float_complex) :: alpha
      complex(c_float_complex),target,dimension(:,:) :: x
      integer(c_int),value :: incx
      complex(c_float_complex),target,dimension(:,:) :: y
      integer(c_int),value :: incy
      complex(c_float_complex),target,dimension(:,:,:) :: A
      integer(c_int),value :: lda
      integer(c_int),value :: batch_count
      !
      rocblas_cgeru_batched_full_rank = rocblas_cgeru_batched_orig(handle,m,n,alpha,c_loc(x),incx,c_loc(y),incy,c_loc(A),lda,batch_count)
    end function

    function rocblas_cgeru_batched_rank_0(handle,m,n,alpha,x,incx,y,incy,A,lda,batch_count)
      use iso_c_binding
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocblas_cgeru_batched_rank_0
      type(c_ptr),value :: handle
      integer(c_int),value :: m
      integer(c_int),value :: n
      complex(c_float_complex) :: alpha
      complex(c_float_complex),target :: x
      integer(c_int),value :: incx
      complex(c_float_complex),target :: y
      integer(c_int),value :: incy
      complex(c_float_complex),target :: A
      integer(c_int),value :: lda
      integer(c_int),value :: batch_count
      !
      rocblas_cgeru_batched_rank_0 = rocblas_cgeru_batched_orig(handle,m,n,alpha,c_loc(x),incx,c_loc(y),incy,c_loc(A),lda,batch_count)
    end function

    function rocblas_cgeru_batched_rank_1(handle,m,n,alpha,x,incx,y,incy,A,lda,batch_count)
      use iso_c_binding
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocblas_cgeru_batched_rank_1
      type(c_ptr),value :: handle
      integer(c_int),value :: m
      integer(c_int),value :: n
      complex(c_float_complex) :: alpha
      complex(c_float_complex),target,dimension(:) :: x
      integer(c_int),value :: incx
      complex(c_float_complex),target,dimension(:) :: y
      integer(c_int),value :: incy
      complex(c_float_complex),target,dimension(:) :: A
      integer(c_int),value :: lda
      integer(c_int),value :: batch_count
      !
      rocblas_cgeru_batched_rank_1 = rocblas_cgeru_batched_orig(handle,m,n,alpha,c_loc(x),incx,c_loc(y),incy,c_loc(A),lda,batch_count)
    end function

    function rocblas_zgeru_batched_full_rank(handle,m,n,alpha,x,incx,y,incy,A,lda,batch_count)
      use iso_c_binding
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocblas_zgeru_batched_full_rank
      type(c_ptr),value :: handle
      integer(c_int),value :: m
      integer(c_int),value :: n
      complex(c_double_complex) :: alpha
      complex(c_double_complex),target,dimension(:,:) :: x
      integer(c_int),value :: incx
      complex(c_double_complex),target,dimension(:,:) :: y
      integer(c_int),value :: incy
      complex(c_double_complex),target,dimension(:,:,:) :: A
      integer(c_int),value :: lda
      integer(c_int),value :: batch_count
      !
      rocblas_zgeru_batched_full_rank = rocblas_zgeru_batched_orig(handle,m,n,alpha,c_loc(x),incx,c_loc(y),incy,c_loc(A),lda,batch_count)
    end function

    function rocblas_zgeru_batched_rank_0(handle,m,n,alpha,x,incx,y,incy,A,lda,batch_count)
      use iso_c_binding
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocblas_zgeru_batched_rank_0
      type(c_ptr),value :: handle
      integer(c_int),value :: m
      integer(c_int),value :: n
      complex(c_double_complex) :: alpha
      complex(c_double_complex),target :: x
      integer(c_int),value :: incx
      complex(c_double_complex),target :: y
      integer(c_int),value :: incy
      complex(c_double_complex),target :: A
      integer(c_int),value :: lda
      integer(c_int),value :: batch_count
      !
      rocblas_zgeru_batched_rank_0 = rocblas_zgeru_batched_orig(handle,m,n,alpha,c_loc(x),incx,c_loc(y),incy,c_loc(A),lda,batch_count)
    end function

    function rocblas_zgeru_batched_rank_1(handle,m,n,alpha,x,incx,y,incy,A,lda,batch_count)
      use iso_c_binding
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocblas_zgeru_batched_rank_1
      type(c_ptr),value :: handle
      integer(c_int),value :: m
      integer(c_int),value :: n
      complex(c_double_complex) :: alpha
      complex(c_double_complex),target,dimension(:) :: x
      integer(c_int),value :: incx
      complex(c_double_complex),target,dimension(:) :: y
      integer(c_int),value :: incy
      complex(c_double_complex),target,dimension(:) :: A
      integer(c_int),value :: lda
      integer(c_int),value :: batch_count
      !
      rocblas_zgeru_batched_rank_1 = rocblas_zgeru_batched_orig(handle,m,n,alpha,c_loc(x),incx,c_loc(y),incy,c_loc(A),lda,batch_count)
    end function

    function rocblas_cgerc_batched_full_rank(handle,m,n,alpha,x,incx,y,incy,A,lda,batch_count)
      use iso_c_binding
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocblas_cgerc_batched_full_rank
      type(c_ptr),value :: handle
      integer(c_int),value :: m
      integer(c_int),value :: n
      complex(c_float_complex) :: alpha
      complex(c_float_complex),target,dimension(:,:) :: x
      integer(c_int),value :: incx
      complex(c_float_complex),target,dimension(:,:) :: y
      integer(c_int),value :: incy
      complex(c_float_complex),target,dimension(:,:,:) :: A
      integer(c_int),value :: lda
      integer(c_int),value :: batch_count
      !
      rocblas_cgerc_batched_full_rank = rocblas_cgerc_batched_orig(handle,m,n,alpha,c_loc(x),incx,c_loc(y),incy,c_loc(A),lda,batch_count)
    end function

    function rocblas_cgerc_batched_rank_0(handle,m,n,alpha,x,incx,y,incy,A,lda,batch_count)
      use iso_c_binding
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocblas_cgerc_batched_rank_0
      type(c_ptr),value :: handle
      integer(c_int),value :: m
      integer(c_int),value :: n
      complex(c_float_complex) :: alpha
      complex(c_float_complex),target :: x
      integer(c_int),value :: incx
      complex(c_float_complex),target :: y
      integer(c_int),value :: incy
      complex(c_float_complex),target :: A
      integer(c_int),value :: lda
      integer(c_int),value :: batch_count
      !
      rocblas_cgerc_batched_rank_0 = rocblas_cgerc_batched_orig(handle,m,n,alpha,c_loc(x),incx,c_loc(y),incy,c_loc(A),lda,batch_count)
    end function

    function rocblas_cgerc_batched_rank_1(handle,m,n,alpha,x,incx,y,incy,A,lda,batch_count)
      use iso_c_binding
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocblas_cgerc_batched_rank_1
      type(c_ptr),value :: handle
      integer(c_int),value :: m
      integer(c_int),value :: n
      complex(c_float_complex) :: alpha
      complex(c_float_complex),target,dimension(:) :: x
      integer(c_int),value :: incx
      complex(c_float_complex),target,dimension(:) :: y
      integer(c_int),value :: incy
      complex(c_float_complex),target,dimension(:) :: A
      integer(c_int),value :: lda
      integer(c_int),value :: batch_count
      !
      rocblas_cgerc_batched_rank_1 = rocblas_cgerc_batched_orig(handle,m,n,alpha,c_loc(x),incx,c_loc(y),incy,c_loc(A),lda,batch_count)
    end function

    function rocblas_zgerc_batched_full_rank(handle,m,n,alpha,x,incx,y,incy,A,lda,batch_count)
      use iso_c_binding
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocblas_zgerc_batched_full_rank
      type(c_ptr),value :: handle
      integer(c_int),value :: m
      integer(c_int),value :: n
      complex(c_double_complex) :: alpha
      complex(c_double_complex),target,dimension(:,:) :: x
      integer(c_int),value :: incx
      complex(c_double_complex),target,dimension(:,:) :: y
      integer(c_int),value :: incy
      complex(c_double_complex),target,dimension(:,:,:) :: A
      integer(c_int),value :: lda
      integer(c_int),value :: batch_count
      !
      rocblas_zgerc_batched_full_rank = rocblas_zgerc_batched_orig(handle,m,n,alpha,c_loc(x),incx,c_loc(y),incy,c_loc(A),lda,batch_count)
    end function

    function rocblas_zgerc_batched_rank_0(handle,m,n,alpha,x,incx,y,incy,A,lda,batch_count)
      use iso_c_binding
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocblas_zgerc_batched_rank_0
      type(c_ptr),value :: handle
      integer(c_int),value :: m
      integer(c_int),value :: n
      complex(c_double_complex) :: alpha
      complex(c_double_complex),target :: x
      integer(c_int),value :: incx
      complex(c_double_complex),target :: y
      integer(c_int),value :: incy
      complex(c_double_complex),target :: A
      integer(c_int),value :: lda
      integer(c_int),value :: batch_count
      !
      rocblas_zgerc_batched_rank_0 = rocblas_zgerc_batched_orig(handle,m,n,alpha,c_loc(x),incx,c_loc(y),incy,c_loc(A),lda,batch_count)
    end function

    function rocblas_zgerc_batched_rank_1(handle,m,n,alpha,x,incx,y,incy,A,lda,batch_count)
      use iso_c_binding
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocblas_zgerc_batched_rank_1
      type(c_ptr),value :: handle
      integer(c_int),value :: m
      integer(c_int),value :: n
      complex(c_double_complex) :: alpha
      complex(c_double_complex),target,dimension(:) :: x
      integer(c_int),value :: incx
      complex(c_double_complex),target,dimension(:) :: y
      integer(c_int),value :: incy
      complex(c_double_complex),target,dimension(:) :: A
      integer(c_int),value :: lda
      integer(c_int),value :: batch_count
      !
      rocblas_zgerc_batched_rank_1 = rocblas_zgerc_batched_orig(handle,m,n,alpha,c_loc(x),incx,c_loc(y),incy,c_loc(A),lda,batch_count)
    end function

    function rocblas_sger_strided_batched_full_rank(handle,m,n,alpha,x,incx,stridex,y,incy,stridey,A,lda,strideA,batch_count)
      use iso_c_binding
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocblas_sger_strided_batched_full_rank
      type(c_ptr),value :: handle
      integer(c_int),value :: m
      integer(c_int),value :: n
      real(c_float) :: alpha
      real(c_float),target,dimension(:) :: x
      integer(c_int),value :: incx
      integer(c_int64_t),value :: stridex
      real(c_float),target,dimension(:) :: y
      integer(c_int),value :: incy
      integer(c_int64_t),value :: stridey
      real(c_float),target,dimension(:,:) :: A
      integer(c_int),value :: lda
      integer(c_int64_t),value :: strideA
      integer(c_int),value :: batch_count
      !
      rocblas_sger_strided_batched_full_rank = rocblas_sger_strided_batched_orig(handle,m,n,alpha,c_loc(x),incx,stridex,c_loc(y),incy,stridey,c_loc(A),lda,strideA,batch_count)
    end function

    function rocblas_sger_strided_batched_rank_0(handle,m,n,alpha,x,incx,stridex,y,incy,stridey,A,lda,strideA,batch_count)
      use iso_c_binding
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocblas_sger_strided_batched_rank_0
      type(c_ptr),value :: handle
      integer(c_int),value :: m
      integer(c_int),value :: n
      real(c_float) :: alpha
      real(c_float),target :: x
      integer(c_int),value :: incx
      integer(c_int64_t),value :: stridex
      real(c_float),target :: y
      integer(c_int),value :: incy
      integer(c_int64_t),value :: stridey
      real(c_float),target :: A
      integer(c_int),value :: lda
      integer(c_int64_t),value :: strideA
      integer(c_int),value :: batch_count
      !
      rocblas_sger_strided_batched_rank_0 = rocblas_sger_strided_batched_orig(handle,m,n,alpha,c_loc(x),incx,stridex,c_loc(y),incy,stridey,c_loc(A),lda,strideA,batch_count)
    end function

    function rocblas_sger_strided_batched_rank_1(handle,m,n,alpha,x,incx,stridex,y,incy,stridey,A,lda,strideA,batch_count)
      use iso_c_binding
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocblas_sger_strided_batched_rank_1
      type(c_ptr),value :: handle
      integer(c_int),value :: m
      integer(c_int),value :: n
      real(c_float) :: alpha
      real(c_float),target,dimension(:) :: x
      integer(c_int),value :: incx
      integer(c_int64_t),value :: stridex
      real(c_float),target,dimension(:) :: y
      integer(c_int),value :: incy
      integer(c_int64_t),value :: stridey
      real(c_float),target,dimension(:) :: A
      integer(c_int),value :: lda
      integer(c_int64_t),value :: strideA
      integer(c_int),value :: batch_count
      !
      rocblas_sger_strided_batched_rank_1 = rocblas_sger_strided_batched_orig(handle,m,n,alpha,c_loc(x),incx,stridex,c_loc(y),incy,stridey,c_loc(A),lda,strideA,batch_count)
    end function

    function rocblas_dger_strided_batched_full_rank(handle,m,n,alpha,x,incx,stridex,y,incy,stridey,A,lda,strideA,batch_count)
      use iso_c_binding
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocblas_dger_strided_batched_full_rank
      type(c_ptr),value :: handle
      integer(c_int),value :: m
      integer(c_int),value :: n
      real(c_double) :: alpha
      real(c_double),target,dimension(:) :: x
      integer(c_int),value :: incx
      integer(c_int64_t),value :: stridex
      real(c_double),target,dimension(:) :: y
      integer(c_int),value :: incy
      integer(c_int64_t),value :: stridey
      real(c_double),target,dimension(:,:) :: A
      integer(c_int),value :: lda
      integer(c_int64_t),value :: strideA
      integer(c_int),value :: batch_count
      !
      rocblas_dger_strided_batched_full_rank = rocblas_dger_strided_batched_orig(handle,m,n,alpha,c_loc(x),incx,stridex,c_loc(y),incy,stridey,c_loc(A),lda,strideA,batch_count)
    end function

    function rocblas_dger_strided_batched_rank_0(handle,m,n,alpha,x,incx,stridex,y,incy,stridey,A,lda,strideA,batch_count)
      use iso_c_binding
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocblas_dger_strided_batched_rank_0
      type(c_ptr),value :: handle
      integer(c_int),value :: m
      integer(c_int),value :: n
      real(c_double) :: alpha
      real(c_double),target :: x
      integer(c_int),value :: incx
      integer(c_int64_t),value :: stridex
      real(c_double),target :: y
      integer(c_int),value :: incy
      integer(c_int64_t),value :: stridey
      real(c_double),target :: A
      integer(c_int),value :: lda
      integer(c_int64_t),value :: strideA
      integer(c_int),value :: batch_count
      !
      rocblas_dger_strided_batched_rank_0 = rocblas_dger_strided_batched_orig(handle,m,n,alpha,c_loc(x),incx,stridex,c_loc(y),incy,stridey,c_loc(A),lda,strideA,batch_count)
    end function

    function rocblas_dger_strided_batched_rank_1(handle,m,n,alpha,x,incx,stridex,y,incy,stridey,A,lda,strideA,batch_count)
      use iso_c_binding
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocblas_dger_strided_batched_rank_1
      type(c_ptr),value :: handle
      integer(c_int),value :: m
      integer(c_int),value :: n
      real(c_double) :: alpha
      real(c_double),target,dimension(:) :: x
      integer(c_int),value :: incx
      integer(c_int64_t),value :: stridex
      real(c_double),target,dimension(:) :: y
      integer(c_int),value :: incy
      integer(c_int64_t),value :: stridey
      real(c_double),target,dimension(:) :: A
      integer(c_int),value :: lda
      integer(c_int64_t),value :: strideA
      integer(c_int),value :: batch_count
      !
      rocblas_dger_strided_batched_rank_1 = rocblas_dger_strided_batched_orig(handle,m,n,alpha,c_loc(x),incx,stridex,c_loc(y),incy,stridey,c_loc(A),lda,strideA,batch_count)
    end function

    function rocblas_cgeru_strided_batched_full_rank(handle,m,n,alpha,x,incx,stridex,y,incy,stridey,A,lda,strideA,batch_count)
      use iso_c_binding
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocblas_cgeru_strided_batched_full_rank
      type(c_ptr),value :: handle
      integer(c_int),value :: m
      integer(c_int),value :: n
      complex(c_float_complex) :: alpha
      complex(c_float_complex),target,dimension(:) :: x
      integer(c_int),value :: incx
      integer(c_int64_t),value :: stridex
      complex(c_float_complex),target,dimension(:) :: y
      integer(c_int),value :: incy
      integer(c_int64_t),value :: stridey
      complex(c_float_complex),target,dimension(:,:) :: A
      integer(c_int),value :: lda
      integer(c_int64_t),value :: strideA
      integer(c_int),value :: batch_count
      !
      rocblas_cgeru_strided_batched_full_rank = rocblas_cgeru_strided_batched_orig(handle,m,n,alpha,c_loc(x),incx,stridex,c_loc(y),incy,stridey,c_loc(A),lda,strideA,batch_count)
    end function

    function rocblas_cgeru_strided_batched_rank_0(handle,m,n,alpha,x,incx,stridex,y,incy,stridey,A,lda,strideA,batch_count)
      use iso_c_binding
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocblas_cgeru_strided_batched_rank_0
      type(c_ptr),value :: handle
      integer(c_int),value :: m
      integer(c_int),value :: n
      complex(c_float_complex) :: alpha
      complex(c_float_complex),target :: x
      integer(c_int),value :: incx
      integer(c_int64_t),value :: stridex
      complex(c_float_complex),target :: y
      integer(c_int),value :: incy
      integer(c_int64_t),value :: stridey
      complex(c_float_complex),target :: A
      integer(c_int),value :: lda
      integer(c_int64_t),value :: strideA
      integer(c_int),value :: batch_count
      !
      rocblas_cgeru_strided_batched_rank_0 = rocblas_cgeru_strided_batched_orig(handle,m,n,alpha,c_loc(x),incx,stridex,c_loc(y),incy,stridey,c_loc(A),lda,strideA,batch_count)
    end function

    function rocblas_cgeru_strided_batched_rank_1(handle,m,n,alpha,x,incx,stridex,y,incy,stridey,A,lda,strideA,batch_count)
      use iso_c_binding
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocblas_cgeru_strided_batched_rank_1
      type(c_ptr),value :: handle
      integer(c_int),value :: m
      integer(c_int),value :: n
      complex(c_float_complex) :: alpha
      complex(c_float_complex),target,dimension(:) :: x
      integer(c_int),value :: incx
      integer(c_int64_t),value :: stridex
      complex(c_float_complex),target,dimension(:) :: y
      integer(c_int),value :: incy
      integer(c_int64_t),value :: stridey
      complex(c_float_complex),target,dimension(:) :: A
      integer(c_int),value :: lda
      integer(c_int64_t),value :: strideA
      integer(c_int),value :: batch_count
      !
      rocblas_cgeru_strided_batched_rank_1 = rocblas_cgeru_strided_batched_orig(handle,m,n,alpha,c_loc(x),incx,stridex,c_loc(y),incy,stridey,c_loc(A),lda,strideA,batch_count)
    end function

    function rocblas_zgeru_strided_batched_full_rank(handle,m,n,alpha,x,incx,stridex,y,incy,stridey,A,lda,strideA,batch_count)
      use iso_c_binding
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocblas_zgeru_strided_batched_full_rank
      type(c_ptr),value :: handle
      integer(c_int),value :: m
      integer(c_int),value :: n
      complex(c_double_complex) :: alpha
      complex(c_double_complex),target,dimension(:) :: x
      integer(c_int),value :: incx
      integer(c_int64_t),value :: stridex
      complex(c_double_complex),target,dimension(:) :: y
      integer(c_int),value :: incy
      integer(c_int64_t),value :: stridey
      complex(c_double_complex),target,dimension(:,:) :: A
      integer(c_int),value :: lda
      integer(c_int64_t),value :: strideA
      integer(c_int),value :: batch_count
      !
      rocblas_zgeru_strided_batched_full_rank = rocblas_zgeru_strided_batched_orig(handle,m,n,alpha,c_loc(x),incx,stridex,c_loc(y),incy,stridey,c_loc(A),lda,strideA,batch_count)
    end function

    function rocblas_zgeru_strided_batched_rank_0(handle,m,n,alpha,x,incx,stridex,y,incy,stridey,A,lda,strideA,batch_count)
      use iso_c_binding
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocblas_zgeru_strided_batched_rank_0
      type(c_ptr),value :: handle
      integer(c_int),value :: m
      integer(c_int),value :: n
      complex(c_double_complex) :: alpha
      complex(c_double_complex),target :: x
      integer(c_int),value :: incx
      integer(c_int64_t),value :: stridex
      complex(c_double_complex),target :: y
      integer(c_int),value :: incy
      integer(c_int64_t),value :: stridey
      complex(c_double_complex),target :: A
      integer(c_int),value :: lda
      integer(c_int64_t),value :: strideA
      integer(c_int),value :: batch_count
      !
      rocblas_zgeru_strided_batched_rank_0 = rocblas_zgeru_strided_batched_orig(handle,m,n,alpha,c_loc(x),incx,stridex,c_loc(y),incy,stridey,c_loc(A),lda,strideA,batch_count)
    end function

    function rocblas_zgeru_strided_batched_rank_1(handle,m,n,alpha,x,incx,stridex,y,incy,stridey,A,lda,strideA,batch_count)
      use iso_c_binding
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocblas_zgeru_strided_batched_rank_1
      type(c_ptr),value :: handle
      integer(c_int),value :: m
      integer(c_int),value :: n
      complex(c_double_complex) :: alpha
      complex(c_double_complex),target,dimension(:) :: x
      integer(c_int),value :: incx
      integer(c_int64_t),value :: stridex
      complex(c_double_complex),target,dimension(:) :: y
      integer(c_int),value :: incy
      integer(c_int64_t),value :: stridey
      complex(c_double_complex),target,dimension(:) :: A
      integer(c_int),value :: lda
      integer(c_int64_t),value :: strideA
      integer(c_int),value :: batch_count
      !
      rocblas_zgeru_strided_batched_rank_1 = rocblas_zgeru_strided_batched_orig(handle,m,n,alpha,c_loc(x),incx,stridex,c_loc(y),incy,stridey,c_loc(A),lda,strideA,batch_count)
    end function

    function rocblas_cgerc_strided_batched_full_rank(handle,m,n,alpha,x,incx,stridex,y,incy,stridey,A,lda,strideA,batch_count)
      use iso_c_binding
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocblas_cgerc_strided_batched_full_rank
      type(c_ptr),value :: handle
      integer(c_int),value :: m
      integer(c_int),value :: n
      complex(c_float_complex) :: alpha
      complex(c_float_complex),target,dimension(:) :: x
      integer(c_int),value :: incx
      integer(c_int64_t),value :: stridex
      complex(c_float_complex),target,dimension(:) :: y
      integer(c_int),value :: incy
      integer(c_int64_t),value :: stridey
      complex(c_float_complex),target,dimension(:,:) :: A
      integer(c_int),value :: lda
      integer(c_int64_t),value :: strideA
      integer(c_int),value :: batch_count
      !
      rocblas_cgerc_strided_batched_full_rank = rocblas_cgerc_strided_batched_orig(handle,m,n,alpha,c_loc(x),incx,stridex,c_loc(y),incy,stridey,c_loc(A),lda,strideA,batch_count)
    end function

    function rocblas_cgerc_strided_batched_rank_0(handle,m,n,alpha,x,incx,stridex,y,incy,stridey,A,lda,strideA,batch_count)
      use iso_c_binding
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocblas_cgerc_strided_batched_rank_0
      type(c_ptr),value :: handle
      integer(c_int),value :: m
      integer(c_int),value :: n
      complex(c_float_complex) :: alpha
      complex(c_float_complex),target :: x
      integer(c_int),value :: incx
      integer(c_int64_t),value :: stridex
      complex(c_float_complex),target :: y
      integer(c_int),value :: incy
      integer(c_int64_t),value :: stridey
      complex(c_float_complex),target :: A
      integer(c_int),value :: lda
      integer(c_int64_t),value :: strideA
      integer(c_int),value :: batch_count
      !
      rocblas_cgerc_strided_batched_rank_0 = rocblas_cgerc_strided_batched_orig(handle,m,n,alpha,c_loc(x),incx,stridex,c_loc(y),incy,stridey,c_loc(A),lda,strideA,batch_count)
    end function

    function rocblas_cgerc_strided_batched_rank_1(handle,m,n,alpha,x,incx,stridex,y,incy,stridey,A,lda,strideA,batch_count)
      use iso_c_binding
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocblas_cgerc_strided_batched_rank_1
      type(c_ptr),value :: handle
      integer(c_int),value :: m
      integer(c_int),value :: n
      complex(c_float_complex) :: alpha
      complex(c_float_complex),target,dimension(:) :: x
      integer(c_int),value :: incx
      integer(c_int64_t),value :: stridex
      complex(c_float_complex),target,dimension(:) :: y
      integer(c_int),value :: incy
      integer(c_int64_t),value :: stridey
      complex(c_float_complex),target,dimension(:) :: A
      integer(c_int),value :: lda
      integer(c_int64_t),value :: strideA
      integer(c_int),value :: batch_count
      !
      rocblas_cgerc_strided_batched_rank_1 = rocblas_cgerc_strided_batched_orig(handle,m,n,alpha,c_loc(x),incx,stridex,c_loc(y),incy,stridey,c_loc(A),lda,strideA,batch_count)
    end function

    function rocblas_zgerc_strided_batched_full_rank(handle,m,n,alpha,x,incx,stridex,y,incy,stridey,A,lda,strideA,batch_count)
      use iso_c_binding
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocblas_zgerc_strided_batched_full_rank
      type(c_ptr),value :: handle
      integer(c_int),value :: m
      integer(c_int),value :: n
      complex(c_double_complex) :: alpha
      complex(c_double_complex),target,dimension(:) :: x
      integer(c_int),value :: incx
      integer(c_int64_t),value :: stridex
      complex(c_double_complex),target,dimension(:) :: y
      integer(c_int),value :: incy
      integer(c_int64_t),value :: stridey
      complex(c_double_complex),target,dimension(:,:) :: A
      integer(c_int),value :: lda
      integer(c_int64_t),value :: strideA
      integer(c_int),value :: batch_count
      !
      rocblas_zgerc_strided_batched_full_rank = rocblas_zgerc_strided_batched_orig(handle,m,n,alpha,c_loc(x),incx,stridex,c_loc(y),incy,stridey,c_loc(A),lda,strideA,batch_count)
    end function

    function rocblas_zgerc_strided_batched_rank_0(handle,m,n,alpha,x,incx,stridex,y,incy,stridey,A,lda,strideA,batch_count)
      use iso_c_binding
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocblas_zgerc_strided_batched_rank_0
      type(c_ptr),value :: handle
      integer(c_int),value :: m
      integer(c_int),value :: n
      complex(c_double_complex) :: alpha
      complex(c_double_complex),target :: x
      integer(c_int),value :: incx
      integer(c_int64_t),value :: stridex
      complex(c_double_complex),target :: y
      integer(c_int),value :: incy
      integer(c_int64_t),value :: stridey
      complex(c_double_complex),target :: A
      integer(c_int),value :: lda
      integer(c_int64_t),value :: strideA
      integer(c_int),value :: batch_count
      !
      rocblas_zgerc_strided_batched_rank_0 = rocblas_zgerc_strided_batched_orig(handle,m,n,alpha,c_loc(x),incx,stridex,c_loc(y),incy,stridey,c_loc(A),lda,strideA,batch_count)
    end function

    function rocblas_zgerc_strided_batched_rank_1(handle,m,n,alpha,x,incx,stridex,y,incy,stridey,A,lda,strideA,batch_count)
      use iso_c_binding
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocblas_zgerc_strided_batched_rank_1
      type(c_ptr),value :: handle
      integer(c_int),value :: m
      integer(c_int),value :: n
      complex(c_double_complex) :: alpha
      complex(c_double_complex),target,dimension(:) :: x
      integer(c_int),value :: incx
      integer(c_int64_t),value :: stridex
      complex(c_double_complex),target,dimension(:) :: y
      integer(c_int),value :: incy
      integer(c_int64_t),value :: stridey
      complex(c_double_complex),target,dimension(:) :: A
      integer(c_int),value :: lda
      integer(c_int64_t),value :: strideA
      integer(c_int),value :: batch_count
      !
      rocblas_zgerc_strided_batched_rank_1 = rocblas_zgerc_strided_batched_orig(handle,m,n,alpha,c_loc(x),incx,stridex,c_loc(y),incy,stridey,c_loc(A),lda,strideA,batch_count)
    end function

    function rocblas_sspr_rank_0(handle,uplo,n,alpha,x,incx,AP)
      use iso_c_binding
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocblas_sspr_rank_0
      type(c_ptr),value :: handle
      integer(kind(rocblas_fill_upper)),value :: uplo
      integer(c_int),value :: n
      real(c_float) :: alpha
      real(c_float),target :: x
      integer(c_int),value :: incx
      type(c_ptr),value :: AP
      !
      rocblas_sspr_rank_0 = rocblas_sspr_orig(handle,uplo,n,alpha,c_loc(x),incx,AP)
    end function

    function rocblas_sspr_rank_1(handle,uplo,n,alpha,x,incx,AP)
      use iso_c_binding
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocblas_sspr_rank_1
      type(c_ptr),value :: handle
      integer(kind(rocblas_fill_upper)),value :: uplo
      integer(c_int),value :: n
      real(c_float) :: alpha
      real(c_float),target,dimension(:) :: x
      integer(c_int),value :: incx
      type(c_ptr),value :: AP
      !
      rocblas_sspr_rank_1 = rocblas_sspr_orig(handle,uplo,n,alpha,c_loc(x),incx,AP)
    end function

    function rocblas_dspr_rank_0(handle,uplo,n,alpha,x,incx,AP)
      use iso_c_binding
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocblas_dspr_rank_0
      type(c_ptr),value :: handle
      integer(kind(rocblas_fill_upper)),value :: uplo
      integer(c_int),value :: n
      real(c_double) :: alpha
      real(c_double),target :: x
      integer(c_int),value :: incx
      type(c_ptr),value :: AP
      !
      rocblas_dspr_rank_0 = rocblas_dspr_orig(handle,uplo,n,alpha,c_loc(x),incx,AP)
    end function

    function rocblas_dspr_rank_1(handle,uplo,n,alpha,x,incx,AP)
      use iso_c_binding
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocblas_dspr_rank_1
      type(c_ptr),value :: handle
      integer(kind(rocblas_fill_upper)),value :: uplo
      integer(c_int),value :: n
      real(c_double) :: alpha
      real(c_double),target,dimension(:) :: x
      integer(c_int),value :: incx
      type(c_ptr),value :: AP
      !
      rocblas_dspr_rank_1 = rocblas_dspr_orig(handle,uplo,n,alpha,c_loc(x),incx,AP)
    end function

    function rocblas_cspr_rank_0(handle,uplo,n,alpha,x,incx,AP)
      use iso_c_binding
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocblas_cspr_rank_0
      type(c_ptr),value :: handle
      integer(kind(rocblas_fill_upper)),value :: uplo
      integer(c_int),value :: n
      complex(c_float_complex) :: alpha
      complex(c_float_complex),target :: x
      integer(c_int),value :: incx
      type(c_ptr),value :: AP
      !
      rocblas_cspr_rank_0 = rocblas_cspr_orig(handle,uplo,n,alpha,c_loc(x),incx,AP)
    end function

    function rocblas_cspr_rank_1(handle,uplo,n,alpha,x,incx,AP)
      use iso_c_binding
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocblas_cspr_rank_1
      type(c_ptr),value :: handle
      integer(kind(rocblas_fill_upper)),value :: uplo
      integer(c_int),value :: n
      complex(c_float_complex) :: alpha
      complex(c_float_complex),target,dimension(:) :: x
      integer(c_int),value :: incx
      type(c_ptr),value :: AP
      !
      rocblas_cspr_rank_1 = rocblas_cspr_orig(handle,uplo,n,alpha,c_loc(x),incx,AP)
    end function

    function rocblas_zspr_rank_0(handle,uplo,n,alpha,x,incx,AP)
      use iso_c_binding
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocblas_zspr_rank_0
      type(c_ptr),value :: handle
      integer(kind(rocblas_fill_upper)),value :: uplo
      integer(c_int),value :: n
      complex(c_double_complex) :: alpha
      complex(c_double_complex),target :: x
      integer(c_int),value :: incx
      type(c_ptr),value :: AP
      !
      rocblas_zspr_rank_0 = rocblas_zspr_orig(handle,uplo,n,alpha,c_loc(x),incx,AP)
    end function

    function rocblas_zspr_rank_1(handle,uplo,n,alpha,x,incx,AP)
      use iso_c_binding
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocblas_zspr_rank_1
      type(c_ptr),value :: handle
      integer(kind(rocblas_fill_upper)),value :: uplo
      integer(c_int),value :: n
      complex(c_double_complex) :: alpha
      complex(c_double_complex),target,dimension(:) :: x
      integer(c_int),value :: incx
      type(c_ptr),value :: AP
      !
      rocblas_zspr_rank_1 = rocblas_zspr_orig(handle,uplo,n,alpha,c_loc(x),incx,AP)
    end function

    function rocblas_sspr_batched_full_rank(handle,uplo,n,alpha,x,incx,AP,batch_count)
      use iso_c_binding
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocblas_sspr_batched_full_rank
      type(c_ptr),value :: handle
      integer(kind(rocblas_fill_upper)),value :: uplo
      integer(c_int),value :: n
      real(c_float) :: alpha
      real(c_float),target,dimension(:,:) :: x
      integer(c_int),value :: incx
      type(c_ptr) :: AP
      integer(c_int),value :: batch_count
      !
      rocblas_sspr_batched_full_rank = rocblas_sspr_batched_orig(handle,uplo,n,alpha,c_loc(x),incx,AP,batch_count)
    end function

    function rocblas_sspr_batched_rank_0(handle,uplo,n,alpha,x,incx,AP,batch_count)
      use iso_c_binding
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocblas_sspr_batched_rank_0
      type(c_ptr),value :: handle
      integer(kind(rocblas_fill_upper)),value :: uplo
      integer(c_int),value :: n
      real(c_float) :: alpha
      real(c_float),target :: x
      integer(c_int),value :: incx
      type(c_ptr) :: AP
      integer(c_int),value :: batch_count
      !
      rocblas_sspr_batched_rank_0 = rocblas_sspr_batched_orig(handle,uplo,n,alpha,c_loc(x),incx,AP,batch_count)
    end function

    function rocblas_sspr_batched_rank_1(handle,uplo,n,alpha,x,incx,AP,batch_count)
      use iso_c_binding
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocblas_sspr_batched_rank_1
      type(c_ptr),value :: handle
      integer(kind(rocblas_fill_upper)),value :: uplo
      integer(c_int),value :: n
      real(c_float) :: alpha
      real(c_float),target,dimension(:) :: x
      integer(c_int),value :: incx
      type(c_ptr) :: AP
      integer(c_int),value :: batch_count
      !
      rocblas_sspr_batched_rank_1 = rocblas_sspr_batched_orig(handle,uplo,n,alpha,c_loc(x),incx,AP,batch_count)
    end function

    function rocblas_dspr_batched_full_rank(handle,uplo,n,alpha,x,incx,AP,batch_count)
      use iso_c_binding
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocblas_dspr_batched_full_rank
      type(c_ptr),value :: handle
      integer(kind(rocblas_fill_upper)),value :: uplo
      integer(c_int),value :: n
      real(c_double) :: alpha
      real(c_double),target,dimension(:,:) :: x
      integer(c_int),value :: incx
      type(c_ptr) :: AP
      integer(c_int),value :: batch_count
      !
      rocblas_dspr_batched_full_rank = rocblas_dspr_batched_orig(handle,uplo,n,alpha,c_loc(x),incx,AP,batch_count)
    end function

    function rocblas_dspr_batched_rank_0(handle,uplo,n,alpha,x,incx,AP,batch_count)
      use iso_c_binding
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocblas_dspr_batched_rank_0
      type(c_ptr),value :: handle
      integer(kind(rocblas_fill_upper)),value :: uplo
      integer(c_int),value :: n
      real(c_double) :: alpha
      real(c_double),target :: x
      integer(c_int),value :: incx
      type(c_ptr) :: AP
      integer(c_int),value :: batch_count
      !
      rocblas_dspr_batched_rank_0 = rocblas_dspr_batched_orig(handle,uplo,n,alpha,c_loc(x),incx,AP,batch_count)
    end function

    function rocblas_dspr_batched_rank_1(handle,uplo,n,alpha,x,incx,AP,batch_count)
      use iso_c_binding
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocblas_dspr_batched_rank_1
      type(c_ptr),value :: handle
      integer(kind(rocblas_fill_upper)),value :: uplo
      integer(c_int),value :: n
      real(c_double) :: alpha
      real(c_double),target,dimension(:) :: x
      integer(c_int),value :: incx
      type(c_ptr) :: AP
      integer(c_int),value :: batch_count
      !
      rocblas_dspr_batched_rank_1 = rocblas_dspr_batched_orig(handle,uplo,n,alpha,c_loc(x),incx,AP,batch_count)
    end function

    function rocblas_cspr_batched_full_rank(handle,uplo,n,alpha,x,incx,AP,batch_count)
      use iso_c_binding
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocblas_cspr_batched_full_rank
      type(c_ptr),value :: handle
      integer(kind(rocblas_fill_upper)),value :: uplo
      integer(c_int),value :: n
      complex(c_float_complex) :: alpha
      complex(c_float_complex),target,dimension(:,:) :: x
      integer(c_int),value :: incx
      type(c_ptr) :: AP
      integer(c_int),value :: batch_count
      !
      rocblas_cspr_batched_full_rank = rocblas_cspr_batched_orig(handle,uplo,n,alpha,c_loc(x),incx,AP,batch_count)
    end function

    function rocblas_cspr_batched_rank_0(handle,uplo,n,alpha,x,incx,AP,batch_count)
      use iso_c_binding
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocblas_cspr_batched_rank_0
      type(c_ptr),value :: handle
      integer(kind(rocblas_fill_upper)),value :: uplo
      integer(c_int),value :: n
      complex(c_float_complex) :: alpha
      complex(c_float_complex),target :: x
      integer(c_int),value :: incx
      type(c_ptr) :: AP
      integer(c_int),value :: batch_count
      !
      rocblas_cspr_batched_rank_0 = rocblas_cspr_batched_orig(handle,uplo,n,alpha,c_loc(x),incx,AP,batch_count)
    end function

    function rocblas_cspr_batched_rank_1(handle,uplo,n,alpha,x,incx,AP,batch_count)
      use iso_c_binding
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocblas_cspr_batched_rank_1
      type(c_ptr),value :: handle
      integer(kind(rocblas_fill_upper)),value :: uplo
      integer(c_int),value :: n
      complex(c_float_complex) :: alpha
      complex(c_float_complex),target,dimension(:) :: x
      integer(c_int),value :: incx
      type(c_ptr) :: AP
      integer(c_int),value :: batch_count
      !
      rocblas_cspr_batched_rank_1 = rocblas_cspr_batched_orig(handle,uplo,n,alpha,c_loc(x),incx,AP,batch_count)
    end function

    function rocblas_zspr_batched_full_rank(handle,uplo,n,alpha,x,incx,AP,batch_count)
      use iso_c_binding
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocblas_zspr_batched_full_rank
      type(c_ptr),value :: handle
      integer(kind(rocblas_fill_upper)),value :: uplo
      integer(c_int),value :: n
      complex(c_double_complex) :: alpha
      complex(c_double_complex),target,dimension(:,:) :: x
      integer(c_int),value :: incx
      type(c_ptr) :: AP
      integer(c_int),value :: batch_count
      !
      rocblas_zspr_batched_full_rank = rocblas_zspr_batched_orig(handle,uplo,n,alpha,c_loc(x),incx,AP,batch_count)
    end function

    function rocblas_zspr_batched_rank_0(handle,uplo,n,alpha,x,incx,AP,batch_count)
      use iso_c_binding
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocblas_zspr_batched_rank_0
      type(c_ptr),value :: handle
      integer(kind(rocblas_fill_upper)),value :: uplo
      integer(c_int),value :: n
      complex(c_double_complex) :: alpha
      complex(c_double_complex),target :: x
      integer(c_int),value :: incx
      type(c_ptr) :: AP
      integer(c_int),value :: batch_count
      !
      rocblas_zspr_batched_rank_0 = rocblas_zspr_batched_orig(handle,uplo,n,alpha,c_loc(x),incx,AP,batch_count)
    end function

    function rocblas_zspr_batched_rank_1(handle,uplo,n,alpha,x,incx,AP,batch_count)
      use iso_c_binding
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocblas_zspr_batched_rank_1
      type(c_ptr),value :: handle
      integer(kind(rocblas_fill_upper)),value :: uplo
      integer(c_int),value :: n
      complex(c_double_complex) :: alpha
      complex(c_double_complex),target,dimension(:) :: x
      integer(c_int),value :: incx
      type(c_ptr) :: AP
      integer(c_int),value :: batch_count
      !
      rocblas_zspr_batched_rank_1 = rocblas_zspr_batched_orig(handle,uplo,n,alpha,c_loc(x),incx,AP,batch_count)
    end function

    function rocblas_sspr_strided_batched_rank_0(handle,uplo,n,alpha,x,incx,stride_x,AP,stride_A,batch_count)
      use iso_c_binding
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocblas_sspr_strided_batched_rank_0
      type(c_ptr),value :: handle
      integer(kind(rocblas_fill_upper)),value :: uplo
      integer(c_int),value :: n
      real(c_float) :: alpha
      real(c_float),target :: x
      integer(c_int),value :: incx
      integer(c_int64_t),value :: stride_x
      type(c_ptr),value :: AP
      integer(c_int64_t),value :: stride_A
      integer(c_int),value :: batch_count
      !
      rocblas_sspr_strided_batched_rank_0 = rocblas_sspr_strided_batched_orig(handle,uplo,n,alpha,c_loc(x),incx,stride_x,AP,stride_A,batch_count)
    end function

    function rocblas_sspr_strided_batched_rank_1(handle,uplo,n,alpha,x,incx,stride_x,AP,stride_A,batch_count)
      use iso_c_binding
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocblas_sspr_strided_batched_rank_1
      type(c_ptr),value :: handle
      integer(kind(rocblas_fill_upper)),value :: uplo
      integer(c_int),value :: n
      real(c_float) :: alpha
      real(c_float),target,dimension(:) :: x
      integer(c_int),value :: incx
      integer(c_int64_t),value :: stride_x
      type(c_ptr),value :: AP
      integer(c_int64_t),value :: stride_A
      integer(c_int),value :: batch_count
      !
      rocblas_sspr_strided_batched_rank_1 = rocblas_sspr_strided_batched_orig(handle,uplo,n,alpha,c_loc(x),incx,stride_x,AP,stride_A,batch_count)
    end function

    function rocblas_dspr_strided_batched_rank_0(handle,uplo,n,alpha,x,incx,stride_x,AP,stride_A,batch_count)
      use iso_c_binding
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocblas_dspr_strided_batched_rank_0
      type(c_ptr),value :: handle
      integer(kind(rocblas_fill_upper)),value :: uplo
      integer(c_int),value :: n
      real(c_double) :: alpha
      real(c_double),target :: x
      integer(c_int),value :: incx
      integer(c_int64_t),value :: stride_x
      type(c_ptr),value :: AP
      integer(c_int64_t),value :: stride_A
      integer(c_int),value :: batch_count
      !
      rocblas_dspr_strided_batched_rank_0 = rocblas_dspr_strided_batched_orig(handle,uplo,n,alpha,c_loc(x),incx,stride_x,AP,stride_A,batch_count)
    end function

    function rocblas_dspr_strided_batched_rank_1(handle,uplo,n,alpha,x,incx,stride_x,AP,stride_A,batch_count)
      use iso_c_binding
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocblas_dspr_strided_batched_rank_1
      type(c_ptr),value :: handle
      integer(kind(rocblas_fill_upper)),value :: uplo
      integer(c_int),value :: n
      real(c_double) :: alpha
      real(c_double),target,dimension(:) :: x
      integer(c_int),value :: incx
      integer(c_int64_t),value :: stride_x
      type(c_ptr),value :: AP
      integer(c_int64_t),value :: stride_A
      integer(c_int),value :: batch_count
      !
      rocblas_dspr_strided_batched_rank_1 = rocblas_dspr_strided_batched_orig(handle,uplo,n,alpha,c_loc(x),incx,stride_x,AP,stride_A,batch_count)
    end function

    function rocblas_cspr_strided_batched_rank_0(handle,uplo,n,alpha,x,incx,stride_x,AP,stride_A,batch_count)
      use iso_c_binding
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocblas_cspr_strided_batched_rank_0
      type(c_ptr),value :: handle
      integer(kind(rocblas_fill_upper)),value :: uplo
      integer(c_int),value :: n
      complex(c_float_complex) :: alpha
      complex(c_float_complex),target :: x
      integer(c_int),value :: incx
      integer(c_int64_t),value :: stride_x
      type(c_ptr),value :: AP
      integer(c_int64_t),value :: stride_A
      integer(c_int),value :: batch_count
      !
      rocblas_cspr_strided_batched_rank_0 = rocblas_cspr_strided_batched_orig(handle,uplo,n,alpha,c_loc(x),incx,stride_x,AP,stride_A,batch_count)
    end function

    function rocblas_cspr_strided_batched_rank_1(handle,uplo,n,alpha,x,incx,stride_x,AP,stride_A,batch_count)
      use iso_c_binding
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocblas_cspr_strided_batched_rank_1
      type(c_ptr),value :: handle
      integer(kind(rocblas_fill_upper)),value :: uplo
      integer(c_int),value :: n
      complex(c_float_complex) :: alpha
      complex(c_float_complex),target,dimension(:) :: x
      integer(c_int),value :: incx
      integer(c_int64_t),value :: stride_x
      type(c_ptr),value :: AP
      integer(c_int64_t),value :: stride_A
      integer(c_int),value :: batch_count
      !
      rocblas_cspr_strided_batched_rank_1 = rocblas_cspr_strided_batched_orig(handle,uplo,n,alpha,c_loc(x),incx,stride_x,AP,stride_A,batch_count)
    end function

    function rocblas_zspr_strided_batched_rank_0(handle,uplo,n,alpha,x,incx,stride_x,AP,stride_A,batch_count)
      use iso_c_binding
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocblas_zspr_strided_batched_rank_0
      type(c_ptr),value :: handle
      integer(kind(rocblas_fill_upper)),value :: uplo
      integer(c_int),value :: n
      complex(c_double_complex) :: alpha
      complex(c_double_complex),target :: x
      integer(c_int),value :: incx
      integer(c_int64_t),value :: stride_x
      type(c_ptr),value :: AP
      integer(c_int64_t),value :: stride_A
      integer(c_int),value :: batch_count
      !
      rocblas_zspr_strided_batched_rank_0 = rocblas_zspr_strided_batched_orig(handle,uplo,n,alpha,c_loc(x),incx,stride_x,AP,stride_A,batch_count)
    end function

    function rocblas_zspr_strided_batched_rank_1(handle,uplo,n,alpha,x,incx,stride_x,AP,stride_A,batch_count)
      use iso_c_binding
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocblas_zspr_strided_batched_rank_1
      type(c_ptr),value :: handle
      integer(kind(rocblas_fill_upper)),value :: uplo
      integer(c_int),value :: n
      complex(c_double_complex) :: alpha
      complex(c_double_complex),target,dimension(:) :: x
      integer(c_int),value :: incx
      integer(c_int64_t),value :: stride_x
      type(c_ptr),value :: AP
      integer(c_int64_t),value :: stride_A
      integer(c_int),value :: batch_count
      !
      rocblas_zspr_strided_batched_rank_1 = rocblas_zspr_strided_batched_orig(handle,uplo,n,alpha,c_loc(x),incx,stride_x,AP,stride_A,batch_count)
    end function

    function rocblas_sspr2_rank_0(handle,uplo,n,alpha,x,incx,y,incy,AP)
      use iso_c_binding
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocblas_sspr2_rank_0
      type(c_ptr),value :: handle
      integer(kind(rocblas_fill_upper)),value :: uplo
      integer(c_int),value :: n
      real(c_float) :: alpha
      real(c_float),target :: x
      integer(c_int),value :: incx
      real(c_float),target :: y
      integer(c_int),value :: incy
      type(c_ptr),value :: AP
      !
      rocblas_sspr2_rank_0 = rocblas_sspr2_orig(handle,uplo,n,alpha,c_loc(x),incx,c_loc(y),incy,AP)
    end function

    function rocblas_sspr2_rank_1(handle,uplo,n,alpha,x,incx,y,incy,AP)
      use iso_c_binding
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocblas_sspr2_rank_1
      type(c_ptr),value :: handle
      integer(kind(rocblas_fill_upper)),value :: uplo
      integer(c_int),value :: n
      real(c_float) :: alpha
      real(c_float),target,dimension(:) :: x
      integer(c_int),value :: incx
      real(c_float),target,dimension(:) :: y
      integer(c_int),value :: incy
      type(c_ptr),value :: AP
      !
      rocblas_sspr2_rank_1 = rocblas_sspr2_orig(handle,uplo,n,alpha,c_loc(x),incx,c_loc(y),incy,AP)
    end function

    function rocblas_dspr2_rank_0(handle,uplo,n,alpha,x,incx,y,incy,AP)
      use iso_c_binding
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocblas_dspr2_rank_0
      type(c_ptr),value :: handle
      integer(kind(rocblas_fill_upper)),value :: uplo
      integer(c_int),value :: n
      real(c_double) :: alpha
      real(c_double),target :: x
      integer(c_int),value :: incx
      real(c_double),target :: y
      integer(c_int),value :: incy
      type(c_ptr),value :: AP
      !
      rocblas_dspr2_rank_0 = rocblas_dspr2_orig(handle,uplo,n,alpha,c_loc(x),incx,c_loc(y),incy,AP)
    end function

    function rocblas_dspr2_rank_1(handle,uplo,n,alpha,x,incx,y,incy,AP)
      use iso_c_binding
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocblas_dspr2_rank_1
      type(c_ptr),value :: handle
      integer(kind(rocblas_fill_upper)),value :: uplo
      integer(c_int),value :: n
      real(c_double) :: alpha
      real(c_double),target,dimension(:) :: x
      integer(c_int),value :: incx
      real(c_double),target,dimension(:) :: y
      integer(c_int),value :: incy
      type(c_ptr),value :: AP
      !
      rocblas_dspr2_rank_1 = rocblas_dspr2_orig(handle,uplo,n,alpha,c_loc(x),incx,c_loc(y),incy,AP)
    end function

    function rocblas_sspr2_batched_full_rank(handle,uplo,n,alpha,x,incx,y,incy,AP,batch_count)
      use iso_c_binding
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocblas_sspr2_batched_full_rank
      type(c_ptr),value :: handle
      integer(kind(rocblas_fill_upper)),value :: uplo
      integer(c_int),value :: n
      real(c_float) :: alpha
      real(c_float),target,dimension(:,:) :: x
      integer(c_int),value :: incx
      real(c_float),target,dimension(:,:) :: y
      integer(c_int),value :: incy
      type(c_ptr) :: AP
      integer(c_int),value :: batch_count
      !
      rocblas_sspr2_batched_full_rank = rocblas_sspr2_batched_orig(handle,uplo,n,alpha,c_loc(x),incx,c_loc(y),incy,AP,batch_count)
    end function

    function rocblas_sspr2_batched_rank_0(handle,uplo,n,alpha,x,incx,y,incy,AP,batch_count)
      use iso_c_binding
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocblas_sspr2_batched_rank_0
      type(c_ptr),value :: handle
      integer(kind(rocblas_fill_upper)),value :: uplo
      integer(c_int),value :: n
      real(c_float) :: alpha
      real(c_float),target :: x
      integer(c_int),value :: incx
      real(c_float),target :: y
      integer(c_int),value :: incy
      type(c_ptr) :: AP
      integer(c_int),value :: batch_count
      !
      rocblas_sspr2_batched_rank_0 = rocblas_sspr2_batched_orig(handle,uplo,n,alpha,c_loc(x),incx,c_loc(y),incy,AP,batch_count)
    end function

    function rocblas_sspr2_batched_rank_1(handle,uplo,n,alpha,x,incx,y,incy,AP,batch_count)
      use iso_c_binding
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocblas_sspr2_batched_rank_1
      type(c_ptr),value :: handle
      integer(kind(rocblas_fill_upper)),value :: uplo
      integer(c_int),value :: n
      real(c_float) :: alpha
      real(c_float),target,dimension(:) :: x
      integer(c_int),value :: incx
      real(c_float),target,dimension(:) :: y
      integer(c_int),value :: incy
      type(c_ptr) :: AP
      integer(c_int),value :: batch_count
      !
      rocblas_sspr2_batched_rank_1 = rocblas_sspr2_batched_orig(handle,uplo,n,alpha,c_loc(x),incx,c_loc(y),incy,AP,batch_count)
    end function

    function rocblas_dspr2_batched_full_rank(handle,uplo,n,alpha,x,incx,y,incy,AP,batch_count)
      use iso_c_binding
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocblas_dspr2_batched_full_rank
      type(c_ptr),value :: handle
      integer(kind(rocblas_fill_upper)),value :: uplo
      integer(c_int),value :: n
      real(c_double) :: alpha
      real(c_double),target,dimension(:,:) :: x
      integer(c_int),value :: incx
      real(c_double),target,dimension(:,:) :: y
      integer(c_int),value :: incy
      type(c_ptr) :: AP
      integer(c_int),value :: batch_count
      !
      rocblas_dspr2_batched_full_rank = rocblas_dspr2_batched_orig(handle,uplo,n,alpha,c_loc(x),incx,c_loc(y),incy,AP,batch_count)
    end function

    function rocblas_dspr2_batched_rank_0(handle,uplo,n,alpha,x,incx,y,incy,AP,batch_count)
      use iso_c_binding
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocblas_dspr2_batched_rank_0
      type(c_ptr),value :: handle
      integer(kind(rocblas_fill_upper)),value :: uplo
      integer(c_int),value :: n
      real(c_double) :: alpha
      real(c_double),target :: x
      integer(c_int),value :: incx
      real(c_double),target :: y
      integer(c_int),value :: incy
      type(c_ptr) :: AP
      integer(c_int),value :: batch_count
      !
      rocblas_dspr2_batched_rank_0 = rocblas_dspr2_batched_orig(handle,uplo,n,alpha,c_loc(x),incx,c_loc(y),incy,AP,batch_count)
    end function

    function rocblas_dspr2_batched_rank_1(handle,uplo,n,alpha,x,incx,y,incy,AP,batch_count)
      use iso_c_binding
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocblas_dspr2_batched_rank_1
      type(c_ptr),value :: handle
      integer(kind(rocblas_fill_upper)),value :: uplo
      integer(c_int),value :: n
      real(c_double) :: alpha
      real(c_double),target,dimension(:) :: x
      integer(c_int),value :: incx
      real(c_double),target,dimension(:) :: y
      integer(c_int),value :: incy
      type(c_ptr) :: AP
      integer(c_int),value :: batch_count
      !
      rocblas_dspr2_batched_rank_1 = rocblas_dspr2_batched_orig(handle,uplo,n,alpha,c_loc(x),incx,c_loc(y),incy,AP,batch_count)
    end function

    function rocblas_sspr2_strided_batched_rank_0(handle,uplo,n,alpha,x,incx,stride_x,y,incy,stride_y,AP,stride_A,batch_count)
      use iso_c_binding
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocblas_sspr2_strided_batched_rank_0
      type(c_ptr),value :: handle
      integer(kind(rocblas_fill_upper)),value :: uplo
      integer(c_int),value :: n
      real(c_float) :: alpha
      real(c_float),target :: x
      integer(c_int),value :: incx
      integer(c_int64_t),value :: stride_x
      real(c_float),target :: y
      integer(c_int),value :: incy
      integer(c_int64_t),value :: stride_y
      type(c_ptr),value :: AP
      integer(c_int64_t),value :: stride_A
      integer(c_int),value :: batch_count
      !
      rocblas_sspr2_strided_batched_rank_0 = rocblas_sspr2_strided_batched_orig(handle,uplo,n,alpha,c_loc(x),incx,stride_x,c_loc(y),incy,stride_y,AP,stride_A,batch_count)
    end function

    function rocblas_sspr2_strided_batched_rank_1(handle,uplo,n,alpha,x,incx,stride_x,y,incy,stride_y,AP,stride_A,batch_count)
      use iso_c_binding
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocblas_sspr2_strided_batched_rank_1
      type(c_ptr),value :: handle
      integer(kind(rocblas_fill_upper)),value :: uplo
      integer(c_int),value :: n
      real(c_float) :: alpha
      real(c_float),target,dimension(:) :: x
      integer(c_int),value :: incx
      integer(c_int64_t),value :: stride_x
      real(c_float),target,dimension(:) :: y
      integer(c_int),value :: incy
      integer(c_int64_t),value :: stride_y
      type(c_ptr),value :: AP
      integer(c_int64_t),value :: stride_A
      integer(c_int),value :: batch_count
      !
      rocblas_sspr2_strided_batched_rank_1 = rocblas_sspr2_strided_batched_orig(handle,uplo,n,alpha,c_loc(x),incx,stride_x,c_loc(y),incy,stride_y,AP,stride_A,batch_count)
    end function

    function rocblas_dspr2_strided_batched_rank_0(handle,uplo,n,alpha,x,incx,stride_x,y,incy,stride_y,AP,stride_A,batch_count)
      use iso_c_binding
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocblas_dspr2_strided_batched_rank_0
      type(c_ptr),value :: handle
      integer(kind(rocblas_fill_upper)),value :: uplo
      integer(c_int),value :: n
      real(c_double) :: alpha
      real(c_double),target :: x
      integer(c_int),value :: incx
      integer(c_int64_t),value :: stride_x
      real(c_double),target :: y
      integer(c_int),value :: incy
      integer(c_int64_t),value :: stride_y
      type(c_ptr),value :: AP
      integer(c_int64_t),value :: stride_A
      integer(c_int),value :: batch_count
      !
      rocblas_dspr2_strided_batched_rank_0 = rocblas_dspr2_strided_batched_orig(handle,uplo,n,alpha,c_loc(x),incx,stride_x,c_loc(y),incy,stride_y,AP,stride_A,batch_count)
    end function

    function rocblas_dspr2_strided_batched_rank_1(handle,uplo,n,alpha,x,incx,stride_x,y,incy,stride_y,AP,stride_A,batch_count)
      use iso_c_binding
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocblas_dspr2_strided_batched_rank_1
      type(c_ptr),value :: handle
      integer(kind(rocblas_fill_upper)),value :: uplo
      integer(c_int),value :: n
      real(c_double) :: alpha
      real(c_double),target,dimension(:) :: x
      integer(c_int),value :: incx
      integer(c_int64_t),value :: stride_x
      real(c_double),target,dimension(:) :: y
      integer(c_int),value :: incy
      integer(c_int64_t),value :: stride_y
      type(c_ptr),value :: AP
      integer(c_int64_t),value :: stride_A
      integer(c_int),value :: batch_count
      !
      rocblas_dspr2_strided_batched_rank_1 = rocblas_dspr2_strided_batched_orig(handle,uplo,n,alpha,c_loc(x),incx,stride_x,c_loc(y),incy,stride_y,AP,stride_A,batch_count)
    end function

    function rocblas_ssyr_full_rank(handle,uplo,n,alpha,x,incx,A,lda)
      use iso_c_binding
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocblas_ssyr_full_rank
      type(c_ptr),value :: handle
      integer(kind(rocblas_fill_upper)),value :: uplo
      integer(c_int),value :: n
      real(c_float) :: alpha
      real(c_float),target,dimension(:) :: x
      integer(c_int),value :: incx
      real(c_float),target,dimension(:,:) :: A
      integer(c_int),value :: lda
      !
      rocblas_ssyr_full_rank = rocblas_ssyr_orig(handle,uplo,n,alpha,c_loc(x),incx,c_loc(A),lda)
    end function

    function rocblas_ssyr_rank_0(handle,uplo,n,alpha,x,incx,A,lda)
      use iso_c_binding
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocblas_ssyr_rank_0
      type(c_ptr),value :: handle
      integer(kind(rocblas_fill_upper)),value :: uplo
      integer(c_int),value :: n
      real(c_float) :: alpha
      real(c_float),target :: x
      integer(c_int),value :: incx
      real(c_float),target :: A
      integer(c_int),value :: lda
      !
      rocblas_ssyr_rank_0 = rocblas_ssyr_orig(handle,uplo,n,alpha,c_loc(x),incx,c_loc(A),lda)
    end function

    function rocblas_ssyr_rank_1(handle,uplo,n,alpha,x,incx,A,lda)
      use iso_c_binding
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocblas_ssyr_rank_1
      type(c_ptr),value :: handle
      integer(kind(rocblas_fill_upper)),value :: uplo
      integer(c_int),value :: n
      real(c_float) :: alpha
      real(c_float),target,dimension(:) :: x
      integer(c_int),value :: incx
      real(c_float),target,dimension(:) :: A
      integer(c_int),value :: lda
      !
      rocblas_ssyr_rank_1 = rocblas_ssyr_orig(handle,uplo,n,alpha,c_loc(x),incx,c_loc(A),lda)
    end function

    function rocblas_dsyr_full_rank(handle,uplo,n,alpha,x,incx,A,lda)
      use iso_c_binding
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocblas_dsyr_full_rank
      type(c_ptr),value :: handle
      integer(kind(rocblas_fill_upper)),value :: uplo
      integer(c_int),value :: n
      real(c_double) :: alpha
      real(c_double),target,dimension(:) :: x
      integer(c_int),value :: incx
      real(c_double),target,dimension(:,:) :: A
      integer(c_int),value :: lda
      !
      rocblas_dsyr_full_rank = rocblas_dsyr_orig(handle,uplo,n,alpha,c_loc(x),incx,c_loc(A),lda)
    end function

    function rocblas_dsyr_rank_0(handle,uplo,n,alpha,x,incx,A,lda)
      use iso_c_binding
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocblas_dsyr_rank_0
      type(c_ptr),value :: handle
      integer(kind(rocblas_fill_upper)),value :: uplo
      integer(c_int),value :: n
      real(c_double) :: alpha
      real(c_double),target :: x
      integer(c_int),value :: incx
      real(c_double),target :: A
      integer(c_int),value :: lda
      !
      rocblas_dsyr_rank_0 = rocblas_dsyr_orig(handle,uplo,n,alpha,c_loc(x),incx,c_loc(A),lda)
    end function

    function rocblas_dsyr_rank_1(handle,uplo,n,alpha,x,incx,A,lda)
      use iso_c_binding
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocblas_dsyr_rank_1
      type(c_ptr),value :: handle
      integer(kind(rocblas_fill_upper)),value :: uplo
      integer(c_int),value :: n
      real(c_double) :: alpha
      real(c_double),target,dimension(:) :: x
      integer(c_int),value :: incx
      real(c_double),target,dimension(:) :: A
      integer(c_int),value :: lda
      !
      rocblas_dsyr_rank_1 = rocblas_dsyr_orig(handle,uplo,n,alpha,c_loc(x),incx,c_loc(A),lda)
    end function

    function rocblas_csyr_full_rank(handle,uplo,n,alpha,x,incx,A,lda)
      use iso_c_binding
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocblas_csyr_full_rank
      type(c_ptr),value :: handle
      integer(kind(rocblas_fill_upper)),value :: uplo
      integer(c_int),value :: n
      complex(c_float_complex) :: alpha
      complex(c_float_complex),target,dimension(:) :: x
      integer(c_int),value :: incx
      complex(c_float_complex),target,dimension(:,:) :: A
      integer(c_int),value :: lda
      !
      rocblas_csyr_full_rank = rocblas_csyr_orig(handle,uplo,n,alpha,c_loc(x),incx,c_loc(A),lda)
    end function

    function rocblas_csyr_rank_0(handle,uplo,n,alpha,x,incx,A,lda)
      use iso_c_binding
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocblas_csyr_rank_0
      type(c_ptr),value :: handle
      integer(kind(rocblas_fill_upper)),value :: uplo
      integer(c_int),value :: n
      complex(c_float_complex) :: alpha
      complex(c_float_complex),target :: x
      integer(c_int),value :: incx
      complex(c_float_complex),target :: A
      integer(c_int),value :: lda
      !
      rocblas_csyr_rank_0 = rocblas_csyr_orig(handle,uplo,n,alpha,c_loc(x),incx,c_loc(A),lda)
    end function

    function rocblas_csyr_rank_1(handle,uplo,n,alpha,x,incx,A,lda)
      use iso_c_binding
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocblas_csyr_rank_1
      type(c_ptr),value :: handle
      integer(kind(rocblas_fill_upper)),value :: uplo
      integer(c_int),value :: n
      complex(c_float_complex) :: alpha
      complex(c_float_complex),target,dimension(:) :: x
      integer(c_int),value :: incx
      complex(c_float_complex),target,dimension(:) :: A
      integer(c_int),value :: lda
      !
      rocblas_csyr_rank_1 = rocblas_csyr_orig(handle,uplo,n,alpha,c_loc(x),incx,c_loc(A),lda)
    end function

    function rocblas_zsyr_full_rank(handle,uplo,n,alpha,x,incx,A,lda)
      use iso_c_binding
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocblas_zsyr_full_rank
      type(c_ptr),value :: handle
      integer(kind(rocblas_fill_upper)),value :: uplo
      integer(c_int),value :: n
      complex(c_double_complex) :: alpha
      complex(c_double_complex),target,dimension(:) :: x
      integer(c_int),value :: incx
      complex(c_double_complex),target,dimension(:,:) :: A
      integer(c_int),value :: lda
      !
      rocblas_zsyr_full_rank = rocblas_zsyr_orig(handle,uplo,n,alpha,c_loc(x),incx,c_loc(A),lda)
    end function

    function rocblas_zsyr_rank_0(handle,uplo,n,alpha,x,incx,A,lda)
      use iso_c_binding
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocblas_zsyr_rank_0
      type(c_ptr),value :: handle
      integer(kind(rocblas_fill_upper)),value :: uplo
      integer(c_int),value :: n
      complex(c_double_complex) :: alpha
      complex(c_double_complex),target :: x
      integer(c_int),value :: incx
      complex(c_double_complex),target :: A
      integer(c_int),value :: lda
      !
      rocblas_zsyr_rank_0 = rocblas_zsyr_orig(handle,uplo,n,alpha,c_loc(x),incx,c_loc(A),lda)
    end function

    function rocblas_zsyr_rank_1(handle,uplo,n,alpha,x,incx,A,lda)
      use iso_c_binding
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocblas_zsyr_rank_1
      type(c_ptr),value :: handle
      integer(kind(rocblas_fill_upper)),value :: uplo
      integer(c_int),value :: n
      complex(c_double_complex) :: alpha
      complex(c_double_complex),target,dimension(:) :: x
      integer(c_int),value :: incx
      complex(c_double_complex),target,dimension(:) :: A
      integer(c_int),value :: lda
      !
      rocblas_zsyr_rank_1 = rocblas_zsyr_orig(handle,uplo,n,alpha,c_loc(x),incx,c_loc(A),lda)
    end function

    function rocblas_ssyr_batched_full_rank(handle,uplo,n,alpha,x,incx,A,lda,batch_count)
      use iso_c_binding
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocblas_ssyr_batched_full_rank
      type(c_ptr),value :: handle
      integer(kind(rocblas_fill_upper)),value :: uplo
      integer(c_int),value :: n
      real(c_float) :: alpha
      real(c_float),target,dimension(:,:) :: x
      integer(c_int),value :: incx
      real(c_float),target,dimension(:,:,:) :: A
      integer(c_int),value :: lda
      integer(c_int),value :: batch_count
      !
      rocblas_ssyr_batched_full_rank = rocblas_ssyr_batched_orig(handle,uplo,n,alpha,c_loc(x),incx,c_loc(A),lda,batch_count)
    end function

    function rocblas_ssyr_batched_rank_0(handle,uplo,n,alpha,x,incx,A,lda,batch_count)
      use iso_c_binding
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocblas_ssyr_batched_rank_0
      type(c_ptr),value :: handle
      integer(kind(rocblas_fill_upper)),value :: uplo
      integer(c_int),value :: n
      real(c_float) :: alpha
      real(c_float),target :: x
      integer(c_int),value :: incx
      real(c_float),target :: A
      integer(c_int),value :: lda
      integer(c_int),value :: batch_count
      !
      rocblas_ssyr_batched_rank_0 = rocblas_ssyr_batched_orig(handle,uplo,n,alpha,c_loc(x),incx,c_loc(A),lda,batch_count)
    end function

    function rocblas_ssyr_batched_rank_1(handle,uplo,n,alpha,x,incx,A,lda,batch_count)
      use iso_c_binding
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocblas_ssyr_batched_rank_1
      type(c_ptr),value :: handle
      integer(kind(rocblas_fill_upper)),value :: uplo
      integer(c_int),value :: n
      real(c_float) :: alpha
      real(c_float),target,dimension(:) :: x
      integer(c_int),value :: incx
      real(c_float),target,dimension(:) :: A
      integer(c_int),value :: lda
      integer(c_int),value :: batch_count
      !
      rocblas_ssyr_batched_rank_1 = rocblas_ssyr_batched_orig(handle,uplo,n,alpha,c_loc(x),incx,c_loc(A),lda,batch_count)
    end function

    function rocblas_dsyr_batched_full_rank(handle,uplo,n,alpha,x,incx,A,lda,batch_count)
      use iso_c_binding
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocblas_dsyr_batched_full_rank
      type(c_ptr),value :: handle
      integer(kind(rocblas_fill_upper)),value :: uplo
      integer(c_int),value :: n
      real(c_double) :: alpha
      real(c_double),target,dimension(:,:) :: x
      integer(c_int),value :: incx
      real(c_double),target,dimension(:,:,:) :: A
      integer(c_int),value :: lda
      integer(c_int),value :: batch_count
      !
      rocblas_dsyr_batched_full_rank = rocblas_dsyr_batched_orig(handle,uplo,n,alpha,c_loc(x),incx,c_loc(A),lda,batch_count)
    end function

    function rocblas_dsyr_batched_rank_0(handle,uplo,n,alpha,x,incx,A,lda,batch_count)
      use iso_c_binding
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocblas_dsyr_batched_rank_0
      type(c_ptr),value :: handle
      integer(kind(rocblas_fill_upper)),value :: uplo
      integer(c_int),value :: n
      real(c_double) :: alpha
      real(c_double),target :: x
      integer(c_int),value :: incx
      real(c_double),target :: A
      integer(c_int),value :: lda
      integer(c_int),value :: batch_count
      !
      rocblas_dsyr_batched_rank_0 = rocblas_dsyr_batched_orig(handle,uplo,n,alpha,c_loc(x),incx,c_loc(A),lda,batch_count)
    end function

    function rocblas_dsyr_batched_rank_1(handle,uplo,n,alpha,x,incx,A,lda,batch_count)
      use iso_c_binding
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocblas_dsyr_batched_rank_1
      type(c_ptr),value :: handle
      integer(kind(rocblas_fill_upper)),value :: uplo
      integer(c_int),value :: n
      real(c_double) :: alpha
      real(c_double),target,dimension(:) :: x
      integer(c_int),value :: incx
      real(c_double),target,dimension(:) :: A
      integer(c_int),value :: lda
      integer(c_int),value :: batch_count
      !
      rocblas_dsyr_batched_rank_1 = rocblas_dsyr_batched_orig(handle,uplo,n,alpha,c_loc(x),incx,c_loc(A),lda,batch_count)
    end function

    function rocblas_csyr_batched_full_rank(handle,uplo,n,alpha,x,incx,A,lda,batch_count)
      use iso_c_binding
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocblas_csyr_batched_full_rank
      type(c_ptr),value :: handle
      integer(kind(rocblas_fill_upper)),value :: uplo
      integer(c_int),value :: n
      complex(c_float_complex) :: alpha
      complex(c_float_complex),target,dimension(:,:) :: x
      integer(c_int),value :: incx
      complex(c_float_complex),target,dimension(:,:,:) :: A
      integer(c_int),value :: lda
      integer(c_int),value :: batch_count
      !
      rocblas_csyr_batched_full_rank = rocblas_csyr_batched_orig(handle,uplo,n,alpha,c_loc(x),incx,c_loc(A),lda,batch_count)
    end function

    function rocblas_csyr_batched_rank_0(handle,uplo,n,alpha,x,incx,A,lda,batch_count)
      use iso_c_binding
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocblas_csyr_batched_rank_0
      type(c_ptr),value :: handle
      integer(kind(rocblas_fill_upper)),value :: uplo
      integer(c_int),value :: n
      complex(c_float_complex) :: alpha
      complex(c_float_complex),target :: x
      integer(c_int),value :: incx
      complex(c_float_complex),target :: A
      integer(c_int),value :: lda
      integer(c_int),value :: batch_count
      !
      rocblas_csyr_batched_rank_0 = rocblas_csyr_batched_orig(handle,uplo,n,alpha,c_loc(x),incx,c_loc(A),lda,batch_count)
    end function

    function rocblas_csyr_batched_rank_1(handle,uplo,n,alpha,x,incx,A,lda,batch_count)
      use iso_c_binding
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocblas_csyr_batched_rank_1
      type(c_ptr),value :: handle
      integer(kind(rocblas_fill_upper)),value :: uplo
      integer(c_int),value :: n
      complex(c_float_complex) :: alpha
      complex(c_float_complex),target,dimension(:) :: x
      integer(c_int),value :: incx
      complex(c_float_complex),target,dimension(:) :: A
      integer(c_int),value :: lda
      integer(c_int),value :: batch_count
      !
      rocblas_csyr_batched_rank_1 = rocblas_csyr_batched_orig(handle,uplo,n,alpha,c_loc(x),incx,c_loc(A),lda,batch_count)
    end function

    function rocblas_zsyr_batched_full_rank(handle,uplo,n,alpha,x,incx,A,lda,batch_count)
      use iso_c_binding
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocblas_zsyr_batched_full_rank
      type(c_ptr),value :: handle
      integer(kind(rocblas_fill_upper)),value :: uplo
      integer(c_int),value :: n
      complex(c_double_complex) :: alpha
      complex(c_double_complex),target,dimension(:,:) :: x
      integer(c_int),value :: incx
      complex(c_double_complex),target,dimension(:,:,:) :: A
      integer(c_int),value :: lda
      integer(c_int),value :: batch_count
      !
      rocblas_zsyr_batched_full_rank = rocblas_zsyr_batched_orig(handle,uplo,n,alpha,c_loc(x),incx,c_loc(A),lda,batch_count)
    end function

    function rocblas_zsyr_batched_rank_0(handle,uplo,n,alpha,x,incx,A,lda,batch_count)
      use iso_c_binding
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocblas_zsyr_batched_rank_0
      type(c_ptr),value :: handle
      integer(kind(rocblas_fill_upper)),value :: uplo
      integer(c_int),value :: n
      complex(c_double_complex) :: alpha
      complex(c_double_complex),target :: x
      integer(c_int),value :: incx
      complex(c_double_complex),target :: A
      integer(c_int),value :: lda
      integer(c_int),value :: batch_count
      !
      rocblas_zsyr_batched_rank_0 = rocblas_zsyr_batched_orig(handle,uplo,n,alpha,c_loc(x),incx,c_loc(A),lda,batch_count)
    end function

    function rocblas_zsyr_batched_rank_1(handle,uplo,n,alpha,x,incx,A,lda,batch_count)
      use iso_c_binding
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocblas_zsyr_batched_rank_1
      type(c_ptr),value :: handle
      integer(kind(rocblas_fill_upper)),value :: uplo
      integer(c_int),value :: n
      complex(c_double_complex) :: alpha
      complex(c_double_complex),target,dimension(:) :: x
      integer(c_int),value :: incx
      complex(c_double_complex),target,dimension(:) :: A
      integer(c_int),value :: lda
      integer(c_int),value :: batch_count
      !
      rocblas_zsyr_batched_rank_1 = rocblas_zsyr_batched_orig(handle,uplo,n,alpha,c_loc(x),incx,c_loc(A),lda,batch_count)
    end function

    function rocblas_ssyr_strided_batched_full_rank(handle,uplo,n,alpha,x,incx,stridex,A,lda,strideA,batch_count)
      use iso_c_binding
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocblas_ssyr_strided_batched_full_rank
      type(c_ptr),value :: handle
      integer(kind(rocblas_fill_upper)),value :: uplo
      integer(c_int),value :: n
      real(c_float) :: alpha
      real(c_float),target,dimension(:) :: x
      integer(c_int),value :: incx
      integer(c_int64_t),value :: stridex
      real(c_float),target,dimension(:,:) :: A
      integer(c_int),value :: lda
      integer(c_int64_t),value :: strideA
      integer(c_int),value :: batch_count
      !
      rocblas_ssyr_strided_batched_full_rank = rocblas_ssyr_strided_batched_orig(handle,uplo,n,alpha,c_loc(x),incx,stridex,c_loc(A),lda,strideA,batch_count)
    end function

    function rocblas_ssyr_strided_batched_rank_0(handle,uplo,n,alpha,x,incx,stridex,A,lda,strideA,batch_count)
      use iso_c_binding
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocblas_ssyr_strided_batched_rank_0
      type(c_ptr),value :: handle
      integer(kind(rocblas_fill_upper)),value :: uplo
      integer(c_int),value :: n
      real(c_float) :: alpha
      real(c_float),target :: x
      integer(c_int),value :: incx
      integer(c_int64_t),value :: stridex
      real(c_float),target :: A
      integer(c_int),value :: lda
      integer(c_int64_t),value :: strideA
      integer(c_int),value :: batch_count
      !
      rocblas_ssyr_strided_batched_rank_0 = rocblas_ssyr_strided_batched_orig(handle,uplo,n,alpha,c_loc(x),incx,stridex,c_loc(A),lda,strideA,batch_count)
    end function

    function rocblas_ssyr_strided_batched_rank_1(handle,uplo,n,alpha,x,incx,stridex,A,lda,strideA,batch_count)
      use iso_c_binding
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocblas_ssyr_strided_batched_rank_1
      type(c_ptr),value :: handle
      integer(kind(rocblas_fill_upper)),value :: uplo
      integer(c_int),value :: n
      real(c_float) :: alpha
      real(c_float),target,dimension(:) :: x
      integer(c_int),value :: incx
      integer(c_int64_t),value :: stridex
      real(c_float),target,dimension(:) :: A
      integer(c_int),value :: lda
      integer(c_int64_t),value :: strideA
      integer(c_int),value :: batch_count
      !
      rocblas_ssyr_strided_batched_rank_1 = rocblas_ssyr_strided_batched_orig(handle,uplo,n,alpha,c_loc(x),incx,stridex,c_loc(A),lda,strideA,batch_count)
    end function

    function rocblas_dsyr_strided_batched_full_rank(handle,uplo,n,alpha,x,incx,stridex,A,lda,strideA,batch_count)
      use iso_c_binding
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocblas_dsyr_strided_batched_full_rank
      type(c_ptr),value :: handle
      integer(kind(rocblas_fill_upper)),value :: uplo
      integer(c_int),value :: n
      real(c_double) :: alpha
      real(c_double),target,dimension(:) :: x
      integer(c_int),value :: incx
      integer(c_int64_t),value :: stridex
      real(c_double),target,dimension(:,:) :: A
      integer(c_int),value :: lda
      integer(c_int64_t),value :: strideA
      integer(c_int),value :: batch_count
      !
      rocblas_dsyr_strided_batched_full_rank = rocblas_dsyr_strided_batched_orig(handle,uplo,n,alpha,c_loc(x),incx,stridex,c_loc(A),lda,strideA,batch_count)
    end function

    function rocblas_dsyr_strided_batched_rank_0(handle,uplo,n,alpha,x,incx,stridex,A,lda,strideA,batch_count)
      use iso_c_binding
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocblas_dsyr_strided_batched_rank_0
      type(c_ptr),value :: handle
      integer(kind(rocblas_fill_upper)),value :: uplo
      integer(c_int),value :: n
      real(c_double) :: alpha
      real(c_double),target :: x
      integer(c_int),value :: incx
      integer(c_int64_t),value :: stridex
      real(c_double),target :: A
      integer(c_int),value :: lda
      integer(c_int64_t),value :: strideA
      integer(c_int),value :: batch_count
      !
      rocblas_dsyr_strided_batched_rank_0 = rocblas_dsyr_strided_batched_orig(handle,uplo,n,alpha,c_loc(x),incx,stridex,c_loc(A),lda,strideA,batch_count)
    end function

    function rocblas_dsyr_strided_batched_rank_1(handle,uplo,n,alpha,x,incx,stridex,A,lda,strideA,batch_count)
      use iso_c_binding
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocblas_dsyr_strided_batched_rank_1
      type(c_ptr),value :: handle
      integer(kind(rocblas_fill_upper)),value :: uplo
      integer(c_int),value :: n
      real(c_double) :: alpha
      real(c_double),target,dimension(:) :: x
      integer(c_int),value :: incx
      integer(c_int64_t),value :: stridex
      real(c_double),target,dimension(:) :: A
      integer(c_int),value :: lda
      integer(c_int64_t),value :: strideA
      integer(c_int),value :: batch_count
      !
      rocblas_dsyr_strided_batched_rank_1 = rocblas_dsyr_strided_batched_orig(handle,uplo,n,alpha,c_loc(x),incx,stridex,c_loc(A),lda,strideA,batch_count)
    end function

    function rocblas_csyr_strided_batched_full_rank(handle,uplo,n,alpha,x,incx,stridex,A,lda,strideA,batch_count)
      use iso_c_binding
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocblas_csyr_strided_batched_full_rank
      type(c_ptr),value :: handle
      integer(kind(rocblas_fill_upper)),value :: uplo
      integer(c_int),value :: n
      complex(c_float_complex) :: alpha
      complex(c_float_complex),target,dimension(:) :: x
      integer(c_int),value :: incx
      integer(c_int64_t),value :: stridex
      complex(c_float_complex),target,dimension(:,:) :: A
      integer(c_int),value :: lda
      integer(c_int64_t),value :: strideA
      integer(c_int),value :: batch_count
      !
      rocblas_csyr_strided_batched_full_rank = rocblas_csyr_strided_batched_orig(handle,uplo,n,alpha,c_loc(x),incx,stridex,c_loc(A),lda,strideA,batch_count)
    end function

    function rocblas_csyr_strided_batched_rank_0(handle,uplo,n,alpha,x,incx,stridex,A,lda,strideA,batch_count)
      use iso_c_binding
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocblas_csyr_strided_batched_rank_0
      type(c_ptr),value :: handle
      integer(kind(rocblas_fill_upper)),value :: uplo
      integer(c_int),value :: n
      complex(c_float_complex) :: alpha
      complex(c_float_complex),target :: x
      integer(c_int),value :: incx
      integer(c_int64_t),value :: stridex
      complex(c_float_complex),target :: A
      integer(c_int),value :: lda
      integer(c_int64_t),value :: strideA
      integer(c_int),value :: batch_count
      !
      rocblas_csyr_strided_batched_rank_0 = rocblas_csyr_strided_batched_orig(handle,uplo,n,alpha,c_loc(x),incx,stridex,c_loc(A),lda,strideA,batch_count)
    end function

    function rocblas_csyr_strided_batched_rank_1(handle,uplo,n,alpha,x,incx,stridex,A,lda,strideA,batch_count)
      use iso_c_binding
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocblas_csyr_strided_batched_rank_1
      type(c_ptr),value :: handle
      integer(kind(rocblas_fill_upper)),value :: uplo
      integer(c_int),value :: n
      complex(c_float_complex) :: alpha
      complex(c_float_complex),target,dimension(:) :: x
      integer(c_int),value :: incx
      integer(c_int64_t),value :: stridex
      complex(c_float_complex),target,dimension(:) :: A
      integer(c_int),value :: lda
      integer(c_int64_t),value :: strideA
      integer(c_int),value :: batch_count
      !
      rocblas_csyr_strided_batched_rank_1 = rocblas_csyr_strided_batched_orig(handle,uplo,n,alpha,c_loc(x),incx,stridex,c_loc(A),lda,strideA,batch_count)
    end function

    function rocblas_zsyr_strided_batched_full_rank(handle,uplo,n,alpha,x,incx,stridex,A,lda,strideA,batch_count)
      use iso_c_binding
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocblas_zsyr_strided_batched_full_rank
      type(c_ptr),value :: handle
      integer(kind(rocblas_fill_upper)),value :: uplo
      integer(c_int),value :: n
      complex(c_double_complex) :: alpha
      complex(c_double_complex),target,dimension(:) :: x
      integer(c_int),value :: incx
      integer(c_int64_t),value :: stridex
      complex(c_double_complex),target,dimension(:,:) :: A
      integer(c_int),value :: lda
      integer(c_int64_t),value :: strideA
      integer(c_int),value :: batch_count
      !
      rocblas_zsyr_strided_batched_full_rank = rocblas_zsyr_strided_batched_orig(handle,uplo,n,alpha,c_loc(x),incx,stridex,c_loc(A),lda,strideA,batch_count)
    end function

    function rocblas_zsyr_strided_batched_rank_0(handle,uplo,n,alpha,x,incx,stridex,A,lda,strideA,batch_count)
      use iso_c_binding
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocblas_zsyr_strided_batched_rank_0
      type(c_ptr),value :: handle
      integer(kind(rocblas_fill_upper)),value :: uplo
      integer(c_int),value :: n
      complex(c_double_complex) :: alpha
      complex(c_double_complex),target :: x
      integer(c_int),value :: incx
      integer(c_int64_t),value :: stridex
      complex(c_double_complex),target :: A
      integer(c_int),value :: lda
      integer(c_int64_t),value :: strideA
      integer(c_int),value :: batch_count
      !
      rocblas_zsyr_strided_batched_rank_0 = rocblas_zsyr_strided_batched_orig(handle,uplo,n,alpha,c_loc(x),incx,stridex,c_loc(A),lda,strideA,batch_count)
    end function

    function rocblas_zsyr_strided_batched_rank_1(handle,uplo,n,alpha,x,incx,stridex,A,lda,strideA,batch_count)
      use iso_c_binding
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocblas_zsyr_strided_batched_rank_1
      type(c_ptr),value :: handle
      integer(kind(rocblas_fill_upper)),value :: uplo
      integer(c_int),value :: n
      complex(c_double_complex) :: alpha
      complex(c_double_complex),target,dimension(:) :: x
      integer(c_int),value :: incx
      integer(c_int64_t),value :: stridex
      complex(c_double_complex),target,dimension(:) :: A
      integer(c_int),value :: lda
      integer(c_int64_t),value :: strideA
      integer(c_int),value :: batch_count
      !
      rocblas_zsyr_strided_batched_rank_1 = rocblas_zsyr_strided_batched_orig(handle,uplo,n,alpha,c_loc(x),incx,stridex,c_loc(A),lda,strideA,batch_count)
    end function

    function rocblas_ssyr2_full_rank(handle,uplo,n,alpha,x,incx,y,incy,A,lda)
      use iso_c_binding
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocblas_ssyr2_full_rank
      type(c_ptr),value :: handle
      integer(kind(rocblas_fill_upper)),value :: uplo
      integer(c_int),value :: n
      real(c_float) :: alpha
      real(c_float),target,dimension(:) :: x
      integer(c_int),value :: incx
      real(c_float),target,dimension(:) :: y
      integer(c_int),value :: incy
      real(c_float),target,dimension(:,:) :: A
      integer(c_int),value :: lda
      !
      rocblas_ssyr2_full_rank = rocblas_ssyr2_orig(handle,uplo,n,alpha,c_loc(x),incx,c_loc(y),incy,c_loc(A),lda)
    end function

    function rocblas_ssyr2_rank_0(handle,uplo,n,alpha,x,incx,y,incy,A,lda)
      use iso_c_binding
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocblas_ssyr2_rank_0
      type(c_ptr),value :: handle
      integer(kind(rocblas_fill_upper)),value :: uplo
      integer(c_int),value :: n
      real(c_float) :: alpha
      real(c_float),target :: x
      integer(c_int),value :: incx
      real(c_float),target :: y
      integer(c_int),value :: incy
      real(c_float),target :: A
      integer(c_int),value :: lda
      !
      rocblas_ssyr2_rank_0 = rocblas_ssyr2_orig(handle,uplo,n,alpha,c_loc(x),incx,c_loc(y),incy,c_loc(A),lda)
    end function

    function rocblas_ssyr2_rank_1(handle,uplo,n,alpha,x,incx,y,incy,A,lda)
      use iso_c_binding
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocblas_ssyr2_rank_1
      type(c_ptr),value :: handle
      integer(kind(rocblas_fill_upper)),value :: uplo
      integer(c_int),value :: n
      real(c_float) :: alpha
      real(c_float),target,dimension(:) :: x
      integer(c_int),value :: incx
      real(c_float),target,dimension(:) :: y
      integer(c_int),value :: incy
      real(c_float),target,dimension(:) :: A
      integer(c_int),value :: lda
      !
      rocblas_ssyr2_rank_1 = rocblas_ssyr2_orig(handle,uplo,n,alpha,c_loc(x),incx,c_loc(y),incy,c_loc(A),lda)
    end function

    function rocblas_dsyr2_full_rank(handle,uplo,n,alpha,x,incx,y,incy,A,lda)
      use iso_c_binding
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocblas_dsyr2_full_rank
      type(c_ptr),value :: handle
      integer(kind(rocblas_fill_upper)),value :: uplo
      integer(c_int),value :: n
      real(c_double) :: alpha
      real(c_double),target,dimension(:) :: x
      integer(c_int),value :: incx
      real(c_double),target,dimension(:) :: y
      integer(c_int),value :: incy
      real(c_double),target,dimension(:,:) :: A
      integer(c_int),value :: lda
      !
      rocblas_dsyr2_full_rank = rocblas_dsyr2_orig(handle,uplo,n,alpha,c_loc(x),incx,c_loc(y),incy,c_loc(A),lda)
    end function

    function rocblas_dsyr2_rank_0(handle,uplo,n,alpha,x,incx,y,incy,A,lda)
      use iso_c_binding
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocblas_dsyr2_rank_0
      type(c_ptr),value :: handle
      integer(kind(rocblas_fill_upper)),value :: uplo
      integer(c_int),value :: n
      real(c_double) :: alpha
      real(c_double),target :: x
      integer(c_int),value :: incx
      real(c_double),target :: y
      integer(c_int),value :: incy
      real(c_double),target :: A
      integer(c_int),value :: lda
      !
      rocblas_dsyr2_rank_0 = rocblas_dsyr2_orig(handle,uplo,n,alpha,c_loc(x),incx,c_loc(y),incy,c_loc(A),lda)
    end function

    function rocblas_dsyr2_rank_1(handle,uplo,n,alpha,x,incx,y,incy,A,lda)
      use iso_c_binding
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocblas_dsyr2_rank_1
      type(c_ptr),value :: handle
      integer(kind(rocblas_fill_upper)),value :: uplo
      integer(c_int),value :: n
      real(c_double) :: alpha
      real(c_double),target,dimension(:) :: x
      integer(c_int),value :: incx
      real(c_double),target,dimension(:) :: y
      integer(c_int),value :: incy
      real(c_double),target,dimension(:) :: A
      integer(c_int),value :: lda
      !
      rocblas_dsyr2_rank_1 = rocblas_dsyr2_orig(handle,uplo,n,alpha,c_loc(x),incx,c_loc(y),incy,c_loc(A),lda)
    end function

    function rocblas_csyr2_full_rank(handle,uplo,n,alpha,x,incx,y,incy,A,lda)
      use iso_c_binding
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocblas_csyr2_full_rank
      type(c_ptr),value :: handle
      integer(kind(rocblas_fill_upper)),value :: uplo
      integer(c_int),value :: n
      complex(c_float_complex) :: alpha
      complex(c_float_complex),target,dimension(:) :: x
      integer(c_int),value :: incx
      complex(c_float_complex),target,dimension(:) :: y
      integer(c_int),value :: incy
      complex(c_float_complex),target,dimension(:,:) :: A
      integer(c_int),value :: lda
      !
      rocblas_csyr2_full_rank = rocblas_csyr2_orig(handle,uplo,n,alpha,c_loc(x),incx,c_loc(y),incy,c_loc(A),lda)
    end function

    function rocblas_csyr2_rank_0(handle,uplo,n,alpha,x,incx,y,incy,A,lda)
      use iso_c_binding
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocblas_csyr2_rank_0
      type(c_ptr),value :: handle
      integer(kind(rocblas_fill_upper)),value :: uplo
      integer(c_int),value :: n
      complex(c_float_complex) :: alpha
      complex(c_float_complex),target :: x
      integer(c_int),value :: incx
      complex(c_float_complex),target :: y
      integer(c_int),value :: incy
      complex(c_float_complex),target :: A
      integer(c_int),value :: lda
      !
      rocblas_csyr2_rank_0 = rocblas_csyr2_orig(handle,uplo,n,alpha,c_loc(x),incx,c_loc(y),incy,c_loc(A),lda)
    end function

    function rocblas_csyr2_rank_1(handle,uplo,n,alpha,x,incx,y,incy,A,lda)
      use iso_c_binding
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocblas_csyr2_rank_1
      type(c_ptr),value :: handle
      integer(kind(rocblas_fill_upper)),value :: uplo
      integer(c_int),value :: n
      complex(c_float_complex) :: alpha
      complex(c_float_complex),target,dimension(:) :: x
      integer(c_int),value :: incx
      complex(c_float_complex),target,dimension(:) :: y
      integer(c_int),value :: incy
      complex(c_float_complex),target,dimension(:) :: A
      integer(c_int),value :: lda
      !
      rocblas_csyr2_rank_1 = rocblas_csyr2_orig(handle,uplo,n,alpha,c_loc(x),incx,c_loc(y),incy,c_loc(A),lda)
    end function

    function rocblas_zsyr2_full_rank(handle,uplo,n,alpha,x,incx,y,incy,A,lda)
      use iso_c_binding
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocblas_zsyr2_full_rank
      type(c_ptr),value :: handle
      integer(kind(rocblas_fill_upper)),value :: uplo
      integer(c_int),value :: n
      complex(c_double_complex) :: alpha
      complex(c_double_complex),target,dimension(:) :: x
      integer(c_int),value :: incx
      complex(c_double_complex),target,dimension(:) :: y
      integer(c_int),value :: incy
      complex(c_double_complex),target,dimension(:,:) :: A
      integer(c_int),value :: lda
      !
      rocblas_zsyr2_full_rank = rocblas_zsyr2_orig(handle,uplo,n,alpha,c_loc(x),incx,c_loc(y),incy,c_loc(A),lda)
    end function

    function rocblas_zsyr2_rank_0(handle,uplo,n,alpha,x,incx,y,incy,A,lda)
      use iso_c_binding
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocblas_zsyr2_rank_0
      type(c_ptr),value :: handle
      integer(kind(rocblas_fill_upper)),value :: uplo
      integer(c_int),value :: n
      complex(c_double_complex) :: alpha
      complex(c_double_complex),target :: x
      integer(c_int),value :: incx
      complex(c_double_complex),target :: y
      integer(c_int),value :: incy
      complex(c_double_complex),target :: A
      integer(c_int),value :: lda
      !
      rocblas_zsyr2_rank_0 = rocblas_zsyr2_orig(handle,uplo,n,alpha,c_loc(x),incx,c_loc(y),incy,c_loc(A),lda)
    end function

    function rocblas_zsyr2_rank_1(handle,uplo,n,alpha,x,incx,y,incy,A,lda)
      use iso_c_binding
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocblas_zsyr2_rank_1
      type(c_ptr),value :: handle
      integer(kind(rocblas_fill_upper)),value :: uplo
      integer(c_int),value :: n
      complex(c_double_complex) :: alpha
      complex(c_double_complex),target,dimension(:) :: x
      integer(c_int),value :: incx
      complex(c_double_complex),target,dimension(:) :: y
      integer(c_int),value :: incy
      complex(c_double_complex),target,dimension(:) :: A
      integer(c_int),value :: lda
      !
      rocblas_zsyr2_rank_1 = rocblas_zsyr2_orig(handle,uplo,n,alpha,c_loc(x),incx,c_loc(y),incy,c_loc(A),lda)
    end function

    function rocblas_ssyr2_batched_full_rank(handle,uplo,n,alpha,x,incx,y,incy,A,lda,batch_count)
      use iso_c_binding
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocblas_ssyr2_batched_full_rank
      type(c_ptr),value :: handle
      integer(kind(rocblas_fill_upper)),value :: uplo
      integer(c_int),value :: n
      real(c_float) :: alpha
      real(c_float),target,dimension(:,:) :: x
      integer(c_int),value :: incx
      real(c_float),target,dimension(:,:) :: y
      integer(c_int),value :: incy
      real(c_float),target,dimension(:,:,:) :: A
      integer(c_int),value :: lda
      integer(c_int),value :: batch_count
      !
      rocblas_ssyr2_batched_full_rank = rocblas_ssyr2_batched_orig(handle,uplo,n,alpha,c_loc(x),incx,c_loc(y),incy,c_loc(A),lda,batch_count)
    end function

    function rocblas_ssyr2_batched_rank_0(handle,uplo,n,alpha,x,incx,y,incy,A,lda,batch_count)
      use iso_c_binding
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocblas_ssyr2_batched_rank_0
      type(c_ptr),value :: handle
      integer(kind(rocblas_fill_upper)),value :: uplo
      integer(c_int),value :: n
      real(c_float) :: alpha
      real(c_float),target :: x
      integer(c_int),value :: incx
      real(c_float),target :: y
      integer(c_int),value :: incy
      real(c_float),target :: A
      integer(c_int),value :: lda
      integer(c_int),value :: batch_count
      !
      rocblas_ssyr2_batched_rank_0 = rocblas_ssyr2_batched_orig(handle,uplo,n,alpha,c_loc(x),incx,c_loc(y),incy,c_loc(A),lda,batch_count)
    end function

    function rocblas_ssyr2_batched_rank_1(handle,uplo,n,alpha,x,incx,y,incy,A,lda,batch_count)
      use iso_c_binding
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocblas_ssyr2_batched_rank_1
      type(c_ptr),value :: handle
      integer(kind(rocblas_fill_upper)),value :: uplo
      integer(c_int),value :: n
      real(c_float) :: alpha
      real(c_float),target,dimension(:) :: x
      integer(c_int),value :: incx
      real(c_float),target,dimension(:) :: y
      integer(c_int),value :: incy
      real(c_float),target,dimension(:) :: A
      integer(c_int),value :: lda
      integer(c_int),value :: batch_count
      !
      rocblas_ssyr2_batched_rank_1 = rocblas_ssyr2_batched_orig(handle,uplo,n,alpha,c_loc(x),incx,c_loc(y),incy,c_loc(A),lda,batch_count)
    end function

    function rocblas_dsyr2_batched_full_rank(handle,uplo,n,alpha,x,incx,y,incy,A,lda,batch_count)
      use iso_c_binding
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocblas_dsyr2_batched_full_rank
      type(c_ptr),value :: handle
      integer(kind(rocblas_fill_upper)),value :: uplo
      integer(c_int),value :: n
      real(c_double) :: alpha
      real(c_double),target,dimension(:,:) :: x
      integer(c_int),value :: incx
      real(c_double),target,dimension(:,:) :: y
      integer(c_int),value :: incy
      real(c_double),target,dimension(:,:,:) :: A
      integer(c_int),value :: lda
      integer(c_int),value :: batch_count
      !
      rocblas_dsyr2_batched_full_rank = rocblas_dsyr2_batched_orig(handle,uplo,n,alpha,c_loc(x),incx,c_loc(y),incy,c_loc(A),lda,batch_count)
    end function

    function rocblas_dsyr2_batched_rank_0(handle,uplo,n,alpha,x,incx,y,incy,A,lda,batch_count)
      use iso_c_binding
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocblas_dsyr2_batched_rank_0
      type(c_ptr),value :: handle
      integer(kind(rocblas_fill_upper)),value :: uplo
      integer(c_int),value :: n
      real(c_double) :: alpha
      real(c_double),target :: x
      integer(c_int),value :: incx
      real(c_double),target :: y
      integer(c_int),value :: incy
      real(c_double),target :: A
      integer(c_int),value :: lda
      integer(c_int),value :: batch_count
      !
      rocblas_dsyr2_batched_rank_0 = rocblas_dsyr2_batched_orig(handle,uplo,n,alpha,c_loc(x),incx,c_loc(y),incy,c_loc(A),lda,batch_count)
    end function

    function rocblas_dsyr2_batched_rank_1(handle,uplo,n,alpha,x,incx,y,incy,A,lda,batch_count)
      use iso_c_binding
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocblas_dsyr2_batched_rank_1
      type(c_ptr),value :: handle
      integer(kind(rocblas_fill_upper)),value :: uplo
      integer(c_int),value :: n
      real(c_double) :: alpha
      real(c_double),target,dimension(:) :: x
      integer(c_int),value :: incx
      real(c_double),target,dimension(:) :: y
      integer(c_int),value :: incy
      real(c_double),target,dimension(:) :: A
      integer(c_int),value :: lda
      integer(c_int),value :: batch_count
      !
      rocblas_dsyr2_batched_rank_1 = rocblas_dsyr2_batched_orig(handle,uplo,n,alpha,c_loc(x),incx,c_loc(y),incy,c_loc(A),lda,batch_count)
    end function

    function rocblas_csyr2_batched_full_rank(handle,uplo,n,alpha,x,incx,y,incy,A,lda,batch_count)
      use iso_c_binding
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocblas_csyr2_batched_full_rank
      type(c_ptr),value :: handle
      integer(kind(rocblas_fill_upper)),value :: uplo
      integer(c_int),value :: n
      complex(c_float_complex) :: alpha
      complex(c_float_complex),target,dimension(:,:) :: x
      integer(c_int),value :: incx
      complex(c_float_complex),target,dimension(:,:) :: y
      integer(c_int),value :: incy
      complex(c_float_complex),target,dimension(:,:,:) :: A
      integer(c_int),value :: lda
      integer(c_int),value :: batch_count
      !
      rocblas_csyr2_batched_full_rank = rocblas_csyr2_batched_orig(handle,uplo,n,alpha,c_loc(x),incx,c_loc(y),incy,c_loc(A),lda,batch_count)
    end function

    function rocblas_csyr2_batched_rank_0(handle,uplo,n,alpha,x,incx,y,incy,A,lda,batch_count)
      use iso_c_binding
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocblas_csyr2_batched_rank_0
      type(c_ptr),value :: handle
      integer(kind(rocblas_fill_upper)),value :: uplo
      integer(c_int),value :: n
      complex(c_float_complex) :: alpha
      complex(c_float_complex),target :: x
      integer(c_int),value :: incx
      complex(c_float_complex),target :: y
      integer(c_int),value :: incy
      complex(c_float_complex),target :: A
      integer(c_int),value :: lda
      integer(c_int),value :: batch_count
      !
      rocblas_csyr2_batched_rank_0 = rocblas_csyr2_batched_orig(handle,uplo,n,alpha,c_loc(x),incx,c_loc(y),incy,c_loc(A),lda,batch_count)
    end function

    function rocblas_csyr2_batched_rank_1(handle,uplo,n,alpha,x,incx,y,incy,A,lda,batch_count)
      use iso_c_binding
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocblas_csyr2_batched_rank_1
      type(c_ptr),value :: handle
      integer(kind(rocblas_fill_upper)),value :: uplo
      integer(c_int),value :: n
      complex(c_float_complex) :: alpha
      complex(c_float_complex),target,dimension(:) :: x
      integer(c_int),value :: incx
      complex(c_float_complex),target,dimension(:) :: y
      integer(c_int),value :: incy
      complex(c_float_complex),target,dimension(:) :: A
      integer(c_int),value :: lda
      integer(c_int),value :: batch_count
      !
      rocblas_csyr2_batched_rank_1 = rocblas_csyr2_batched_orig(handle,uplo,n,alpha,c_loc(x),incx,c_loc(y),incy,c_loc(A),lda,batch_count)
    end function

    function rocblas_zsyr2_batched_full_rank(handle,uplo,n,alpha,x,incx,y,incy,A,lda,batch_count)
      use iso_c_binding
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocblas_zsyr2_batched_full_rank
      type(c_ptr),value :: handle
      integer(kind(rocblas_fill_upper)),value :: uplo
      integer(c_int),value :: n
      complex(c_double_complex) :: alpha
      complex(c_double_complex),target,dimension(:,:) :: x
      integer(c_int),value :: incx
      complex(c_double_complex),target,dimension(:,:) :: y
      integer(c_int),value :: incy
      complex(c_double_complex),target,dimension(:,:,:) :: A
      integer(c_int),value :: lda
      integer(c_int),value :: batch_count
      !
      rocblas_zsyr2_batched_full_rank = rocblas_zsyr2_batched_orig(handle,uplo,n,alpha,c_loc(x),incx,c_loc(y),incy,c_loc(A),lda,batch_count)
    end function

    function rocblas_zsyr2_batched_rank_0(handle,uplo,n,alpha,x,incx,y,incy,A,lda,batch_count)
      use iso_c_binding
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocblas_zsyr2_batched_rank_0
      type(c_ptr),value :: handle
      integer(kind(rocblas_fill_upper)),value :: uplo
      integer(c_int),value :: n
      complex(c_double_complex) :: alpha
      complex(c_double_complex),target :: x
      integer(c_int),value :: incx
      complex(c_double_complex),target :: y
      integer(c_int),value :: incy
      complex(c_double_complex),target :: A
      integer(c_int),value :: lda
      integer(c_int),value :: batch_count
      !
      rocblas_zsyr2_batched_rank_0 = rocblas_zsyr2_batched_orig(handle,uplo,n,alpha,c_loc(x),incx,c_loc(y),incy,c_loc(A),lda,batch_count)
    end function

    function rocblas_zsyr2_batched_rank_1(handle,uplo,n,alpha,x,incx,y,incy,A,lda,batch_count)
      use iso_c_binding
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocblas_zsyr2_batched_rank_1
      type(c_ptr),value :: handle
      integer(kind(rocblas_fill_upper)),value :: uplo
      integer(c_int),value :: n
      complex(c_double_complex) :: alpha
      complex(c_double_complex),target,dimension(:) :: x
      integer(c_int),value :: incx
      complex(c_double_complex),target,dimension(:) :: y
      integer(c_int),value :: incy
      complex(c_double_complex),target,dimension(:) :: A
      integer(c_int),value :: lda
      integer(c_int),value :: batch_count
      !
      rocblas_zsyr2_batched_rank_1 = rocblas_zsyr2_batched_orig(handle,uplo,n,alpha,c_loc(x),incx,c_loc(y),incy,c_loc(A),lda,batch_count)
    end function

    function rocblas_ssyr2_strided_batched_full_rank(handle,uplo,n,alpha,x,incx,stridex,y,incy,stridey,A,lda,strideA,batch_count)
      use iso_c_binding
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocblas_ssyr2_strided_batched_full_rank
      type(c_ptr),value :: handle
      integer(kind(rocblas_fill_upper)),value :: uplo
      integer(c_int),value :: n
      real(c_float) :: alpha
      real(c_float),target,dimension(:) :: x
      integer(c_int),value :: incx
      integer(c_int64_t),value :: stridex
      real(c_float),target,dimension(:) :: y
      integer(c_int),value :: incy
      integer(c_int64_t),value :: stridey
      real(c_float),target,dimension(:,:) :: A
      integer(c_int),value :: lda
      integer(c_int64_t),value :: strideA
      integer(c_int),value :: batch_count
      !
      rocblas_ssyr2_strided_batched_full_rank = rocblas_ssyr2_strided_batched_orig(handle,uplo,n,alpha,c_loc(x),incx,stridex,c_loc(y),incy,stridey,c_loc(A),lda,strideA,batch_count)
    end function

    function rocblas_ssyr2_strided_batched_rank_0(handle,uplo,n,alpha,x,incx,stridex,y,incy,stridey,A,lda,strideA,batch_count)
      use iso_c_binding
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocblas_ssyr2_strided_batched_rank_0
      type(c_ptr),value :: handle
      integer(kind(rocblas_fill_upper)),value :: uplo
      integer(c_int),value :: n
      real(c_float) :: alpha
      real(c_float),target :: x
      integer(c_int),value :: incx
      integer(c_int64_t),value :: stridex
      real(c_float),target :: y
      integer(c_int),value :: incy
      integer(c_int64_t),value :: stridey
      real(c_float),target :: A
      integer(c_int),value :: lda
      integer(c_int64_t),value :: strideA
      integer(c_int),value :: batch_count
      !
      rocblas_ssyr2_strided_batched_rank_0 = rocblas_ssyr2_strided_batched_orig(handle,uplo,n,alpha,c_loc(x),incx,stridex,c_loc(y),incy,stridey,c_loc(A),lda,strideA,batch_count)
    end function

    function rocblas_ssyr2_strided_batched_rank_1(handle,uplo,n,alpha,x,incx,stridex,y,incy,stridey,A,lda,strideA,batch_count)
      use iso_c_binding
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocblas_ssyr2_strided_batched_rank_1
      type(c_ptr),value :: handle
      integer(kind(rocblas_fill_upper)),value :: uplo
      integer(c_int),value :: n
      real(c_float) :: alpha
      real(c_float),target,dimension(:) :: x
      integer(c_int),value :: incx
      integer(c_int64_t),value :: stridex
      real(c_float),target,dimension(:) :: y
      integer(c_int),value :: incy
      integer(c_int64_t),value :: stridey
      real(c_float),target,dimension(:) :: A
      integer(c_int),value :: lda
      integer(c_int64_t),value :: strideA
      integer(c_int),value :: batch_count
      !
      rocblas_ssyr2_strided_batched_rank_1 = rocblas_ssyr2_strided_batched_orig(handle,uplo,n,alpha,c_loc(x),incx,stridex,c_loc(y),incy,stridey,c_loc(A),lda,strideA,batch_count)
    end function

    function rocblas_dsyr2_strided_batched_full_rank(handle,uplo,n,alpha,x,incx,stridex,y,incy,stridey,A,lda,strideA,batch_count)
      use iso_c_binding
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocblas_dsyr2_strided_batched_full_rank
      type(c_ptr),value :: handle
      integer(kind(rocblas_fill_upper)),value :: uplo
      integer(c_int),value :: n
      real(c_double) :: alpha
      real(c_double),target,dimension(:) :: x
      integer(c_int),value :: incx
      integer(c_int64_t),value :: stridex
      real(c_double),target,dimension(:) :: y
      integer(c_int),value :: incy
      integer(c_int64_t),value :: stridey
      real(c_double),target,dimension(:,:) :: A
      integer(c_int),value :: lda
      integer(c_int64_t),value :: strideA
      integer(c_int),value :: batch_count
      !
      rocblas_dsyr2_strided_batched_full_rank = rocblas_dsyr2_strided_batched_orig(handle,uplo,n,alpha,c_loc(x),incx,stridex,c_loc(y),incy,stridey,c_loc(A),lda,strideA,batch_count)
    end function

    function rocblas_dsyr2_strided_batched_rank_0(handle,uplo,n,alpha,x,incx,stridex,y,incy,stridey,A,lda,strideA,batch_count)
      use iso_c_binding
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocblas_dsyr2_strided_batched_rank_0
      type(c_ptr),value :: handle
      integer(kind(rocblas_fill_upper)),value :: uplo
      integer(c_int),value :: n
      real(c_double) :: alpha
      real(c_double),target :: x
      integer(c_int),value :: incx
      integer(c_int64_t),value :: stridex
      real(c_double),target :: y
      integer(c_int),value :: incy
      integer(c_int64_t),value :: stridey
      real(c_double),target :: A
      integer(c_int),value :: lda
      integer(c_int64_t),value :: strideA
      integer(c_int),value :: batch_count
      !
      rocblas_dsyr2_strided_batched_rank_0 = rocblas_dsyr2_strided_batched_orig(handle,uplo,n,alpha,c_loc(x),incx,stridex,c_loc(y),incy,stridey,c_loc(A),lda,strideA,batch_count)
    end function

    function rocblas_dsyr2_strided_batched_rank_1(handle,uplo,n,alpha,x,incx,stridex,y,incy,stridey,A,lda,strideA,batch_count)
      use iso_c_binding
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocblas_dsyr2_strided_batched_rank_1
      type(c_ptr),value :: handle
      integer(kind(rocblas_fill_upper)),value :: uplo
      integer(c_int),value :: n
      real(c_double) :: alpha
      real(c_double),target,dimension(:) :: x
      integer(c_int),value :: incx
      integer(c_int64_t),value :: stridex
      real(c_double),target,dimension(:) :: y
      integer(c_int),value :: incy
      integer(c_int64_t),value :: stridey
      real(c_double),target,dimension(:) :: A
      integer(c_int),value :: lda
      integer(c_int64_t),value :: strideA
      integer(c_int),value :: batch_count
      !
      rocblas_dsyr2_strided_batched_rank_1 = rocblas_dsyr2_strided_batched_orig(handle,uplo,n,alpha,c_loc(x),incx,stridex,c_loc(y),incy,stridey,c_loc(A),lda,strideA,batch_count)
    end function

    function rocblas_csyr2_strided_batched_full_rank(handle,uplo,n,alpha,x,incx,stridex,y,incy,stridey,A,lda,strideA,batch_count)
      use iso_c_binding
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocblas_csyr2_strided_batched_full_rank
      type(c_ptr),value :: handle
      integer(kind(rocblas_fill_upper)),value :: uplo
      integer(c_int),value :: n
      complex(c_float_complex) :: alpha
      complex(c_float_complex),target,dimension(:) :: x
      integer(c_int),value :: incx
      integer(c_int64_t),value :: stridex
      complex(c_float_complex),target,dimension(:) :: y
      integer(c_int),value :: incy
      integer(c_int64_t),value :: stridey
      complex(c_float_complex),target,dimension(:,:) :: A
      integer(c_int),value :: lda
      integer(c_int64_t),value :: strideA
      integer(c_int),value :: batch_count
      !
      rocblas_csyr2_strided_batched_full_rank = rocblas_csyr2_strided_batched_orig(handle,uplo,n,alpha,c_loc(x),incx,stridex,c_loc(y),incy,stridey,c_loc(A),lda,strideA,batch_count)
    end function

    function rocblas_csyr2_strided_batched_rank_0(handle,uplo,n,alpha,x,incx,stridex,y,incy,stridey,A,lda,strideA,batch_count)
      use iso_c_binding
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocblas_csyr2_strided_batched_rank_0
      type(c_ptr),value :: handle
      integer(kind(rocblas_fill_upper)),value :: uplo
      integer(c_int),value :: n
      complex(c_float_complex) :: alpha
      complex(c_float_complex),target :: x
      integer(c_int),value :: incx
      integer(c_int64_t),value :: stridex
      complex(c_float_complex),target :: y
      integer(c_int),value :: incy
      integer(c_int64_t),value :: stridey
      complex(c_float_complex),target :: A
      integer(c_int),value :: lda
      integer(c_int64_t),value :: strideA
      integer(c_int),value :: batch_count
      !
      rocblas_csyr2_strided_batched_rank_0 = rocblas_csyr2_strided_batched_orig(handle,uplo,n,alpha,c_loc(x),incx,stridex,c_loc(y),incy,stridey,c_loc(A),lda,strideA,batch_count)
    end function

    function rocblas_csyr2_strided_batched_rank_1(handle,uplo,n,alpha,x,incx,stridex,y,incy,stridey,A,lda,strideA,batch_count)
      use iso_c_binding
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocblas_csyr2_strided_batched_rank_1
      type(c_ptr),value :: handle
      integer(kind(rocblas_fill_upper)),value :: uplo
      integer(c_int),value :: n
      complex(c_float_complex) :: alpha
      complex(c_float_complex),target,dimension(:) :: x
      integer(c_int),value :: incx
      integer(c_int64_t),value :: stridex
      complex(c_float_complex),target,dimension(:) :: y
      integer(c_int),value :: incy
      integer(c_int64_t),value :: stridey
      complex(c_float_complex),target,dimension(:) :: A
      integer(c_int),value :: lda
      integer(c_int64_t),value :: strideA
      integer(c_int),value :: batch_count
      !
      rocblas_csyr2_strided_batched_rank_1 = rocblas_csyr2_strided_batched_orig(handle,uplo,n,alpha,c_loc(x),incx,stridex,c_loc(y),incy,stridey,c_loc(A),lda,strideA,batch_count)
    end function

    function rocblas_zsyr2_strided_batched_full_rank(handle,uplo,n,alpha,x,incx,stridex,y,incy,stridey,A,lda,strideA,batch_count)
      use iso_c_binding
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocblas_zsyr2_strided_batched_full_rank
      type(c_ptr),value :: handle
      integer(kind(rocblas_fill_upper)),value :: uplo
      integer(c_int),value :: n
      complex(c_double_complex) :: alpha
      complex(c_double_complex),target,dimension(:) :: x
      integer(c_int),value :: incx
      integer(c_int64_t),value :: stridex
      complex(c_double_complex),target,dimension(:) :: y
      integer(c_int),value :: incy
      integer(c_int64_t),value :: stridey
      complex(c_double_complex),target,dimension(:,:) :: A
      integer(c_int),value :: lda
      integer(c_int64_t),value :: strideA
      integer(c_int),value :: batch_count
      !
      rocblas_zsyr2_strided_batched_full_rank = rocblas_zsyr2_strided_batched_orig(handle,uplo,n,alpha,c_loc(x),incx,stridex,c_loc(y),incy,stridey,c_loc(A),lda,strideA,batch_count)
    end function

    function rocblas_zsyr2_strided_batched_rank_0(handle,uplo,n,alpha,x,incx,stridex,y,incy,stridey,A,lda,strideA,batch_count)
      use iso_c_binding
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocblas_zsyr2_strided_batched_rank_0
      type(c_ptr),value :: handle
      integer(kind(rocblas_fill_upper)),value :: uplo
      integer(c_int),value :: n
      complex(c_double_complex) :: alpha
      complex(c_double_complex),target :: x
      integer(c_int),value :: incx
      integer(c_int64_t),value :: stridex
      complex(c_double_complex),target :: y
      integer(c_int),value :: incy
      integer(c_int64_t),value :: stridey
      complex(c_double_complex),target :: A
      integer(c_int),value :: lda
      integer(c_int64_t),value :: strideA
      integer(c_int),value :: batch_count
      !
      rocblas_zsyr2_strided_batched_rank_0 = rocblas_zsyr2_strided_batched_orig(handle,uplo,n,alpha,c_loc(x),incx,stridex,c_loc(y),incy,stridey,c_loc(A),lda,strideA,batch_count)
    end function

    function rocblas_zsyr2_strided_batched_rank_1(handle,uplo,n,alpha,x,incx,stridex,y,incy,stridey,A,lda,strideA,batch_count)
      use iso_c_binding
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocblas_zsyr2_strided_batched_rank_1
      type(c_ptr),value :: handle
      integer(kind(rocblas_fill_upper)),value :: uplo
      integer(c_int),value :: n
      complex(c_double_complex) :: alpha
      complex(c_double_complex),target,dimension(:) :: x
      integer(c_int),value :: incx
      integer(c_int64_t),value :: stridex
      complex(c_double_complex),target,dimension(:) :: y
      integer(c_int),value :: incy
      integer(c_int64_t),value :: stridey
      complex(c_double_complex),target,dimension(:) :: A
      integer(c_int),value :: lda
      integer(c_int64_t),value :: strideA
      integer(c_int),value :: batch_count
      !
      rocblas_zsyr2_strided_batched_rank_1 = rocblas_zsyr2_strided_batched_orig(handle,uplo,n,alpha,c_loc(x),incx,stridex,c_loc(y),incy,stridey,c_loc(A),lda,strideA,batch_count)
    end function

    function rocblas_chemm_full_rank(handle,side,uplo,n,k,alpha,A,lda,B,ldb,beta,C,ldc)
      use iso_c_binding
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocblas_chemm_full_rank
      type(c_ptr),value :: handle
      integer(kind(rocblas_side_left)),value :: side
      integer(kind(rocblas_fill_upper)),value :: uplo
      integer(c_int),value :: n
      integer(c_int),value :: k
      complex(c_float_complex) :: alpha
      complex(c_float_complex),target,dimension(:,:) :: A
      integer(c_int),value :: lda
      complex(c_float_complex),target,dimension(:,:) :: B
      integer(c_int),value :: ldb
      complex(c_float_complex) :: beta
      complex(c_float_complex),target,dimension(:,:) :: C
      integer(c_int),value :: ldc
      !
      rocblas_chemm_full_rank = rocblas_chemm_orig(handle,side,uplo,n,k,alpha,c_loc(A),lda,c_loc(B),ldb,beta,c_loc(C),ldc)
    end function

    function rocblas_chemm_rank_0(handle,side,uplo,n,k,alpha,A,lda,B,ldb,beta,C,ldc)
      use iso_c_binding
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocblas_chemm_rank_0
      type(c_ptr),value :: handle
      integer(kind(rocblas_side_left)),value :: side
      integer(kind(rocblas_fill_upper)),value :: uplo
      integer(c_int),value :: n
      integer(c_int),value :: k
      complex(c_float_complex) :: alpha
      complex(c_float_complex),target :: A
      integer(c_int),value :: lda
      complex(c_float_complex),target :: B
      integer(c_int),value :: ldb
      complex(c_float_complex) :: beta
      complex(c_float_complex),target :: C
      integer(c_int),value :: ldc
      !
      rocblas_chemm_rank_0 = rocblas_chemm_orig(handle,side,uplo,n,k,alpha,c_loc(A),lda,c_loc(B),ldb,beta,c_loc(C),ldc)
    end function

    function rocblas_chemm_rank_1(handle,side,uplo,n,k,alpha,A,lda,B,ldb,beta,C,ldc)
      use iso_c_binding
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocblas_chemm_rank_1
      type(c_ptr),value :: handle
      integer(kind(rocblas_side_left)),value :: side
      integer(kind(rocblas_fill_upper)),value :: uplo
      integer(c_int),value :: n
      integer(c_int),value :: k
      complex(c_float_complex) :: alpha
      complex(c_float_complex),target,dimension(:) :: A
      integer(c_int),value :: lda
      complex(c_float_complex),target,dimension(:) :: B
      integer(c_int),value :: ldb
      complex(c_float_complex) :: beta
      complex(c_float_complex),target,dimension(:) :: C
      integer(c_int),value :: ldc
      !
      rocblas_chemm_rank_1 = rocblas_chemm_orig(handle,side,uplo,n,k,alpha,c_loc(A),lda,c_loc(B),ldb,beta,c_loc(C),ldc)
    end function

    function rocblas_zhemm_full_rank(handle,side,uplo,n,k,alpha,A,lda,B,ldb,beta,C,ldc)
      use iso_c_binding
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocblas_zhemm_full_rank
      type(c_ptr),value :: handle
      integer(kind(rocblas_side_left)),value :: side
      integer(kind(rocblas_fill_upper)),value :: uplo
      integer(c_int),value :: n
      integer(c_int),value :: k
      complex(c_double_complex) :: alpha
      complex(c_double_complex),target,dimension(:,:) :: A
      integer(c_int),value :: lda
      complex(c_double_complex),target,dimension(:,:) :: B
      integer(c_int),value :: ldb
      complex(c_double_complex) :: beta
      complex(c_double_complex),target,dimension(:,:) :: C
      integer(c_int),value :: ldc
      !
      rocblas_zhemm_full_rank = rocblas_zhemm_orig(handle,side,uplo,n,k,alpha,c_loc(A),lda,c_loc(B),ldb,beta,c_loc(C),ldc)
    end function

    function rocblas_zhemm_rank_0(handle,side,uplo,n,k,alpha,A,lda,B,ldb,beta,C,ldc)
      use iso_c_binding
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocblas_zhemm_rank_0
      type(c_ptr),value :: handle
      integer(kind(rocblas_side_left)),value :: side
      integer(kind(rocblas_fill_upper)),value :: uplo
      integer(c_int),value :: n
      integer(c_int),value :: k
      complex(c_double_complex) :: alpha
      complex(c_double_complex),target :: A
      integer(c_int),value :: lda
      complex(c_double_complex),target :: B
      integer(c_int),value :: ldb
      complex(c_double_complex) :: beta
      complex(c_double_complex),target :: C
      integer(c_int),value :: ldc
      !
      rocblas_zhemm_rank_0 = rocblas_zhemm_orig(handle,side,uplo,n,k,alpha,c_loc(A),lda,c_loc(B),ldb,beta,c_loc(C),ldc)
    end function

    function rocblas_zhemm_rank_1(handle,side,uplo,n,k,alpha,A,lda,B,ldb,beta,C,ldc)
      use iso_c_binding
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocblas_zhemm_rank_1
      type(c_ptr),value :: handle
      integer(kind(rocblas_side_left)),value :: side
      integer(kind(rocblas_fill_upper)),value :: uplo
      integer(c_int),value :: n
      integer(c_int),value :: k
      complex(c_double_complex) :: alpha
      complex(c_double_complex),target,dimension(:) :: A
      integer(c_int),value :: lda
      complex(c_double_complex),target,dimension(:) :: B
      integer(c_int),value :: ldb
      complex(c_double_complex) :: beta
      complex(c_double_complex),target,dimension(:) :: C
      integer(c_int),value :: ldc
      !
      rocblas_zhemm_rank_1 = rocblas_zhemm_orig(handle,side,uplo,n,k,alpha,c_loc(A),lda,c_loc(B),ldb,beta,c_loc(C),ldc)
    end function

    function rocblas_chemm_batched_full_rank(handle,side,uplo,m,n,alpha,A,lda,B,ldb,beta,C,ldc,batch_count)
      use iso_c_binding
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocblas_chemm_batched_full_rank
      type(c_ptr),value :: handle
      integer(kind(rocblas_side_left)),value :: side
      integer(kind(rocblas_fill_upper)),value :: uplo
      integer(c_int),value :: m
      integer(c_int),value :: n
      complex(c_float_complex) :: alpha
      complex(c_float_complex),target,dimension(:,:,:) :: A
      integer(c_int),value :: lda
      complex(c_float_complex),target,dimension(:,:,:) :: B
      integer(c_int),value :: ldb
      complex(c_float_complex) :: beta
      complex(c_float_complex),target,dimension(:,:,:) :: C
      integer(c_int),value :: ldc
      integer(c_int),value :: batch_count
      !
      rocblas_chemm_batched_full_rank = rocblas_chemm_batched_orig(handle,side,uplo,m,n,alpha,c_loc(A),lda,c_loc(B),ldb,beta,c_loc(C),ldc,batch_count)
    end function

    function rocblas_chemm_batched_rank_0(handle,side,uplo,m,n,alpha,A,lda,B,ldb,beta,C,ldc,batch_count)
      use iso_c_binding
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocblas_chemm_batched_rank_0
      type(c_ptr),value :: handle
      integer(kind(rocblas_side_left)),value :: side
      integer(kind(rocblas_fill_upper)),value :: uplo
      integer(c_int),value :: m
      integer(c_int),value :: n
      complex(c_float_complex) :: alpha
      complex(c_float_complex),target :: A
      integer(c_int),value :: lda
      complex(c_float_complex),target :: B
      integer(c_int),value :: ldb
      complex(c_float_complex) :: beta
      complex(c_float_complex),target :: C
      integer(c_int),value :: ldc
      integer(c_int),value :: batch_count
      !
      rocblas_chemm_batched_rank_0 = rocblas_chemm_batched_orig(handle,side,uplo,m,n,alpha,c_loc(A),lda,c_loc(B),ldb,beta,c_loc(C),ldc,batch_count)
    end function

    function rocblas_chemm_batched_rank_1(handle,side,uplo,m,n,alpha,A,lda,B,ldb,beta,C,ldc,batch_count)
      use iso_c_binding
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocblas_chemm_batched_rank_1
      type(c_ptr),value :: handle
      integer(kind(rocblas_side_left)),value :: side
      integer(kind(rocblas_fill_upper)),value :: uplo
      integer(c_int),value :: m
      integer(c_int),value :: n
      complex(c_float_complex) :: alpha
      complex(c_float_complex),target,dimension(:) :: A
      integer(c_int),value :: lda
      complex(c_float_complex),target,dimension(:) :: B
      integer(c_int),value :: ldb
      complex(c_float_complex) :: beta
      complex(c_float_complex),target,dimension(:) :: C
      integer(c_int),value :: ldc
      integer(c_int),value :: batch_count
      !
      rocblas_chemm_batched_rank_1 = rocblas_chemm_batched_orig(handle,side,uplo,m,n,alpha,c_loc(A),lda,c_loc(B),ldb,beta,c_loc(C),ldc,batch_count)
    end function

    function rocblas_zhemm_batched_full_rank(handle,side,uplo,m,n,alpha,A,lda,B,ldb,beta,C,ldc,batch_count)
      use iso_c_binding
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocblas_zhemm_batched_full_rank
      type(c_ptr),value :: handle
      integer(kind(rocblas_side_left)),value :: side
      integer(kind(rocblas_fill_upper)),value :: uplo
      integer(c_int),value :: m
      integer(c_int),value :: n
      complex(c_double_complex) :: alpha
      complex(c_double_complex),target,dimension(:,:,:) :: A
      integer(c_int),value :: lda
      complex(c_double_complex),target,dimension(:,:,:) :: B
      integer(c_int),value :: ldb
      complex(c_double_complex) :: beta
      complex(c_double_complex),target,dimension(:,:,:) :: C
      integer(c_int),value :: ldc
      integer(c_int),value :: batch_count
      !
      rocblas_zhemm_batched_full_rank = rocblas_zhemm_batched_orig(handle,side,uplo,m,n,alpha,c_loc(A),lda,c_loc(B),ldb,beta,c_loc(C),ldc,batch_count)
    end function

    function rocblas_zhemm_batched_rank_0(handle,side,uplo,m,n,alpha,A,lda,B,ldb,beta,C,ldc,batch_count)
      use iso_c_binding
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocblas_zhemm_batched_rank_0
      type(c_ptr),value :: handle
      integer(kind(rocblas_side_left)),value :: side
      integer(kind(rocblas_fill_upper)),value :: uplo
      integer(c_int),value :: m
      integer(c_int),value :: n
      complex(c_double_complex) :: alpha
      complex(c_double_complex),target :: A
      integer(c_int),value :: lda
      complex(c_double_complex),target :: B
      integer(c_int),value :: ldb
      complex(c_double_complex) :: beta
      complex(c_double_complex),target :: C
      integer(c_int),value :: ldc
      integer(c_int),value :: batch_count
      !
      rocblas_zhemm_batched_rank_0 = rocblas_zhemm_batched_orig(handle,side,uplo,m,n,alpha,c_loc(A),lda,c_loc(B),ldb,beta,c_loc(C),ldc,batch_count)
    end function

    function rocblas_zhemm_batched_rank_1(handle,side,uplo,m,n,alpha,A,lda,B,ldb,beta,C,ldc,batch_count)
      use iso_c_binding
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocblas_zhemm_batched_rank_1
      type(c_ptr),value :: handle
      integer(kind(rocblas_side_left)),value :: side
      integer(kind(rocblas_fill_upper)),value :: uplo
      integer(c_int),value :: m
      integer(c_int),value :: n
      complex(c_double_complex) :: alpha
      complex(c_double_complex),target,dimension(:) :: A
      integer(c_int),value :: lda
      complex(c_double_complex),target,dimension(:) :: B
      integer(c_int),value :: ldb
      complex(c_double_complex) :: beta
      complex(c_double_complex),target,dimension(:) :: C
      integer(c_int),value :: ldc
      integer(c_int),value :: batch_count
      !
      rocblas_zhemm_batched_rank_1 = rocblas_zhemm_batched_orig(handle,side,uplo,m,n,alpha,c_loc(A),lda,c_loc(B),ldb,beta,c_loc(C),ldc,batch_count)
    end function

    function rocblas_chemm_strided_batched_full_rank(handle,side,uplo,m,n,alpha,A,lda,stride_A,B,ldb,stride_B,beta,C,ldc,stride_C,batch_count)
      use iso_c_binding
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocblas_chemm_strided_batched_full_rank
      type(c_ptr),value :: handle
      integer(kind(rocblas_side_left)),value :: side
      integer(kind(rocblas_fill_upper)),value :: uplo
      integer(c_int),value :: m
      integer(c_int),value :: n
      complex(c_float_complex) :: alpha
      complex(c_float_complex),target,dimension(:,:) :: A
      integer(c_int),value :: lda
      integer(c_int64_t),value :: stride_A
      complex(c_float_complex),target,dimension(:,:) :: B
      integer(c_int),value :: ldb
      integer(c_int64_t),value :: stride_B
      complex(c_float_complex) :: beta
      complex(c_float_complex),target,dimension(:,:) :: C
      integer(c_int),value :: ldc
      integer(c_int64_t),value :: stride_C
      integer(c_int),value :: batch_count
      !
      rocblas_chemm_strided_batched_full_rank = rocblas_chemm_strided_batched_orig(handle,side,uplo,m,n,alpha,c_loc(A),lda,stride_A,c_loc(B),ldb,stride_B,beta,c_loc(C),ldc,stride_C,batch_count)
    end function

    function rocblas_chemm_strided_batched_rank_0(handle,side,uplo,m,n,alpha,A,lda,stride_A,B,ldb,stride_B,beta,C,ldc,stride_C,batch_count)
      use iso_c_binding
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocblas_chemm_strided_batched_rank_0
      type(c_ptr),value :: handle
      integer(kind(rocblas_side_left)),value :: side
      integer(kind(rocblas_fill_upper)),value :: uplo
      integer(c_int),value :: m
      integer(c_int),value :: n
      complex(c_float_complex) :: alpha
      complex(c_float_complex),target :: A
      integer(c_int),value :: lda
      integer(c_int64_t),value :: stride_A
      complex(c_float_complex),target :: B
      integer(c_int),value :: ldb
      integer(c_int64_t),value :: stride_B
      complex(c_float_complex) :: beta
      complex(c_float_complex),target :: C
      integer(c_int),value :: ldc
      integer(c_int64_t),value :: stride_C
      integer(c_int),value :: batch_count
      !
      rocblas_chemm_strided_batched_rank_0 = rocblas_chemm_strided_batched_orig(handle,side,uplo,m,n,alpha,c_loc(A),lda,stride_A,c_loc(B),ldb,stride_B,beta,c_loc(C),ldc,stride_C,batch_count)
    end function

    function rocblas_chemm_strided_batched_rank_1(handle,side,uplo,m,n,alpha,A,lda,stride_A,B,ldb,stride_B,beta,C,ldc,stride_C,batch_count)
      use iso_c_binding
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocblas_chemm_strided_batched_rank_1
      type(c_ptr),value :: handle
      integer(kind(rocblas_side_left)),value :: side
      integer(kind(rocblas_fill_upper)),value :: uplo
      integer(c_int),value :: m
      integer(c_int),value :: n
      complex(c_float_complex) :: alpha
      complex(c_float_complex),target,dimension(:) :: A
      integer(c_int),value :: lda
      integer(c_int64_t),value :: stride_A
      complex(c_float_complex),target,dimension(:) :: B
      integer(c_int),value :: ldb
      integer(c_int64_t),value :: stride_B
      complex(c_float_complex) :: beta
      complex(c_float_complex),target,dimension(:) :: C
      integer(c_int),value :: ldc
      integer(c_int64_t),value :: stride_C
      integer(c_int),value :: batch_count
      !
      rocblas_chemm_strided_batched_rank_1 = rocblas_chemm_strided_batched_orig(handle,side,uplo,m,n,alpha,c_loc(A),lda,stride_A,c_loc(B),ldb,stride_B,beta,c_loc(C),ldc,stride_C,batch_count)
    end function

    function rocblas_zhemm_strided_batched_full_rank(handle,side,uplo,m,n,alpha,A,lda,stride_A,B,ldb,stride_B,beta,C,ldc,stride_C,batch_count)
      use iso_c_binding
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocblas_zhemm_strided_batched_full_rank
      type(c_ptr),value :: handle
      integer(kind(rocblas_side_left)),value :: side
      integer(kind(rocblas_fill_upper)),value :: uplo
      integer(c_int),value :: m
      integer(c_int),value :: n
      complex(c_double_complex) :: alpha
      complex(c_double_complex),target,dimension(:,:) :: A
      integer(c_int),value :: lda
      integer(c_int64_t),value :: stride_A
      complex(c_double_complex),target,dimension(:,:) :: B
      integer(c_int),value :: ldb
      integer(c_int64_t),value :: stride_B
      complex(c_double_complex) :: beta
      complex(c_double_complex),target,dimension(:,:) :: C
      integer(c_int),value :: ldc
      integer(c_int64_t),value :: stride_C
      integer(c_int),value :: batch_count
      !
      rocblas_zhemm_strided_batched_full_rank = rocblas_zhemm_strided_batched_orig(handle,side,uplo,m,n,alpha,c_loc(A),lda,stride_A,c_loc(B),ldb,stride_B,beta,c_loc(C),ldc,stride_C,batch_count)
    end function

    function rocblas_zhemm_strided_batched_rank_0(handle,side,uplo,m,n,alpha,A,lda,stride_A,B,ldb,stride_B,beta,C,ldc,stride_C,batch_count)
      use iso_c_binding
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocblas_zhemm_strided_batched_rank_0
      type(c_ptr),value :: handle
      integer(kind(rocblas_side_left)),value :: side
      integer(kind(rocblas_fill_upper)),value :: uplo
      integer(c_int),value :: m
      integer(c_int),value :: n
      complex(c_double_complex) :: alpha
      complex(c_double_complex),target :: A
      integer(c_int),value :: lda
      integer(c_int64_t),value :: stride_A
      complex(c_double_complex),target :: B
      integer(c_int),value :: ldb
      integer(c_int64_t),value :: stride_B
      complex(c_double_complex) :: beta
      complex(c_double_complex),target :: C
      integer(c_int),value :: ldc
      integer(c_int64_t),value :: stride_C
      integer(c_int),value :: batch_count
      !
      rocblas_zhemm_strided_batched_rank_0 = rocblas_zhemm_strided_batched_orig(handle,side,uplo,m,n,alpha,c_loc(A),lda,stride_A,c_loc(B),ldb,stride_B,beta,c_loc(C),ldc,stride_C,batch_count)
    end function

    function rocblas_zhemm_strided_batched_rank_1(handle,side,uplo,m,n,alpha,A,lda,stride_A,B,ldb,stride_B,beta,C,ldc,stride_C,batch_count)
      use iso_c_binding
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocblas_zhemm_strided_batched_rank_1
      type(c_ptr),value :: handle
      integer(kind(rocblas_side_left)),value :: side
      integer(kind(rocblas_fill_upper)),value :: uplo
      integer(c_int),value :: m
      integer(c_int),value :: n
      complex(c_double_complex) :: alpha
      complex(c_double_complex),target,dimension(:) :: A
      integer(c_int),value :: lda
      integer(c_int64_t),value :: stride_A
      complex(c_double_complex),target,dimension(:) :: B
      integer(c_int),value :: ldb
      integer(c_int64_t),value :: stride_B
      complex(c_double_complex) :: beta
      complex(c_double_complex),target,dimension(:) :: C
      integer(c_int),value :: ldc
      integer(c_int64_t),value :: stride_C
      integer(c_int),value :: batch_count
      !
      rocblas_zhemm_strided_batched_rank_1 = rocblas_zhemm_strided_batched_orig(handle,side,uplo,m,n,alpha,c_loc(A),lda,stride_A,c_loc(B),ldb,stride_B,beta,c_loc(C),ldc,stride_C,batch_count)
    end function

    function rocblas_cherk_full_rank(handle,uplo,transA,n,k,alpha,A,lda,beta,C,ldc)
      use iso_c_binding
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocblas_cherk_full_rank
      type(c_ptr),value :: handle
      integer(kind(rocblas_fill_upper)),value :: uplo
      integer(kind(rocblas_operation_none)),value :: transA
      integer(c_int),value :: n
      integer(c_int),value :: k
      real(c_float) :: alpha
      complex(c_float_complex),target,dimension(:,:) :: A
      integer(c_int),value :: lda
      real(c_float) :: beta
      complex(c_float_complex),target,dimension(:,:) :: C
      integer(c_int),value :: ldc
      !
      rocblas_cherk_full_rank = rocblas_cherk_orig(handle,uplo,transA,n,k,alpha,c_loc(A),lda,beta,c_loc(C),ldc)
    end function

    function rocblas_cherk_rank_0(handle,uplo,transA,n,k,alpha,A,lda,beta,C,ldc)
      use iso_c_binding
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocblas_cherk_rank_0
      type(c_ptr),value :: handle
      integer(kind(rocblas_fill_upper)),value :: uplo
      integer(kind(rocblas_operation_none)),value :: transA
      integer(c_int),value :: n
      integer(c_int),value :: k
      real(c_float) :: alpha
      complex(c_float_complex),target :: A
      integer(c_int),value :: lda
      real(c_float) :: beta
      complex(c_float_complex),target :: C
      integer(c_int),value :: ldc
      !
      rocblas_cherk_rank_0 = rocblas_cherk_orig(handle,uplo,transA,n,k,alpha,c_loc(A),lda,beta,c_loc(C),ldc)
    end function

    function rocblas_cherk_rank_1(handle,uplo,transA,n,k,alpha,A,lda,beta,C,ldc)
      use iso_c_binding
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocblas_cherk_rank_1
      type(c_ptr),value :: handle
      integer(kind(rocblas_fill_upper)),value :: uplo
      integer(kind(rocblas_operation_none)),value :: transA
      integer(c_int),value :: n
      integer(c_int),value :: k
      real(c_float) :: alpha
      complex(c_float_complex),target,dimension(:) :: A
      integer(c_int),value :: lda
      real(c_float) :: beta
      complex(c_float_complex),target,dimension(:) :: C
      integer(c_int),value :: ldc
      !
      rocblas_cherk_rank_1 = rocblas_cherk_orig(handle,uplo,transA,n,k,alpha,c_loc(A),lda,beta,c_loc(C),ldc)
    end function

    function rocblas_zherk_full_rank(handle,uplo,transA,n,k,alpha,A,lda,beta,C,ldc)
      use iso_c_binding
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocblas_zherk_full_rank
      type(c_ptr),value :: handle
      integer(kind(rocblas_fill_upper)),value :: uplo
      integer(kind(rocblas_operation_none)),value :: transA
      integer(c_int),value :: n
      integer(c_int),value :: k
      real(c_double) :: alpha
      complex(c_double_complex),target,dimension(:,:) :: A
      integer(c_int),value :: lda
      real(c_double) :: beta
      complex(c_double_complex),target,dimension(:,:) :: C
      integer(c_int),value :: ldc
      !
      rocblas_zherk_full_rank = rocblas_zherk_orig(handle,uplo,transA,n,k,alpha,c_loc(A),lda,beta,c_loc(C),ldc)
    end function

    function rocblas_zherk_rank_0(handle,uplo,transA,n,k,alpha,A,lda,beta,C,ldc)
      use iso_c_binding
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocblas_zherk_rank_0
      type(c_ptr),value :: handle
      integer(kind(rocblas_fill_upper)),value :: uplo
      integer(kind(rocblas_operation_none)),value :: transA
      integer(c_int),value :: n
      integer(c_int),value :: k
      real(c_double) :: alpha
      complex(c_double_complex),target :: A
      integer(c_int),value :: lda
      real(c_double) :: beta
      complex(c_double_complex),target :: C
      integer(c_int),value :: ldc
      !
      rocblas_zherk_rank_0 = rocblas_zherk_orig(handle,uplo,transA,n,k,alpha,c_loc(A),lda,beta,c_loc(C),ldc)
    end function

    function rocblas_zherk_rank_1(handle,uplo,transA,n,k,alpha,A,lda,beta,C,ldc)
      use iso_c_binding
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocblas_zherk_rank_1
      type(c_ptr),value :: handle
      integer(kind(rocblas_fill_upper)),value :: uplo
      integer(kind(rocblas_operation_none)),value :: transA
      integer(c_int),value :: n
      integer(c_int),value :: k
      real(c_double) :: alpha
      complex(c_double_complex),target,dimension(:) :: A
      integer(c_int),value :: lda
      real(c_double) :: beta
      complex(c_double_complex),target,dimension(:) :: C
      integer(c_int),value :: ldc
      !
      rocblas_zherk_rank_1 = rocblas_zherk_orig(handle,uplo,transA,n,k,alpha,c_loc(A),lda,beta,c_loc(C),ldc)
    end function

    function rocblas_cherk_batched_full_rank(handle,uplo,transA,n,k,alpha,A,lda,beta,C,ldc,batch_count)
      use iso_c_binding
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocblas_cherk_batched_full_rank
      type(c_ptr),value :: handle
      integer(kind(rocblas_fill_upper)),value :: uplo
      integer(kind(rocblas_operation_none)),value :: transA
      integer(c_int),value :: n
      integer(c_int),value :: k
      real(c_float) :: alpha
      complex(c_float_complex),target,dimension(:,:,:) :: A
      integer(c_int),value :: lda
      real(c_float) :: beta
      complex(c_float_complex),target,dimension(:,:,:) :: C
      integer(c_int),value :: ldc
      integer(c_int),value :: batch_count
      !
      rocblas_cherk_batched_full_rank = rocblas_cherk_batched_orig(handle,uplo,transA,n,k,alpha,c_loc(A),lda,beta,c_loc(C),ldc,batch_count)
    end function

    function rocblas_cherk_batched_rank_0(handle,uplo,transA,n,k,alpha,A,lda,beta,C,ldc,batch_count)
      use iso_c_binding
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocblas_cherk_batched_rank_0
      type(c_ptr),value :: handle
      integer(kind(rocblas_fill_upper)),value :: uplo
      integer(kind(rocblas_operation_none)),value :: transA
      integer(c_int),value :: n
      integer(c_int),value :: k
      real(c_float) :: alpha
      complex(c_float_complex),target :: A
      integer(c_int),value :: lda
      real(c_float) :: beta
      complex(c_float_complex),target :: C
      integer(c_int),value :: ldc
      integer(c_int),value :: batch_count
      !
      rocblas_cherk_batched_rank_0 = rocblas_cherk_batched_orig(handle,uplo,transA,n,k,alpha,c_loc(A),lda,beta,c_loc(C),ldc,batch_count)
    end function

    function rocblas_cherk_batched_rank_1(handle,uplo,transA,n,k,alpha,A,lda,beta,C,ldc,batch_count)
      use iso_c_binding
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocblas_cherk_batched_rank_1
      type(c_ptr),value :: handle
      integer(kind(rocblas_fill_upper)),value :: uplo
      integer(kind(rocblas_operation_none)),value :: transA
      integer(c_int),value :: n
      integer(c_int),value :: k
      real(c_float) :: alpha
      complex(c_float_complex),target,dimension(:) :: A
      integer(c_int),value :: lda
      real(c_float) :: beta
      complex(c_float_complex),target,dimension(:) :: C
      integer(c_int),value :: ldc
      integer(c_int),value :: batch_count
      !
      rocblas_cherk_batched_rank_1 = rocblas_cherk_batched_orig(handle,uplo,transA,n,k,alpha,c_loc(A),lda,beta,c_loc(C),ldc,batch_count)
    end function

    function rocblas_zherk_batched_full_rank(handle,uplo,transA,n,k,alpha,A,lda,beta,C,ldc,batch_count)
      use iso_c_binding
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocblas_zherk_batched_full_rank
      type(c_ptr),value :: handle
      integer(kind(rocblas_fill_upper)),value :: uplo
      integer(kind(rocblas_operation_none)),value :: transA
      integer(c_int),value :: n
      integer(c_int),value :: k
      real(c_double) :: alpha
      complex(c_double_complex),target,dimension(:,:,:) :: A
      integer(c_int),value :: lda
      real(c_double) :: beta
      complex(c_double_complex),target,dimension(:,:,:) :: C
      integer(c_int),value :: ldc
      integer(c_int),value :: batch_count
      !
      rocblas_zherk_batched_full_rank = rocblas_zherk_batched_orig(handle,uplo,transA,n,k,alpha,c_loc(A),lda,beta,c_loc(C),ldc,batch_count)
    end function

    function rocblas_zherk_batched_rank_0(handle,uplo,transA,n,k,alpha,A,lda,beta,C,ldc,batch_count)
      use iso_c_binding
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocblas_zherk_batched_rank_0
      type(c_ptr),value :: handle
      integer(kind(rocblas_fill_upper)),value :: uplo
      integer(kind(rocblas_operation_none)),value :: transA
      integer(c_int),value :: n
      integer(c_int),value :: k
      real(c_double) :: alpha
      complex(c_double_complex),target :: A
      integer(c_int),value :: lda
      real(c_double) :: beta
      complex(c_double_complex),target :: C
      integer(c_int),value :: ldc
      integer(c_int),value :: batch_count
      !
      rocblas_zherk_batched_rank_0 = rocblas_zherk_batched_orig(handle,uplo,transA,n,k,alpha,c_loc(A),lda,beta,c_loc(C),ldc,batch_count)
    end function

    function rocblas_zherk_batched_rank_1(handle,uplo,transA,n,k,alpha,A,lda,beta,C,ldc,batch_count)
      use iso_c_binding
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocblas_zherk_batched_rank_1
      type(c_ptr),value :: handle
      integer(kind(rocblas_fill_upper)),value :: uplo
      integer(kind(rocblas_operation_none)),value :: transA
      integer(c_int),value :: n
      integer(c_int),value :: k
      real(c_double) :: alpha
      complex(c_double_complex),target,dimension(:) :: A
      integer(c_int),value :: lda
      real(c_double) :: beta
      complex(c_double_complex),target,dimension(:) :: C
      integer(c_int),value :: ldc
      integer(c_int),value :: batch_count
      !
      rocblas_zherk_batched_rank_1 = rocblas_zherk_batched_orig(handle,uplo,transA,n,k,alpha,c_loc(A),lda,beta,c_loc(C),ldc,batch_count)
    end function

    function rocblas_cherk_strided_batched_full_rank(handle,uplo,transA,n,k,alpha,A,lda,stride_A,beta,C,ldc,stride_C,batch_count)
      use iso_c_binding
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocblas_cherk_strided_batched_full_rank
      type(c_ptr),value :: handle
      integer(kind(rocblas_fill_upper)),value :: uplo
      integer(kind(rocblas_operation_none)),value :: transA
      integer(c_int),value :: n
      integer(c_int),value :: k
      real(c_float) :: alpha
      complex(c_float_complex),target,dimension(:,:) :: A
      integer(c_int),value :: lda
      integer(c_int64_t),value :: stride_A
      real(c_float) :: beta
      complex(c_float_complex),target,dimension(:,:) :: C
      integer(c_int),value :: ldc
      integer(c_int64_t),value :: stride_C
      integer(c_int),value :: batch_count
      !
      rocblas_cherk_strided_batched_full_rank = rocblas_cherk_strided_batched_orig(handle,uplo,transA,n,k,alpha,c_loc(A),lda,stride_A,beta,c_loc(C),ldc,stride_C,batch_count)
    end function

    function rocblas_cherk_strided_batched_rank_0(handle,uplo,transA,n,k,alpha,A,lda,stride_A,beta,C,ldc,stride_C,batch_count)
      use iso_c_binding
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocblas_cherk_strided_batched_rank_0
      type(c_ptr),value :: handle
      integer(kind(rocblas_fill_upper)),value :: uplo
      integer(kind(rocblas_operation_none)),value :: transA
      integer(c_int),value :: n
      integer(c_int),value :: k
      real(c_float) :: alpha
      complex(c_float_complex),target :: A
      integer(c_int),value :: lda
      integer(c_int64_t),value :: stride_A
      real(c_float) :: beta
      complex(c_float_complex),target :: C
      integer(c_int),value :: ldc
      integer(c_int64_t),value :: stride_C
      integer(c_int),value :: batch_count
      !
      rocblas_cherk_strided_batched_rank_0 = rocblas_cherk_strided_batched_orig(handle,uplo,transA,n,k,alpha,c_loc(A),lda,stride_A,beta,c_loc(C),ldc,stride_C,batch_count)
    end function

    function rocblas_cherk_strided_batched_rank_1(handle,uplo,transA,n,k,alpha,A,lda,stride_A,beta,C,ldc,stride_C,batch_count)
      use iso_c_binding
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocblas_cherk_strided_batched_rank_1
      type(c_ptr),value :: handle
      integer(kind(rocblas_fill_upper)),value :: uplo
      integer(kind(rocblas_operation_none)),value :: transA
      integer(c_int),value :: n
      integer(c_int),value :: k
      real(c_float) :: alpha
      complex(c_float_complex),target,dimension(:) :: A
      integer(c_int),value :: lda
      integer(c_int64_t),value :: stride_A
      real(c_float) :: beta
      complex(c_float_complex),target,dimension(:) :: C
      integer(c_int),value :: ldc
      integer(c_int64_t),value :: stride_C
      integer(c_int),value :: batch_count
      !
      rocblas_cherk_strided_batched_rank_1 = rocblas_cherk_strided_batched_orig(handle,uplo,transA,n,k,alpha,c_loc(A),lda,stride_A,beta,c_loc(C),ldc,stride_C,batch_count)
    end function

    function rocblas_zherk_strided_batched_full_rank(handle,uplo,transA,n,k,alpha,A,lda,stride_A,beta,C,ldc,stride_C,batch_count)
      use iso_c_binding
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocblas_zherk_strided_batched_full_rank
      type(c_ptr),value :: handle
      integer(kind(rocblas_fill_upper)),value :: uplo
      integer(kind(rocblas_operation_none)),value :: transA
      integer(c_int),value :: n
      integer(c_int),value :: k
      real(c_double) :: alpha
      complex(c_double_complex),target,dimension(:,:) :: A
      integer(c_int),value :: lda
      integer(c_int64_t),value :: stride_A
      real(c_double) :: beta
      complex(c_double_complex),target,dimension(:,:) :: C
      integer(c_int),value :: ldc
      integer(c_int64_t),value :: stride_C
      integer(c_int),value :: batch_count
      !
      rocblas_zherk_strided_batched_full_rank = rocblas_zherk_strided_batched_orig(handle,uplo,transA,n,k,alpha,c_loc(A),lda,stride_A,beta,c_loc(C),ldc,stride_C,batch_count)
    end function

    function rocblas_zherk_strided_batched_rank_0(handle,uplo,transA,n,k,alpha,A,lda,stride_A,beta,C,ldc,stride_C,batch_count)
      use iso_c_binding
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocblas_zherk_strided_batched_rank_0
      type(c_ptr),value :: handle
      integer(kind(rocblas_fill_upper)),value :: uplo
      integer(kind(rocblas_operation_none)),value :: transA
      integer(c_int),value :: n
      integer(c_int),value :: k
      real(c_double) :: alpha
      complex(c_double_complex),target :: A
      integer(c_int),value :: lda
      integer(c_int64_t),value :: stride_A
      real(c_double) :: beta
      complex(c_double_complex),target :: C
      integer(c_int),value :: ldc
      integer(c_int64_t),value :: stride_C
      integer(c_int),value :: batch_count
      !
      rocblas_zherk_strided_batched_rank_0 = rocblas_zherk_strided_batched_orig(handle,uplo,transA,n,k,alpha,c_loc(A),lda,stride_A,beta,c_loc(C),ldc,stride_C,batch_count)
    end function

    function rocblas_zherk_strided_batched_rank_1(handle,uplo,transA,n,k,alpha,A,lda,stride_A,beta,C,ldc,stride_C,batch_count)
      use iso_c_binding
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocblas_zherk_strided_batched_rank_1
      type(c_ptr),value :: handle
      integer(kind(rocblas_fill_upper)),value :: uplo
      integer(kind(rocblas_operation_none)),value :: transA
      integer(c_int),value :: n
      integer(c_int),value :: k
      real(c_double) :: alpha
      complex(c_double_complex),target,dimension(:) :: A
      integer(c_int),value :: lda
      integer(c_int64_t),value :: stride_A
      real(c_double) :: beta
      complex(c_double_complex),target,dimension(:) :: C
      integer(c_int),value :: ldc
      integer(c_int64_t),value :: stride_C
      integer(c_int),value :: batch_count
      !
      rocblas_zherk_strided_batched_rank_1 = rocblas_zherk_strided_batched_orig(handle,uplo,transA,n,k,alpha,c_loc(A),lda,stride_A,beta,c_loc(C),ldc,stride_C,batch_count)
    end function

    function rocblas_cher2k_full_rank(handle,uplo,trans,n,k,alpha,A,lda,B,ldb,beta,C,ldc)
      use iso_c_binding
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocblas_cher2k_full_rank
      type(c_ptr),value :: handle
      integer(kind(rocblas_fill_upper)),value :: uplo
      integer(kind(rocblas_operation_none)),value :: trans
      integer(c_int),value :: n
      integer(c_int),value :: k
      complex(c_float_complex) :: alpha
      complex(c_float_complex),target,dimension(:,:) :: A
      integer(c_int),value :: lda
      complex(c_float_complex),target,dimension(:,:) :: B
      integer(c_int),value :: ldb
      real(c_float) :: beta
      complex(c_float_complex),target,dimension(:,:) :: C
      integer(c_int),value :: ldc
      !
      rocblas_cher2k_full_rank = rocblas_cher2k_orig(handle,uplo,trans,n,k,alpha,c_loc(A),lda,c_loc(B),ldb,beta,c_loc(C),ldc)
    end function

    function rocblas_cher2k_rank_0(handle,uplo,trans,n,k,alpha,A,lda,B,ldb,beta,C,ldc)
      use iso_c_binding
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocblas_cher2k_rank_0
      type(c_ptr),value :: handle
      integer(kind(rocblas_fill_upper)),value :: uplo
      integer(kind(rocblas_operation_none)),value :: trans
      integer(c_int),value :: n
      integer(c_int),value :: k
      complex(c_float_complex) :: alpha
      complex(c_float_complex),target :: A
      integer(c_int),value :: lda
      complex(c_float_complex),target :: B
      integer(c_int),value :: ldb
      real(c_float) :: beta
      complex(c_float_complex),target :: C
      integer(c_int),value :: ldc
      !
      rocblas_cher2k_rank_0 = rocblas_cher2k_orig(handle,uplo,trans,n,k,alpha,c_loc(A),lda,c_loc(B),ldb,beta,c_loc(C),ldc)
    end function

    function rocblas_cher2k_rank_1(handle,uplo,trans,n,k,alpha,A,lda,B,ldb,beta,C,ldc)
      use iso_c_binding
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocblas_cher2k_rank_1
      type(c_ptr),value :: handle
      integer(kind(rocblas_fill_upper)),value :: uplo
      integer(kind(rocblas_operation_none)),value :: trans
      integer(c_int),value :: n
      integer(c_int),value :: k
      complex(c_float_complex) :: alpha
      complex(c_float_complex),target,dimension(:) :: A
      integer(c_int),value :: lda
      complex(c_float_complex),target,dimension(:) :: B
      integer(c_int),value :: ldb
      real(c_float) :: beta
      complex(c_float_complex),target,dimension(:) :: C
      integer(c_int),value :: ldc
      !
      rocblas_cher2k_rank_1 = rocblas_cher2k_orig(handle,uplo,trans,n,k,alpha,c_loc(A),lda,c_loc(B),ldb,beta,c_loc(C),ldc)
    end function

    function rocblas_zher2k_full_rank(handle,uplo,trans,n,k,alpha,A,lda,B,ldb,beta,C,ldc)
      use iso_c_binding
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocblas_zher2k_full_rank
      type(c_ptr),value :: handle
      integer(kind(rocblas_fill_upper)),value :: uplo
      integer(kind(rocblas_operation_none)),value :: trans
      integer(c_int),value :: n
      integer(c_int),value :: k
      complex(c_double_complex) :: alpha
      complex(c_double_complex),target,dimension(:,:) :: A
      integer(c_int),value :: lda
      complex(c_double_complex),target,dimension(:,:) :: B
      integer(c_int),value :: ldb
      real(c_double) :: beta
      complex(c_double_complex),target,dimension(:,:) :: C
      integer(c_int),value :: ldc
      !
      rocblas_zher2k_full_rank = rocblas_zher2k_orig(handle,uplo,trans,n,k,alpha,c_loc(A),lda,c_loc(B),ldb,beta,c_loc(C),ldc)
    end function

    function rocblas_zher2k_rank_0(handle,uplo,trans,n,k,alpha,A,lda,B,ldb,beta,C,ldc)
      use iso_c_binding
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocblas_zher2k_rank_0
      type(c_ptr),value :: handle
      integer(kind(rocblas_fill_upper)),value :: uplo
      integer(kind(rocblas_operation_none)),value :: trans
      integer(c_int),value :: n
      integer(c_int),value :: k
      complex(c_double_complex) :: alpha
      complex(c_double_complex),target :: A
      integer(c_int),value :: lda
      complex(c_double_complex),target :: B
      integer(c_int),value :: ldb
      real(c_double) :: beta
      complex(c_double_complex),target :: C
      integer(c_int),value :: ldc
      !
      rocblas_zher2k_rank_0 = rocblas_zher2k_orig(handle,uplo,trans,n,k,alpha,c_loc(A),lda,c_loc(B),ldb,beta,c_loc(C),ldc)
    end function

    function rocblas_zher2k_rank_1(handle,uplo,trans,n,k,alpha,A,lda,B,ldb,beta,C,ldc)
      use iso_c_binding
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocblas_zher2k_rank_1
      type(c_ptr),value :: handle
      integer(kind(rocblas_fill_upper)),value :: uplo
      integer(kind(rocblas_operation_none)),value :: trans
      integer(c_int),value :: n
      integer(c_int),value :: k
      complex(c_double_complex) :: alpha
      complex(c_double_complex),target,dimension(:) :: A
      integer(c_int),value :: lda
      complex(c_double_complex),target,dimension(:) :: B
      integer(c_int),value :: ldb
      real(c_double) :: beta
      complex(c_double_complex),target,dimension(:) :: C
      integer(c_int),value :: ldc
      !
      rocblas_zher2k_rank_1 = rocblas_zher2k_orig(handle,uplo,trans,n,k,alpha,c_loc(A),lda,c_loc(B),ldb,beta,c_loc(C),ldc)
    end function

    function rocblas_cher2k_batched_full_rank(handle,uplo,trans,n,k,alpha,A,lda,B,ldb,beta,C,ldc,batch_count)
      use iso_c_binding
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocblas_cher2k_batched_full_rank
      type(c_ptr),value :: handle
      integer(kind(rocblas_fill_upper)),value :: uplo
      integer(kind(rocblas_operation_none)),value :: trans
      integer(c_int),value :: n
      integer(c_int),value :: k
      complex(c_float_complex) :: alpha
      complex(c_float_complex),target,dimension(:,:,:) :: A
      integer(c_int),value :: lda
      complex(c_float_complex),target,dimension(:,:,:) :: B
      integer(c_int),value :: ldb
      real(c_float) :: beta
      complex(c_float_complex),target,dimension(:,:,:) :: C
      integer(c_int),value :: ldc
      integer(c_int),value :: batch_count
      !
      rocblas_cher2k_batched_full_rank = rocblas_cher2k_batched_orig(handle,uplo,trans,n,k,alpha,c_loc(A),lda,c_loc(B),ldb,beta,c_loc(C),ldc,batch_count)
    end function

    function rocblas_cher2k_batched_rank_0(handle,uplo,trans,n,k,alpha,A,lda,B,ldb,beta,C,ldc,batch_count)
      use iso_c_binding
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocblas_cher2k_batched_rank_0
      type(c_ptr),value :: handle
      integer(kind(rocblas_fill_upper)),value :: uplo
      integer(kind(rocblas_operation_none)),value :: trans
      integer(c_int),value :: n
      integer(c_int),value :: k
      complex(c_float_complex) :: alpha
      complex(c_float_complex),target :: A
      integer(c_int),value :: lda
      complex(c_float_complex),target :: B
      integer(c_int),value :: ldb
      real(c_float) :: beta
      complex(c_float_complex),target :: C
      integer(c_int),value :: ldc
      integer(c_int),value :: batch_count
      !
      rocblas_cher2k_batched_rank_0 = rocblas_cher2k_batched_orig(handle,uplo,trans,n,k,alpha,c_loc(A),lda,c_loc(B),ldb,beta,c_loc(C),ldc,batch_count)
    end function

    function rocblas_cher2k_batched_rank_1(handle,uplo,trans,n,k,alpha,A,lda,B,ldb,beta,C,ldc,batch_count)
      use iso_c_binding
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocblas_cher2k_batched_rank_1
      type(c_ptr),value :: handle
      integer(kind(rocblas_fill_upper)),value :: uplo
      integer(kind(rocblas_operation_none)),value :: trans
      integer(c_int),value :: n
      integer(c_int),value :: k
      complex(c_float_complex) :: alpha
      complex(c_float_complex),target,dimension(:) :: A
      integer(c_int),value :: lda
      complex(c_float_complex),target,dimension(:) :: B
      integer(c_int),value :: ldb
      real(c_float) :: beta
      complex(c_float_complex),target,dimension(:) :: C
      integer(c_int),value :: ldc
      integer(c_int),value :: batch_count
      !
      rocblas_cher2k_batched_rank_1 = rocblas_cher2k_batched_orig(handle,uplo,trans,n,k,alpha,c_loc(A),lda,c_loc(B),ldb,beta,c_loc(C),ldc,batch_count)
    end function

    function rocblas_zher2k_batched_full_rank(handle,uplo,trans,n,k,alpha,A,lda,B,ldb,beta,C,ldc,batch_count)
      use iso_c_binding
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocblas_zher2k_batched_full_rank
      type(c_ptr),value :: handle
      integer(kind(rocblas_fill_upper)),value :: uplo
      integer(kind(rocblas_operation_none)),value :: trans
      integer(c_int),value :: n
      integer(c_int),value :: k
      complex(c_double_complex) :: alpha
      complex(c_double_complex),target,dimension(:,:,:) :: A
      integer(c_int),value :: lda
      complex(c_double_complex),target,dimension(:,:,:) :: B
      integer(c_int),value :: ldb
      real(c_double) :: beta
      complex(c_double_complex),target,dimension(:,:,:) :: C
      integer(c_int),value :: ldc
      integer(c_int),value :: batch_count
      !
      rocblas_zher2k_batched_full_rank = rocblas_zher2k_batched_orig(handle,uplo,trans,n,k,alpha,c_loc(A),lda,c_loc(B),ldb,beta,c_loc(C),ldc,batch_count)
    end function

    function rocblas_zher2k_batched_rank_0(handle,uplo,trans,n,k,alpha,A,lda,B,ldb,beta,C,ldc,batch_count)
      use iso_c_binding
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocblas_zher2k_batched_rank_0
      type(c_ptr),value :: handle
      integer(kind(rocblas_fill_upper)),value :: uplo
      integer(kind(rocblas_operation_none)),value :: trans
      integer(c_int),value :: n
      integer(c_int),value :: k
      complex(c_double_complex) :: alpha
      complex(c_double_complex),target :: A
      integer(c_int),value :: lda
      complex(c_double_complex),target :: B
      integer(c_int),value :: ldb
      real(c_double) :: beta
      complex(c_double_complex),target :: C
      integer(c_int),value :: ldc
      integer(c_int),value :: batch_count
      !
      rocblas_zher2k_batched_rank_0 = rocblas_zher2k_batched_orig(handle,uplo,trans,n,k,alpha,c_loc(A),lda,c_loc(B),ldb,beta,c_loc(C),ldc,batch_count)
    end function

    function rocblas_zher2k_batched_rank_1(handle,uplo,trans,n,k,alpha,A,lda,B,ldb,beta,C,ldc,batch_count)
      use iso_c_binding
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocblas_zher2k_batched_rank_1
      type(c_ptr),value :: handle
      integer(kind(rocblas_fill_upper)),value :: uplo
      integer(kind(rocblas_operation_none)),value :: trans
      integer(c_int),value :: n
      integer(c_int),value :: k
      complex(c_double_complex) :: alpha
      complex(c_double_complex),target,dimension(:) :: A
      integer(c_int),value :: lda
      complex(c_double_complex),target,dimension(:) :: B
      integer(c_int),value :: ldb
      real(c_double) :: beta
      complex(c_double_complex),target,dimension(:) :: C
      integer(c_int),value :: ldc
      integer(c_int),value :: batch_count
      !
      rocblas_zher2k_batched_rank_1 = rocblas_zher2k_batched_orig(handle,uplo,trans,n,k,alpha,c_loc(A),lda,c_loc(B),ldb,beta,c_loc(C),ldc,batch_count)
    end function

    function rocblas_cher2k_strided_batched_full_rank(handle,uplo,trans,n,k,alpha,A,lda,stride_A,B,ldb,stride_B,beta,C,ldc,stride_C,batch_count)
      use iso_c_binding
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocblas_cher2k_strided_batched_full_rank
      type(c_ptr),value :: handle
      integer(kind(rocblas_fill_upper)),value :: uplo
      integer(kind(rocblas_operation_none)),value :: trans
      integer(c_int),value :: n
      integer(c_int),value :: k
      complex(c_float_complex) :: alpha
      complex(c_float_complex),target,dimension(:,:) :: A
      integer(c_int),value :: lda
      integer(c_int64_t),value :: stride_A
      complex(c_float_complex),target,dimension(:,:) :: B
      integer(c_int),value :: ldb
      integer(c_int64_t),value :: stride_B
      real(c_float) :: beta
      complex(c_float_complex),target,dimension(:,:) :: C
      integer(c_int),value :: ldc
      integer(c_int64_t),value :: stride_C
      integer(c_int),value :: batch_count
      !
      rocblas_cher2k_strided_batched_full_rank = rocblas_cher2k_strided_batched_orig(handle,uplo,trans,n,k,alpha,c_loc(A),lda,stride_A,c_loc(B),ldb,stride_B,beta,c_loc(C),ldc,stride_C,batch_count)
    end function

    function rocblas_cher2k_strided_batched_rank_0(handle,uplo,trans,n,k,alpha,A,lda,stride_A,B,ldb,stride_B,beta,C,ldc,stride_C,batch_count)
      use iso_c_binding
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocblas_cher2k_strided_batched_rank_0
      type(c_ptr),value :: handle
      integer(kind(rocblas_fill_upper)),value :: uplo
      integer(kind(rocblas_operation_none)),value :: trans
      integer(c_int),value :: n
      integer(c_int),value :: k
      complex(c_float_complex) :: alpha
      complex(c_float_complex),target :: A
      integer(c_int),value :: lda
      integer(c_int64_t),value :: stride_A
      complex(c_float_complex),target :: B
      integer(c_int),value :: ldb
      integer(c_int64_t),value :: stride_B
      real(c_float) :: beta
      complex(c_float_complex),target :: C
      integer(c_int),value :: ldc
      integer(c_int64_t),value :: stride_C
      integer(c_int),value :: batch_count
      !
      rocblas_cher2k_strided_batched_rank_0 = rocblas_cher2k_strided_batched_orig(handle,uplo,trans,n,k,alpha,c_loc(A),lda,stride_A,c_loc(B),ldb,stride_B,beta,c_loc(C),ldc,stride_C,batch_count)
    end function

    function rocblas_cher2k_strided_batched_rank_1(handle,uplo,trans,n,k,alpha,A,lda,stride_A,B,ldb,stride_B,beta,C,ldc,stride_C,batch_count)
      use iso_c_binding
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocblas_cher2k_strided_batched_rank_1
      type(c_ptr),value :: handle
      integer(kind(rocblas_fill_upper)),value :: uplo
      integer(kind(rocblas_operation_none)),value :: trans
      integer(c_int),value :: n
      integer(c_int),value :: k
      complex(c_float_complex) :: alpha
      complex(c_float_complex),target,dimension(:) :: A
      integer(c_int),value :: lda
      integer(c_int64_t),value :: stride_A
      complex(c_float_complex),target,dimension(:) :: B
      integer(c_int),value :: ldb
      integer(c_int64_t),value :: stride_B
      real(c_float) :: beta
      complex(c_float_complex),target,dimension(:) :: C
      integer(c_int),value :: ldc
      integer(c_int64_t),value :: stride_C
      integer(c_int),value :: batch_count
      !
      rocblas_cher2k_strided_batched_rank_1 = rocblas_cher2k_strided_batched_orig(handle,uplo,trans,n,k,alpha,c_loc(A),lda,stride_A,c_loc(B),ldb,stride_B,beta,c_loc(C),ldc,stride_C,batch_count)
    end function

    function rocblas_zher2k_strided_batched_full_rank(handle,uplo,trans,n,k,alpha,A,lda,stride_A,B,ldb,stride_B,beta,C,ldc,stride_C,batch_count)
      use iso_c_binding
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocblas_zher2k_strided_batched_full_rank
      type(c_ptr),value :: handle
      integer(kind(rocblas_fill_upper)),value :: uplo
      integer(kind(rocblas_operation_none)),value :: trans
      integer(c_int),value :: n
      integer(c_int),value :: k
      complex(c_double_complex) :: alpha
      complex(c_double_complex),target,dimension(:,:) :: A
      integer(c_int),value :: lda
      integer(c_int64_t),value :: stride_A
      complex(c_double_complex),target,dimension(:,:) :: B
      integer(c_int),value :: ldb
      integer(c_int64_t),value :: stride_B
      real(c_double) :: beta
      complex(c_double_complex),target,dimension(:,:) :: C
      integer(c_int),value :: ldc
      integer(c_int64_t),value :: stride_C
      integer(c_int),value :: batch_count
      !
      rocblas_zher2k_strided_batched_full_rank = rocblas_zher2k_strided_batched_orig(handle,uplo,trans,n,k,alpha,c_loc(A),lda,stride_A,c_loc(B),ldb,stride_B,beta,c_loc(C),ldc,stride_C,batch_count)
    end function

    function rocblas_zher2k_strided_batched_rank_0(handle,uplo,trans,n,k,alpha,A,lda,stride_A,B,ldb,stride_B,beta,C,ldc,stride_C,batch_count)
      use iso_c_binding
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocblas_zher2k_strided_batched_rank_0
      type(c_ptr),value :: handle
      integer(kind(rocblas_fill_upper)),value :: uplo
      integer(kind(rocblas_operation_none)),value :: trans
      integer(c_int),value :: n
      integer(c_int),value :: k
      complex(c_double_complex) :: alpha
      complex(c_double_complex),target :: A
      integer(c_int),value :: lda
      integer(c_int64_t),value :: stride_A
      complex(c_double_complex),target :: B
      integer(c_int),value :: ldb
      integer(c_int64_t),value :: stride_B
      real(c_double) :: beta
      complex(c_double_complex),target :: C
      integer(c_int),value :: ldc
      integer(c_int64_t),value :: stride_C
      integer(c_int),value :: batch_count
      !
      rocblas_zher2k_strided_batched_rank_0 = rocblas_zher2k_strided_batched_orig(handle,uplo,trans,n,k,alpha,c_loc(A),lda,stride_A,c_loc(B),ldb,stride_B,beta,c_loc(C),ldc,stride_C,batch_count)
    end function

    function rocblas_zher2k_strided_batched_rank_1(handle,uplo,trans,n,k,alpha,A,lda,stride_A,B,ldb,stride_B,beta,C,ldc,stride_C,batch_count)
      use iso_c_binding
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocblas_zher2k_strided_batched_rank_1
      type(c_ptr),value :: handle
      integer(kind(rocblas_fill_upper)),value :: uplo
      integer(kind(rocblas_operation_none)),value :: trans
      integer(c_int),value :: n
      integer(c_int),value :: k
      complex(c_double_complex) :: alpha
      complex(c_double_complex),target,dimension(:) :: A
      integer(c_int),value :: lda
      integer(c_int64_t),value :: stride_A
      complex(c_double_complex),target,dimension(:) :: B
      integer(c_int),value :: ldb
      integer(c_int64_t),value :: stride_B
      real(c_double) :: beta
      complex(c_double_complex),target,dimension(:) :: C
      integer(c_int),value :: ldc
      integer(c_int64_t),value :: stride_C
      integer(c_int),value :: batch_count
      !
      rocblas_zher2k_strided_batched_rank_1 = rocblas_zher2k_strided_batched_orig(handle,uplo,trans,n,k,alpha,c_loc(A),lda,stride_A,c_loc(B),ldb,stride_B,beta,c_loc(C),ldc,stride_C,batch_count)
    end function

    function rocblas_cherkx_full_rank(handle,uplo,trans,n,k,alpha,A,lda,B,ldb,beta,C,ldc)
      use iso_c_binding
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocblas_cherkx_full_rank
      type(c_ptr),value :: handle
      integer(kind(rocblas_fill_upper)),value :: uplo
      integer(kind(rocblas_operation_none)),value :: trans
      integer(c_int),value :: n
      integer(c_int),value :: k
      complex(c_float_complex) :: alpha
      complex(c_float_complex),target,dimension(:,:) :: A
      integer(c_int),value :: lda
      complex(c_float_complex),target,dimension(:,:) :: B
      integer(c_int),value :: ldb
      real(c_float) :: beta
      complex(c_float_complex),target,dimension(:,:) :: C
      integer(c_int),value :: ldc
      !
      rocblas_cherkx_full_rank = rocblas_cherkx_orig(handle,uplo,trans,n,k,alpha,c_loc(A),lda,c_loc(B),ldb,beta,c_loc(C),ldc)
    end function

    function rocblas_cherkx_rank_0(handle,uplo,trans,n,k,alpha,A,lda,B,ldb,beta,C,ldc)
      use iso_c_binding
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocblas_cherkx_rank_0
      type(c_ptr),value :: handle
      integer(kind(rocblas_fill_upper)),value :: uplo
      integer(kind(rocblas_operation_none)),value :: trans
      integer(c_int),value :: n
      integer(c_int),value :: k
      complex(c_float_complex) :: alpha
      complex(c_float_complex),target :: A
      integer(c_int),value :: lda
      complex(c_float_complex),target :: B
      integer(c_int),value :: ldb
      real(c_float) :: beta
      complex(c_float_complex),target :: C
      integer(c_int),value :: ldc
      !
      rocblas_cherkx_rank_0 = rocblas_cherkx_orig(handle,uplo,trans,n,k,alpha,c_loc(A),lda,c_loc(B),ldb,beta,c_loc(C),ldc)
    end function

    function rocblas_cherkx_rank_1(handle,uplo,trans,n,k,alpha,A,lda,B,ldb,beta,C,ldc)
      use iso_c_binding
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocblas_cherkx_rank_1
      type(c_ptr),value :: handle
      integer(kind(rocblas_fill_upper)),value :: uplo
      integer(kind(rocblas_operation_none)),value :: trans
      integer(c_int),value :: n
      integer(c_int),value :: k
      complex(c_float_complex) :: alpha
      complex(c_float_complex),target,dimension(:) :: A
      integer(c_int),value :: lda
      complex(c_float_complex),target,dimension(:) :: B
      integer(c_int),value :: ldb
      real(c_float) :: beta
      complex(c_float_complex),target,dimension(:) :: C
      integer(c_int),value :: ldc
      !
      rocblas_cherkx_rank_1 = rocblas_cherkx_orig(handle,uplo,trans,n,k,alpha,c_loc(A),lda,c_loc(B),ldb,beta,c_loc(C),ldc)
    end function

    function rocblas_zherkx_full_rank(handle,uplo,trans,n,k,alpha,A,lda,B,ldb,beta,C,ldc)
      use iso_c_binding
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocblas_zherkx_full_rank
      type(c_ptr),value :: handle
      integer(kind(rocblas_fill_upper)),value :: uplo
      integer(kind(rocblas_operation_none)),value :: trans
      integer(c_int),value :: n
      integer(c_int),value :: k
      complex(c_double_complex) :: alpha
      complex(c_double_complex),target,dimension(:,:) :: A
      integer(c_int),value :: lda
      complex(c_double_complex),target,dimension(:,:) :: B
      integer(c_int),value :: ldb
      real(c_double) :: beta
      complex(c_double_complex),target,dimension(:,:) :: C
      integer(c_int),value :: ldc
      !
      rocblas_zherkx_full_rank = rocblas_zherkx_orig(handle,uplo,trans,n,k,alpha,c_loc(A),lda,c_loc(B),ldb,beta,c_loc(C),ldc)
    end function

    function rocblas_zherkx_rank_0(handle,uplo,trans,n,k,alpha,A,lda,B,ldb,beta,C,ldc)
      use iso_c_binding
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocblas_zherkx_rank_0
      type(c_ptr),value :: handle
      integer(kind(rocblas_fill_upper)),value :: uplo
      integer(kind(rocblas_operation_none)),value :: trans
      integer(c_int),value :: n
      integer(c_int),value :: k
      complex(c_double_complex) :: alpha
      complex(c_double_complex),target :: A
      integer(c_int),value :: lda
      complex(c_double_complex),target :: B
      integer(c_int),value :: ldb
      real(c_double) :: beta
      complex(c_double_complex),target :: C
      integer(c_int),value :: ldc
      !
      rocblas_zherkx_rank_0 = rocblas_zherkx_orig(handle,uplo,trans,n,k,alpha,c_loc(A),lda,c_loc(B),ldb,beta,c_loc(C),ldc)
    end function

    function rocblas_zherkx_rank_1(handle,uplo,trans,n,k,alpha,A,lda,B,ldb,beta,C,ldc)
      use iso_c_binding
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocblas_zherkx_rank_1
      type(c_ptr),value :: handle
      integer(kind(rocblas_fill_upper)),value :: uplo
      integer(kind(rocblas_operation_none)),value :: trans
      integer(c_int),value :: n
      integer(c_int),value :: k
      complex(c_double_complex) :: alpha
      complex(c_double_complex),target,dimension(:) :: A
      integer(c_int),value :: lda
      complex(c_double_complex),target,dimension(:) :: B
      integer(c_int),value :: ldb
      real(c_double) :: beta
      complex(c_double_complex),target,dimension(:) :: C
      integer(c_int),value :: ldc
      !
      rocblas_zherkx_rank_1 = rocblas_zherkx_orig(handle,uplo,trans,n,k,alpha,c_loc(A),lda,c_loc(B),ldb,beta,c_loc(C),ldc)
    end function

    function rocblas_cherkx_batched_full_rank(handle,uplo,trans,n,k,alpha,A,lda,B,ldb,beta,C,ldc,batch_count)
      use iso_c_binding
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocblas_cherkx_batched_full_rank
      type(c_ptr),value :: handle
      integer(kind(rocblas_fill_upper)),value :: uplo
      integer(kind(rocblas_operation_none)),value :: trans
      integer(c_int),value :: n
      integer(c_int),value :: k
      complex(c_float_complex) :: alpha
      complex(c_float_complex),target,dimension(:,:,:) :: A
      integer(c_int),value :: lda
      complex(c_float_complex),target,dimension(:,:,:) :: B
      integer(c_int),value :: ldb
      real(c_float) :: beta
      complex(c_float_complex),target,dimension(:,:,:) :: C
      integer(c_int),value :: ldc
      integer(c_int),value :: batch_count
      !
      rocblas_cherkx_batched_full_rank = rocblas_cherkx_batched_orig(handle,uplo,trans,n,k,alpha,c_loc(A),lda,c_loc(B),ldb,beta,c_loc(C),ldc,batch_count)
    end function

    function rocblas_cherkx_batched_rank_0(handle,uplo,trans,n,k,alpha,A,lda,B,ldb,beta,C,ldc,batch_count)
      use iso_c_binding
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocblas_cherkx_batched_rank_0
      type(c_ptr),value :: handle
      integer(kind(rocblas_fill_upper)),value :: uplo
      integer(kind(rocblas_operation_none)),value :: trans
      integer(c_int),value :: n
      integer(c_int),value :: k
      complex(c_float_complex) :: alpha
      complex(c_float_complex),target :: A
      integer(c_int),value :: lda
      complex(c_float_complex),target :: B
      integer(c_int),value :: ldb
      real(c_float) :: beta
      complex(c_float_complex),target :: C
      integer(c_int),value :: ldc
      integer(c_int),value :: batch_count
      !
      rocblas_cherkx_batched_rank_0 = rocblas_cherkx_batched_orig(handle,uplo,trans,n,k,alpha,c_loc(A),lda,c_loc(B),ldb,beta,c_loc(C),ldc,batch_count)
    end function

    function rocblas_cherkx_batched_rank_1(handle,uplo,trans,n,k,alpha,A,lda,B,ldb,beta,C,ldc,batch_count)
      use iso_c_binding
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocblas_cherkx_batched_rank_1
      type(c_ptr),value :: handle
      integer(kind(rocblas_fill_upper)),value :: uplo
      integer(kind(rocblas_operation_none)),value :: trans
      integer(c_int),value :: n
      integer(c_int),value :: k
      complex(c_float_complex) :: alpha
      complex(c_float_complex),target,dimension(:) :: A
      integer(c_int),value :: lda
      complex(c_float_complex),target,dimension(:) :: B
      integer(c_int),value :: ldb
      real(c_float) :: beta
      complex(c_float_complex),target,dimension(:) :: C
      integer(c_int),value :: ldc
      integer(c_int),value :: batch_count
      !
      rocblas_cherkx_batched_rank_1 = rocblas_cherkx_batched_orig(handle,uplo,trans,n,k,alpha,c_loc(A),lda,c_loc(B),ldb,beta,c_loc(C),ldc,batch_count)
    end function

    function rocblas_zherkx_batched_full_rank(handle,uplo,trans,n,k,alpha,A,lda,B,ldb,beta,C,ldc,batch_count)
      use iso_c_binding
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocblas_zherkx_batched_full_rank
      type(c_ptr),value :: handle
      integer(kind(rocblas_fill_upper)),value :: uplo
      integer(kind(rocblas_operation_none)),value :: trans
      integer(c_int),value :: n
      integer(c_int),value :: k
      complex(c_double_complex) :: alpha
      complex(c_double_complex),target,dimension(:,:,:) :: A
      integer(c_int),value :: lda
      complex(c_double_complex),target,dimension(:,:,:) :: B
      integer(c_int),value :: ldb
      real(c_double) :: beta
      complex(c_double_complex),target,dimension(:,:,:) :: C
      integer(c_int),value :: ldc
      integer(c_int),value :: batch_count
      !
      rocblas_zherkx_batched_full_rank = rocblas_zherkx_batched_orig(handle,uplo,trans,n,k,alpha,c_loc(A),lda,c_loc(B),ldb,beta,c_loc(C),ldc,batch_count)
    end function

    function rocblas_zherkx_batched_rank_0(handle,uplo,trans,n,k,alpha,A,lda,B,ldb,beta,C,ldc,batch_count)
      use iso_c_binding
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocblas_zherkx_batched_rank_0
      type(c_ptr),value :: handle
      integer(kind(rocblas_fill_upper)),value :: uplo
      integer(kind(rocblas_operation_none)),value :: trans
      integer(c_int),value :: n
      integer(c_int),value :: k
      complex(c_double_complex) :: alpha
      complex(c_double_complex),target :: A
      integer(c_int),value :: lda
      complex(c_double_complex),target :: B
      integer(c_int),value :: ldb
      real(c_double) :: beta
      complex(c_double_complex),target :: C
      integer(c_int),value :: ldc
      integer(c_int),value :: batch_count
      !
      rocblas_zherkx_batched_rank_0 = rocblas_zherkx_batched_orig(handle,uplo,trans,n,k,alpha,c_loc(A),lda,c_loc(B),ldb,beta,c_loc(C),ldc,batch_count)
    end function

    function rocblas_zherkx_batched_rank_1(handle,uplo,trans,n,k,alpha,A,lda,B,ldb,beta,C,ldc,batch_count)
      use iso_c_binding
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocblas_zherkx_batched_rank_1
      type(c_ptr),value :: handle
      integer(kind(rocblas_fill_upper)),value :: uplo
      integer(kind(rocblas_operation_none)),value :: trans
      integer(c_int),value :: n
      integer(c_int),value :: k
      complex(c_double_complex) :: alpha
      complex(c_double_complex),target,dimension(:) :: A
      integer(c_int),value :: lda
      complex(c_double_complex),target,dimension(:) :: B
      integer(c_int),value :: ldb
      real(c_double) :: beta
      complex(c_double_complex),target,dimension(:) :: C
      integer(c_int),value :: ldc
      integer(c_int),value :: batch_count
      !
      rocblas_zherkx_batched_rank_1 = rocblas_zherkx_batched_orig(handle,uplo,trans,n,k,alpha,c_loc(A),lda,c_loc(B),ldb,beta,c_loc(C),ldc,batch_count)
    end function

    function rocblas_cherkx_strided_batched_full_rank(handle,uplo,trans,n,k,alpha,A,lda,stride_A,B,ldb,stride_B,beta,C,ldc,stride_C,batch_count)
      use iso_c_binding
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocblas_cherkx_strided_batched_full_rank
      type(c_ptr),value :: handle
      integer(kind(rocblas_fill_upper)),value :: uplo
      integer(kind(rocblas_operation_none)),value :: trans
      integer(c_int),value :: n
      integer(c_int),value :: k
      complex(c_float_complex) :: alpha
      complex(c_float_complex),target,dimension(:,:) :: A
      integer(c_int),value :: lda
      integer(c_int64_t),value :: stride_A
      complex(c_float_complex),target,dimension(:,:) :: B
      integer(c_int),value :: ldb
      integer(c_int64_t),value :: stride_B
      real(c_float) :: beta
      complex(c_float_complex),target,dimension(:,:) :: C
      integer(c_int),value :: ldc
      integer(c_int64_t),value :: stride_C
      integer(c_int),value :: batch_count
      !
      rocblas_cherkx_strided_batched_full_rank = rocblas_cherkx_strided_batched_orig(handle,uplo,trans,n,k,alpha,c_loc(A),lda,stride_A,c_loc(B),ldb,stride_B,beta,c_loc(C),ldc,stride_C,batch_count)
    end function

    function rocblas_cherkx_strided_batched_rank_0(handle,uplo,trans,n,k,alpha,A,lda,stride_A,B,ldb,stride_B,beta,C,ldc,stride_C,batch_count)
      use iso_c_binding
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocblas_cherkx_strided_batched_rank_0
      type(c_ptr),value :: handle
      integer(kind(rocblas_fill_upper)),value :: uplo
      integer(kind(rocblas_operation_none)),value :: trans
      integer(c_int),value :: n
      integer(c_int),value :: k
      complex(c_float_complex) :: alpha
      complex(c_float_complex),target :: A
      integer(c_int),value :: lda
      integer(c_int64_t),value :: stride_A
      complex(c_float_complex),target :: B
      integer(c_int),value :: ldb
      integer(c_int64_t),value :: stride_B
      real(c_float) :: beta
      complex(c_float_complex),target :: C
      integer(c_int),value :: ldc
      integer(c_int64_t),value :: stride_C
      integer(c_int),value :: batch_count
      !
      rocblas_cherkx_strided_batched_rank_0 = rocblas_cherkx_strided_batched_orig(handle,uplo,trans,n,k,alpha,c_loc(A),lda,stride_A,c_loc(B),ldb,stride_B,beta,c_loc(C),ldc,stride_C,batch_count)
    end function

    function rocblas_cherkx_strided_batched_rank_1(handle,uplo,trans,n,k,alpha,A,lda,stride_A,B,ldb,stride_B,beta,C,ldc,stride_C,batch_count)
      use iso_c_binding
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocblas_cherkx_strided_batched_rank_1
      type(c_ptr),value :: handle
      integer(kind(rocblas_fill_upper)),value :: uplo
      integer(kind(rocblas_operation_none)),value :: trans
      integer(c_int),value :: n
      integer(c_int),value :: k
      complex(c_float_complex) :: alpha
      complex(c_float_complex),target,dimension(:) :: A
      integer(c_int),value :: lda
      integer(c_int64_t),value :: stride_A
      complex(c_float_complex),target,dimension(:) :: B
      integer(c_int),value :: ldb
      integer(c_int64_t),value :: stride_B
      real(c_float) :: beta
      complex(c_float_complex),target,dimension(:) :: C
      integer(c_int),value :: ldc
      integer(c_int64_t),value :: stride_C
      integer(c_int),value :: batch_count
      !
      rocblas_cherkx_strided_batched_rank_1 = rocblas_cherkx_strided_batched_orig(handle,uplo,trans,n,k,alpha,c_loc(A),lda,stride_A,c_loc(B),ldb,stride_B,beta,c_loc(C),ldc,stride_C,batch_count)
    end function

    function rocblas_zherkx_strided_batched_full_rank(handle,uplo,trans,n,k,alpha,A,lda,stride_A,B,ldb,stride_B,beta,C,ldc,stride_C,batch_count)
      use iso_c_binding
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocblas_zherkx_strided_batched_full_rank
      type(c_ptr),value :: handle
      integer(kind(rocblas_fill_upper)),value :: uplo
      integer(kind(rocblas_operation_none)),value :: trans
      integer(c_int),value :: n
      integer(c_int),value :: k
      complex(c_double_complex) :: alpha
      complex(c_double_complex),target,dimension(:,:) :: A
      integer(c_int),value :: lda
      integer(c_int64_t),value :: stride_A
      complex(c_double_complex),target,dimension(:,:) :: B
      integer(c_int),value :: ldb
      integer(c_int64_t),value :: stride_B
      real(c_double) :: beta
      complex(c_double_complex),target,dimension(:,:) :: C
      integer(c_int),value :: ldc
      integer(c_int64_t),value :: stride_C
      integer(c_int),value :: batch_count
      !
      rocblas_zherkx_strided_batched_full_rank = rocblas_zherkx_strided_batched_orig(handle,uplo,trans,n,k,alpha,c_loc(A),lda,stride_A,c_loc(B),ldb,stride_B,beta,c_loc(C),ldc,stride_C,batch_count)
    end function

    function rocblas_zherkx_strided_batched_rank_0(handle,uplo,trans,n,k,alpha,A,lda,stride_A,B,ldb,stride_B,beta,C,ldc,stride_C,batch_count)
      use iso_c_binding
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocblas_zherkx_strided_batched_rank_0
      type(c_ptr),value :: handle
      integer(kind(rocblas_fill_upper)),value :: uplo
      integer(kind(rocblas_operation_none)),value :: trans
      integer(c_int),value :: n
      integer(c_int),value :: k
      complex(c_double_complex) :: alpha
      complex(c_double_complex),target :: A
      integer(c_int),value :: lda
      integer(c_int64_t),value :: stride_A
      complex(c_double_complex),target :: B
      integer(c_int),value :: ldb
      integer(c_int64_t),value :: stride_B
      real(c_double) :: beta
      complex(c_double_complex),target :: C
      integer(c_int),value :: ldc
      integer(c_int64_t),value :: stride_C
      integer(c_int),value :: batch_count
      !
      rocblas_zherkx_strided_batched_rank_0 = rocblas_zherkx_strided_batched_orig(handle,uplo,trans,n,k,alpha,c_loc(A),lda,stride_A,c_loc(B),ldb,stride_B,beta,c_loc(C),ldc,stride_C,batch_count)
    end function

    function rocblas_zherkx_strided_batched_rank_1(handle,uplo,trans,n,k,alpha,A,lda,stride_A,B,ldb,stride_B,beta,C,ldc,stride_C,batch_count)
      use iso_c_binding
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocblas_zherkx_strided_batched_rank_1
      type(c_ptr),value :: handle
      integer(kind(rocblas_fill_upper)),value :: uplo
      integer(kind(rocblas_operation_none)),value :: trans
      integer(c_int),value :: n
      integer(c_int),value :: k
      complex(c_double_complex) :: alpha
      complex(c_double_complex),target,dimension(:) :: A
      integer(c_int),value :: lda
      integer(c_int64_t),value :: stride_A
      complex(c_double_complex),target,dimension(:) :: B
      integer(c_int),value :: ldb
      integer(c_int64_t),value :: stride_B
      real(c_double) :: beta
      complex(c_double_complex),target,dimension(:) :: C
      integer(c_int),value :: ldc
      integer(c_int64_t),value :: stride_C
      integer(c_int),value :: batch_count
      !
      rocblas_zherkx_strided_batched_rank_1 = rocblas_zherkx_strided_batched_orig(handle,uplo,trans,n,k,alpha,c_loc(A),lda,stride_A,c_loc(B),ldb,stride_B,beta,c_loc(C),ldc,stride_C,batch_count)
    end function

    function rocblas_ssymm_full_rank(handle,side,uplo,m,n,alpha,A,lda,B,ldb,beta,C,ldc)
      use iso_c_binding
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocblas_ssymm_full_rank
      type(c_ptr),value :: handle
      integer(kind(rocblas_side_left)),value :: side
      integer(kind(rocblas_fill_upper)),value :: uplo
      integer(c_int),value :: m
      integer(c_int),value :: n
      real(c_float) :: alpha
      real(c_float),target,dimension(:,:) :: A
      integer(c_int),value :: lda
      real(c_float),target,dimension(:,:) :: B
      integer(c_int),value :: ldb
      real(c_float) :: beta
      real(c_float),target,dimension(:,:) :: C
      integer(c_int),value :: ldc
      !
      rocblas_ssymm_full_rank = rocblas_ssymm_orig(handle,side,uplo,m,n,alpha,c_loc(A),lda,c_loc(B),ldb,beta,c_loc(C),ldc)
    end function

    function rocblas_ssymm_rank_0(handle,side,uplo,m,n,alpha,A,lda,B,ldb,beta,C,ldc)
      use iso_c_binding
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocblas_ssymm_rank_0
      type(c_ptr),value :: handle
      integer(kind(rocblas_side_left)),value :: side
      integer(kind(rocblas_fill_upper)),value :: uplo
      integer(c_int),value :: m
      integer(c_int),value :: n
      real(c_float) :: alpha
      real(c_float),target :: A
      integer(c_int),value :: lda
      real(c_float),target :: B
      integer(c_int),value :: ldb
      real(c_float) :: beta
      real(c_float),target :: C
      integer(c_int),value :: ldc
      !
      rocblas_ssymm_rank_0 = rocblas_ssymm_orig(handle,side,uplo,m,n,alpha,c_loc(A),lda,c_loc(B),ldb,beta,c_loc(C),ldc)
    end function

    function rocblas_ssymm_rank_1(handle,side,uplo,m,n,alpha,A,lda,B,ldb,beta,C,ldc)
      use iso_c_binding
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocblas_ssymm_rank_1
      type(c_ptr),value :: handle
      integer(kind(rocblas_side_left)),value :: side
      integer(kind(rocblas_fill_upper)),value :: uplo
      integer(c_int),value :: m
      integer(c_int),value :: n
      real(c_float) :: alpha
      real(c_float),target,dimension(:) :: A
      integer(c_int),value :: lda
      real(c_float),target,dimension(:) :: B
      integer(c_int),value :: ldb
      real(c_float) :: beta
      real(c_float),target,dimension(:) :: C
      integer(c_int),value :: ldc
      !
      rocblas_ssymm_rank_1 = rocblas_ssymm_orig(handle,side,uplo,m,n,alpha,c_loc(A),lda,c_loc(B),ldb,beta,c_loc(C),ldc)
    end function

    function rocblas_dsymm_full_rank(handle,side,uplo,m,n,alpha,A,lda,B,ldb,beta,C,ldc)
      use iso_c_binding
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocblas_dsymm_full_rank
      type(c_ptr),value :: handle
      integer(kind(rocblas_side_left)),value :: side
      integer(kind(rocblas_fill_upper)),value :: uplo
      integer(c_int),value :: m
      integer(c_int),value :: n
      real(c_double) :: alpha
      real(c_double),target,dimension(:,:) :: A
      integer(c_int),value :: lda
      real(c_double),target,dimension(:,:) :: B
      integer(c_int),value :: ldb
      real(c_double) :: beta
      real(c_double),target,dimension(:,:) :: C
      integer(c_int),value :: ldc
      !
      rocblas_dsymm_full_rank = rocblas_dsymm_orig(handle,side,uplo,m,n,alpha,c_loc(A),lda,c_loc(B),ldb,beta,c_loc(C),ldc)
    end function

    function rocblas_dsymm_rank_0(handle,side,uplo,m,n,alpha,A,lda,B,ldb,beta,C,ldc)
      use iso_c_binding
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocblas_dsymm_rank_0
      type(c_ptr),value :: handle
      integer(kind(rocblas_side_left)),value :: side
      integer(kind(rocblas_fill_upper)),value :: uplo
      integer(c_int),value :: m
      integer(c_int),value :: n
      real(c_double) :: alpha
      real(c_double),target :: A
      integer(c_int),value :: lda
      real(c_double),target :: B
      integer(c_int),value :: ldb
      real(c_double) :: beta
      real(c_double),target :: C
      integer(c_int),value :: ldc
      !
      rocblas_dsymm_rank_0 = rocblas_dsymm_orig(handle,side,uplo,m,n,alpha,c_loc(A),lda,c_loc(B),ldb,beta,c_loc(C),ldc)
    end function

    function rocblas_dsymm_rank_1(handle,side,uplo,m,n,alpha,A,lda,B,ldb,beta,C,ldc)
      use iso_c_binding
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocblas_dsymm_rank_1
      type(c_ptr),value :: handle
      integer(kind(rocblas_side_left)),value :: side
      integer(kind(rocblas_fill_upper)),value :: uplo
      integer(c_int),value :: m
      integer(c_int),value :: n
      real(c_double) :: alpha
      real(c_double),target,dimension(:) :: A
      integer(c_int),value :: lda
      real(c_double),target,dimension(:) :: B
      integer(c_int),value :: ldb
      real(c_double) :: beta
      real(c_double),target,dimension(:) :: C
      integer(c_int),value :: ldc
      !
      rocblas_dsymm_rank_1 = rocblas_dsymm_orig(handle,side,uplo,m,n,alpha,c_loc(A),lda,c_loc(B),ldb,beta,c_loc(C),ldc)
    end function

    function rocblas_csymm_full_rank(handle,side,uplo,m,n,alpha,A,lda,B,ldb,beta,C,ldc)
      use iso_c_binding
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocblas_csymm_full_rank
      type(c_ptr),value :: handle
      integer(kind(rocblas_side_left)),value :: side
      integer(kind(rocblas_fill_upper)),value :: uplo
      integer(c_int),value :: m
      integer(c_int),value :: n
      complex(c_float_complex) :: alpha
      complex(c_float_complex),target,dimension(:,:) :: A
      integer(c_int),value :: lda
      complex(c_float_complex),target,dimension(:,:) :: B
      integer(c_int),value :: ldb
      complex(c_float_complex) :: beta
      complex(c_float_complex),target,dimension(:,:) :: C
      integer(c_int),value :: ldc
      !
      rocblas_csymm_full_rank = rocblas_csymm_orig(handle,side,uplo,m,n,alpha,c_loc(A),lda,c_loc(B),ldb,beta,c_loc(C),ldc)
    end function

    function rocblas_csymm_rank_0(handle,side,uplo,m,n,alpha,A,lda,B,ldb,beta,C,ldc)
      use iso_c_binding
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocblas_csymm_rank_0
      type(c_ptr),value :: handle
      integer(kind(rocblas_side_left)),value :: side
      integer(kind(rocblas_fill_upper)),value :: uplo
      integer(c_int),value :: m
      integer(c_int),value :: n
      complex(c_float_complex) :: alpha
      complex(c_float_complex),target :: A
      integer(c_int),value :: lda
      complex(c_float_complex),target :: B
      integer(c_int),value :: ldb
      complex(c_float_complex) :: beta
      complex(c_float_complex),target :: C
      integer(c_int),value :: ldc
      !
      rocblas_csymm_rank_0 = rocblas_csymm_orig(handle,side,uplo,m,n,alpha,c_loc(A),lda,c_loc(B),ldb,beta,c_loc(C),ldc)
    end function

    function rocblas_csymm_rank_1(handle,side,uplo,m,n,alpha,A,lda,B,ldb,beta,C,ldc)
      use iso_c_binding
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocblas_csymm_rank_1
      type(c_ptr),value :: handle
      integer(kind(rocblas_side_left)),value :: side
      integer(kind(rocblas_fill_upper)),value :: uplo
      integer(c_int),value :: m
      integer(c_int),value :: n
      complex(c_float_complex) :: alpha
      complex(c_float_complex),target,dimension(:) :: A
      integer(c_int),value :: lda
      complex(c_float_complex),target,dimension(:) :: B
      integer(c_int),value :: ldb
      complex(c_float_complex) :: beta
      complex(c_float_complex),target,dimension(:) :: C
      integer(c_int),value :: ldc
      !
      rocblas_csymm_rank_1 = rocblas_csymm_orig(handle,side,uplo,m,n,alpha,c_loc(A),lda,c_loc(B),ldb,beta,c_loc(C),ldc)
    end function

    function rocblas_zsymm_full_rank(handle,side,uplo,m,n,alpha,A,lda,B,ldb,beta,C,ldc)
      use iso_c_binding
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocblas_zsymm_full_rank
      type(c_ptr),value :: handle
      integer(kind(rocblas_side_left)),value :: side
      integer(kind(rocblas_fill_upper)),value :: uplo
      integer(c_int),value :: m
      integer(c_int),value :: n
      complex(c_double_complex) :: alpha
      complex(c_double_complex),target,dimension(:,:) :: A
      integer(c_int),value :: lda
      complex(c_double_complex),target,dimension(:,:) :: B
      integer(c_int),value :: ldb
      complex(c_double_complex) :: beta
      complex(c_double_complex),target,dimension(:,:) :: C
      integer(c_int),value :: ldc
      !
      rocblas_zsymm_full_rank = rocblas_zsymm_orig(handle,side,uplo,m,n,alpha,c_loc(A),lda,c_loc(B),ldb,beta,c_loc(C),ldc)
    end function

    function rocblas_zsymm_rank_0(handle,side,uplo,m,n,alpha,A,lda,B,ldb,beta,C,ldc)
      use iso_c_binding
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocblas_zsymm_rank_0
      type(c_ptr),value :: handle
      integer(kind(rocblas_side_left)),value :: side
      integer(kind(rocblas_fill_upper)),value :: uplo
      integer(c_int),value :: m
      integer(c_int),value :: n
      complex(c_double_complex) :: alpha
      complex(c_double_complex),target :: A
      integer(c_int),value :: lda
      complex(c_double_complex),target :: B
      integer(c_int),value :: ldb
      complex(c_double_complex) :: beta
      complex(c_double_complex),target :: C
      integer(c_int),value :: ldc
      !
      rocblas_zsymm_rank_0 = rocblas_zsymm_orig(handle,side,uplo,m,n,alpha,c_loc(A),lda,c_loc(B),ldb,beta,c_loc(C),ldc)
    end function

    function rocblas_zsymm_rank_1(handle,side,uplo,m,n,alpha,A,lda,B,ldb,beta,C,ldc)
      use iso_c_binding
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocblas_zsymm_rank_1
      type(c_ptr),value :: handle
      integer(kind(rocblas_side_left)),value :: side
      integer(kind(rocblas_fill_upper)),value :: uplo
      integer(c_int),value :: m
      integer(c_int),value :: n
      complex(c_double_complex) :: alpha
      complex(c_double_complex),target,dimension(:) :: A
      integer(c_int),value :: lda
      complex(c_double_complex),target,dimension(:) :: B
      integer(c_int),value :: ldb
      complex(c_double_complex) :: beta
      complex(c_double_complex),target,dimension(:) :: C
      integer(c_int),value :: ldc
      !
      rocblas_zsymm_rank_1 = rocblas_zsymm_orig(handle,side,uplo,m,n,alpha,c_loc(A),lda,c_loc(B),ldb,beta,c_loc(C),ldc)
    end function

    function rocblas_ssymm_batched_full_rank(handle,side,uplo,m,n,alpha,A,lda,B,ldb,beta,C,ldc,batch_count)
      use iso_c_binding
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocblas_ssymm_batched_full_rank
      type(c_ptr),value :: handle
      integer(kind(rocblas_side_left)),value :: side
      integer(kind(rocblas_fill_upper)),value :: uplo
      integer(c_int),value :: m
      integer(c_int),value :: n
      real(c_float) :: alpha
      real(c_float),target,dimension(:,:,:) :: A
      integer(c_int),value :: lda
      real(c_float),target,dimension(:,:,:) :: B
      integer(c_int),value :: ldb
      real(c_float) :: beta
      real(c_float),target,dimension(:,:,:) :: C
      integer(c_int),value :: ldc
      integer(c_int),value :: batch_count
      !
      rocblas_ssymm_batched_full_rank = rocblas_ssymm_batched_orig(handle,side,uplo,m,n,alpha,c_loc(A),lda,c_loc(B),ldb,beta,c_loc(C),ldc,batch_count)
    end function

    function rocblas_ssymm_batched_rank_0(handle,side,uplo,m,n,alpha,A,lda,B,ldb,beta,C,ldc,batch_count)
      use iso_c_binding
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocblas_ssymm_batched_rank_0
      type(c_ptr),value :: handle
      integer(kind(rocblas_side_left)),value :: side
      integer(kind(rocblas_fill_upper)),value :: uplo
      integer(c_int),value :: m
      integer(c_int),value :: n
      real(c_float) :: alpha
      real(c_float),target :: A
      integer(c_int),value :: lda
      real(c_float),target :: B
      integer(c_int),value :: ldb
      real(c_float) :: beta
      real(c_float),target :: C
      integer(c_int),value :: ldc
      integer(c_int),value :: batch_count
      !
      rocblas_ssymm_batched_rank_0 = rocblas_ssymm_batched_orig(handle,side,uplo,m,n,alpha,c_loc(A),lda,c_loc(B),ldb,beta,c_loc(C),ldc,batch_count)
    end function

    function rocblas_ssymm_batched_rank_1(handle,side,uplo,m,n,alpha,A,lda,B,ldb,beta,C,ldc,batch_count)
      use iso_c_binding
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocblas_ssymm_batched_rank_1
      type(c_ptr),value :: handle
      integer(kind(rocblas_side_left)),value :: side
      integer(kind(rocblas_fill_upper)),value :: uplo
      integer(c_int),value :: m
      integer(c_int),value :: n
      real(c_float) :: alpha
      real(c_float),target,dimension(:) :: A
      integer(c_int),value :: lda
      real(c_float),target,dimension(:) :: B
      integer(c_int),value :: ldb
      real(c_float) :: beta
      real(c_float),target,dimension(:) :: C
      integer(c_int),value :: ldc
      integer(c_int),value :: batch_count
      !
      rocblas_ssymm_batched_rank_1 = rocblas_ssymm_batched_orig(handle,side,uplo,m,n,alpha,c_loc(A),lda,c_loc(B),ldb,beta,c_loc(C),ldc,batch_count)
    end function

    function rocblas_dsymm_batched_full_rank(handle,side,uplo,m,n,alpha,A,lda,B,ldb,beta,C,ldc,batch_count)
      use iso_c_binding
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocblas_dsymm_batched_full_rank
      type(c_ptr),value :: handle
      integer(kind(rocblas_side_left)),value :: side
      integer(kind(rocblas_fill_upper)),value :: uplo
      integer(c_int),value :: m
      integer(c_int),value :: n
      real(c_double) :: alpha
      real(c_double),target,dimension(:,:,:) :: A
      integer(c_int),value :: lda
      real(c_double),target,dimension(:,:,:) :: B
      integer(c_int),value :: ldb
      real(c_double) :: beta
      real(c_double),target,dimension(:,:,:) :: C
      integer(c_int),value :: ldc
      integer(c_int),value :: batch_count
      !
      rocblas_dsymm_batched_full_rank = rocblas_dsymm_batched_orig(handle,side,uplo,m,n,alpha,c_loc(A),lda,c_loc(B),ldb,beta,c_loc(C),ldc,batch_count)
    end function

    function rocblas_dsymm_batched_rank_0(handle,side,uplo,m,n,alpha,A,lda,B,ldb,beta,C,ldc,batch_count)
      use iso_c_binding
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocblas_dsymm_batched_rank_0
      type(c_ptr),value :: handle
      integer(kind(rocblas_side_left)),value :: side
      integer(kind(rocblas_fill_upper)),value :: uplo
      integer(c_int),value :: m
      integer(c_int),value :: n
      real(c_double) :: alpha
      real(c_double),target :: A
      integer(c_int),value :: lda
      real(c_double),target :: B
      integer(c_int),value :: ldb
      real(c_double) :: beta
      real(c_double),target :: C
      integer(c_int),value :: ldc
      integer(c_int),value :: batch_count
      !
      rocblas_dsymm_batched_rank_0 = rocblas_dsymm_batched_orig(handle,side,uplo,m,n,alpha,c_loc(A),lda,c_loc(B),ldb,beta,c_loc(C),ldc,batch_count)
    end function

    function rocblas_dsymm_batched_rank_1(handle,side,uplo,m,n,alpha,A,lda,B,ldb,beta,C,ldc,batch_count)
      use iso_c_binding
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocblas_dsymm_batched_rank_1
      type(c_ptr),value :: handle
      integer(kind(rocblas_side_left)),value :: side
      integer(kind(rocblas_fill_upper)),value :: uplo
      integer(c_int),value :: m
      integer(c_int),value :: n
      real(c_double) :: alpha
      real(c_double),target,dimension(:) :: A
      integer(c_int),value :: lda
      real(c_double),target,dimension(:) :: B
      integer(c_int),value :: ldb
      real(c_double) :: beta
      real(c_double),target,dimension(:) :: C
      integer(c_int),value :: ldc
      integer(c_int),value :: batch_count
      !
      rocblas_dsymm_batched_rank_1 = rocblas_dsymm_batched_orig(handle,side,uplo,m,n,alpha,c_loc(A),lda,c_loc(B),ldb,beta,c_loc(C),ldc,batch_count)
    end function

    function rocblas_csymm_batched_full_rank(handle,side,uplo,m,n,alpha,A,lda,B,ldb,beta,C,ldc,batch_count)
      use iso_c_binding
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocblas_csymm_batched_full_rank
      type(c_ptr),value :: handle
      integer(kind(rocblas_side_left)),value :: side
      integer(kind(rocblas_fill_upper)),value :: uplo
      integer(c_int),value :: m
      integer(c_int),value :: n
      complex(c_float_complex) :: alpha
      complex(c_float_complex),target,dimension(:,:,:) :: A
      integer(c_int),value :: lda
      complex(c_float_complex),target,dimension(:,:,:) :: B
      integer(c_int),value :: ldb
      complex(c_float_complex) :: beta
      complex(c_float_complex),target,dimension(:,:,:) :: C
      integer(c_int),value :: ldc
      integer(c_int),value :: batch_count
      !
      rocblas_csymm_batched_full_rank = rocblas_csymm_batched_orig(handle,side,uplo,m,n,alpha,c_loc(A),lda,c_loc(B),ldb,beta,c_loc(C),ldc,batch_count)
    end function

    function rocblas_csymm_batched_rank_0(handle,side,uplo,m,n,alpha,A,lda,B,ldb,beta,C,ldc,batch_count)
      use iso_c_binding
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocblas_csymm_batched_rank_0
      type(c_ptr),value :: handle
      integer(kind(rocblas_side_left)),value :: side
      integer(kind(rocblas_fill_upper)),value :: uplo
      integer(c_int),value :: m
      integer(c_int),value :: n
      complex(c_float_complex) :: alpha
      complex(c_float_complex),target :: A
      integer(c_int),value :: lda
      complex(c_float_complex),target :: B
      integer(c_int),value :: ldb
      complex(c_float_complex) :: beta
      complex(c_float_complex),target :: C
      integer(c_int),value :: ldc
      integer(c_int),value :: batch_count
      !
      rocblas_csymm_batched_rank_0 = rocblas_csymm_batched_orig(handle,side,uplo,m,n,alpha,c_loc(A),lda,c_loc(B),ldb,beta,c_loc(C),ldc,batch_count)
    end function

    function rocblas_csymm_batched_rank_1(handle,side,uplo,m,n,alpha,A,lda,B,ldb,beta,C,ldc,batch_count)
      use iso_c_binding
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocblas_csymm_batched_rank_1
      type(c_ptr),value :: handle
      integer(kind(rocblas_side_left)),value :: side
      integer(kind(rocblas_fill_upper)),value :: uplo
      integer(c_int),value :: m
      integer(c_int),value :: n
      complex(c_float_complex) :: alpha
      complex(c_float_complex),target,dimension(:) :: A
      integer(c_int),value :: lda
      complex(c_float_complex),target,dimension(:) :: B
      integer(c_int),value :: ldb
      complex(c_float_complex) :: beta
      complex(c_float_complex),target,dimension(:) :: C
      integer(c_int),value :: ldc
      integer(c_int),value :: batch_count
      !
      rocblas_csymm_batched_rank_1 = rocblas_csymm_batched_orig(handle,side,uplo,m,n,alpha,c_loc(A),lda,c_loc(B),ldb,beta,c_loc(C),ldc,batch_count)
    end function

    function rocblas_zsymm_batched_full_rank(handle,side,uplo,m,n,alpha,A,lda,B,ldb,beta,C,ldc,batch_count)
      use iso_c_binding
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocblas_zsymm_batched_full_rank
      type(c_ptr),value :: handle
      integer(kind(rocblas_side_left)),value :: side
      integer(kind(rocblas_fill_upper)),value :: uplo
      integer(c_int),value :: m
      integer(c_int),value :: n
      complex(c_double_complex) :: alpha
      complex(c_double_complex),target,dimension(:,:,:) :: A
      integer(c_int),value :: lda
      complex(c_double_complex),target,dimension(:,:,:) :: B
      integer(c_int),value :: ldb
      complex(c_double_complex) :: beta
      complex(c_double_complex),target,dimension(:,:,:) :: C
      integer(c_int),value :: ldc
      integer(c_int),value :: batch_count
      !
      rocblas_zsymm_batched_full_rank = rocblas_zsymm_batched_orig(handle,side,uplo,m,n,alpha,c_loc(A),lda,c_loc(B),ldb,beta,c_loc(C),ldc,batch_count)
    end function

    function rocblas_zsymm_batched_rank_0(handle,side,uplo,m,n,alpha,A,lda,B,ldb,beta,C,ldc,batch_count)
      use iso_c_binding
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocblas_zsymm_batched_rank_0
      type(c_ptr),value :: handle
      integer(kind(rocblas_side_left)),value :: side
      integer(kind(rocblas_fill_upper)),value :: uplo
      integer(c_int),value :: m
      integer(c_int),value :: n
      complex(c_double_complex) :: alpha
      complex(c_double_complex),target :: A
      integer(c_int),value :: lda
      complex(c_double_complex),target :: B
      integer(c_int),value :: ldb
      complex(c_double_complex) :: beta
      complex(c_double_complex),target :: C
      integer(c_int),value :: ldc
      integer(c_int),value :: batch_count
      !
      rocblas_zsymm_batched_rank_0 = rocblas_zsymm_batched_orig(handle,side,uplo,m,n,alpha,c_loc(A),lda,c_loc(B),ldb,beta,c_loc(C),ldc,batch_count)
    end function

    function rocblas_zsymm_batched_rank_1(handle,side,uplo,m,n,alpha,A,lda,B,ldb,beta,C,ldc,batch_count)
      use iso_c_binding
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocblas_zsymm_batched_rank_1
      type(c_ptr),value :: handle
      integer(kind(rocblas_side_left)),value :: side
      integer(kind(rocblas_fill_upper)),value :: uplo
      integer(c_int),value :: m
      integer(c_int),value :: n
      complex(c_double_complex) :: alpha
      complex(c_double_complex),target,dimension(:) :: A
      integer(c_int),value :: lda
      complex(c_double_complex),target,dimension(:) :: B
      integer(c_int),value :: ldb
      complex(c_double_complex) :: beta
      complex(c_double_complex),target,dimension(:) :: C
      integer(c_int),value :: ldc
      integer(c_int),value :: batch_count
      !
      rocblas_zsymm_batched_rank_1 = rocblas_zsymm_batched_orig(handle,side,uplo,m,n,alpha,c_loc(A),lda,c_loc(B),ldb,beta,c_loc(C),ldc,batch_count)
    end function

    function rocblas_ssymm_strided_batched_full_rank(handle,side,uplo,m,n,alpha,A,lda,stride_A,B,ldb,stride_B,beta,C,ldc,stride_C,batch_count)
      use iso_c_binding
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocblas_ssymm_strided_batched_full_rank
      type(c_ptr),value :: handle
      integer(kind(rocblas_side_left)),value :: side
      integer(kind(rocblas_fill_upper)),value :: uplo
      integer(c_int),value :: m
      integer(c_int),value :: n
      real(c_float) :: alpha
      real(c_float),target,dimension(:,:) :: A
      integer(c_int),value :: lda
      integer(c_int64_t),value :: stride_A
      real(c_float),target,dimension(:,:) :: B
      integer(c_int),value :: ldb
      integer(c_int64_t),value :: stride_B
      real(c_float) :: beta
      real(c_float),target,dimension(:,:) :: C
      integer(c_int),value :: ldc
      integer(c_int64_t),value :: stride_C
      integer(c_int),value :: batch_count
      !
      rocblas_ssymm_strided_batched_full_rank = rocblas_ssymm_strided_batched_orig(handle,side,uplo,m,n,alpha,c_loc(A),lda,stride_A,c_loc(B),ldb,stride_B,beta,c_loc(C),ldc,stride_C,batch_count)
    end function

    function rocblas_ssymm_strided_batched_rank_0(handle,side,uplo,m,n,alpha,A,lda,stride_A,B,ldb,stride_B,beta,C,ldc,stride_C,batch_count)
      use iso_c_binding
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocblas_ssymm_strided_batched_rank_0
      type(c_ptr),value :: handle
      integer(kind(rocblas_side_left)),value :: side
      integer(kind(rocblas_fill_upper)),value :: uplo
      integer(c_int),value :: m
      integer(c_int),value :: n
      real(c_float) :: alpha
      real(c_float),target :: A
      integer(c_int),value :: lda
      integer(c_int64_t),value :: stride_A
      real(c_float),target :: B
      integer(c_int),value :: ldb
      integer(c_int64_t),value :: stride_B
      real(c_float) :: beta
      real(c_float),target :: C
      integer(c_int),value :: ldc
      integer(c_int64_t),value :: stride_C
      integer(c_int),value :: batch_count
      !
      rocblas_ssymm_strided_batched_rank_0 = rocblas_ssymm_strided_batched_orig(handle,side,uplo,m,n,alpha,c_loc(A),lda,stride_A,c_loc(B),ldb,stride_B,beta,c_loc(C),ldc,stride_C,batch_count)
    end function

    function rocblas_ssymm_strided_batched_rank_1(handle,side,uplo,m,n,alpha,A,lda,stride_A,B,ldb,stride_B,beta,C,ldc,stride_C,batch_count)
      use iso_c_binding
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocblas_ssymm_strided_batched_rank_1
      type(c_ptr),value :: handle
      integer(kind(rocblas_side_left)),value :: side
      integer(kind(rocblas_fill_upper)),value :: uplo
      integer(c_int),value :: m
      integer(c_int),value :: n
      real(c_float) :: alpha
      real(c_float),target,dimension(:) :: A
      integer(c_int),value :: lda
      integer(c_int64_t),value :: stride_A
      real(c_float),target,dimension(:) :: B
      integer(c_int),value :: ldb
      integer(c_int64_t),value :: stride_B
      real(c_float) :: beta
      real(c_float),target,dimension(:) :: C
      integer(c_int),value :: ldc
      integer(c_int64_t),value :: stride_C
      integer(c_int),value :: batch_count
      !
      rocblas_ssymm_strided_batched_rank_1 = rocblas_ssymm_strided_batched_orig(handle,side,uplo,m,n,alpha,c_loc(A),lda,stride_A,c_loc(B),ldb,stride_B,beta,c_loc(C),ldc,stride_C,batch_count)
    end function

    function rocblas_dsymm_strided_batched_full_rank(handle,side,uplo,m,n,alpha,A,lda,stride_A,B,ldb,stride_B,beta,C,ldc,stride_C,batch_count)
      use iso_c_binding
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocblas_dsymm_strided_batched_full_rank
      type(c_ptr),value :: handle
      integer(kind(rocblas_side_left)),value :: side
      integer(kind(rocblas_fill_upper)),value :: uplo
      integer(c_int),value :: m
      integer(c_int),value :: n
      real(c_double) :: alpha
      real(c_double),target,dimension(:,:) :: A
      integer(c_int),value :: lda
      integer(c_int64_t),value :: stride_A
      real(c_double),target,dimension(:,:) :: B
      integer(c_int),value :: ldb
      integer(c_int64_t),value :: stride_B
      real(c_double) :: beta
      real(c_double),target,dimension(:,:) :: C
      integer(c_int),value :: ldc
      integer(c_int64_t),value :: stride_C
      integer(c_int),value :: batch_count
      !
      rocblas_dsymm_strided_batched_full_rank = rocblas_dsymm_strided_batched_orig(handle,side,uplo,m,n,alpha,c_loc(A),lda,stride_A,c_loc(B),ldb,stride_B,beta,c_loc(C),ldc,stride_C,batch_count)
    end function

    function rocblas_dsymm_strided_batched_rank_0(handle,side,uplo,m,n,alpha,A,lda,stride_A,B,ldb,stride_B,beta,C,ldc,stride_C,batch_count)
      use iso_c_binding
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocblas_dsymm_strided_batched_rank_0
      type(c_ptr),value :: handle
      integer(kind(rocblas_side_left)),value :: side
      integer(kind(rocblas_fill_upper)),value :: uplo
      integer(c_int),value :: m
      integer(c_int),value :: n
      real(c_double) :: alpha
      real(c_double),target :: A
      integer(c_int),value :: lda
      integer(c_int64_t),value :: stride_A
      real(c_double),target :: B
      integer(c_int),value :: ldb
      integer(c_int64_t),value :: stride_B
      real(c_double) :: beta
      real(c_double),target :: C
      integer(c_int),value :: ldc
      integer(c_int64_t),value :: stride_C
      integer(c_int),value :: batch_count
      !
      rocblas_dsymm_strided_batched_rank_0 = rocblas_dsymm_strided_batched_orig(handle,side,uplo,m,n,alpha,c_loc(A),lda,stride_A,c_loc(B),ldb,stride_B,beta,c_loc(C),ldc,stride_C,batch_count)
    end function

    function rocblas_dsymm_strided_batched_rank_1(handle,side,uplo,m,n,alpha,A,lda,stride_A,B,ldb,stride_B,beta,C,ldc,stride_C,batch_count)
      use iso_c_binding
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocblas_dsymm_strided_batched_rank_1
      type(c_ptr),value :: handle
      integer(kind(rocblas_side_left)),value :: side
      integer(kind(rocblas_fill_upper)),value :: uplo
      integer(c_int),value :: m
      integer(c_int),value :: n
      real(c_double) :: alpha
      real(c_double),target,dimension(:) :: A
      integer(c_int),value :: lda
      integer(c_int64_t),value :: stride_A
      real(c_double),target,dimension(:) :: B
      integer(c_int),value :: ldb
      integer(c_int64_t),value :: stride_B
      real(c_double) :: beta
      real(c_double),target,dimension(:) :: C
      integer(c_int),value :: ldc
      integer(c_int64_t),value :: stride_C
      integer(c_int),value :: batch_count
      !
      rocblas_dsymm_strided_batched_rank_1 = rocblas_dsymm_strided_batched_orig(handle,side,uplo,m,n,alpha,c_loc(A),lda,stride_A,c_loc(B),ldb,stride_B,beta,c_loc(C),ldc,stride_C,batch_count)
    end function

    function rocblas_csymm_strided_batched_full_rank(handle,side,uplo,m,n,alpha,A,lda,stride_A,B,ldb,stride_B,beta,C,ldc,stride_C,batch_count)
      use iso_c_binding
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocblas_csymm_strided_batched_full_rank
      type(c_ptr),value :: handle
      integer(kind(rocblas_side_left)),value :: side
      integer(kind(rocblas_fill_upper)),value :: uplo
      integer(c_int),value :: m
      integer(c_int),value :: n
      complex(c_float_complex) :: alpha
      complex(c_float_complex),target,dimension(:,:) :: A
      integer(c_int),value :: lda
      integer(c_int64_t),value :: stride_A
      complex(c_float_complex),target,dimension(:,:) :: B
      integer(c_int),value :: ldb
      integer(c_int64_t),value :: stride_B
      complex(c_float_complex) :: beta
      complex(c_float_complex),target,dimension(:,:) :: C
      integer(c_int),value :: ldc
      integer(c_int64_t),value :: stride_C
      integer(c_int),value :: batch_count
      !
      rocblas_csymm_strided_batched_full_rank = rocblas_csymm_strided_batched_orig(handle,side,uplo,m,n,alpha,c_loc(A),lda,stride_A,c_loc(B),ldb,stride_B,beta,c_loc(C),ldc,stride_C,batch_count)
    end function

    function rocblas_csymm_strided_batched_rank_0(handle,side,uplo,m,n,alpha,A,lda,stride_A,B,ldb,stride_B,beta,C,ldc,stride_C,batch_count)
      use iso_c_binding
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocblas_csymm_strided_batched_rank_0
      type(c_ptr),value :: handle
      integer(kind(rocblas_side_left)),value :: side
      integer(kind(rocblas_fill_upper)),value :: uplo
      integer(c_int),value :: m
      integer(c_int),value :: n
      complex(c_float_complex) :: alpha
      complex(c_float_complex),target :: A
      integer(c_int),value :: lda
      integer(c_int64_t),value :: stride_A
      complex(c_float_complex),target :: B
      integer(c_int),value :: ldb
      integer(c_int64_t),value :: stride_B
      complex(c_float_complex) :: beta
      complex(c_float_complex),target :: C
      integer(c_int),value :: ldc
      integer(c_int64_t),value :: stride_C
      integer(c_int),value :: batch_count
      !
      rocblas_csymm_strided_batched_rank_0 = rocblas_csymm_strided_batched_orig(handle,side,uplo,m,n,alpha,c_loc(A),lda,stride_A,c_loc(B),ldb,stride_B,beta,c_loc(C),ldc,stride_C,batch_count)
    end function

    function rocblas_csymm_strided_batched_rank_1(handle,side,uplo,m,n,alpha,A,lda,stride_A,B,ldb,stride_B,beta,C,ldc,stride_C,batch_count)
      use iso_c_binding
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocblas_csymm_strided_batched_rank_1
      type(c_ptr),value :: handle
      integer(kind(rocblas_side_left)),value :: side
      integer(kind(rocblas_fill_upper)),value :: uplo
      integer(c_int),value :: m
      integer(c_int),value :: n
      complex(c_float_complex) :: alpha
      complex(c_float_complex),target,dimension(:) :: A
      integer(c_int),value :: lda
      integer(c_int64_t),value :: stride_A
      complex(c_float_complex),target,dimension(:) :: B
      integer(c_int),value :: ldb
      integer(c_int64_t),value :: stride_B
      complex(c_float_complex) :: beta
      complex(c_float_complex),target,dimension(:) :: C
      integer(c_int),value :: ldc
      integer(c_int64_t),value :: stride_C
      integer(c_int),value :: batch_count
      !
      rocblas_csymm_strided_batched_rank_1 = rocblas_csymm_strided_batched_orig(handle,side,uplo,m,n,alpha,c_loc(A),lda,stride_A,c_loc(B),ldb,stride_B,beta,c_loc(C),ldc,stride_C,batch_count)
    end function

    function rocblas_zsymm_strided_batched_full_rank(handle,side,uplo,m,n,alpha,A,lda,stride_A,B,ldb,stride_B,beta,C,ldc,stride_C,batch_count)
      use iso_c_binding
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocblas_zsymm_strided_batched_full_rank
      type(c_ptr),value :: handle
      integer(kind(rocblas_side_left)),value :: side
      integer(kind(rocblas_fill_upper)),value :: uplo
      integer(c_int),value :: m
      integer(c_int),value :: n
      complex(c_double_complex) :: alpha
      complex(c_double_complex),target,dimension(:,:) :: A
      integer(c_int),value :: lda
      integer(c_int64_t),value :: stride_A
      complex(c_double_complex),target,dimension(:,:) :: B
      integer(c_int),value :: ldb
      integer(c_int64_t),value :: stride_B
      complex(c_double_complex) :: beta
      complex(c_double_complex),target,dimension(:,:) :: C
      integer(c_int),value :: ldc
      integer(c_int64_t),value :: stride_C
      integer(c_int),value :: batch_count
      !
      rocblas_zsymm_strided_batched_full_rank = rocblas_zsymm_strided_batched_orig(handle,side,uplo,m,n,alpha,c_loc(A),lda,stride_A,c_loc(B),ldb,stride_B,beta,c_loc(C),ldc,stride_C,batch_count)
    end function

    function rocblas_zsymm_strided_batched_rank_0(handle,side,uplo,m,n,alpha,A,lda,stride_A,B,ldb,stride_B,beta,C,ldc,stride_C,batch_count)
      use iso_c_binding
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocblas_zsymm_strided_batched_rank_0
      type(c_ptr),value :: handle
      integer(kind(rocblas_side_left)),value :: side
      integer(kind(rocblas_fill_upper)),value :: uplo
      integer(c_int),value :: m
      integer(c_int),value :: n
      complex(c_double_complex) :: alpha
      complex(c_double_complex),target :: A
      integer(c_int),value :: lda
      integer(c_int64_t),value :: stride_A
      complex(c_double_complex),target :: B
      integer(c_int),value :: ldb
      integer(c_int64_t),value :: stride_B
      complex(c_double_complex) :: beta
      complex(c_double_complex),target :: C
      integer(c_int),value :: ldc
      integer(c_int64_t),value :: stride_C
      integer(c_int),value :: batch_count
      !
      rocblas_zsymm_strided_batched_rank_0 = rocblas_zsymm_strided_batched_orig(handle,side,uplo,m,n,alpha,c_loc(A),lda,stride_A,c_loc(B),ldb,stride_B,beta,c_loc(C),ldc,stride_C,batch_count)
    end function

    function rocblas_zsymm_strided_batched_rank_1(handle,side,uplo,m,n,alpha,A,lda,stride_A,B,ldb,stride_B,beta,C,ldc,stride_C,batch_count)
      use iso_c_binding
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocblas_zsymm_strided_batched_rank_1
      type(c_ptr),value :: handle
      integer(kind(rocblas_side_left)),value :: side
      integer(kind(rocblas_fill_upper)),value :: uplo
      integer(c_int),value :: m
      integer(c_int),value :: n
      complex(c_double_complex) :: alpha
      complex(c_double_complex),target,dimension(:) :: A
      integer(c_int),value :: lda
      integer(c_int64_t),value :: stride_A
      complex(c_double_complex),target,dimension(:) :: B
      integer(c_int),value :: ldb
      integer(c_int64_t),value :: stride_B
      complex(c_double_complex) :: beta
      complex(c_double_complex),target,dimension(:) :: C
      integer(c_int),value :: ldc
      integer(c_int64_t),value :: stride_C
      integer(c_int),value :: batch_count
      !
      rocblas_zsymm_strided_batched_rank_1 = rocblas_zsymm_strided_batched_orig(handle,side,uplo,m,n,alpha,c_loc(A),lda,stride_A,c_loc(B),ldb,stride_B,beta,c_loc(C),ldc,stride_C,batch_count)
    end function

    function rocblas_ssyrk_full_rank(handle,uplo,transA,n,k,alpha,A,lda,beta,C,ldc)
      use iso_c_binding
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocblas_ssyrk_full_rank
      type(c_ptr),value :: handle
      integer(kind(rocblas_fill_upper)),value :: uplo
      integer(kind(rocblas_operation_none)),value :: transA
      integer(c_int),value :: n
      integer(c_int),value :: k
      real(c_float) :: alpha
      real(c_float),target,dimension(:,:) :: A
      integer(c_int),value :: lda
      real(c_float) :: beta
      real(c_float),target,dimension(:,:) :: C
      integer(c_int),value :: ldc
      !
      rocblas_ssyrk_full_rank = rocblas_ssyrk_orig(handle,uplo,transA,n,k,alpha,c_loc(A),lda,beta,c_loc(C),ldc)
    end function

    function rocblas_ssyrk_rank_0(handle,uplo,transA,n,k,alpha,A,lda,beta,C,ldc)
      use iso_c_binding
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocblas_ssyrk_rank_0
      type(c_ptr),value :: handle
      integer(kind(rocblas_fill_upper)),value :: uplo
      integer(kind(rocblas_operation_none)),value :: transA
      integer(c_int),value :: n
      integer(c_int),value :: k
      real(c_float) :: alpha
      real(c_float),target :: A
      integer(c_int),value :: lda
      real(c_float) :: beta
      real(c_float),target :: C
      integer(c_int),value :: ldc
      !
      rocblas_ssyrk_rank_0 = rocblas_ssyrk_orig(handle,uplo,transA,n,k,alpha,c_loc(A),lda,beta,c_loc(C),ldc)
    end function

    function rocblas_ssyrk_rank_1(handle,uplo,transA,n,k,alpha,A,lda,beta,C,ldc)
      use iso_c_binding
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocblas_ssyrk_rank_1
      type(c_ptr),value :: handle
      integer(kind(rocblas_fill_upper)),value :: uplo
      integer(kind(rocblas_operation_none)),value :: transA
      integer(c_int),value :: n
      integer(c_int),value :: k
      real(c_float) :: alpha
      real(c_float),target,dimension(:) :: A
      integer(c_int),value :: lda
      real(c_float) :: beta
      real(c_float),target,dimension(:) :: C
      integer(c_int),value :: ldc
      !
      rocblas_ssyrk_rank_1 = rocblas_ssyrk_orig(handle,uplo,transA,n,k,alpha,c_loc(A),lda,beta,c_loc(C),ldc)
    end function

    function rocblas_dsyrk_full_rank(handle,uplo,transA,n,k,alpha,A,lda,beta,C,ldc)
      use iso_c_binding
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocblas_dsyrk_full_rank
      type(c_ptr),value :: handle
      integer(kind(rocblas_fill_upper)),value :: uplo
      integer(kind(rocblas_operation_none)),value :: transA
      integer(c_int),value :: n
      integer(c_int),value :: k
      real(c_double) :: alpha
      real(c_double),target,dimension(:,:) :: A
      integer(c_int),value :: lda
      real(c_double) :: beta
      real(c_double),target,dimension(:,:) :: C
      integer(c_int),value :: ldc
      !
      rocblas_dsyrk_full_rank = rocblas_dsyrk_orig(handle,uplo,transA,n,k,alpha,c_loc(A),lda,beta,c_loc(C),ldc)
    end function

    function rocblas_dsyrk_rank_0(handle,uplo,transA,n,k,alpha,A,lda,beta,C,ldc)
      use iso_c_binding
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocblas_dsyrk_rank_0
      type(c_ptr),value :: handle
      integer(kind(rocblas_fill_upper)),value :: uplo
      integer(kind(rocblas_operation_none)),value :: transA
      integer(c_int),value :: n
      integer(c_int),value :: k
      real(c_double) :: alpha
      real(c_double),target :: A
      integer(c_int),value :: lda
      real(c_double) :: beta
      real(c_double),target :: C
      integer(c_int),value :: ldc
      !
      rocblas_dsyrk_rank_0 = rocblas_dsyrk_orig(handle,uplo,transA,n,k,alpha,c_loc(A),lda,beta,c_loc(C),ldc)
    end function

    function rocblas_dsyrk_rank_1(handle,uplo,transA,n,k,alpha,A,lda,beta,C,ldc)
      use iso_c_binding
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocblas_dsyrk_rank_1
      type(c_ptr),value :: handle
      integer(kind(rocblas_fill_upper)),value :: uplo
      integer(kind(rocblas_operation_none)),value :: transA
      integer(c_int),value :: n
      integer(c_int),value :: k
      real(c_double) :: alpha
      real(c_double),target,dimension(:) :: A
      integer(c_int),value :: lda
      real(c_double) :: beta
      real(c_double),target,dimension(:) :: C
      integer(c_int),value :: ldc
      !
      rocblas_dsyrk_rank_1 = rocblas_dsyrk_orig(handle,uplo,transA,n,k,alpha,c_loc(A),lda,beta,c_loc(C),ldc)
    end function

    function rocblas_csyrk_full_rank(handle,uplo,transA,n,k,alpha,A,lda,beta,C,ldc)
      use iso_c_binding
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocblas_csyrk_full_rank
      type(c_ptr),value :: handle
      integer(kind(rocblas_fill_upper)),value :: uplo
      integer(kind(rocblas_operation_none)),value :: transA
      integer(c_int),value :: n
      integer(c_int),value :: k
      complex(c_float_complex) :: alpha
      complex(c_float_complex),target,dimension(:,:) :: A
      integer(c_int),value :: lda
      complex(c_float_complex) :: beta
      complex(c_float_complex),target,dimension(:,:) :: C
      integer(c_int),value :: ldc
      !
      rocblas_csyrk_full_rank = rocblas_csyrk_orig(handle,uplo,transA,n,k,alpha,c_loc(A),lda,beta,c_loc(C),ldc)
    end function

    function rocblas_csyrk_rank_0(handle,uplo,transA,n,k,alpha,A,lda,beta,C,ldc)
      use iso_c_binding
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocblas_csyrk_rank_0
      type(c_ptr),value :: handle
      integer(kind(rocblas_fill_upper)),value :: uplo
      integer(kind(rocblas_operation_none)),value :: transA
      integer(c_int),value :: n
      integer(c_int),value :: k
      complex(c_float_complex) :: alpha
      complex(c_float_complex),target :: A
      integer(c_int),value :: lda
      complex(c_float_complex) :: beta
      complex(c_float_complex),target :: C
      integer(c_int),value :: ldc
      !
      rocblas_csyrk_rank_0 = rocblas_csyrk_orig(handle,uplo,transA,n,k,alpha,c_loc(A),lda,beta,c_loc(C),ldc)
    end function

    function rocblas_csyrk_rank_1(handle,uplo,transA,n,k,alpha,A,lda,beta,C,ldc)
      use iso_c_binding
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocblas_csyrk_rank_1
      type(c_ptr),value :: handle
      integer(kind(rocblas_fill_upper)),value :: uplo
      integer(kind(rocblas_operation_none)),value :: transA
      integer(c_int),value :: n
      integer(c_int),value :: k
      complex(c_float_complex) :: alpha
      complex(c_float_complex),target,dimension(:) :: A
      integer(c_int),value :: lda
      complex(c_float_complex) :: beta
      complex(c_float_complex),target,dimension(:) :: C
      integer(c_int),value :: ldc
      !
      rocblas_csyrk_rank_1 = rocblas_csyrk_orig(handle,uplo,transA,n,k,alpha,c_loc(A),lda,beta,c_loc(C),ldc)
    end function

    function rocblas_zsyrk_full_rank(handle,uplo,transA,n,k,alpha,A,lda,beta,C,ldc)
      use iso_c_binding
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocblas_zsyrk_full_rank
      type(c_ptr),value :: handle
      integer(kind(rocblas_fill_upper)),value :: uplo
      integer(kind(rocblas_operation_none)),value :: transA
      integer(c_int),value :: n
      integer(c_int),value :: k
      complex(c_double_complex) :: alpha
      complex(c_double_complex),target,dimension(:,:) :: A
      integer(c_int),value :: lda
      complex(c_double_complex) :: beta
      complex(c_double_complex),target,dimension(:,:) :: C
      integer(c_int),value :: ldc
      !
      rocblas_zsyrk_full_rank = rocblas_zsyrk_orig(handle,uplo,transA,n,k,alpha,c_loc(A),lda,beta,c_loc(C),ldc)
    end function

    function rocblas_zsyrk_rank_0(handle,uplo,transA,n,k,alpha,A,lda,beta,C,ldc)
      use iso_c_binding
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocblas_zsyrk_rank_0
      type(c_ptr),value :: handle
      integer(kind(rocblas_fill_upper)),value :: uplo
      integer(kind(rocblas_operation_none)),value :: transA
      integer(c_int),value :: n
      integer(c_int),value :: k
      complex(c_double_complex) :: alpha
      complex(c_double_complex),target :: A
      integer(c_int),value :: lda
      complex(c_double_complex) :: beta
      complex(c_double_complex),target :: C
      integer(c_int),value :: ldc
      !
      rocblas_zsyrk_rank_0 = rocblas_zsyrk_orig(handle,uplo,transA,n,k,alpha,c_loc(A),lda,beta,c_loc(C),ldc)
    end function

    function rocblas_zsyrk_rank_1(handle,uplo,transA,n,k,alpha,A,lda,beta,C,ldc)
      use iso_c_binding
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocblas_zsyrk_rank_1
      type(c_ptr),value :: handle
      integer(kind(rocblas_fill_upper)),value :: uplo
      integer(kind(rocblas_operation_none)),value :: transA
      integer(c_int),value :: n
      integer(c_int),value :: k
      complex(c_double_complex) :: alpha
      complex(c_double_complex),target,dimension(:) :: A
      integer(c_int),value :: lda
      complex(c_double_complex) :: beta
      complex(c_double_complex),target,dimension(:) :: C
      integer(c_int),value :: ldc
      !
      rocblas_zsyrk_rank_1 = rocblas_zsyrk_orig(handle,uplo,transA,n,k,alpha,c_loc(A),lda,beta,c_loc(C),ldc)
    end function

    function rocblas_ssyrk_batched_full_rank(handle,uplo,transA,n,k,alpha,A,lda,beta,C,ldc,batch_count)
      use iso_c_binding
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocblas_ssyrk_batched_full_rank
      type(c_ptr),value :: handle
      integer(kind(rocblas_fill_upper)),value :: uplo
      integer(kind(rocblas_operation_none)),value :: transA
      integer(c_int),value :: n
      integer(c_int),value :: k
      real(c_float) :: alpha
      real(c_float),target,dimension(:,:,:) :: A
      integer(c_int),value :: lda
      real(c_float) :: beta
      real(c_float),target,dimension(:,:,:) :: C
      integer(c_int),value :: ldc
      integer(c_int),value :: batch_count
      !
      rocblas_ssyrk_batched_full_rank = rocblas_ssyrk_batched_orig(handle,uplo,transA,n,k,alpha,c_loc(A),lda,beta,c_loc(C),ldc,batch_count)
    end function

    function rocblas_ssyrk_batched_rank_0(handle,uplo,transA,n,k,alpha,A,lda,beta,C,ldc,batch_count)
      use iso_c_binding
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocblas_ssyrk_batched_rank_0
      type(c_ptr),value :: handle
      integer(kind(rocblas_fill_upper)),value :: uplo
      integer(kind(rocblas_operation_none)),value :: transA
      integer(c_int),value :: n
      integer(c_int),value :: k
      real(c_float) :: alpha
      real(c_float),target :: A
      integer(c_int),value :: lda
      real(c_float) :: beta
      real(c_float),target :: C
      integer(c_int),value :: ldc
      integer(c_int),value :: batch_count
      !
      rocblas_ssyrk_batched_rank_0 = rocblas_ssyrk_batched_orig(handle,uplo,transA,n,k,alpha,c_loc(A),lda,beta,c_loc(C),ldc,batch_count)
    end function

    function rocblas_ssyrk_batched_rank_1(handle,uplo,transA,n,k,alpha,A,lda,beta,C,ldc,batch_count)
      use iso_c_binding
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocblas_ssyrk_batched_rank_1
      type(c_ptr),value :: handle
      integer(kind(rocblas_fill_upper)),value :: uplo
      integer(kind(rocblas_operation_none)),value :: transA
      integer(c_int),value :: n
      integer(c_int),value :: k
      real(c_float) :: alpha
      real(c_float),target,dimension(:) :: A
      integer(c_int),value :: lda
      real(c_float) :: beta
      real(c_float),target,dimension(:) :: C
      integer(c_int),value :: ldc
      integer(c_int),value :: batch_count
      !
      rocblas_ssyrk_batched_rank_1 = rocblas_ssyrk_batched_orig(handle,uplo,transA,n,k,alpha,c_loc(A),lda,beta,c_loc(C),ldc,batch_count)
    end function

    function rocblas_dsyrk_batched_full_rank(handle,uplo,transA,n,k,alpha,A,lda,beta,C,ldc,batch_count)
      use iso_c_binding
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocblas_dsyrk_batched_full_rank
      type(c_ptr),value :: handle
      integer(kind(rocblas_fill_upper)),value :: uplo
      integer(kind(rocblas_operation_none)),value :: transA
      integer(c_int),value :: n
      integer(c_int),value :: k
      real(c_double) :: alpha
      real(c_double),target,dimension(:,:,:) :: A
      integer(c_int),value :: lda
      real(c_double) :: beta
      real(c_double),target,dimension(:,:,:) :: C
      integer(c_int),value :: ldc
      integer(c_int),value :: batch_count
      !
      rocblas_dsyrk_batched_full_rank = rocblas_dsyrk_batched_orig(handle,uplo,transA,n,k,alpha,c_loc(A),lda,beta,c_loc(C),ldc,batch_count)
    end function

    function rocblas_dsyrk_batched_rank_0(handle,uplo,transA,n,k,alpha,A,lda,beta,C,ldc,batch_count)
      use iso_c_binding
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocblas_dsyrk_batched_rank_0
      type(c_ptr),value :: handle
      integer(kind(rocblas_fill_upper)),value :: uplo
      integer(kind(rocblas_operation_none)),value :: transA
      integer(c_int),value :: n
      integer(c_int),value :: k
      real(c_double) :: alpha
      real(c_double),target :: A
      integer(c_int),value :: lda
      real(c_double) :: beta
      real(c_double),target :: C
      integer(c_int),value :: ldc
      integer(c_int),value :: batch_count
      !
      rocblas_dsyrk_batched_rank_0 = rocblas_dsyrk_batched_orig(handle,uplo,transA,n,k,alpha,c_loc(A),lda,beta,c_loc(C),ldc,batch_count)
    end function

    function rocblas_dsyrk_batched_rank_1(handle,uplo,transA,n,k,alpha,A,lda,beta,C,ldc,batch_count)
      use iso_c_binding
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocblas_dsyrk_batched_rank_1
      type(c_ptr),value :: handle
      integer(kind(rocblas_fill_upper)),value :: uplo
      integer(kind(rocblas_operation_none)),value :: transA
      integer(c_int),value :: n
      integer(c_int),value :: k
      real(c_double) :: alpha
      real(c_double),target,dimension(:) :: A
      integer(c_int),value :: lda
      real(c_double) :: beta
      real(c_double),target,dimension(:) :: C
      integer(c_int),value :: ldc
      integer(c_int),value :: batch_count
      !
      rocblas_dsyrk_batched_rank_1 = rocblas_dsyrk_batched_orig(handle,uplo,transA,n,k,alpha,c_loc(A),lda,beta,c_loc(C),ldc,batch_count)
    end function

    function rocblas_csyrk_batched_full_rank(handle,uplo,transA,n,k,alpha,A,lda,beta,C,ldc,batch_count)
      use iso_c_binding
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocblas_csyrk_batched_full_rank
      type(c_ptr),value :: handle
      integer(kind(rocblas_fill_upper)),value :: uplo
      integer(kind(rocblas_operation_none)),value :: transA
      integer(c_int),value :: n
      integer(c_int),value :: k
      complex(c_float_complex) :: alpha
      complex(c_float_complex),target,dimension(:,:,:) :: A
      integer(c_int),value :: lda
      complex(c_float_complex) :: beta
      complex(c_float_complex),target,dimension(:,:,:) :: C
      integer(c_int),value :: ldc
      integer(c_int),value :: batch_count
      !
      rocblas_csyrk_batched_full_rank = rocblas_csyrk_batched_orig(handle,uplo,transA,n,k,alpha,c_loc(A),lda,beta,c_loc(C),ldc,batch_count)
    end function

    function rocblas_csyrk_batched_rank_0(handle,uplo,transA,n,k,alpha,A,lda,beta,C,ldc,batch_count)
      use iso_c_binding
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocblas_csyrk_batched_rank_0
      type(c_ptr),value :: handle
      integer(kind(rocblas_fill_upper)),value :: uplo
      integer(kind(rocblas_operation_none)),value :: transA
      integer(c_int),value :: n
      integer(c_int),value :: k
      complex(c_float_complex) :: alpha
      complex(c_float_complex),target :: A
      integer(c_int),value :: lda
      complex(c_float_complex) :: beta
      complex(c_float_complex),target :: C
      integer(c_int),value :: ldc
      integer(c_int),value :: batch_count
      !
      rocblas_csyrk_batched_rank_0 = rocblas_csyrk_batched_orig(handle,uplo,transA,n,k,alpha,c_loc(A),lda,beta,c_loc(C),ldc,batch_count)
    end function

    function rocblas_csyrk_batched_rank_1(handle,uplo,transA,n,k,alpha,A,lda,beta,C,ldc,batch_count)
      use iso_c_binding
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocblas_csyrk_batched_rank_1
      type(c_ptr),value :: handle
      integer(kind(rocblas_fill_upper)),value :: uplo
      integer(kind(rocblas_operation_none)),value :: transA
      integer(c_int),value :: n
      integer(c_int),value :: k
      complex(c_float_complex) :: alpha
      complex(c_float_complex),target,dimension(:) :: A
      integer(c_int),value :: lda
      complex(c_float_complex) :: beta
      complex(c_float_complex),target,dimension(:) :: C
      integer(c_int),value :: ldc
      integer(c_int),value :: batch_count
      !
      rocblas_csyrk_batched_rank_1 = rocblas_csyrk_batched_orig(handle,uplo,transA,n,k,alpha,c_loc(A),lda,beta,c_loc(C),ldc,batch_count)
    end function

    function rocblas_zsyrk_batched_full_rank(handle,uplo,transA,n,k,alpha,A,lda,beta,C,ldc,batch_count)
      use iso_c_binding
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocblas_zsyrk_batched_full_rank
      type(c_ptr),value :: handle
      integer(kind(rocblas_fill_upper)),value :: uplo
      integer(kind(rocblas_operation_none)),value :: transA
      integer(c_int),value :: n
      integer(c_int),value :: k
      complex(c_double_complex) :: alpha
      complex(c_double_complex),target,dimension(:,:,:) :: A
      integer(c_int),value :: lda
      complex(c_double_complex) :: beta
      complex(c_double_complex),target,dimension(:,:,:) :: C
      integer(c_int),value :: ldc
      integer(c_int),value :: batch_count
      !
      rocblas_zsyrk_batched_full_rank = rocblas_zsyrk_batched_orig(handle,uplo,transA,n,k,alpha,c_loc(A),lda,beta,c_loc(C),ldc,batch_count)
    end function

    function rocblas_zsyrk_batched_rank_0(handle,uplo,transA,n,k,alpha,A,lda,beta,C,ldc,batch_count)
      use iso_c_binding
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocblas_zsyrk_batched_rank_0
      type(c_ptr),value :: handle
      integer(kind(rocblas_fill_upper)),value :: uplo
      integer(kind(rocblas_operation_none)),value :: transA
      integer(c_int),value :: n
      integer(c_int),value :: k
      complex(c_double_complex) :: alpha
      complex(c_double_complex),target :: A
      integer(c_int),value :: lda
      complex(c_double_complex) :: beta
      complex(c_double_complex),target :: C
      integer(c_int),value :: ldc
      integer(c_int),value :: batch_count
      !
      rocblas_zsyrk_batched_rank_0 = rocblas_zsyrk_batched_orig(handle,uplo,transA,n,k,alpha,c_loc(A),lda,beta,c_loc(C),ldc,batch_count)
    end function

    function rocblas_zsyrk_batched_rank_1(handle,uplo,transA,n,k,alpha,A,lda,beta,C,ldc,batch_count)
      use iso_c_binding
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocblas_zsyrk_batched_rank_1
      type(c_ptr),value :: handle
      integer(kind(rocblas_fill_upper)),value :: uplo
      integer(kind(rocblas_operation_none)),value :: transA
      integer(c_int),value :: n
      integer(c_int),value :: k
      complex(c_double_complex) :: alpha
      complex(c_double_complex),target,dimension(:) :: A
      integer(c_int),value :: lda
      complex(c_double_complex) :: beta
      complex(c_double_complex),target,dimension(:) :: C
      integer(c_int),value :: ldc
      integer(c_int),value :: batch_count
      !
      rocblas_zsyrk_batched_rank_1 = rocblas_zsyrk_batched_orig(handle,uplo,transA,n,k,alpha,c_loc(A),lda,beta,c_loc(C),ldc,batch_count)
    end function

    function rocblas_ssyrk_strided_batched_full_rank(handle,uplo,transA,n,k,alpha,A,lda,stride_A,beta,C,ldc,stride_C,batch_count)
      use iso_c_binding
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocblas_ssyrk_strided_batched_full_rank
      type(c_ptr),value :: handle
      integer(kind(rocblas_fill_upper)),value :: uplo
      integer(kind(rocblas_operation_none)),value :: transA
      integer(c_int),value :: n
      integer(c_int),value :: k
      real(c_float) :: alpha
      real(c_float),target,dimension(:,:) :: A
      integer(c_int),value :: lda
      integer(c_int64_t),value :: stride_A
      real(c_float) :: beta
      real(c_float),target,dimension(:,:) :: C
      integer(c_int),value :: ldc
      integer(c_int64_t),value :: stride_C
      integer(c_int),value :: batch_count
      !
      rocblas_ssyrk_strided_batched_full_rank = rocblas_ssyrk_strided_batched_orig(handle,uplo,transA,n,k,alpha,c_loc(A),lda,stride_A,beta,c_loc(C),ldc,stride_C,batch_count)
    end function

    function rocblas_ssyrk_strided_batched_rank_0(handle,uplo,transA,n,k,alpha,A,lda,stride_A,beta,C,ldc,stride_C,batch_count)
      use iso_c_binding
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocblas_ssyrk_strided_batched_rank_0
      type(c_ptr),value :: handle
      integer(kind(rocblas_fill_upper)),value :: uplo
      integer(kind(rocblas_operation_none)),value :: transA
      integer(c_int),value :: n
      integer(c_int),value :: k
      real(c_float) :: alpha
      real(c_float),target :: A
      integer(c_int),value :: lda
      integer(c_int64_t),value :: stride_A
      real(c_float) :: beta
      real(c_float),target :: C
      integer(c_int),value :: ldc
      integer(c_int64_t),value :: stride_C
      integer(c_int),value :: batch_count
      !
      rocblas_ssyrk_strided_batched_rank_0 = rocblas_ssyrk_strided_batched_orig(handle,uplo,transA,n,k,alpha,c_loc(A),lda,stride_A,beta,c_loc(C),ldc,stride_C,batch_count)
    end function

    function rocblas_ssyrk_strided_batched_rank_1(handle,uplo,transA,n,k,alpha,A,lda,stride_A,beta,C,ldc,stride_C,batch_count)
      use iso_c_binding
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocblas_ssyrk_strided_batched_rank_1
      type(c_ptr),value :: handle
      integer(kind(rocblas_fill_upper)),value :: uplo
      integer(kind(rocblas_operation_none)),value :: transA
      integer(c_int),value :: n
      integer(c_int),value :: k
      real(c_float) :: alpha
      real(c_float),target,dimension(:) :: A
      integer(c_int),value :: lda
      integer(c_int64_t),value :: stride_A
      real(c_float) :: beta
      real(c_float),target,dimension(:) :: C
      integer(c_int),value :: ldc
      integer(c_int64_t),value :: stride_C
      integer(c_int),value :: batch_count
      !
      rocblas_ssyrk_strided_batched_rank_1 = rocblas_ssyrk_strided_batched_orig(handle,uplo,transA,n,k,alpha,c_loc(A),lda,stride_A,beta,c_loc(C),ldc,stride_C,batch_count)
    end function

    function rocblas_dsyrk_strided_batched_full_rank(handle,uplo,transA,n,k,alpha,A,lda,stride_A,beta,C,ldc,stride_C,batch_count)
      use iso_c_binding
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocblas_dsyrk_strided_batched_full_rank
      type(c_ptr),value :: handle
      integer(kind(rocblas_fill_upper)),value :: uplo
      integer(kind(rocblas_operation_none)),value :: transA
      integer(c_int),value :: n
      integer(c_int),value :: k
      real(c_double) :: alpha
      real(c_double),target,dimension(:,:) :: A
      integer(c_int),value :: lda
      integer(c_int64_t),value :: stride_A
      real(c_double) :: beta
      real(c_double),target,dimension(:,:) :: C
      integer(c_int),value :: ldc
      integer(c_int64_t),value :: stride_C
      integer(c_int),value :: batch_count
      !
      rocblas_dsyrk_strided_batched_full_rank = rocblas_dsyrk_strided_batched_orig(handle,uplo,transA,n,k,alpha,c_loc(A),lda,stride_A,beta,c_loc(C),ldc,stride_C,batch_count)
    end function

    function rocblas_dsyrk_strided_batched_rank_0(handle,uplo,transA,n,k,alpha,A,lda,stride_A,beta,C,ldc,stride_C,batch_count)
      use iso_c_binding
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocblas_dsyrk_strided_batched_rank_0
      type(c_ptr),value :: handle
      integer(kind(rocblas_fill_upper)),value :: uplo
      integer(kind(rocblas_operation_none)),value :: transA
      integer(c_int),value :: n
      integer(c_int),value :: k
      real(c_double) :: alpha
      real(c_double),target :: A
      integer(c_int),value :: lda
      integer(c_int64_t),value :: stride_A
      real(c_double) :: beta
      real(c_double),target :: C
      integer(c_int),value :: ldc
      integer(c_int64_t),value :: stride_C
      integer(c_int),value :: batch_count
      !
      rocblas_dsyrk_strided_batched_rank_0 = rocblas_dsyrk_strided_batched_orig(handle,uplo,transA,n,k,alpha,c_loc(A),lda,stride_A,beta,c_loc(C),ldc,stride_C,batch_count)
    end function

    function rocblas_dsyrk_strided_batched_rank_1(handle,uplo,transA,n,k,alpha,A,lda,stride_A,beta,C,ldc,stride_C,batch_count)
      use iso_c_binding
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocblas_dsyrk_strided_batched_rank_1
      type(c_ptr),value :: handle
      integer(kind(rocblas_fill_upper)),value :: uplo
      integer(kind(rocblas_operation_none)),value :: transA
      integer(c_int),value :: n
      integer(c_int),value :: k
      real(c_double) :: alpha
      real(c_double),target,dimension(:) :: A
      integer(c_int),value :: lda
      integer(c_int64_t),value :: stride_A
      real(c_double) :: beta
      real(c_double),target,dimension(:) :: C
      integer(c_int),value :: ldc
      integer(c_int64_t),value :: stride_C
      integer(c_int),value :: batch_count
      !
      rocblas_dsyrk_strided_batched_rank_1 = rocblas_dsyrk_strided_batched_orig(handle,uplo,transA,n,k,alpha,c_loc(A),lda,stride_A,beta,c_loc(C),ldc,stride_C,batch_count)
    end function

    function rocblas_csyrk_strided_batched_full_rank(handle,uplo,transA,n,k,alpha,A,lda,stride_A,beta,C,ldc,stride_C,batch_count)
      use iso_c_binding
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocblas_csyrk_strided_batched_full_rank
      type(c_ptr),value :: handle
      integer(kind(rocblas_fill_upper)),value :: uplo
      integer(kind(rocblas_operation_none)),value :: transA
      integer(c_int),value :: n
      integer(c_int),value :: k
      complex(c_float_complex) :: alpha
      complex(c_float_complex),target,dimension(:,:) :: A
      integer(c_int),value :: lda
      integer(c_int64_t),value :: stride_A
      complex(c_float_complex) :: beta
      complex(c_float_complex),target,dimension(:,:) :: C
      integer(c_int),value :: ldc
      integer(c_int64_t),value :: stride_C
      integer(c_int),value :: batch_count
      !
      rocblas_csyrk_strided_batched_full_rank = rocblas_csyrk_strided_batched_orig(handle,uplo,transA,n,k,alpha,c_loc(A),lda,stride_A,beta,c_loc(C),ldc,stride_C,batch_count)
    end function

    function rocblas_csyrk_strided_batched_rank_0(handle,uplo,transA,n,k,alpha,A,lda,stride_A,beta,C,ldc,stride_C,batch_count)
      use iso_c_binding
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocblas_csyrk_strided_batched_rank_0
      type(c_ptr),value :: handle
      integer(kind(rocblas_fill_upper)),value :: uplo
      integer(kind(rocblas_operation_none)),value :: transA
      integer(c_int),value :: n
      integer(c_int),value :: k
      complex(c_float_complex) :: alpha
      complex(c_float_complex),target :: A
      integer(c_int),value :: lda
      integer(c_int64_t),value :: stride_A
      complex(c_float_complex) :: beta
      complex(c_float_complex),target :: C
      integer(c_int),value :: ldc
      integer(c_int64_t),value :: stride_C
      integer(c_int),value :: batch_count
      !
      rocblas_csyrk_strided_batched_rank_0 = rocblas_csyrk_strided_batched_orig(handle,uplo,transA,n,k,alpha,c_loc(A),lda,stride_A,beta,c_loc(C),ldc,stride_C,batch_count)
    end function

    function rocblas_csyrk_strided_batched_rank_1(handle,uplo,transA,n,k,alpha,A,lda,stride_A,beta,C,ldc,stride_C,batch_count)
      use iso_c_binding
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocblas_csyrk_strided_batched_rank_1
      type(c_ptr),value :: handle
      integer(kind(rocblas_fill_upper)),value :: uplo
      integer(kind(rocblas_operation_none)),value :: transA
      integer(c_int),value :: n
      integer(c_int),value :: k
      complex(c_float_complex) :: alpha
      complex(c_float_complex),target,dimension(:) :: A
      integer(c_int),value :: lda
      integer(c_int64_t),value :: stride_A
      complex(c_float_complex) :: beta
      complex(c_float_complex),target,dimension(:) :: C
      integer(c_int),value :: ldc
      integer(c_int64_t),value :: stride_C
      integer(c_int),value :: batch_count
      !
      rocblas_csyrk_strided_batched_rank_1 = rocblas_csyrk_strided_batched_orig(handle,uplo,transA,n,k,alpha,c_loc(A),lda,stride_A,beta,c_loc(C),ldc,stride_C,batch_count)
    end function

    function rocblas_zsyrk_strided_batched_full_rank(handle,uplo,transA,n,k,alpha,A,lda,stride_A,beta,C,ldc,stride_C,batch_count)
      use iso_c_binding
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocblas_zsyrk_strided_batched_full_rank
      type(c_ptr),value :: handle
      integer(kind(rocblas_fill_upper)),value :: uplo
      integer(kind(rocblas_operation_none)),value :: transA
      integer(c_int),value :: n
      integer(c_int),value :: k
      complex(c_double_complex) :: alpha
      complex(c_double_complex),target,dimension(:,:) :: A
      integer(c_int),value :: lda
      integer(c_int64_t),value :: stride_A
      complex(c_double_complex) :: beta
      complex(c_double_complex),target,dimension(:,:) :: C
      integer(c_int),value :: ldc
      integer(c_int64_t),value :: stride_C
      integer(c_int),value :: batch_count
      !
      rocblas_zsyrk_strided_batched_full_rank = rocblas_zsyrk_strided_batched_orig(handle,uplo,transA,n,k,alpha,c_loc(A),lda,stride_A,beta,c_loc(C),ldc,stride_C,batch_count)
    end function

    function rocblas_zsyrk_strided_batched_rank_0(handle,uplo,transA,n,k,alpha,A,lda,stride_A,beta,C,ldc,stride_C,batch_count)
      use iso_c_binding
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocblas_zsyrk_strided_batched_rank_0
      type(c_ptr),value :: handle
      integer(kind(rocblas_fill_upper)),value :: uplo
      integer(kind(rocblas_operation_none)),value :: transA
      integer(c_int),value :: n
      integer(c_int),value :: k
      complex(c_double_complex) :: alpha
      complex(c_double_complex),target :: A
      integer(c_int),value :: lda
      integer(c_int64_t),value :: stride_A
      complex(c_double_complex) :: beta
      complex(c_double_complex),target :: C
      integer(c_int),value :: ldc
      integer(c_int64_t),value :: stride_C
      integer(c_int),value :: batch_count
      !
      rocblas_zsyrk_strided_batched_rank_0 = rocblas_zsyrk_strided_batched_orig(handle,uplo,transA,n,k,alpha,c_loc(A),lda,stride_A,beta,c_loc(C),ldc,stride_C,batch_count)
    end function

    function rocblas_zsyrk_strided_batched_rank_1(handle,uplo,transA,n,k,alpha,A,lda,stride_A,beta,C,ldc,stride_C,batch_count)
      use iso_c_binding
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocblas_zsyrk_strided_batched_rank_1
      type(c_ptr),value :: handle
      integer(kind(rocblas_fill_upper)),value :: uplo
      integer(kind(rocblas_operation_none)),value :: transA
      integer(c_int),value :: n
      integer(c_int),value :: k
      complex(c_double_complex) :: alpha
      complex(c_double_complex),target,dimension(:) :: A
      integer(c_int),value :: lda
      integer(c_int64_t),value :: stride_A
      complex(c_double_complex) :: beta
      complex(c_double_complex),target,dimension(:) :: C
      integer(c_int),value :: ldc
      integer(c_int64_t),value :: stride_C
      integer(c_int),value :: batch_count
      !
      rocblas_zsyrk_strided_batched_rank_1 = rocblas_zsyrk_strided_batched_orig(handle,uplo,transA,n,k,alpha,c_loc(A),lda,stride_A,beta,c_loc(C),ldc,stride_C,batch_count)
    end function

    function rocblas_ssyr2k_full_rank(handle,uplo,trans,n,k,alpha,A,lda,B,ldb,beta,C,ldc)
      use iso_c_binding
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocblas_ssyr2k_full_rank
      type(c_ptr),value :: handle
      integer(kind(rocblas_fill_upper)),value :: uplo
      integer(kind(rocblas_operation_none)),value :: trans
      integer(c_int),value :: n
      integer(c_int),value :: k
      real(c_float) :: alpha
      real(c_float),target,dimension(:,:) :: A
      integer(c_int),value :: lda
      real(c_float),target,dimension(:,:) :: B
      integer(c_int),value :: ldb
      real(c_float) :: beta
      real(c_float),target,dimension(:,:) :: C
      integer(c_int),value :: ldc
      !
      rocblas_ssyr2k_full_rank = rocblas_ssyr2k_orig(handle,uplo,trans,n,k,alpha,c_loc(A),lda,c_loc(B),ldb,beta,c_loc(C),ldc)
    end function

    function rocblas_ssyr2k_rank_0(handle,uplo,trans,n,k,alpha,A,lda,B,ldb,beta,C,ldc)
      use iso_c_binding
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocblas_ssyr2k_rank_0
      type(c_ptr),value :: handle
      integer(kind(rocblas_fill_upper)),value :: uplo
      integer(kind(rocblas_operation_none)),value :: trans
      integer(c_int),value :: n
      integer(c_int),value :: k
      real(c_float) :: alpha
      real(c_float),target :: A
      integer(c_int),value :: lda
      real(c_float),target :: B
      integer(c_int),value :: ldb
      real(c_float) :: beta
      real(c_float),target :: C
      integer(c_int),value :: ldc
      !
      rocblas_ssyr2k_rank_0 = rocblas_ssyr2k_orig(handle,uplo,trans,n,k,alpha,c_loc(A),lda,c_loc(B),ldb,beta,c_loc(C),ldc)
    end function

    function rocblas_ssyr2k_rank_1(handle,uplo,trans,n,k,alpha,A,lda,B,ldb,beta,C,ldc)
      use iso_c_binding
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocblas_ssyr2k_rank_1
      type(c_ptr),value :: handle
      integer(kind(rocblas_fill_upper)),value :: uplo
      integer(kind(rocblas_operation_none)),value :: trans
      integer(c_int),value :: n
      integer(c_int),value :: k
      real(c_float) :: alpha
      real(c_float),target,dimension(:) :: A
      integer(c_int),value :: lda
      real(c_float),target,dimension(:) :: B
      integer(c_int),value :: ldb
      real(c_float) :: beta
      real(c_float),target,dimension(:) :: C
      integer(c_int),value :: ldc
      !
      rocblas_ssyr2k_rank_1 = rocblas_ssyr2k_orig(handle,uplo,trans,n,k,alpha,c_loc(A),lda,c_loc(B),ldb,beta,c_loc(C),ldc)
    end function

    function rocblas_dsyr2k_full_rank(handle,uplo,trans,n,k,alpha,A,lda,B,ldb,beta,C,ldc)
      use iso_c_binding
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocblas_dsyr2k_full_rank
      type(c_ptr),value :: handle
      integer(kind(rocblas_fill_upper)),value :: uplo
      integer(kind(rocblas_operation_none)),value :: trans
      integer(c_int),value :: n
      integer(c_int),value :: k
      real(c_double) :: alpha
      real(c_double),target,dimension(:,:) :: A
      integer(c_int),value :: lda
      real(c_double),target,dimension(:,:) :: B
      integer(c_int),value :: ldb
      real(c_double) :: beta
      real(c_double),target,dimension(:,:) :: C
      integer(c_int),value :: ldc
      !
      rocblas_dsyr2k_full_rank = rocblas_dsyr2k_orig(handle,uplo,trans,n,k,alpha,c_loc(A),lda,c_loc(B),ldb,beta,c_loc(C),ldc)
    end function

    function rocblas_dsyr2k_rank_0(handle,uplo,trans,n,k,alpha,A,lda,B,ldb,beta,C,ldc)
      use iso_c_binding
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocblas_dsyr2k_rank_0
      type(c_ptr),value :: handle
      integer(kind(rocblas_fill_upper)),value :: uplo
      integer(kind(rocblas_operation_none)),value :: trans
      integer(c_int),value :: n
      integer(c_int),value :: k
      real(c_double) :: alpha
      real(c_double),target :: A
      integer(c_int),value :: lda
      real(c_double),target :: B
      integer(c_int),value :: ldb
      real(c_double) :: beta
      real(c_double),target :: C
      integer(c_int),value :: ldc
      !
      rocblas_dsyr2k_rank_0 = rocblas_dsyr2k_orig(handle,uplo,trans,n,k,alpha,c_loc(A),lda,c_loc(B),ldb,beta,c_loc(C),ldc)
    end function

    function rocblas_dsyr2k_rank_1(handle,uplo,trans,n,k,alpha,A,lda,B,ldb,beta,C,ldc)
      use iso_c_binding
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocblas_dsyr2k_rank_1
      type(c_ptr),value :: handle
      integer(kind(rocblas_fill_upper)),value :: uplo
      integer(kind(rocblas_operation_none)),value :: trans
      integer(c_int),value :: n
      integer(c_int),value :: k
      real(c_double) :: alpha
      real(c_double),target,dimension(:) :: A
      integer(c_int),value :: lda
      real(c_double),target,dimension(:) :: B
      integer(c_int),value :: ldb
      real(c_double) :: beta
      real(c_double),target,dimension(:) :: C
      integer(c_int),value :: ldc
      !
      rocblas_dsyr2k_rank_1 = rocblas_dsyr2k_orig(handle,uplo,trans,n,k,alpha,c_loc(A),lda,c_loc(B),ldb,beta,c_loc(C),ldc)
    end function

    function rocblas_csyr2k_full_rank(handle,uplo,trans,n,k,alpha,A,lda,B,ldb,beta,C,ldc)
      use iso_c_binding
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocblas_csyr2k_full_rank
      type(c_ptr),value :: handle
      integer(kind(rocblas_fill_upper)),value :: uplo
      integer(kind(rocblas_operation_none)),value :: trans
      integer(c_int),value :: n
      integer(c_int),value :: k
      complex(c_float_complex) :: alpha
      complex(c_float_complex),target,dimension(:,:) :: A
      integer(c_int),value :: lda
      complex(c_float_complex),target,dimension(:,:) :: B
      integer(c_int),value :: ldb
      complex(c_float_complex) :: beta
      complex(c_float_complex),target,dimension(:,:) :: C
      integer(c_int),value :: ldc
      !
      rocblas_csyr2k_full_rank = rocblas_csyr2k_orig(handle,uplo,trans,n,k,alpha,c_loc(A),lda,c_loc(B),ldb,beta,c_loc(C),ldc)
    end function

    function rocblas_csyr2k_rank_0(handle,uplo,trans,n,k,alpha,A,lda,B,ldb,beta,C,ldc)
      use iso_c_binding
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocblas_csyr2k_rank_0
      type(c_ptr),value :: handle
      integer(kind(rocblas_fill_upper)),value :: uplo
      integer(kind(rocblas_operation_none)),value :: trans
      integer(c_int),value :: n
      integer(c_int),value :: k
      complex(c_float_complex) :: alpha
      complex(c_float_complex),target :: A
      integer(c_int),value :: lda
      complex(c_float_complex),target :: B
      integer(c_int),value :: ldb
      complex(c_float_complex) :: beta
      complex(c_float_complex),target :: C
      integer(c_int),value :: ldc
      !
      rocblas_csyr2k_rank_0 = rocblas_csyr2k_orig(handle,uplo,trans,n,k,alpha,c_loc(A),lda,c_loc(B),ldb,beta,c_loc(C),ldc)
    end function

    function rocblas_csyr2k_rank_1(handle,uplo,trans,n,k,alpha,A,lda,B,ldb,beta,C,ldc)
      use iso_c_binding
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocblas_csyr2k_rank_1
      type(c_ptr),value :: handle
      integer(kind(rocblas_fill_upper)),value :: uplo
      integer(kind(rocblas_operation_none)),value :: trans
      integer(c_int),value :: n
      integer(c_int),value :: k
      complex(c_float_complex) :: alpha
      complex(c_float_complex),target,dimension(:) :: A
      integer(c_int),value :: lda
      complex(c_float_complex),target,dimension(:) :: B
      integer(c_int),value :: ldb
      complex(c_float_complex) :: beta
      complex(c_float_complex),target,dimension(:) :: C
      integer(c_int),value :: ldc
      !
      rocblas_csyr2k_rank_1 = rocblas_csyr2k_orig(handle,uplo,trans,n,k,alpha,c_loc(A),lda,c_loc(B),ldb,beta,c_loc(C),ldc)
    end function

    function rocblas_zsyr2k_full_rank(handle,uplo,trans,n,k,alpha,A,lda,B,ldb,beta,C,ldc)
      use iso_c_binding
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocblas_zsyr2k_full_rank
      type(c_ptr),value :: handle
      integer(kind(rocblas_fill_upper)),value :: uplo
      integer(kind(rocblas_operation_none)),value :: trans
      integer(c_int),value :: n
      integer(c_int),value :: k
      complex(c_double_complex) :: alpha
      complex(c_double_complex),target,dimension(:,:) :: A
      integer(c_int),value :: lda
      complex(c_double_complex),target,dimension(:,:) :: B
      integer(c_int),value :: ldb
      complex(c_double_complex) :: beta
      complex(c_double_complex),target,dimension(:,:) :: C
      integer(c_int),value :: ldc
      !
      rocblas_zsyr2k_full_rank = rocblas_zsyr2k_orig(handle,uplo,trans,n,k,alpha,c_loc(A),lda,c_loc(B),ldb,beta,c_loc(C),ldc)
    end function

    function rocblas_zsyr2k_rank_0(handle,uplo,trans,n,k,alpha,A,lda,B,ldb,beta,C,ldc)
      use iso_c_binding
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocblas_zsyr2k_rank_0
      type(c_ptr),value :: handle
      integer(kind(rocblas_fill_upper)),value :: uplo
      integer(kind(rocblas_operation_none)),value :: trans
      integer(c_int),value :: n
      integer(c_int),value :: k
      complex(c_double_complex) :: alpha
      complex(c_double_complex),target :: A
      integer(c_int),value :: lda
      complex(c_double_complex),target :: B
      integer(c_int),value :: ldb
      complex(c_double_complex) :: beta
      complex(c_double_complex),target :: C
      integer(c_int),value :: ldc
      !
      rocblas_zsyr2k_rank_0 = rocblas_zsyr2k_orig(handle,uplo,trans,n,k,alpha,c_loc(A),lda,c_loc(B),ldb,beta,c_loc(C),ldc)
    end function

    function rocblas_zsyr2k_rank_1(handle,uplo,trans,n,k,alpha,A,lda,B,ldb,beta,C,ldc)
      use iso_c_binding
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocblas_zsyr2k_rank_1
      type(c_ptr),value :: handle
      integer(kind(rocblas_fill_upper)),value :: uplo
      integer(kind(rocblas_operation_none)),value :: trans
      integer(c_int),value :: n
      integer(c_int),value :: k
      complex(c_double_complex) :: alpha
      complex(c_double_complex),target,dimension(:) :: A
      integer(c_int),value :: lda
      complex(c_double_complex),target,dimension(:) :: B
      integer(c_int),value :: ldb
      complex(c_double_complex) :: beta
      complex(c_double_complex),target,dimension(:) :: C
      integer(c_int),value :: ldc
      !
      rocblas_zsyr2k_rank_1 = rocblas_zsyr2k_orig(handle,uplo,trans,n,k,alpha,c_loc(A),lda,c_loc(B),ldb,beta,c_loc(C),ldc)
    end function

    function rocblas_ssyr2k_batched_full_rank(handle,uplo,trans,n,k,alpha,A,lda,B,ldb,beta,C,ldc,batch_count)
      use iso_c_binding
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocblas_ssyr2k_batched_full_rank
      type(c_ptr),value :: handle
      integer(kind(rocblas_fill_upper)),value :: uplo
      integer(kind(rocblas_operation_none)),value :: trans
      integer(c_int),value :: n
      integer(c_int),value :: k
      real(c_float) :: alpha
      real(c_float),target,dimension(:,:,:) :: A
      integer(c_int),value :: lda
      real(c_float),target,dimension(:,:,:) :: B
      integer(c_int),value :: ldb
      real(c_float) :: beta
      real(c_float),target,dimension(:,:,:) :: C
      integer(c_int),value :: ldc
      integer(c_int),value :: batch_count
      !
      rocblas_ssyr2k_batched_full_rank = rocblas_ssyr2k_batched_orig(handle,uplo,trans,n,k,alpha,c_loc(A),lda,c_loc(B),ldb,beta,c_loc(C),ldc,batch_count)
    end function

    function rocblas_ssyr2k_batched_rank_0(handle,uplo,trans,n,k,alpha,A,lda,B,ldb,beta,C,ldc,batch_count)
      use iso_c_binding
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocblas_ssyr2k_batched_rank_0
      type(c_ptr),value :: handle
      integer(kind(rocblas_fill_upper)),value :: uplo
      integer(kind(rocblas_operation_none)),value :: trans
      integer(c_int),value :: n
      integer(c_int),value :: k
      real(c_float) :: alpha
      real(c_float),target :: A
      integer(c_int),value :: lda
      real(c_float),target :: B
      integer(c_int),value :: ldb
      real(c_float) :: beta
      real(c_float),target :: C
      integer(c_int),value :: ldc
      integer(c_int),value :: batch_count
      !
      rocblas_ssyr2k_batched_rank_0 = rocblas_ssyr2k_batched_orig(handle,uplo,trans,n,k,alpha,c_loc(A),lda,c_loc(B),ldb,beta,c_loc(C),ldc,batch_count)
    end function

    function rocblas_ssyr2k_batched_rank_1(handle,uplo,trans,n,k,alpha,A,lda,B,ldb,beta,C,ldc,batch_count)
      use iso_c_binding
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocblas_ssyr2k_batched_rank_1
      type(c_ptr),value :: handle
      integer(kind(rocblas_fill_upper)),value :: uplo
      integer(kind(rocblas_operation_none)),value :: trans
      integer(c_int),value :: n
      integer(c_int),value :: k
      real(c_float) :: alpha
      real(c_float),target,dimension(:) :: A
      integer(c_int),value :: lda
      real(c_float),target,dimension(:) :: B
      integer(c_int),value :: ldb
      real(c_float) :: beta
      real(c_float),target,dimension(:) :: C
      integer(c_int),value :: ldc
      integer(c_int),value :: batch_count
      !
      rocblas_ssyr2k_batched_rank_1 = rocblas_ssyr2k_batched_orig(handle,uplo,trans,n,k,alpha,c_loc(A),lda,c_loc(B),ldb,beta,c_loc(C),ldc,batch_count)
    end function

    function rocblas_dsyr2k_batched_full_rank(handle,uplo,trans,n,k,alpha,A,lda,B,ldb,beta,C,ldc,batch_count)
      use iso_c_binding
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocblas_dsyr2k_batched_full_rank
      type(c_ptr),value :: handle
      integer(kind(rocblas_fill_upper)),value :: uplo
      integer(kind(rocblas_operation_none)),value :: trans
      integer(c_int),value :: n
      integer(c_int),value :: k
      real(c_double) :: alpha
      real(c_double),target,dimension(:,:,:) :: A
      integer(c_int),value :: lda
      real(c_double),target,dimension(:,:,:) :: B
      integer(c_int),value :: ldb
      real(c_double) :: beta
      real(c_double),target,dimension(:,:,:) :: C
      integer(c_int),value :: ldc
      integer(c_int),value :: batch_count
      !
      rocblas_dsyr2k_batched_full_rank = rocblas_dsyr2k_batched_orig(handle,uplo,trans,n,k,alpha,c_loc(A),lda,c_loc(B),ldb,beta,c_loc(C),ldc,batch_count)
    end function

    function rocblas_dsyr2k_batched_rank_0(handle,uplo,trans,n,k,alpha,A,lda,B,ldb,beta,C,ldc,batch_count)
      use iso_c_binding
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocblas_dsyr2k_batched_rank_0
      type(c_ptr),value :: handle
      integer(kind(rocblas_fill_upper)),value :: uplo
      integer(kind(rocblas_operation_none)),value :: trans
      integer(c_int),value :: n
      integer(c_int),value :: k
      real(c_double) :: alpha
      real(c_double),target :: A
      integer(c_int),value :: lda
      real(c_double),target :: B
      integer(c_int),value :: ldb
      real(c_double) :: beta
      real(c_double),target :: C
      integer(c_int),value :: ldc
      integer(c_int),value :: batch_count
      !
      rocblas_dsyr2k_batched_rank_0 = rocblas_dsyr2k_batched_orig(handle,uplo,trans,n,k,alpha,c_loc(A),lda,c_loc(B),ldb,beta,c_loc(C),ldc,batch_count)
    end function

    function rocblas_dsyr2k_batched_rank_1(handle,uplo,trans,n,k,alpha,A,lda,B,ldb,beta,C,ldc,batch_count)
      use iso_c_binding
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocblas_dsyr2k_batched_rank_1
      type(c_ptr),value :: handle
      integer(kind(rocblas_fill_upper)),value :: uplo
      integer(kind(rocblas_operation_none)),value :: trans
      integer(c_int),value :: n
      integer(c_int),value :: k
      real(c_double) :: alpha
      real(c_double),target,dimension(:) :: A
      integer(c_int),value :: lda
      real(c_double),target,dimension(:) :: B
      integer(c_int),value :: ldb
      real(c_double) :: beta
      real(c_double),target,dimension(:) :: C
      integer(c_int),value :: ldc
      integer(c_int),value :: batch_count
      !
      rocblas_dsyr2k_batched_rank_1 = rocblas_dsyr2k_batched_orig(handle,uplo,trans,n,k,alpha,c_loc(A),lda,c_loc(B),ldb,beta,c_loc(C),ldc,batch_count)
    end function

    function rocblas_csyr2k_batched_full_rank(handle,uplo,trans,n,k,alpha,A,lda,B,ldb,beta,C,ldc,batch_count)
      use iso_c_binding
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocblas_csyr2k_batched_full_rank
      type(c_ptr),value :: handle
      integer(kind(rocblas_fill_upper)),value :: uplo
      integer(kind(rocblas_operation_none)),value :: trans
      integer(c_int),value :: n
      integer(c_int),value :: k
      complex(c_float_complex) :: alpha
      complex(c_float_complex),target,dimension(:,:,:) :: A
      integer(c_int),value :: lda
      complex(c_float_complex),target,dimension(:,:,:) :: B
      integer(c_int),value :: ldb
      complex(c_float_complex) :: beta
      complex(c_float_complex),target,dimension(:,:,:) :: C
      integer(c_int),value :: ldc
      integer(c_int),value :: batch_count
      !
      rocblas_csyr2k_batched_full_rank = rocblas_csyr2k_batched_orig(handle,uplo,trans,n,k,alpha,c_loc(A),lda,c_loc(B),ldb,beta,c_loc(C),ldc,batch_count)
    end function

    function rocblas_csyr2k_batched_rank_0(handle,uplo,trans,n,k,alpha,A,lda,B,ldb,beta,C,ldc,batch_count)
      use iso_c_binding
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocblas_csyr2k_batched_rank_0
      type(c_ptr),value :: handle
      integer(kind(rocblas_fill_upper)),value :: uplo
      integer(kind(rocblas_operation_none)),value :: trans
      integer(c_int),value :: n
      integer(c_int),value :: k
      complex(c_float_complex) :: alpha
      complex(c_float_complex),target :: A
      integer(c_int),value :: lda
      complex(c_float_complex),target :: B
      integer(c_int),value :: ldb
      complex(c_float_complex) :: beta
      complex(c_float_complex),target :: C
      integer(c_int),value :: ldc
      integer(c_int),value :: batch_count
      !
      rocblas_csyr2k_batched_rank_0 = rocblas_csyr2k_batched_orig(handle,uplo,trans,n,k,alpha,c_loc(A),lda,c_loc(B),ldb,beta,c_loc(C),ldc,batch_count)
    end function

    function rocblas_csyr2k_batched_rank_1(handle,uplo,trans,n,k,alpha,A,lda,B,ldb,beta,C,ldc,batch_count)
      use iso_c_binding
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocblas_csyr2k_batched_rank_1
      type(c_ptr),value :: handle
      integer(kind(rocblas_fill_upper)),value :: uplo
      integer(kind(rocblas_operation_none)),value :: trans
      integer(c_int),value :: n
      integer(c_int),value :: k
      complex(c_float_complex) :: alpha
      complex(c_float_complex),target,dimension(:) :: A
      integer(c_int),value :: lda
      complex(c_float_complex),target,dimension(:) :: B
      integer(c_int),value :: ldb
      complex(c_float_complex) :: beta
      complex(c_float_complex),target,dimension(:) :: C
      integer(c_int),value :: ldc
      integer(c_int),value :: batch_count
      !
      rocblas_csyr2k_batched_rank_1 = rocblas_csyr2k_batched_orig(handle,uplo,trans,n,k,alpha,c_loc(A),lda,c_loc(B),ldb,beta,c_loc(C),ldc,batch_count)
    end function

    function rocblas_zsyr2k_batched_full_rank(handle,uplo,trans,n,k,alpha,A,lda,B,ldb,beta,C,ldc,batch_count)
      use iso_c_binding
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocblas_zsyr2k_batched_full_rank
      type(c_ptr),value :: handle
      integer(kind(rocblas_fill_upper)),value :: uplo
      integer(kind(rocblas_operation_none)),value :: trans
      integer(c_int),value :: n
      integer(c_int),value :: k
      complex(c_double_complex) :: alpha
      complex(c_double_complex),target,dimension(:,:,:) :: A
      integer(c_int),value :: lda
      complex(c_double_complex),target,dimension(:,:,:) :: B
      integer(c_int),value :: ldb
      complex(c_double_complex) :: beta
      complex(c_double_complex),target,dimension(:,:,:) :: C
      integer(c_int),value :: ldc
      integer(c_int),value :: batch_count
      !
      rocblas_zsyr2k_batched_full_rank = rocblas_zsyr2k_batched_orig(handle,uplo,trans,n,k,alpha,c_loc(A),lda,c_loc(B),ldb,beta,c_loc(C),ldc,batch_count)
    end function

    function rocblas_zsyr2k_batched_rank_0(handle,uplo,trans,n,k,alpha,A,lda,B,ldb,beta,C,ldc,batch_count)
      use iso_c_binding
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocblas_zsyr2k_batched_rank_0
      type(c_ptr),value :: handle
      integer(kind(rocblas_fill_upper)),value :: uplo
      integer(kind(rocblas_operation_none)),value :: trans
      integer(c_int),value :: n
      integer(c_int),value :: k
      complex(c_double_complex) :: alpha
      complex(c_double_complex),target :: A
      integer(c_int),value :: lda
      complex(c_double_complex),target :: B
      integer(c_int),value :: ldb
      complex(c_double_complex) :: beta
      complex(c_double_complex),target :: C
      integer(c_int),value :: ldc
      integer(c_int),value :: batch_count
      !
      rocblas_zsyr2k_batched_rank_0 = rocblas_zsyr2k_batched_orig(handle,uplo,trans,n,k,alpha,c_loc(A),lda,c_loc(B),ldb,beta,c_loc(C),ldc,batch_count)
    end function

    function rocblas_zsyr2k_batched_rank_1(handle,uplo,trans,n,k,alpha,A,lda,B,ldb,beta,C,ldc,batch_count)
      use iso_c_binding
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocblas_zsyr2k_batched_rank_1
      type(c_ptr),value :: handle
      integer(kind(rocblas_fill_upper)),value :: uplo
      integer(kind(rocblas_operation_none)),value :: trans
      integer(c_int),value :: n
      integer(c_int),value :: k
      complex(c_double_complex) :: alpha
      complex(c_double_complex),target,dimension(:) :: A
      integer(c_int),value :: lda
      complex(c_double_complex),target,dimension(:) :: B
      integer(c_int),value :: ldb
      complex(c_double_complex) :: beta
      complex(c_double_complex),target,dimension(:) :: C
      integer(c_int),value :: ldc
      integer(c_int),value :: batch_count
      !
      rocblas_zsyr2k_batched_rank_1 = rocblas_zsyr2k_batched_orig(handle,uplo,trans,n,k,alpha,c_loc(A),lda,c_loc(B),ldb,beta,c_loc(C),ldc,batch_count)
    end function

    function rocblas_ssyr2k_strided_batched_full_rank(handle,uplo,trans,n,k,alpha,A,lda,stride_A,B,ldb,stride_B,beta,C,ldc,stride_C,batch_count)
      use iso_c_binding
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocblas_ssyr2k_strided_batched_full_rank
      type(c_ptr),value :: handle
      integer(kind(rocblas_fill_upper)),value :: uplo
      integer(kind(rocblas_operation_none)),value :: trans
      integer(c_int),value :: n
      integer(c_int),value :: k
      real(c_float) :: alpha
      real(c_float),target,dimension(:,:) :: A
      integer(c_int),value :: lda
      integer(c_int64_t),value :: stride_A
      real(c_float),target,dimension(:,:) :: B
      integer(c_int),value :: ldb
      integer(c_int64_t),value :: stride_B
      real(c_float) :: beta
      real(c_float),target,dimension(:,:) :: C
      integer(c_int),value :: ldc
      integer(c_int64_t),value :: stride_C
      integer(c_int),value :: batch_count
      !
      rocblas_ssyr2k_strided_batched_full_rank = rocblas_ssyr2k_strided_batched_orig(handle,uplo,trans,n,k,alpha,c_loc(A),lda,stride_A,c_loc(B),ldb,stride_B,beta,c_loc(C),ldc,stride_C,batch_count)
    end function

    function rocblas_ssyr2k_strided_batched_rank_0(handle,uplo,trans,n,k,alpha,A,lda,stride_A,B,ldb,stride_B,beta,C,ldc,stride_C,batch_count)
      use iso_c_binding
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocblas_ssyr2k_strided_batched_rank_0
      type(c_ptr),value :: handle
      integer(kind(rocblas_fill_upper)),value :: uplo
      integer(kind(rocblas_operation_none)),value :: trans
      integer(c_int),value :: n
      integer(c_int),value :: k
      real(c_float) :: alpha
      real(c_float),target :: A
      integer(c_int),value :: lda
      integer(c_int64_t),value :: stride_A
      real(c_float),target :: B
      integer(c_int),value :: ldb
      integer(c_int64_t),value :: stride_B
      real(c_float) :: beta
      real(c_float),target :: C
      integer(c_int),value :: ldc
      integer(c_int64_t),value :: stride_C
      integer(c_int),value :: batch_count
      !
      rocblas_ssyr2k_strided_batched_rank_0 = rocblas_ssyr2k_strided_batched_orig(handle,uplo,trans,n,k,alpha,c_loc(A),lda,stride_A,c_loc(B),ldb,stride_B,beta,c_loc(C),ldc,stride_C,batch_count)
    end function

    function rocblas_ssyr2k_strided_batched_rank_1(handle,uplo,trans,n,k,alpha,A,lda,stride_A,B,ldb,stride_B,beta,C,ldc,stride_C,batch_count)
      use iso_c_binding
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocblas_ssyr2k_strided_batched_rank_1
      type(c_ptr),value :: handle
      integer(kind(rocblas_fill_upper)),value :: uplo
      integer(kind(rocblas_operation_none)),value :: trans
      integer(c_int),value :: n
      integer(c_int),value :: k
      real(c_float) :: alpha
      real(c_float),target,dimension(:) :: A
      integer(c_int),value :: lda
      integer(c_int64_t),value :: stride_A
      real(c_float),target,dimension(:) :: B
      integer(c_int),value :: ldb
      integer(c_int64_t),value :: stride_B
      real(c_float) :: beta
      real(c_float),target,dimension(:) :: C
      integer(c_int),value :: ldc
      integer(c_int64_t),value :: stride_C
      integer(c_int),value :: batch_count
      !
      rocblas_ssyr2k_strided_batched_rank_1 = rocblas_ssyr2k_strided_batched_orig(handle,uplo,trans,n,k,alpha,c_loc(A),lda,stride_A,c_loc(B),ldb,stride_B,beta,c_loc(C),ldc,stride_C,batch_count)
    end function

    function rocblas_dsyr2k_strided_batched_full_rank(handle,uplo,trans,n,k,alpha,A,lda,stride_A,B,ldb,stride_B,beta,C,ldc,stride_C,batch_count)
      use iso_c_binding
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocblas_dsyr2k_strided_batched_full_rank
      type(c_ptr),value :: handle
      integer(kind(rocblas_fill_upper)),value :: uplo
      integer(kind(rocblas_operation_none)),value :: trans
      integer(c_int),value :: n
      integer(c_int),value :: k
      real(c_double) :: alpha
      real(c_double),target,dimension(:,:) :: A
      integer(c_int),value :: lda
      integer(c_int64_t),value :: stride_A
      real(c_double),target,dimension(:,:) :: B
      integer(c_int),value :: ldb
      integer(c_int64_t),value :: stride_B
      real(c_double) :: beta
      real(c_double),target,dimension(:,:) :: C
      integer(c_int),value :: ldc
      integer(c_int64_t),value :: stride_C
      integer(c_int),value :: batch_count
      !
      rocblas_dsyr2k_strided_batched_full_rank = rocblas_dsyr2k_strided_batched_orig(handle,uplo,trans,n,k,alpha,c_loc(A),lda,stride_A,c_loc(B),ldb,stride_B,beta,c_loc(C),ldc,stride_C,batch_count)
    end function

    function rocblas_dsyr2k_strided_batched_rank_0(handle,uplo,trans,n,k,alpha,A,lda,stride_A,B,ldb,stride_B,beta,C,ldc,stride_C,batch_count)
      use iso_c_binding
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocblas_dsyr2k_strided_batched_rank_0
      type(c_ptr),value :: handle
      integer(kind(rocblas_fill_upper)),value :: uplo
      integer(kind(rocblas_operation_none)),value :: trans
      integer(c_int),value :: n
      integer(c_int),value :: k
      real(c_double) :: alpha
      real(c_double),target :: A
      integer(c_int),value :: lda
      integer(c_int64_t),value :: stride_A
      real(c_double),target :: B
      integer(c_int),value :: ldb
      integer(c_int64_t),value :: stride_B
      real(c_double) :: beta
      real(c_double),target :: C
      integer(c_int),value :: ldc
      integer(c_int64_t),value :: stride_C
      integer(c_int),value :: batch_count
      !
      rocblas_dsyr2k_strided_batched_rank_0 = rocblas_dsyr2k_strided_batched_orig(handle,uplo,trans,n,k,alpha,c_loc(A),lda,stride_A,c_loc(B),ldb,stride_B,beta,c_loc(C),ldc,stride_C,batch_count)
    end function

    function rocblas_dsyr2k_strided_batched_rank_1(handle,uplo,trans,n,k,alpha,A,lda,stride_A,B,ldb,stride_B,beta,C,ldc,stride_C,batch_count)
      use iso_c_binding
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocblas_dsyr2k_strided_batched_rank_1
      type(c_ptr),value :: handle
      integer(kind(rocblas_fill_upper)),value :: uplo
      integer(kind(rocblas_operation_none)),value :: trans
      integer(c_int),value :: n
      integer(c_int),value :: k
      real(c_double) :: alpha
      real(c_double),target,dimension(:) :: A
      integer(c_int),value :: lda
      integer(c_int64_t),value :: stride_A
      real(c_double),target,dimension(:) :: B
      integer(c_int),value :: ldb
      integer(c_int64_t),value :: stride_B
      real(c_double) :: beta
      real(c_double),target,dimension(:) :: C
      integer(c_int),value :: ldc
      integer(c_int64_t),value :: stride_C
      integer(c_int),value :: batch_count
      !
      rocblas_dsyr2k_strided_batched_rank_1 = rocblas_dsyr2k_strided_batched_orig(handle,uplo,trans,n,k,alpha,c_loc(A),lda,stride_A,c_loc(B),ldb,stride_B,beta,c_loc(C),ldc,stride_C,batch_count)
    end function

    function rocblas_csyr2k_strided_batched_full_rank(handle,uplo,trans,n,k,alpha,A,lda,stride_A,B,ldb,stride_B,beta,C,ldc,stride_C,batch_count)
      use iso_c_binding
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocblas_csyr2k_strided_batched_full_rank
      type(c_ptr),value :: handle
      integer(kind(rocblas_fill_upper)),value :: uplo
      integer(kind(rocblas_operation_none)),value :: trans
      integer(c_int),value :: n
      integer(c_int),value :: k
      complex(c_float_complex) :: alpha
      complex(c_float_complex),target,dimension(:,:) :: A
      integer(c_int),value :: lda
      integer(c_int64_t),value :: stride_A
      complex(c_float_complex),target,dimension(:,:) :: B
      integer(c_int),value :: ldb
      integer(c_int64_t),value :: stride_B
      complex(c_float_complex) :: beta
      complex(c_float_complex),target,dimension(:,:) :: C
      integer(c_int),value :: ldc
      integer(c_int64_t),value :: stride_C
      integer(c_int),value :: batch_count
      !
      rocblas_csyr2k_strided_batched_full_rank = rocblas_csyr2k_strided_batched_orig(handle,uplo,trans,n,k,alpha,c_loc(A),lda,stride_A,c_loc(B),ldb,stride_B,beta,c_loc(C),ldc,stride_C,batch_count)
    end function

    function rocblas_csyr2k_strided_batched_rank_0(handle,uplo,trans,n,k,alpha,A,lda,stride_A,B,ldb,stride_B,beta,C,ldc,stride_C,batch_count)
      use iso_c_binding
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocblas_csyr2k_strided_batched_rank_0
      type(c_ptr),value :: handle
      integer(kind(rocblas_fill_upper)),value :: uplo
      integer(kind(rocblas_operation_none)),value :: trans
      integer(c_int),value :: n
      integer(c_int),value :: k
      complex(c_float_complex) :: alpha
      complex(c_float_complex),target :: A
      integer(c_int),value :: lda
      integer(c_int64_t),value :: stride_A
      complex(c_float_complex),target :: B
      integer(c_int),value :: ldb
      integer(c_int64_t),value :: stride_B
      complex(c_float_complex) :: beta
      complex(c_float_complex),target :: C
      integer(c_int),value :: ldc
      integer(c_int64_t),value :: stride_C
      integer(c_int),value :: batch_count
      !
      rocblas_csyr2k_strided_batched_rank_0 = rocblas_csyr2k_strided_batched_orig(handle,uplo,trans,n,k,alpha,c_loc(A),lda,stride_A,c_loc(B),ldb,stride_B,beta,c_loc(C),ldc,stride_C,batch_count)
    end function

    function rocblas_csyr2k_strided_batched_rank_1(handle,uplo,trans,n,k,alpha,A,lda,stride_A,B,ldb,stride_B,beta,C,ldc,stride_C,batch_count)
      use iso_c_binding
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocblas_csyr2k_strided_batched_rank_1
      type(c_ptr),value :: handle
      integer(kind(rocblas_fill_upper)),value :: uplo
      integer(kind(rocblas_operation_none)),value :: trans
      integer(c_int),value :: n
      integer(c_int),value :: k
      complex(c_float_complex) :: alpha
      complex(c_float_complex),target,dimension(:) :: A
      integer(c_int),value :: lda
      integer(c_int64_t),value :: stride_A
      complex(c_float_complex),target,dimension(:) :: B
      integer(c_int),value :: ldb
      integer(c_int64_t),value :: stride_B
      complex(c_float_complex) :: beta
      complex(c_float_complex),target,dimension(:) :: C
      integer(c_int),value :: ldc
      integer(c_int64_t),value :: stride_C
      integer(c_int),value :: batch_count
      !
      rocblas_csyr2k_strided_batched_rank_1 = rocblas_csyr2k_strided_batched_orig(handle,uplo,trans,n,k,alpha,c_loc(A),lda,stride_A,c_loc(B),ldb,stride_B,beta,c_loc(C),ldc,stride_C,batch_count)
    end function

    function rocblas_zsyr2k_strided_batched_full_rank(handle,uplo,trans,n,k,alpha,A,lda,stride_A,B,ldb,stride_B,beta,C,ldc,stride_C,batch_count)
      use iso_c_binding
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocblas_zsyr2k_strided_batched_full_rank
      type(c_ptr),value :: handle
      integer(kind(rocblas_fill_upper)),value :: uplo
      integer(kind(rocblas_operation_none)),value :: trans
      integer(c_int),value :: n
      integer(c_int),value :: k
      complex(c_double_complex) :: alpha
      complex(c_double_complex),target,dimension(:,:) :: A
      integer(c_int),value :: lda
      integer(c_int64_t),value :: stride_A
      complex(c_double_complex),target,dimension(:,:) :: B
      integer(c_int),value :: ldb
      integer(c_int64_t),value :: stride_B
      complex(c_double_complex) :: beta
      complex(c_double_complex),target,dimension(:,:) :: C
      integer(c_int),value :: ldc
      integer(c_int64_t),value :: stride_C
      integer(c_int),value :: batch_count
      !
      rocblas_zsyr2k_strided_batched_full_rank = rocblas_zsyr2k_strided_batched_orig(handle,uplo,trans,n,k,alpha,c_loc(A),lda,stride_A,c_loc(B),ldb,stride_B,beta,c_loc(C),ldc,stride_C,batch_count)
    end function

    function rocblas_zsyr2k_strided_batched_rank_0(handle,uplo,trans,n,k,alpha,A,lda,stride_A,B,ldb,stride_B,beta,C,ldc,stride_C,batch_count)
      use iso_c_binding
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocblas_zsyr2k_strided_batched_rank_0
      type(c_ptr),value :: handle
      integer(kind(rocblas_fill_upper)),value :: uplo
      integer(kind(rocblas_operation_none)),value :: trans
      integer(c_int),value :: n
      integer(c_int),value :: k
      complex(c_double_complex) :: alpha
      complex(c_double_complex),target :: A
      integer(c_int),value :: lda
      integer(c_int64_t),value :: stride_A
      complex(c_double_complex),target :: B
      integer(c_int),value :: ldb
      integer(c_int64_t),value :: stride_B
      complex(c_double_complex) :: beta
      complex(c_double_complex),target :: C
      integer(c_int),value :: ldc
      integer(c_int64_t),value :: stride_C
      integer(c_int),value :: batch_count
      !
      rocblas_zsyr2k_strided_batched_rank_0 = rocblas_zsyr2k_strided_batched_orig(handle,uplo,trans,n,k,alpha,c_loc(A),lda,stride_A,c_loc(B),ldb,stride_B,beta,c_loc(C),ldc,stride_C,batch_count)
    end function

    function rocblas_zsyr2k_strided_batched_rank_1(handle,uplo,trans,n,k,alpha,A,lda,stride_A,B,ldb,stride_B,beta,C,ldc,stride_C,batch_count)
      use iso_c_binding
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocblas_zsyr2k_strided_batched_rank_1
      type(c_ptr),value :: handle
      integer(kind(rocblas_fill_upper)),value :: uplo
      integer(kind(rocblas_operation_none)),value :: trans
      integer(c_int),value :: n
      integer(c_int),value :: k
      complex(c_double_complex) :: alpha
      complex(c_double_complex),target,dimension(:) :: A
      integer(c_int),value :: lda
      integer(c_int64_t),value :: stride_A
      complex(c_double_complex),target,dimension(:) :: B
      integer(c_int),value :: ldb
      integer(c_int64_t),value :: stride_B
      complex(c_double_complex) :: beta
      complex(c_double_complex),target,dimension(:) :: C
      integer(c_int),value :: ldc
      integer(c_int64_t),value :: stride_C
      integer(c_int),value :: batch_count
      !
      rocblas_zsyr2k_strided_batched_rank_1 = rocblas_zsyr2k_strided_batched_orig(handle,uplo,trans,n,k,alpha,c_loc(A),lda,stride_A,c_loc(B),ldb,stride_B,beta,c_loc(C),ldc,stride_C,batch_count)
    end function

    function rocblas_ssyrkx_full_rank(handle,uplo,trans,n,k,alpha,A,lda,B,ldb,beta,C,ldc)
      use iso_c_binding
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocblas_ssyrkx_full_rank
      type(c_ptr),value :: handle
      integer(kind(rocblas_fill_upper)),value :: uplo
      integer(kind(rocblas_operation_none)),value :: trans
      integer(c_int),value :: n
      integer(c_int),value :: k
      real(c_float) :: alpha
      real(c_float),target,dimension(:,:) :: A
      integer(c_int),value :: lda
      real(c_float),target,dimension(:,:) :: B
      integer(c_int),value :: ldb
      real(c_float) :: beta
      real(c_float),target,dimension(:,:) :: C
      integer(c_int),value :: ldc
      !
      rocblas_ssyrkx_full_rank = rocblas_ssyrkx_orig(handle,uplo,trans,n,k,alpha,c_loc(A),lda,c_loc(B),ldb,beta,c_loc(C),ldc)
    end function

    function rocblas_ssyrkx_rank_0(handle,uplo,trans,n,k,alpha,A,lda,B,ldb,beta,C,ldc)
      use iso_c_binding
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocblas_ssyrkx_rank_0
      type(c_ptr),value :: handle
      integer(kind(rocblas_fill_upper)),value :: uplo
      integer(kind(rocblas_operation_none)),value :: trans
      integer(c_int),value :: n
      integer(c_int),value :: k
      real(c_float) :: alpha
      real(c_float),target :: A
      integer(c_int),value :: lda
      real(c_float),target :: B
      integer(c_int),value :: ldb
      real(c_float) :: beta
      real(c_float),target :: C
      integer(c_int),value :: ldc
      !
      rocblas_ssyrkx_rank_0 = rocblas_ssyrkx_orig(handle,uplo,trans,n,k,alpha,c_loc(A),lda,c_loc(B),ldb,beta,c_loc(C),ldc)
    end function

    function rocblas_ssyrkx_rank_1(handle,uplo,trans,n,k,alpha,A,lda,B,ldb,beta,C,ldc)
      use iso_c_binding
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocblas_ssyrkx_rank_1
      type(c_ptr),value :: handle
      integer(kind(rocblas_fill_upper)),value :: uplo
      integer(kind(rocblas_operation_none)),value :: trans
      integer(c_int),value :: n
      integer(c_int),value :: k
      real(c_float) :: alpha
      real(c_float),target,dimension(:) :: A
      integer(c_int),value :: lda
      real(c_float),target,dimension(:) :: B
      integer(c_int),value :: ldb
      real(c_float) :: beta
      real(c_float),target,dimension(:) :: C
      integer(c_int),value :: ldc
      !
      rocblas_ssyrkx_rank_1 = rocblas_ssyrkx_orig(handle,uplo,trans,n,k,alpha,c_loc(A),lda,c_loc(B),ldb,beta,c_loc(C),ldc)
    end function

    function rocblas_dsyrkx_full_rank(handle,uplo,trans,n,k,alpha,A,lda,B,ldb,beta,C,ldc)
      use iso_c_binding
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocblas_dsyrkx_full_rank
      type(c_ptr),value :: handle
      integer(kind(rocblas_fill_upper)),value :: uplo
      integer(kind(rocblas_operation_none)),value :: trans
      integer(c_int),value :: n
      integer(c_int),value :: k
      real(c_double) :: alpha
      real(c_double),target,dimension(:,:) :: A
      integer(c_int),value :: lda
      real(c_double),target,dimension(:,:) :: B
      integer(c_int),value :: ldb
      real(c_double) :: beta
      real(c_double),target,dimension(:,:) :: C
      integer(c_int),value :: ldc
      !
      rocblas_dsyrkx_full_rank = rocblas_dsyrkx_orig(handle,uplo,trans,n,k,alpha,c_loc(A),lda,c_loc(B),ldb,beta,c_loc(C),ldc)
    end function

    function rocblas_dsyrkx_rank_0(handle,uplo,trans,n,k,alpha,A,lda,B,ldb,beta,C,ldc)
      use iso_c_binding
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocblas_dsyrkx_rank_0
      type(c_ptr),value :: handle
      integer(kind(rocblas_fill_upper)),value :: uplo
      integer(kind(rocblas_operation_none)),value :: trans
      integer(c_int),value :: n
      integer(c_int),value :: k
      real(c_double) :: alpha
      real(c_double),target :: A
      integer(c_int),value :: lda
      real(c_double),target :: B
      integer(c_int),value :: ldb
      real(c_double) :: beta
      real(c_double),target :: C
      integer(c_int),value :: ldc
      !
      rocblas_dsyrkx_rank_0 = rocblas_dsyrkx_orig(handle,uplo,trans,n,k,alpha,c_loc(A),lda,c_loc(B),ldb,beta,c_loc(C),ldc)
    end function

    function rocblas_dsyrkx_rank_1(handle,uplo,trans,n,k,alpha,A,lda,B,ldb,beta,C,ldc)
      use iso_c_binding
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocblas_dsyrkx_rank_1
      type(c_ptr),value :: handle
      integer(kind(rocblas_fill_upper)),value :: uplo
      integer(kind(rocblas_operation_none)),value :: trans
      integer(c_int),value :: n
      integer(c_int),value :: k
      real(c_double) :: alpha
      real(c_double),target,dimension(:) :: A
      integer(c_int),value :: lda
      real(c_double),target,dimension(:) :: B
      integer(c_int),value :: ldb
      real(c_double) :: beta
      real(c_double),target,dimension(:) :: C
      integer(c_int),value :: ldc
      !
      rocblas_dsyrkx_rank_1 = rocblas_dsyrkx_orig(handle,uplo,trans,n,k,alpha,c_loc(A),lda,c_loc(B),ldb,beta,c_loc(C),ldc)
    end function

    function rocblas_csyrkx_full_rank(handle,uplo,trans,n,k,alpha,A,lda,B,ldb,beta,C,ldc)
      use iso_c_binding
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocblas_csyrkx_full_rank
      type(c_ptr),value :: handle
      integer(kind(rocblas_fill_upper)),value :: uplo
      integer(kind(rocblas_operation_none)),value :: trans
      integer(c_int),value :: n
      integer(c_int),value :: k
      complex(c_float_complex) :: alpha
      complex(c_float_complex),target,dimension(:,:) :: A
      integer(c_int),value :: lda
      complex(c_float_complex),target,dimension(:,:) :: B
      integer(c_int),value :: ldb
      complex(c_float_complex) :: beta
      complex(c_float_complex),target,dimension(:,:) :: C
      integer(c_int),value :: ldc
      !
      rocblas_csyrkx_full_rank = rocblas_csyrkx_orig(handle,uplo,trans,n,k,alpha,c_loc(A),lda,c_loc(B),ldb,beta,c_loc(C),ldc)
    end function

    function rocblas_csyrkx_rank_0(handle,uplo,trans,n,k,alpha,A,lda,B,ldb,beta,C,ldc)
      use iso_c_binding
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocblas_csyrkx_rank_0
      type(c_ptr),value :: handle
      integer(kind(rocblas_fill_upper)),value :: uplo
      integer(kind(rocblas_operation_none)),value :: trans
      integer(c_int),value :: n
      integer(c_int),value :: k
      complex(c_float_complex) :: alpha
      complex(c_float_complex),target :: A
      integer(c_int),value :: lda
      complex(c_float_complex),target :: B
      integer(c_int),value :: ldb
      complex(c_float_complex) :: beta
      complex(c_float_complex),target :: C
      integer(c_int),value :: ldc
      !
      rocblas_csyrkx_rank_0 = rocblas_csyrkx_orig(handle,uplo,trans,n,k,alpha,c_loc(A),lda,c_loc(B),ldb,beta,c_loc(C),ldc)
    end function

    function rocblas_csyrkx_rank_1(handle,uplo,trans,n,k,alpha,A,lda,B,ldb,beta,C,ldc)
      use iso_c_binding
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocblas_csyrkx_rank_1
      type(c_ptr),value :: handle
      integer(kind(rocblas_fill_upper)),value :: uplo
      integer(kind(rocblas_operation_none)),value :: trans
      integer(c_int),value :: n
      integer(c_int),value :: k
      complex(c_float_complex) :: alpha
      complex(c_float_complex),target,dimension(:) :: A
      integer(c_int),value :: lda
      complex(c_float_complex),target,dimension(:) :: B
      integer(c_int),value :: ldb
      complex(c_float_complex) :: beta
      complex(c_float_complex),target,dimension(:) :: C
      integer(c_int),value :: ldc
      !
      rocblas_csyrkx_rank_1 = rocblas_csyrkx_orig(handle,uplo,trans,n,k,alpha,c_loc(A),lda,c_loc(B),ldb,beta,c_loc(C),ldc)
    end function

    function rocblas_zsyrkx_full_rank(handle,uplo,trans,n,k,alpha,A,lda,B,ldb,beta,C,ldc)
      use iso_c_binding
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocblas_zsyrkx_full_rank
      type(c_ptr),value :: handle
      integer(kind(rocblas_fill_upper)),value :: uplo
      integer(kind(rocblas_operation_none)),value :: trans
      integer(c_int),value :: n
      integer(c_int),value :: k
      complex(c_double_complex) :: alpha
      complex(c_double_complex),target,dimension(:,:) :: A
      integer(c_int),value :: lda
      complex(c_double_complex),target,dimension(:,:) :: B
      integer(c_int),value :: ldb
      complex(c_double_complex) :: beta
      complex(c_double_complex),target,dimension(:,:) :: C
      integer(c_int),value :: ldc
      !
      rocblas_zsyrkx_full_rank = rocblas_zsyrkx_orig(handle,uplo,trans,n,k,alpha,c_loc(A),lda,c_loc(B),ldb,beta,c_loc(C),ldc)
    end function

    function rocblas_zsyrkx_rank_0(handle,uplo,trans,n,k,alpha,A,lda,B,ldb,beta,C,ldc)
      use iso_c_binding
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocblas_zsyrkx_rank_0
      type(c_ptr),value :: handle
      integer(kind(rocblas_fill_upper)),value :: uplo
      integer(kind(rocblas_operation_none)),value :: trans
      integer(c_int),value :: n
      integer(c_int),value :: k
      complex(c_double_complex) :: alpha
      complex(c_double_complex),target :: A
      integer(c_int),value :: lda
      complex(c_double_complex),target :: B
      integer(c_int),value :: ldb
      complex(c_double_complex) :: beta
      complex(c_double_complex),target :: C
      integer(c_int),value :: ldc
      !
      rocblas_zsyrkx_rank_0 = rocblas_zsyrkx_orig(handle,uplo,trans,n,k,alpha,c_loc(A),lda,c_loc(B),ldb,beta,c_loc(C),ldc)
    end function

    function rocblas_zsyrkx_rank_1(handle,uplo,trans,n,k,alpha,A,lda,B,ldb,beta,C,ldc)
      use iso_c_binding
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocblas_zsyrkx_rank_1
      type(c_ptr),value :: handle
      integer(kind(rocblas_fill_upper)),value :: uplo
      integer(kind(rocblas_operation_none)),value :: trans
      integer(c_int),value :: n
      integer(c_int),value :: k
      complex(c_double_complex) :: alpha
      complex(c_double_complex),target,dimension(:) :: A
      integer(c_int),value :: lda
      complex(c_double_complex),target,dimension(:) :: B
      integer(c_int),value :: ldb
      complex(c_double_complex) :: beta
      complex(c_double_complex),target,dimension(:) :: C
      integer(c_int),value :: ldc
      !
      rocblas_zsyrkx_rank_1 = rocblas_zsyrkx_orig(handle,uplo,trans,n,k,alpha,c_loc(A),lda,c_loc(B),ldb,beta,c_loc(C),ldc)
    end function

    function rocblas_ssyrkx_batched_full_rank(handle,uplo,trans,n,k,alpha,A,lda,B,ldb,beta,C,ldc,batch_count)
      use iso_c_binding
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocblas_ssyrkx_batched_full_rank
      type(c_ptr),value :: handle
      integer(kind(rocblas_fill_upper)),value :: uplo
      integer(kind(rocblas_operation_none)),value :: trans
      integer(c_int),value :: n
      integer(c_int),value :: k
      real(c_float) :: alpha
      real(c_float),target,dimension(:,:,:) :: A
      integer(c_int),value :: lda
      real(c_float),target,dimension(:,:,:) :: B
      integer(c_int),value :: ldb
      real(c_float) :: beta
      real(c_float),target,dimension(:,:,:) :: C
      integer(c_int),value :: ldc
      integer(c_int),value :: batch_count
      !
      rocblas_ssyrkx_batched_full_rank = rocblas_ssyrkx_batched_orig(handle,uplo,trans,n,k,alpha,c_loc(A),lda,c_loc(B),ldb,beta,c_loc(C),ldc,batch_count)
    end function

    function rocblas_ssyrkx_batched_rank_0(handle,uplo,trans,n,k,alpha,A,lda,B,ldb,beta,C,ldc,batch_count)
      use iso_c_binding
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocblas_ssyrkx_batched_rank_0
      type(c_ptr),value :: handle
      integer(kind(rocblas_fill_upper)),value :: uplo
      integer(kind(rocblas_operation_none)),value :: trans
      integer(c_int),value :: n
      integer(c_int),value :: k
      real(c_float) :: alpha
      real(c_float),target :: A
      integer(c_int),value :: lda
      real(c_float),target :: B
      integer(c_int),value :: ldb
      real(c_float) :: beta
      real(c_float),target :: C
      integer(c_int),value :: ldc
      integer(c_int),value :: batch_count
      !
      rocblas_ssyrkx_batched_rank_0 = rocblas_ssyrkx_batched_orig(handle,uplo,trans,n,k,alpha,c_loc(A),lda,c_loc(B),ldb,beta,c_loc(C),ldc,batch_count)
    end function

    function rocblas_ssyrkx_batched_rank_1(handle,uplo,trans,n,k,alpha,A,lda,B,ldb,beta,C,ldc,batch_count)
      use iso_c_binding
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocblas_ssyrkx_batched_rank_1
      type(c_ptr),value :: handle
      integer(kind(rocblas_fill_upper)),value :: uplo
      integer(kind(rocblas_operation_none)),value :: trans
      integer(c_int),value :: n
      integer(c_int),value :: k
      real(c_float) :: alpha
      real(c_float),target,dimension(:) :: A
      integer(c_int),value :: lda
      real(c_float),target,dimension(:) :: B
      integer(c_int),value :: ldb
      real(c_float) :: beta
      real(c_float),target,dimension(:) :: C
      integer(c_int),value :: ldc
      integer(c_int),value :: batch_count
      !
      rocblas_ssyrkx_batched_rank_1 = rocblas_ssyrkx_batched_orig(handle,uplo,trans,n,k,alpha,c_loc(A),lda,c_loc(B),ldb,beta,c_loc(C),ldc,batch_count)
    end function

    function rocblas_dsyrkx_batched_full_rank(handle,uplo,trans,n,k,alpha,A,lda,B,ldb,beta,C,ldc,batch_count)
      use iso_c_binding
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocblas_dsyrkx_batched_full_rank
      type(c_ptr),value :: handle
      integer(kind(rocblas_fill_upper)),value :: uplo
      integer(kind(rocblas_operation_none)),value :: trans
      integer(c_int),value :: n
      integer(c_int),value :: k
      real(c_double) :: alpha
      real(c_double),target,dimension(:,:,:) :: A
      integer(c_int),value :: lda
      real(c_double),target,dimension(:,:,:) :: B
      integer(c_int),value :: ldb
      real(c_double) :: beta
      real(c_double),target,dimension(:,:,:) :: C
      integer(c_int),value :: ldc
      integer(c_int),value :: batch_count
      !
      rocblas_dsyrkx_batched_full_rank = rocblas_dsyrkx_batched_orig(handle,uplo,trans,n,k,alpha,c_loc(A),lda,c_loc(B),ldb,beta,c_loc(C),ldc,batch_count)
    end function

    function rocblas_dsyrkx_batched_rank_0(handle,uplo,trans,n,k,alpha,A,lda,B,ldb,beta,C,ldc,batch_count)
      use iso_c_binding
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocblas_dsyrkx_batched_rank_0
      type(c_ptr),value :: handle
      integer(kind(rocblas_fill_upper)),value :: uplo
      integer(kind(rocblas_operation_none)),value :: trans
      integer(c_int),value :: n
      integer(c_int),value :: k
      real(c_double) :: alpha
      real(c_double),target :: A
      integer(c_int),value :: lda
      real(c_double),target :: B
      integer(c_int),value :: ldb
      real(c_double) :: beta
      real(c_double),target :: C
      integer(c_int),value :: ldc
      integer(c_int),value :: batch_count
      !
      rocblas_dsyrkx_batched_rank_0 = rocblas_dsyrkx_batched_orig(handle,uplo,trans,n,k,alpha,c_loc(A),lda,c_loc(B),ldb,beta,c_loc(C),ldc,batch_count)
    end function

    function rocblas_dsyrkx_batched_rank_1(handle,uplo,trans,n,k,alpha,A,lda,B,ldb,beta,C,ldc,batch_count)
      use iso_c_binding
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocblas_dsyrkx_batched_rank_1
      type(c_ptr),value :: handle
      integer(kind(rocblas_fill_upper)),value :: uplo
      integer(kind(rocblas_operation_none)),value :: trans
      integer(c_int),value :: n
      integer(c_int),value :: k
      real(c_double) :: alpha
      real(c_double),target,dimension(:) :: A
      integer(c_int),value :: lda
      real(c_double),target,dimension(:) :: B
      integer(c_int),value :: ldb
      real(c_double) :: beta
      real(c_double),target,dimension(:) :: C
      integer(c_int),value :: ldc
      integer(c_int),value :: batch_count
      !
      rocblas_dsyrkx_batched_rank_1 = rocblas_dsyrkx_batched_orig(handle,uplo,trans,n,k,alpha,c_loc(A),lda,c_loc(B),ldb,beta,c_loc(C),ldc,batch_count)
    end function

    function rocblas_csyrkx_batched_full_rank(handle,uplo,trans,n,k,alpha,A,lda,B,ldb,beta,C,ldc,batch_count)
      use iso_c_binding
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocblas_csyrkx_batched_full_rank
      type(c_ptr),value :: handle
      integer(kind(rocblas_fill_upper)),value :: uplo
      integer(kind(rocblas_operation_none)),value :: trans
      integer(c_int),value :: n
      integer(c_int),value :: k
      complex(c_float_complex) :: alpha
      complex(c_float_complex),target,dimension(:,:,:) :: A
      integer(c_int),value :: lda
      complex(c_float_complex),target,dimension(:,:,:) :: B
      integer(c_int),value :: ldb
      complex(c_float_complex) :: beta
      complex(c_float_complex),target,dimension(:,:,:) :: C
      integer(c_int),value :: ldc
      integer(c_int),value :: batch_count
      !
      rocblas_csyrkx_batched_full_rank = rocblas_csyrkx_batched_orig(handle,uplo,trans,n,k,alpha,c_loc(A),lda,c_loc(B),ldb,beta,c_loc(C),ldc,batch_count)
    end function

    function rocblas_csyrkx_batched_rank_0(handle,uplo,trans,n,k,alpha,A,lda,B,ldb,beta,C,ldc,batch_count)
      use iso_c_binding
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocblas_csyrkx_batched_rank_0
      type(c_ptr),value :: handle
      integer(kind(rocblas_fill_upper)),value :: uplo
      integer(kind(rocblas_operation_none)),value :: trans
      integer(c_int),value :: n
      integer(c_int),value :: k
      complex(c_float_complex) :: alpha
      complex(c_float_complex),target :: A
      integer(c_int),value :: lda
      complex(c_float_complex),target :: B
      integer(c_int),value :: ldb
      complex(c_float_complex) :: beta
      complex(c_float_complex),target :: C
      integer(c_int),value :: ldc
      integer(c_int),value :: batch_count
      !
      rocblas_csyrkx_batched_rank_0 = rocblas_csyrkx_batched_orig(handle,uplo,trans,n,k,alpha,c_loc(A),lda,c_loc(B),ldb,beta,c_loc(C),ldc,batch_count)
    end function

    function rocblas_csyrkx_batched_rank_1(handle,uplo,trans,n,k,alpha,A,lda,B,ldb,beta,C,ldc,batch_count)
      use iso_c_binding
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocblas_csyrkx_batched_rank_1
      type(c_ptr),value :: handle
      integer(kind(rocblas_fill_upper)),value :: uplo
      integer(kind(rocblas_operation_none)),value :: trans
      integer(c_int),value :: n
      integer(c_int),value :: k
      complex(c_float_complex) :: alpha
      complex(c_float_complex),target,dimension(:) :: A
      integer(c_int),value :: lda
      complex(c_float_complex),target,dimension(:) :: B
      integer(c_int),value :: ldb
      complex(c_float_complex) :: beta
      complex(c_float_complex),target,dimension(:) :: C
      integer(c_int),value :: ldc
      integer(c_int),value :: batch_count
      !
      rocblas_csyrkx_batched_rank_1 = rocblas_csyrkx_batched_orig(handle,uplo,trans,n,k,alpha,c_loc(A),lda,c_loc(B),ldb,beta,c_loc(C),ldc,batch_count)
    end function

    function rocblas_zsyrkx_batched_full_rank(handle,uplo,trans,n,k,alpha,A,lda,B,ldb,beta,C,ldc,batch_count)
      use iso_c_binding
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocblas_zsyrkx_batched_full_rank
      type(c_ptr),value :: handle
      integer(kind(rocblas_fill_upper)),value :: uplo
      integer(kind(rocblas_operation_none)),value :: trans
      integer(c_int),value :: n
      integer(c_int),value :: k
      complex(c_double_complex) :: alpha
      complex(c_double_complex),target,dimension(:,:,:) :: A
      integer(c_int),value :: lda
      complex(c_double_complex),target,dimension(:,:,:) :: B
      integer(c_int),value :: ldb
      complex(c_double_complex) :: beta
      complex(c_double_complex),target,dimension(:,:,:) :: C
      integer(c_int),value :: ldc
      integer(c_int),value :: batch_count
      !
      rocblas_zsyrkx_batched_full_rank = rocblas_zsyrkx_batched_orig(handle,uplo,trans,n,k,alpha,c_loc(A),lda,c_loc(B),ldb,beta,c_loc(C),ldc,batch_count)
    end function

    function rocblas_zsyrkx_batched_rank_0(handle,uplo,trans,n,k,alpha,A,lda,B,ldb,beta,C,ldc,batch_count)
      use iso_c_binding
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocblas_zsyrkx_batched_rank_0
      type(c_ptr),value :: handle
      integer(kind(rocblas_fill_upper)),value :: uplo
      integer(kind(rocblas_operation_none)),value :: trans
      integer(c_int),value :: n
      integer(c_int),value :: k
      complex(c_double_complex) :: alpha
      complex(c_double_complex),target :: A
      integer(c_int),value :: lda
      complex(c_double_complex),target :: B
      integer(c_int),value :: ldb
      complex(c_double_complex) :: beta
      complex(c_double_complex),target :: C
      integer(c_int),value :: ldc
      integer(c_int),value :: batch_count
      !
      rocblas_zsyrkx_batched_rank_0 = rocblas_zsyrkx_batched_orig(handle,uplo,trans,n,k,alpha,c_loc(A),lda,c_loc(B),ldb,beta,c_loc(C),ldc,batch_count)
    end function

    function rocblas_zsyrkx_batched_rank_1(handle,uplo,trans,n,k,alpha,A,lda,B,ldb,beta,C,ldc,batch_count)
      use iso_c_binding
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocblas_zsyrkx_batched_rank_1
      type(c_ptr),value :: handle
      integer(kind(rocblas_fill_upper)),value :: uplo
      integer(kind(rocblas_operation_none)),value :: trans
      integer(c_int),value :: n
      integer(c_int),value :: k
      complex(c_double_complex) :: alpha
      complex(c_double_complex),target,dimension(:) :: A
      integer(c_int),value :: lda
      complex(c_double_complex),target,dimension(:) :: B
      integer(c_int),value :: ldb
      complex(c_double_complex) :: beta
      complex(c_double_complex),target,dimension(:) :: C
      integer(c_int),value :: ldc
      integer(c_int),value :: batch_count
      !
      rocblas_zsyrkx_batched_rank_1 = rocblas_zsyrkx_batched_orig(handle,uplo,trans,n,k,alpha,c_loc(A),lda,c_loc(B),ldb,beta,c_loc(C),ldc,batch_count)
    end function

    function rocblas_ssyrkx_strided_batched_full_rank(handle,uplo,trans,n,k,alpha,A,lda,stride_A,B,ldb,stride_B,beta,C,ldc,stride_C,batch_count)
      use iso_c_binding
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocblas_ssyrkx_strided_batched_full_rank
      type(c_ptr),value :: handle
      integer(kind(rocblas_fill_upper)),value :: uplo
      integer(kind(rocblas_operation_none)),value :: trans
      integer(c_int),value :: n
      integer(c_int),value :: k
      real(c_float) :: alpha
      real(c_float),target,dimension(:,:) :: A
      integer(c_int),value :: lda
      integer(c_int64_t),value :: stride_A
      real(c_float),target,dimension(:,:) :: B
      integer(c_int),value :: ldb
      integer(c_int64_t),value :: stride_B
      real(c_float) :: beta
      real(c_float),target,dimension(:,:) :: C
      integer(c_int),value :: ldc
      integer(c_int64_t),value :: stride_C
      integer(c_int),value :: batch_count
      !
      rocblas_ssyrkx_strided_batched_full_rank = rocblas_ssyrkx_strided_batched_orig(handle,uplo,trans,n,k,alpha,c_loc(A),lda,stride_A,c_loc(B),ldb,stride_B,beta,c_loc(C),ldc,stride_C,batch_count)
    end function

    function rocblas_ssyrkx_strided_batched_rank_0(handle,uplo,trans,n,k,alpha,A,lda,stride_A,B,ldb,stride_B,beta,C,ldc,stride_C,batch_count)
      use iso_c_binding
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocblas_ssyrkx_strided_batched_rank_0
      type(c_ptr),value :: handle
      integer(kind(rocblas_fill_upper)),value :: uplo
      integer(kind(rocblas_operation_none)),value :: trans
      integer(c_int),value :: n
      integer(c_int),value :: k
      real(c_float) :: alpha
      real(c_float),target :: A
      integer(c_int),value :: lda
      integer(c_int64_t),value :: stride_A
      real(c_float),target :: B
      integer(c_int),value :: ldb
      integer(c_int64_t),value :: stride_B
      real(c_float) :: beta
      real(c_float),target :: C
      integer(c_int),value :: ldc
      integer(c_int64_t),value :: stride_C
      integer(c_int),value :: batch_count
      !
      rocblas_ssyrkx_strided_batched_rank_0 = rocblas_ssyrkx_strided_batched_orig(handle,uplo,trans,n,k,alpha,c_loc(A),lda,stride_A,c_loc(B),ldb,stride_B,beta,c_loc(C),ldc,stride_C,batch_count)
    end function

    function rocblas_ssyrkx_strided_batched_rank_1(handle,uplo,trans,n,k,alpha,A,lda,stride_A,B,ldb,stride_B,beta,C,ldc,stride_C,batch_count)
      use iso_c_binding
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocblas_ssyrkx_strided_batched_rank_1
      type(c_ptr),value :: handle
      integer(kind(rocblas_fill_upper)),value :: uplo
      integer(kind(rocblas_operation_none)),value :: trans
      integer(c_int),value :: n
      integer(c_int),value :: k
      real(c_float) :: alpha
      real(c_float),target,dimension(:) :: A
      integer(c_int),value :: lda
      integer(c_int64_t),value :: stride_A
      real(c_float),target,dimension(:) :: B
      integer(c_int),value :: ldb
      integer(c_int64_t),value :: stride_B
      real(c_float) :: beta
      real(c_float),target,dimension(:) :: C
      integer(c_int),value :: ldc
      integer(c_int64_t),value :: stride_C
      integer(c_int),value :: batch_count
      !
      rocblas_ssyrkx_strided_batched_rank_1 = rocblas_ssyrkx_strided_batched_orig(handle,uplo,trans,n,k,alpha,c_loc(A),lda,stride_A,c_loc(B),ldb,stride_B,beta,c_loc(C),ldc,stride_C,batch_count)
    end function

    function rocblas_dsyrkx_strided_batched_full_rank(handle,uplo,trans,n,k,alpha,A,lda,stride_A,B,ldb,stride_B,beta,C,ldc,stride_C,batch_count)
      use iso_c_binding
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocblas_dsyrkx_strided_batched_full_rank
      type(c_ptr),value :: handle
      integer(kind(rocblas_fill_upper)),value :: uplo
      integer(kind(rocblas_operation_none)),value :: trans
      integer(c_int),value :: n
      integer(c_int),value :: k
      real(c_double) :: alpha
      real(c_double),target,dimension(:,:) :: A
      integer(c_int),value :: lda
      integer(c_int64_t),value :: stride_A
      real(c_double),target,dimension(:,:) :: B
      integer(c_int),value :: ldb
      integer(c_int64_t),value :: stride_B
      real(c_double) :: beta
      real(c_double),target,dimension(:,:) :: C
      integer(c_int),value :: ldc
      integer(c_int64_t),value :: stride_C
      integer(c_int),value :: batch_count
      !
      rocblas_dsyrkx_strided_batched_full_rank = rocblas_dsyrkx_strided_batched_orig(handle,uplo,trans,n,k,alpha,c_loc(A),lda,stride_A,c_loc(B),ldb,stride_B,beta,c_loc(C),ldc,stride_C,batch_count)
    end function

    function rocblas_dsyrkx_strided_batched_rank_0(handle,uplo,trans,n,k,alpha,A,lda,stride_A,B,ldb,stride_B,beta,C,ldc,stride_C,batch_count)
      use iso_c_binding
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocblas_dsyrkx_strided_batched_rank_0
      type(c_ptr),value :: handle
      integer(kind(rocblas_fill_upper)),value :: uplo
      integer(kind(rocblas_operation_none)),value :: trans
      integer(c_int),value :: n
      integer(c_int),value :: k
      real(c_double) :: alpha
      real(c_double),target :: A
      integer(c_int),value :: lda
      integer(c_int64_t),value :: stride_A
      real(c_double),target :: B
      integer(c_int),value :: ldb
      integer(c_int64_t),value :: stride_B
      real(c_double) :: beta
      real(c_double),target :: C
      integer(c_int),value :: ldc
      integer(c_int64_t),value :: stride_C
      integer(c_int),value :: batch_count
      !
      rocblas_dsyrkx_strided_batched_rank_0 = rocblas_dsyrkx_strided_batched_orig(handle,uplo,trans,n,k,alpha,c_loc(A),lda,stride_A,c_loc(B),ldb,stride_B,beta,c_loc(C),ldc,stride_C,batch_count)
    end function

    function rocblas_dsyrkx_strided_batched_rank_1(handle,uplo,trans,n,k,alpha,A,lda,stride_A,B,ldb,stride_B,beta,C,ldc,stride_C,batch_count)
      use iso_c_binding
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocblas_dsyrkx_strided_batched_rank_1
      type(c_ptr),value :: handle
      integer(kind(rocblas_fill_upper)),value :: uplo
      integer(kind(rocblas_operation_none)),value :: trans
      integer(c_int),value :: n
      integer(c_int),value :: k
      real(c_double) :: alpha
      real(c_double),target,dimension(:) :: A
      integer(c_int),value :: lda
      integer(c_int64_t),value :: stride_A
      real(c_double),target,dimension(:) :: B
      integer(c_int),value :: ldb
      integer(c_int64_t),value :: stride_B
      real(c_double) :: beta
      real(c_double),target,dimension(:) :: C
      integer(c_int),value :: ldc
      integer(c_int64_t),value :: stride_C
      integer(c_int),value :: batch_count
      !
      rocblas_dsyrkx_strided_batched_rank_1 = rocblas_dsyrkx_strided_batched_orig(handle,uplo,trans,n,k,alpha,c_loc(A),lda,stride_A,c_loc(B),ldb,stride_B,beta,c_loc(C),ldc,stride_C,batch_count)
    end function

    function rocblas_csyrkx_strided_batched_full_rank(handle,uplo,trans,n,k,alpha,A,lda,stride_A,B,ldb,stride_B,beta,C,ldc,stride_C,batch_count)
      use iso_c_binding
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocblas_csyrkx_strided_batched_full_rank
      type(c_ptr),value :: handle
      integer(kind(rocblas_fill_upper)),value :: uplo
      integer(kind(rocblas_operation_none)),value :: trans
      integer(c_int),value :: n
      integer(c_int),value :: k
      complex(c_float_complex) :: alpha
      complex(c_float_complex),target,dimension(:,:) :: A
      integer(c_int),value :: lda
      integer(c_int64_t),value :: stride_A
      complex(c_float_complex),target,dimension(:,:) :: B
      integer(c_int),value :: ldb
      integer(c_int64_t),value :: stride_B
      complex(c_float_complex) :: beta
      complex(c_float_complex),target,dimension(:,:) :: C
      integer(c_int),value :: ldc
      integer(c_int64_t),value :: stride_C
      integer(c_int),value :: batch_count
      !
      rocblas_csyrkx_strided_batched_full_rank = rocblas_csyrkx_strided_batched_orig(handle,uplo,trans,n,k,alpha,c_loc(A),lda,stride_A,c_loc(B),ldb,stride_B,beta,c_loc(C),ldc,stride_C,batch_count)
    end function

    function rocblas_csyrkx_strided_batched_rank_0(handle,uplo,trans,n,k,alpha,A,lda,stride_A,B,ldb,stride_B,beta,C,ldc,stride_C,batch_count)
      use iso_c_binding
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocblas_csyrkx_strided_batched_rank_0
      type(c_ptr),value :: handle
      integer(kind(rocblas_fill_upper)),value :: uplo
      integer(kind(rocblas_operation_none)),value :: trans
      integer(c_int),value :: n
      integer(c_int),value :: k
      complex(c_float_complex) :: alpha
      complex(c_float_complex),target :: A
      integer(c_int),value :: lda
      integer(c_int64_t),value :: stride_A
      complex(c_float_complex),target :: B
      integer(c_int),value :: ldb
      integer(c_int64_t),value :: stride_B
      complex(c_float_complex) :: beta
      complex(c_float_complex),target :: C
      integer(c_int),value :: ldc
      integer(c_int64_t),value :: stride_C
      integer(c_int),value :: batch_count
      !
      rocblas_csyrkx_strided_batched_rank_0 = rocblas_csyrkx_strided_batched_orig(handle,uplo,trans,n,k,alpha,c_loc(A),lda,stride_A,c_loc(B),ldb,stride_B,beta,c_loc(C),ldc,stride_C,batch_count)
    end function

    function rocblas_csyrkx_strided_batched_rank_1(handle,uplo,trans,n,k,alpha,A,lda,stride_A,B,ldb,stride_B,beta,C,ldc,stride_C,batch_count)
      use iso_c_binding
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocblas_csyrkx_strided_batched_rank_1
      type(c_ptr),value :: handle
      integer(kind(rocblas_fill_upper)),value :: uplo
      integer(kind(rocblas_operation_none)),value :: trans
      integer(c_int),value :: n
      integer(c_int),value :: k
      complex(c_float_complex) :: alpha
      complex(c_float_complex),target,dimension(:) :: A
      integer(c_int),value :: lda
      integer(c_int64_t),value :: stride_A
      complex(c_float_complex),target,dimension(:) :: B
      integer(c_int),value :: ldb
      integer(c_int64_t),value :: stride_B
      complex(c_float_complex) :: beta
      complex(c_float_complex),target,dimension(:) :: C
      integer(c_int),value :: ldc
      integer(c_int64_t),value :: stride_C
      integer(c_int),value :: batch_count
      !
      rocblas_csyrkx_strided_batched_rank_1 = rocblas_csyrkx_strided_batched_orig(handle,uplo,trans,n,k,alpha,c_loc(A),lda,stride_A,c_loc(B),ldb,stride_B,beta,c_loc(C),ldc,stride_C,batch_count)
    end function

    function rocblas_zsyrkx_strided_batched_full_rank(handle,uplo,trans,n,k,alpha,A,lda,stride_A,B,ldb,stride_B,beta,C,ldc,stride_C,batch_count)
      use iso_c_binding
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocblas_zsyrkx_strided_batched_full_rank
      type(c_ptr),value :: handle
      integer(kind(rocblas_fill_upper)),value :: uplo
      integer(kind(rocblas_operation_none)),value :: trans
      integer(c_int),value :: n
      integer(c_int),value :: k
      complex(c_double_complex) :: alpha
      complex(c_double_complex),target,dimension(:,:) :: A
      integer(c_int),value :: lda
      integer(c_int64_t),value :: stride_A
      complex(c_double_complex),target,dimension(:,:) :: B
      integer(c_int),value :: ldb
      integer(c_int64_t),value :: stride_B
      complex(c_double_complex) :: beta
      complex(c_double_complex),target,dimension(:,:) :: C
      integer(c_int),value :: ldc
      integer(c_int64_t),value :: stride_C
      integer(c_int),value :: batch_count
      !
      rocblas_zsyrkx_strided_batched_full_rank = rocblas_zsyrkx_strided_batched_orig(handle,uplo,trans,n,k,alpha,c_loc(A),lda,stride_A,c_loc(B),ldb,stride_B,beta,c_loc(C),ldc,stride_C,batch_count)
    end function

    function rocblas_zsyrkx_strided_batched_rank_0(handle,uplo,trans,n,k,alpha,A,lda,stride_A,B,ldb,stride_B,beta,C,ldc,stride_C,batch_count)
      use iso_c_binding
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocblas_zsyrkx_strided_batched_rank_0
      type(c_ptr),value :: handle
      integer(kind(rocblas_fill_upper)),value :: uplo
      integer(kind(rocblas_operation_none)),value :: trans
      integer(c_int),value :: n
      integer(c_int),value :: k
      complex(c_double_complex) :: alpha
      complex(c_double_complex),target :: A
      integer(c_int),value :: lda
      integer(c_int64_t),value :: stride_A
      complex(c_double_complex),target :: B
      integer(c_int),value :: ldb
      integer(c_int64_t),value :: stride_B
      complex(c_double_complex) :: beta
      complex(c_double_complex),target :: C
      integer(c_int),value :: ldc
      integer(c_int64_t),value :: stride_C
      integer(c_int),value :: batch_count
      !
      rocblas_zsyrkx_strided_batched_rank_0 = rocblas_zsyrkx_strided_batched_orig(handle,uplo,trans,n,k,alpha,c_loc(A),lda,stride_A,c_loc(B),ldb,stride_B,beta,c_loc(C),ldc,stride_C,batch_count)
    end function

    function rocblas_zsyrkx_strided_batched_rank_1(handle,uplo,trans,n,k,alpha,A,lda,stride_A,B,ldb,stride_B,beta,C,ldc,stride_C,batch_count)
      use iso_c_binding
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocblas_zsyrkx_strided_batched_rank_1
      type(c_ptr),value :: handle
      integer(kind(rocblas_fill_upper)),value :: uplo
      integer(kind(rocblas_operation_none)),value :: trans
      integer(c_int),value :: n
      integer(c_int),value :: k
      complex(c_double_complex) :: alpha
      complex(c_double_complex),target,dimension(:) :: A
      integer(c_int),value :: lda
      integer(c_int64_t),value :: stride_A
      complex(c_double_complex),target,dimension(:) :: B
      integer(c_int),value :: ldb
      integer(c_int64_t),value :: stride_B
      complex(c_double_complex) :: beta
      complex(c_double_complex),target,dimension(:) :: C
      integer(c_int),value :: ldc
      integer(c_int64_t),value :: stride_C
      integer(c_int),value :: batch_count
      !
      rocblas_zsyrkx_strided_batched_rank_1 = rocblas_zsyrkx_strided_batched_orig(handle,uplo,trans,n,k,alpha,c_loc(A),lda,stride_A,c_loc(B),ldb,stride_B,beta,c_loc(C),ldc,stride_C,batch_count)
    end function

    function rocblas_strmm_full_rank(handle,side,uplo,transA,diag,m,n,alpha,A,lda,B,ldb)
      use iso_c_binding
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocblas_strmm_full_rank
      type(c_ptr),value :: handle
      integer(kind(rocblas_side_left)),value :: side
      integer(kind(rocblas_fill_upper)),value :: uplo
      integer(kind(rocblas_operation_none)),value :: transA
      integer(kind(rocblas_diagonal_non_unit)),value :: diag
      integer(c_int),value :: m
      integer(c_int),value :: n
      real(c_float) :: alpha
      real(c_float),target,dimension(:,:) :: A
      integer(c_int),value :: lda
      real(c_float),target,dimension(:,:) :: B
      integer(c_int),value :: ldb
      !
      rocblas_strmm_full_rank = rocblas_strmm_orig(handle,side,uplo,transA,diag,m,n,alpha,c_loc(A),lda,c_loc(B),ldb)
    end function

    function rocblas_strmm_rank_0(handle,side,uplo,transA,diag,m,n,alpha,A,lda,B,ldb)
      use iso_c_binding
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocblas_strmm_rank_0
      type(c_ptr),value :: handle
      integer(kind(rocblas_side_left)),value :: side
      integer(kind(rocblas_fill_upper)),value :: uplo
      integer(kind(rocblas_operation_none)),value :: transA
      integer(kind(rocblas_diagonal_non_unit)),value :: diag
      integer(c_int),value :: m
      integer(c_int),value :: n
      real(c_float) :: alpha
      real(c_float),target :: A
      integer(c_int),value :: lda
      real(c_float),target :: B
      integer(c_int),value :: ldb
      !
      rocblas_strmm_rank_0 = rocblas_strmm_orig(handle,side,uplo,transA,diag,m,n,alpha,c_loc(A),lda,c_loc(B),ldb)
    end function

    function rocblas_strmm_rank_1(handle,side,uplo,transA,diag,m,n,alpha,A,lda,B,ldb)
      use iso_c_binding
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocblas_strmm_rank_1
      type(c_ptr),value :: handle
      integer(kind(rocblas_side_left)),value :: side
      integer(kind(rocblas_fill_upper)),value :: uplo
      integer(kind(rocblas_operation_none)),value :: transA
      integer(kind(rocblas_diagonal_non_unit)),value :: diag
      integer(c_int),value :: m
      integer(c_int),value :: n
      real(c_float) :: alpha
      real(c_float),target,dimension(:) :: A
      integer(c_int),value :: lda
      real(c_float),target,dimension(:) :: B
      integer(c_int),value :: ldb
      !
      rocblas_strmm_rank_1 = rocblas_strmm_orig(handle,side,uplo,transA,diag,m,n,alpha,c_loc(A),lda,c_loc(B),ldb)
    end function

    function rocblas_dtrmm_full_rank(handle,side,uplo,transA,diag,m,n,alpha,A,lda,B,ldb)
      use iso_c_binding
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocblas_dtrmm_full_rank
      type(c_ptr),value :: handle
      integer(kind(rocblas_side_left)),value :: side
      integer(kind(rocblas_fill_upper)),value :: uplo
      integer(kind(rocblas_operation_none)),value :: transA
      integer(kind(rocblas_diagonal_non_unit)),value :: diag
      integer(c_int),value :: m
      integer(c_int),value :: n
      real(c_double) :: alpha
      real(c_double),target,dimension(:,:) :: A
      integer(c_int),value :: lda
      real(c_double),target,dimension(:,:) :: B
      integer(c_int),value :: ldb
      !
      rocblas_dtrmm_full_rank = rocblas_dtrmm_orig(handle,side,uplo,transA,diag,m,n,alpha,c_loc(A),lda,c_loc(B),ldb)
    end function

    function rocblas_dtrmm_rank_0(handle,side,uplo,transA,diag,m,n,alpha,A,lda,B,ldb)
      use iso_c_binding
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocblas_dtrmm_rank_0
      type(c_ptr),value :: handle
      integer(kind(rocblas_side_left)),value :: side
      integer(kind(rocblas_fill_upper)),value :: uplo
      integer(kind(rocblas_operation_none)),value :: transA
      integer(kind(rocblas_diagonal_non_unit)),value :: diag
      integer(c_int),value :: m
      integer(c_int),value :: n
      real(c_double) :: alpha
      real(c_double),target :: A
      integer(c_int),value :: lda
      real(c_double),target :: B
      integer(c_int),value :: ldb
      !
      rocblas_dtrmm_rank_0 = rocblas_dtrmm_orig(handle,side,uplo,transA,diag,m,n,alpha,c_loc(A),lda,c_loc(B),ldb)
    end function

    function rocblas_dtrmm_rank_1(handle,side,uplo,transA,diag,m,n,alpha,A,lda,B,ldb)
      use iso_c_binding
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocblas_dtrmm_rank_1
      type(c_ptr),value :: handle
      integer(kind(rocblas_side_left)),value :: side
      integer(kind(rocblas_fill_upper)),value :: uplo
      integer(kind(rocblas_operation_none)),value :: transA
      integer(kind(rocblas_diagonal_non_unit)),value :: diag
      integer(c_int),value :: m
      integer(c_int),value :: n
      real(c_double) :: alpha
      real(c_double),target,dimension(:) :: A
      integer(c_int),value :: lda
      real(c_double),target,dimension(:) :: B
      integer(c_int),value :: ldb
      !
      rocblas_dtrmm_rank_1 = rocblas_dtrmm_orig(handle,side,uplo,transA,diag,m,n,alpha,c_loc(A),lda,c_loc(B),ldb)
    end function

    function rocblas_ctrmm_full_rank(handle,side,uplo,transA,diag,m,n,alpha,A,lda,B,ldb)
      use iso_c_binding
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocblas_ctrmm_full_rank
      type(c_ptr),value :: handle
      integer(kind(rocblas_side_left)),value :: side
      integer(kind(rocblas_fill_upper)),value :: uplo
      integer(kind(rocblas_operation_none)),value :: transA
      integer(kind(rocblas_diagonal_non_unit)),value :: diag
      integer(c_int),value :: m
      integer(c_int),value :: n
      complex(c_float_complex) :: alpha
      complex(c_float_complex),target,dimension(:,:) :: A
      integer(c_int),value :: lda
      complex(c_float_complex),target,dimension(:,:) :: B
      integer(c_int),value :: ldb
      !
      rocblas_ctrmm_full_rank = rocblas_ctrmm_orig(handle,side,uplo,transA,diag,m,n,alpha,c_loc(A),lda,c_loc(B),ldb)
    end function

    function rocblas_ctrmm_rank_0(handle,side,uplo,transA,diag,m,n,alpha,A,lda,B,ldb)
      use iso_c_binding
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocblas_ctrmm_rank_0
      type(c_ptr),value :: handle
      integer(kind(rocblas_side_left)),value :: side
      integer(kind(rocblas_fill_upper)),value :: uplo
      integer(kind(rocblas_operation_none)),value :: transA
      integer(kind(rocblas_diagonal_non_unit)),value :: diag
      integer(c_int),value :: m
      integer(c_int),value :: n
      complex(c_float_complex) :: alpha
      complex(c_float_complex),target :: A
      integer(c_int),value :: lda
      complex(c_float_complex),target :: B
      integer(c_int),value :: ldb
      !
      rocblas_ctrmm_rank_0 = rocblas_ctrmm_orig(handle,side,uplo,transA,diag,m,n,alpha,c_loc(A),lda,c_loc(B),ldb)
    end function

    function rocblas_ctrmm_rank_1(handle,side,uplo,transA,diag,m,n,alpha,A,lda,B,ldb)
      use iso_c_binding
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocblas_ctrmm_rank_1
      type(c_ptr),value :: handle
      integer(kind(rocblas_side_left)),value :: side
      integer(kind(rocblas_fill_upper)),value :: uplo
      integer(kind(rocblas_operation_none)),value :: transA
      integer(kind(rocblas_diagonal_non_unit)),value :: diag
      integer(c_int),value :: m
      integer(c_int),value :: n
      complex(c_float_complex) :: alpha
      complex(c_float_complex),target,dimension(:) :: A
      integer(c_int),value :: lda
      complex(c_float_complex),target,dimension(:) :: B
      integer(c_int),value :: ldb
      !
      rocblas_ctrmm_rank_1 = rocblas_ctrmm_orig(handle,side,uplo,transA,diag,m,n,alpha,c_loc(A),lda,c_loc(B),ldb)
    end function

    function rocblas_ztrmm_full_rank(handle,side,uplo,transA,diag,m,n,alpha,A,lda,B,ldb)
      use iso_c_binding
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocblas_ztrmm_full_rank
      type(c_ptr),value :: handle
      integer(kind(rocblas_side_left)),value :: side
      integer(kind(rocblas_fill_upper)),value :: uplo
      integer(kind(rocblas_operation_none)),value :: transA
      integer(kind(rocblas_diagonal_non_unit)),value :: diag
      integer(c_int),value :: m
      integer(c_int),value :: n
      complex(c_double_complex) :: alpha
      complex(c_double_complex),target,dimension(:,:) :: A
      integer(c_int),value :: lda
      complex(c_double_complex),target,dimension(:,:) :: B
      integer(c_int),value :: ldb
      !
      rocblas_ztrmm_full_rank = rocblas_ztrmm_orig(handle,side,uplo,transA,diag,m,n,alpha,c_loc(A),lda,c_loc(B),ldb)
    end function

    function rocblas_ztrmm_rank_0(handle,side,uplo,transA,diag,m,n,alpha,A,lda,B,ldb)
      use iso_c_binding
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocblas_ztrmm_rank_0
      type(c_ptr),value :: handle
      integer(kind(rocblas_side_left)),value :: side
      integer(kind(rocblas_fill_upper)),value :: uplo
      integer(kind(rocblas_operation_none)),value :: transA
      integer(kind(rocblas_diagonal_non_unit)),value :: diag
      integer(c_int),value :: m
      integer(c_int),value :: n
      complex(c_double_complex) :: alpha
      complex(c_double_complex),target :: A
      integer(c_int),value :: lda
      complex(c_double_complex),target :: B
      integer(c_int),value :: ldb
      !
      rocblas_ztrmm_rank_0 = rocblas_ztrmm_orig(handle,side,uplo,transA,diag,m,n,alpha,c_loc(A),lda,c_loc(B),ldb)
    end function

    function rocblas_ztrmm_rank_1(handle,side,uplo,transA,diag,m,n,alpha,A,lda,B,ldb)
      use iso_c_binding
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocblas_ztrmm_rank_1
      type(c_ptr),value :: handle
      integer(kind(rocblas_side_left)),value :: side
      integer(kind(rocblas_fill_upper)),value :: uplo
      integer(kind(rocblas_operation_none)),value :: transA
      integer(kind(rocblas_diagonal_non_unit)),value :: diag
      integer(c_int),value :: m
      integer(c_int),value :: n
      complex(c_double_complex) :: alpha
      complex(c_double_complex),target,dimension(:) :: A
      integer(c_int),value :: lda
      complex(c_double_complex),target,dimension(:) :: B
      integer(c_int),value :: ldb
      !
      rocblas_ztrmm_rank_1 = rocblas_ztrmm_orig(handle,side,uplo,transA,diag,m,n,alpha,c_loc(A),lda,c_loc(B),ldb)
    end function

    function rocblas_strtri_full_rank(handle,uplo,diag,n,A,lda,invA,ldinvA)
      use iso_c_binding
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocblas_strtri_full_rank
      type(c_ptr),value :: handle
      integer(kind(rocblas_fill_upper)),value :: uplo
      integer(kind(rocblas_diagonal_non_unit)),value :: diag
      integer(c_int),value :: n
      real(c_float),target,dimension(:,:) :: A
      integer(c_int),value :: lda
      real(c_float),target,dimension(:,:) :: invA
      integer(c_int),value :: ldinvA
      !
      rocblas_strtri_full_rank = rocblas_strtri_orig(handle,uplo,diag,n,c_loc(A),lda,c_loc(invA),ldinvA)
    end function

    function rocblas_strtri_rank_0(handle,uplo,diag,n,A,lda,invA,ldinvA)
      use iso_c_binding
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocblas_strtri_rank_0
      type(c_ptr),value :: handle
      integer(kind(rocblas_fill_upper)),value :: uplo
      integer(kind(rocblas_diagonal_non_unit)),value :: diag
      integer(c_int),value :: n
      real(c_float),target :: A
      integer(c_int),value :: lda
      real(c_float),target :: invA
      integer(c_int),value :: ldinvA
      !
      rocblas_strtri_rank_0 = rocblas_strtri_orig(handle,uplo,diag,n,c_loc(A),lda,c_loc(invA),ldinvA)
    end function

    function rocblas_strtri_rank_1(handle,uplo,diag,n,A,lda,invA,ldinvA)
      use iso_c_binding
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocblas_strtri_rank_1
      type(c_ptr),value :: handle
      integer(kind(rocblas_fill_upper)),value :: uplo
      integer(kind(rocblas_diagonal_non_unit)),value :: diag
      integer(c_int),value :: n
      real(c_float),target,dimension(:) :: A
      integer(c_int),value :: lda
      real(c_float),target,dimension(:) :: invA
      integer(c_int),value :: ldinvA
      !
      rocblas_strtri_rank_1 = rocblas_strtri_orig(handle,uplo,diag,n,c_loc(A),lda,c_loc(invA),ldinvA)
    end function

    function rocblas_dtrtri_full_rank(handle,uplo,diag,n,A,lda,invA,ldinvA)
      use iso_c_binding
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocblas_dtrtri_full_rank
      type(c_ptr),value :: handle
      integer(kind(rocblas_fill_upper)),value :: uplo
      integer(kind(rocblas_diagonal_non_unit)),value :: diag
      integer(c_int),value :: n
      real(c_double),target,dimension(:,:) :: A
      integer(c_int),value :: lda
      real(c_double),target,dimension(:,:) :: invA
      integer(c_int),value :: ldinvA
      !
      rocblas_dtrtri_full_rank = rocblas_dtrtri_orig(handle,uplo,diag,n,c_loc(A),lda,c_loc(invA),ldinvA)
    end function

    function rocblas_dtrtri_rank_0(handle,uplo,diag,n,A,lda,invA,ldinvA)
      use iso_c_binding
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocblas_dtrtri_rank_0
      type(c_ptr),value :: handle
      integer(kind(rocblas_fill_upper)),value :: uplo
      integer(kind(rocblas_diagonal_non_unit)),value :: diag
      integer(c_int),value :: n
      real(c_double),target :: A
      integer(c_int),value :: lda
      real(c_double),target :: invA
      integer(c_int),value :: ldinvA
      !
      rocblas_dtrtri_rank_0 = rocblas_dtrtri_orig(handle,uplo,diag,n,c_loc(A),lda,c_loc(invA),ldinvA)
    end function

    function rocblas_dtrtri_rank_1(handle,uplo,diag,n,A,lda,invA,ldinvA)
      use iso_c_binding
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocblas_dtrtri_rank_1
      type(c_ptr),value :: handle
      integer(kind(rocblas_fill_upper)),value :: uplo
      integer(kind(rocblas_diagonal_non_unit)),value :: diag
      integer(c_int),value :: n
      real(c_double),target,dimension(:) :: A
      integer(c_int),value :: lda
      real(c_double),target,dimension(:) :: invA
      integer(c_int),value :: ldinvA
      !
      rocblas_dtrtri_rank_1 = rocblas_dtrtri_orig(handle,uplo,diag,n,c_loc(A),lda,c_loc(invA),ldinvA)
    end function

    function rocblas_ctrtri_full_rank(handle,uplo,diag,n,A,lda,invA,ldinvA)
      use iso_c_binding
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocblas_ctrtri_full_rank
      type(c_ptr),value :: handle
      integer(kind(rocblas_fill_upper)),value :: uplo
      integer(kind(rocblas_diagonal_non_unit)),value :: diag
      integer(c_int),value :: n
      complex(c_float_complex),target,dimension(:,:) :: A
      integer(c_int),value :: lda
      complex(c_float_complex),target,dimension(:,:) :: invA
      integer(c_int),value :: ldinvA
      !
      rocblas_ctrtri_full_rank = rocblas_ctrtri_orig(handle,uplo,diag,n,c_loc(A),lda,c_loc(invA),ldinvA)
    end function

    function rocblas_ctrtri_rank_0(handle,uplo,diag,n,A,lda,invA,ldinvA)
      use iso_c_binding
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocblas_ctrtri_rank_0
      type(c_ptr),value :: handle
      integer(kind(rocblas_fill_upper)),value :: uplo
      integer(kind(rocblas_diagonal_non_unit)),value :: diag
      integer(c_int),value :: n
      complex(c_float_complex),target :: A
      integer(c_int),value :: lda
      complex(c_float_complex),target :: invA
      integer(c_int),value :: ldinvA
      !
      rocblas_ctrtri_rank_0 = rocblas_ctrtri_orig(handle,uplo,diag,n,c_loc(A),lda,c_loc(invA),ldinvA)
    end function

    function rocblas_ctrtri_rank_1(handle,uplo,diag,n,A,lda,invA,ldinvA)
      use iso_c_binding
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocblas_ctrtri_rank_1
      type(c_ptr),value :: handle
      integer(kind(rocblas_fill_upper)),value :: uplo
      integer(kind(rocblas_diagonal_non_unit)),value :: diag
      integer(c_int),value :: n
      complex(c_float_complex),target,dimension(:) :: A
      integer(c_int),value :: lda
      complex(c_float_complex),target,dimension(:) :: invA
      integer(c_int),value :: ldinvA
      !
      rocblas_ctrtri_rank_1 = rocblas_ctrtri_orig(handle,uplo,diag,n,c_loc(A),lda,c_loc(invA),ldinvA)
    end function

    function rocblas_ztrtri_full_rank(handle,uplo,diag,n,A,lda,invA,ldinvA)
      use iso_c_binding
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocblas_ztrtri_full_rank
      type(c_ptr),value :: handle
      integer(kind(rocblas_fill_upper)),value :: uplo
      integer(kind(rocblas_diagonal_non_unit)),value :: diag
      integer(c_int),value :: n
      complex(c_double_complex),target,dimension(:,:) :: A
      integer(c_int),value :: lda
      complex(c_double_complex),target,dimension(:,:) :: invA
      integer(c_int),value :: ldinvA
      !
      rocblas_ztrtri_full_rank = rocblas_ztrtri_orig(handle,uplo,diag,n,c_loc(A),lda,c_loc(invA),ldinvA)
    end function

    function rocblas_ztrtri_rank_0(handle,uplo,diag,n,A,lda,invA,ldinvA)
      use iso_c_binding
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocblas_ztrtri_rank_0
      type(c_ptr),value :: handle
      integer(kind(rocblas_fill_upper)),value :: uplo
      integer(kind(rocblas_diagonal_non_unit)),value :: diag
      integer(c_int),value :: n
      complex(c_double_complex),target :: A
      integer(c_int),value :: lda
      complex(c_double_complex),target :: invA
      integer(c_int),value :: ldinvA
      !
      rocblas_ztrtri_rank_0 = rocblas_ztrtri_orig(handle,uplo,diag,n,c_loc(A),lda,c_loc(invA),ldinvA)
    end function

    function rocblas_ztrtri_rank_1(handle,uplo,diag,n,A,lda,invA,ldinvA)
      use iso_c_binding
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocblas_ztrtri_rank_1
      type(c_ptr),value :: handle
      integer(kind(rocblas_fill_upper)),value :: uplo
      integer(kind(rocblas_diagonal_non_unit)),value :: diag
      integer(c_int),value :: n
      complex(c_double_complex),target,dimension(:) :: A
      integer(c_int),value :: lda
      complex(c_double_complex),target,dimension(:) :: invA
      integer(c_int),value :: ldinvA
      !
      rocblas_ztrtri_rank_1 = rocblas_ztrtri_orig(handle,uplo,diag,n,c_loc(A),lda,c_loc(invA),ldinvA)
    end function

    function rocblas_strtri_batched_full_rank(handle,uplo,diag,n,A,lda,invA,ldinvA,batch_count)
      use iso_c_binding
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocblas_strtri_batched_full_rank
      type(c_ptr),value :: handle
      integer(kind(rocblas_fill_upper)),value :: uplo
      integer(kind(rocblas_diagonal_non_unit)),value :: diag
      integer(c_int),value :: n
      real(c_float),target,dimension(:,:,:) :: A
      integer(c_int),value :: lda
      real(c_float),target,dimension(:,:,:) :: invA
      integer(c_int),value :: ldinvA
      integer(c_int),value :: batch_count
      !
      rocblas_strtri_batched_full_rank = rocblas_strtri_batched_orig(handle,uplo,diag,n,c_loc(A),lda,c_loc(invA),ldinvA,batch_count)
    end function

    function rocblas_strtri_batched_rank_0(handle,uplo,diag,n,A,lda,invA,ldinvA,batch_count)
      use iso_c_binding
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocblas_strtri_batched_rank_0
      type(c_ptr),value :: handle
      integer(kind(rocblas_fill_upper)),value :: uplo
      integer(kind(rocblas_diagonal_non_unit)),value :: diag
      integer(c_int),value :: n
      real(c_float),target :: A
      integer(c_int),value :: lda
      real(c_float),target :: invA
      integer(c_int),value :: ldinvA
      integer(c_int),value :: batch_count
      !
      rocblas_strtri_batched_rank_0 = rocblas_strtri_batched_orig(handle,uplo,diag,n,c_loc(A),lda,c_loc(invA),ldinvA,batch_count)
    end function

    function rocblas_strtri_batched_rank_1(handle,uplo,diag,n,A,lda,invA,ldinvA,batch_count)
      use iso_c_binding
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocblas_strtri_batched_rank_1
      type(c_ptr),value :: handle
      integer(kind(rocblas_fill_upper)),value :: uplo
      integer(kind(rocblas_diagonal_non_unit)),value :: diag
      integer(c_int),value :: n
      real(c_float),target,dimension(:) :: A
      integer(c_int),value :: lda
      real(c_float),target,dimension(:) :: invA
      integer(c_int),value :: ldinvA
      integer(c_int),value :: batch_count
      !
      rocblas_strtri_batched_rank_1 = rocblas_strtri_batched_orig(handle,uplo,diag,n,c_loc(A),lda,c_loc(invA),ldinvA,batch_count)
    end function

    function rocblas_dtrtri_batched_full_rank(handle,uplo,diag,n,A,lda,invA,ldinvA,batch_count)
      use iso_c_binding
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocblas_dtrtri_batched_full_rank
      type(c_ptr),value :: handle
      integer(kind(rocblas_fill_upper)),value :: uplo
      integer(kind(rocblas_diagonal_non_unit)),value :: diag
      integer(c_int),value :: n
      real(c_double),target,dimension(:,:,:) :: A
      integer(c_int),value :: lda
      real(c_double),target,dimension(:,:,:) :: invA
      integer(c_int),value :: ldinvA
      integer(c_int),value :: batch_count
      !
      rocblas_dtrtri_batched_full_rank = rocblas_dtrtri_batched_orig(handle,uplo,diag,n,c_loc(A),lda,c_loc(invA),ldinvA,batch_count)
    end function

    function rocblas_dtrtri_batched_rank_0(handle,uplo,diag,n,A,lda,invA,ldinvA,batch_count)
      use iso_c_binding
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocblas_dtrtri_batched_rank_0
      type(c_ptr),value :: handle
      integer(kind(rocblas_fill_upper)),value :: uplo
      integer(kind(rocblas_diagonal_non_unit)),value :: diag
      integer(c_int),value :: n
      real(c_double),target :: A
      integer(c_int),value :: lda
      real(c_double),target :: invA
      integer(c_int),value :: ldinvA
      integer(c_int),value :: batch_count
      !
      rocblas_dtrtri_batched_rank_0 = rocblas_dtrtri_batched_orig(handle,uplo,diag,n,c_loc(A),lda,c_loc(invA),ldinvA,batch_count)
    end function

    function rocblas_dtrtri_batched_rank_1(handle,uplo,diag,n,A,lda,invA,ldinvA,batch_count)
      use iso_c_binding
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocblas_dtrtri_batched_rank_1
      type(c_ptr),value :: handle
      integer(kind(rocblas_fill_upper)),value :: uplo
      integer(kind(rocblas_diagonal_non_unit)),value :: diag
      integer(c_int),value :: n
      real(c_double),target,dimension(:) :: A
      integer(c_int),value :: lda
      real(c_double),target,dimension(:) :: invA
      integer(c_int),value :: ldinvA
      integer(c_int),value :: batch_count
      !
      rocblas_dtrtri_batched_rank_1 = rocblas_dtrtri_batched_orig(handle,uplo,diag,n,c_loc(A),lda,c_loc(invA),ldinvA,batch_count)
    end function

    function rocblas_ctrtri_batched_full_rank(handle,uplo,diag,n,A,lda,invA,ldinvA,batch_count)
      use iso_c_binding
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocblas_ctrtri_batched_full_rank
      type(c_ptr),value :: handle
      integer(kind(rocblas_fill_upper)),value :: uplo
      integer(kind(rocblas_diagonal_non_unit)),value :: diag
      integer(c_int),value :: n
      complex(c_float_complex),target,dimension(:,:,:) :: A
      integer(c_int),value :: lda
      complex(c_float_complex),target,dimension(:,:,:) :: invA
      integer(c_int),value :: ldinvA
      integer(c_int),value :: batch_count
      !
      rocblas_ctrtri_batched_full_rank = rocblas_ctrtri_batched_orig(handle,uplo,diag,n,c_loc(A),lda,c_loc(invA),ldinvA,batch_count)
    end function

    function rocblas_ctrtri_batched_rank_0(handle,uplo,diag,n,A,lda,invA,ldinvA,batch_count)
      use iso_c_binding
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocblas_ctrtri_batched_rank_0
      type(c_ptr),value :: handle
      integer(kind(rocblas_fill_upper)),value :: uplo
      integer(kind(rocblas_diagonal_non_unit)),value :: diag
      integer(c_int),value :: n
      complex(c_float_complex),target :: A
      integer(c_int),value :: lda
      complex(c_float_complex),target :: invA
      integer(c_int),value :: ldinvA
      integer(c_int),value :: batch_count
      !
      rocblas_ctrtri_batched_rank_0 = rocblas_ctrtri_batched_orig(handle,uplo,diag,n,c_loc(A),lda,c_loc(invA),ldinvA,batch_count)
    end function

    function rocblas_ctrtri_batched_rank_1(handle,uplo,diag,n,A,lda,invA,ldinvA,batch_count)
      use iso_c_binding
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocblas_ctrtri_batched_rank_1
      type(c_ptr),value :: handle
      integer(kind(rocblas_fill_upper)),value :: uplo
      integer(kind(rocblas_diagonal_non_unit)),value :: diag
      integer(c_int),value :: n
      complex(c_float_complex),target,dimension(:) :: A
      integer(c_int),value :: lda
      complex(c_float_complex),target,dimension(:) :: invA
      integer(c_int),value :: ldinvA
      integer(c_int),value :: batch_count
      !
      rocblas_ctrtri_batched_rank_1 = rocblas_ctrtri_batched_orig(handle,uplo,diag,n,c_loc(A),lda,c_loc(invA),ldinvA,batch_count)
    end function

    function rocblas_ztrtri_batched_full_rank(handle,uplo,diag,n,A,lda,invA,ldinvA,batch_count)
      use iso_c_binding
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocblas_ztrtri_batched_full_rank
      type(c_ptr),value :: handle
      integer(kind(rocblas_fill_upper)),value :: uplo
      integer(kind(rocblas_diagonal_non_unit)),value :: diag
      integer(c_int),value :: n
      complex(c_double_complex),target,dimension(:,:,:) :: A
      integer(c_int),value :: lda
      complex(c_double_complex),target,dimension(:,:,:) :: invA
      integer(c_int),value :: ldinvA
      integer(c_int),value :: batch_count
      !
      rocblas_ztrtri_batched_full_rank = rocblas_ztrtri_batched_orig(handle,uplo,diag,n,c_loc(A),lda,c_loc(invA),ldinvA,batch_count)
    end function

    function rocblas_ztrtri_batched_rank_0(handle,uplo,diag,n,A,lda,invA,ldinvA,batch_count)
      use iso_c_binding
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocblas_ztrtri_batched_rank_0
      type(c_ptr),value :: handle
      integer(kind(rocblas_fill_upper)),value :: uplo
      integer(kind(rocblas_diagonal_non_unit)),value :: diag
      integer(c_int),value :: n
      complex(c_double_complex),target :: A
      integer(c_int),value :: lda
      complex(c_double_complex),target :: invA
      integer(c_int),value :: ldinvA
      integer(c_int),value :: batch_count
      !
      rocblas_ztrtri_batched_rank_0 = rocblas_ztrtri_batched_orig(handle,uplo,diag,n,c_loc(A),lda,c_loc(invA),ldinvA,batch_count)
    end function

    function rocblas_ztrtri_batched_rank_1(handle,uplo,diag,n,A,lda,invA,ldinvA,batch_count)
      use iso_c_binding
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocblas_ztrtri_batched_rank_1
      type(c_ptr),value :: handle
      integer(kind(rocblas_fill_upper)),value :: uplo
      integer(kind(rocblas_diagonal_non_unit)),value :: diag
      integer(c_int),value :: n
      complex(c_double_complex),target,dimension(:) :: A
      integer(c_int),value :: lda
      complex(c_double_complex),target,dimension(:) :: invA
      integer(c_int),value :: ldinvA
      integer(c_int),value :: batch_count
      !
      rocblas_ztrtri_batched_rank_1 = rocblas_ztrtri_batched_orig(handle,uplo,diag,n,c_loc(A),lda,c_loc(invA),ldinvA,batch_count)
    end function

    function rocblas_strtri_strided_batched_full_rank(handle,uplo,diag,n,A,lda,stride_a,invA,ldinvA,stride_invA,batch_count)
      use iso_c_binding
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocblas_strtri_strided_batched_full_rank
      type(c_ptr),value :: handle
      integer(kind(rocblas_fill_upper)),value :: uplo
      integer(kind(rocblas_diagonal_non_unit)),value :: diag
      integer(c_int),value :: n
      real(c_float),target,dimension(:,:) :: A
      integer(c_int),value :: lda
      integer(c_int64_t),value :: stride_a
      real(c_float),target,dimension(:,:) :: invA
      integer(c_int),value :: ldinvA
      integer(c_int64_t),value :: stride_invA
      integer(c_int),value :: batch_count
      !
      rocblas_strtri_strided_batched_full_rank = rocblas_strtri_strided_batched_orig(handle,uplo,diag,n,c_loc(A),lda,stride_a,c_loc(invA),ldinvA,stride_invA,batch_count)
    end function

    function rocblas_strtri_strided_batched_rank_0(handle,uplo,diag,n,A,lda,stride_a,invA,ldinvA,stride_invA,batch_count)
      use iso_c_binding
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocblas_strtri_strided_batched_rank_0
      type(c_ptr),value :: handle
      integer(kind(rocblas_fill_upper)),value :: uplo
      integer(kind(rocblas_diagonal_non_unit)),value :: diag
      integer(c_int),value :: n
      real(c_float),target :: A
      integer(c_int),value :: lda
      integer(c_int64_t),value :: stride_a
      real(c_float),target :: invA
      integer(c_int),value :: ldinvA
      integer(c_int64_t),value :: stride_invA
      integer(c_int),value :: batch_count
      !
      rocblas_strtri_strided_batched_rank_0 = rocblas_strtri_strided_batched_orig(handle,uplo,diag,n,c_loc(A),lda,stride_a,c_loc(invA),ldinvA,stride_invA,batch_count)
    end function

    function rocblas_strtri_strided_batched_rank_1(handle,uplo,diag,n,A,lda,stride_a,invA,ldinvA,stride_invA,batch_count)
      use iso_c_binding
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocblas_strtri_strided_batched_rank_1
      type(c_ptr),value :: handle
      integer(kind(rocblas_fill_upper)),value :: uplo
      integer(kind(rocblas_diagonal_non_unit)),value :: diag
      integer(c_int),value :: n
      real(c_float),target,dimension(:) :: A
      integer(c_int),value :: lda
      integer(c_int64_t),value :: stride_a
      real(c_float),target,dimension(:) :: invA
      integer(c_int),value :: ldinvA
      integer(c_int64_t),value :: stride_invA
      integer(c_int),value :: batch_count
      !
      rocblas_strtri_strided_batched_rank_1 = rocblas_strtri_strided_batched_orig(handle,uplo,diag,n,c_loc(A),lda,stride_a,c_loc(invA),ldinvA,stride_invA,batch_count)
    end function

    function rocblas_dtrtri_strided_batched_full_rank(handle,uplo,diag,n,A,lda,stride_a,invA,ldinvA,stride_invA,batch_count)
      use iso_c_binding
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocblas_dtrtri_strided_batched_full_rank
      type(c_ptr),value :: handle
      integer(kind(rocblas_fill_upper)),value :: uplo
      integer(kind(rocblas_diagonal_non_unit)),value :: diag
      integer(c_int),value :: n
      real(c_double),target,dimension(:,:) :: A
      integer(c_int),value :: lda
      integer(c_int64_t),value :: stride_a
      real(c_double),target,dimension(:,:) :: invA
      integer(c_int),value :: ldinvA
      integer(c_int64_t),value :: stride_invA
      integer(c_int),value :: batch_count
      !
      rocblas_dtrtri_strided_batched_full_rank = rocblas_dtrtri_strided_batched_orig(handle,uplo,diag,n,c_loc(A),lda,stride_a,c_loc(invA),ldinvA,stride_invA,batch_count)
    end function

    function rocblas_dtrtri_strided_batched_rank_0(handle,uplo,diag,n,A,lda,stride_a,invA,ldinvA,stride_invA,batch_count)
      use iso_c_binding
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocblas_dtrtri_strided_batched_rank_0
      type(c_ptr),value :: handle
      integer(kind(rocblas_fill_upper)),value :: uplo
      integer(kind(rocblas_diagonal_non_unit)),value :: diag
      integer(c_int),value :: n
      real(c_double),target :: A
      integer(c_int),value :: lda
      integer(c_int64_t),value :: stride_a
      real(c_double),target :: invA
      integer(c_int),value :: ldinvA
      integer(c_int64_t),value :: stride_invA
      integer(c_int),value :: batch_count
      !
      rocblas_dtrtri_strided_batched_rank_0 = rocblas_dtrtri_strided_batched_orig(handle,uplo,diag,n,c_loc(A),lda,stride_a,c_loc(invA),ldinvA,stride_invA,batch_count)
    end function

    function rocblas_dtrtri_strided_batched_rank_1(handle,uplo,diag,n,A,lda,stride_a,invA,ldinvA,stride_invA,batch_count)
      use iso_c_binding
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocblas_dtrtri_strided_batched_rank_1
      type(c_ptr),value :: handle
      integer(kind(rocblas_fill_upper)),value :: uplo
      integer(kind(rocblas_diagonal_non_unit)),value :: diag
      integer(c_int),value :: n
      real(c_double),target,dimension(:) :: A
      integer(c_int),value :: lda
      integer(c_int64_t),value :: stride_a
      real(c_double),target,dimension(:) :: invA
      integer(c_int),value :: ldinvA
      integer(c_int64_t),value :: stride_invA
      integer(c_int),value :: batch_count
      !
      rocblas_dtrtri_strided_batched_rank_1 = rocblas_dtrtri_strided_batched_orig(handle,uplo,diag,n,c_loc(A),lda,stride_a,c_loc(invA),ldinvA,stride_invA,batch_count)
    end function

    function rocblas_ctrtri_strided_batched_full_rank(handle,uplo,diag,n,A,lda,stride_a,invA,ldinvA,stride_invA,batch_count)
      use iso_c_binding
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocblas_ctrtri_strided_batched_full_rank
      type(c_ptr),value :: handle
      integer(kind(rocblas_fill_upper)),value :: uplo
      integer(kind(rocblas_diagonal_non_unit)),value :: diag
      integer(c_int),value :: n
      complex(c_float_complex),target,dimension(:,:) :: A
      integer(c_int),value :: lda
      integer(c_int64_t),value :: stride_a
      complex(c_float_complex),target,dimension(:,:) :: invA
      integer(c_int),value :: ldinvA
      integer(c_int64_t),value :: stride_invA
      integer(c_int),value :: batch_count
      !
      rocblas_ctrtri_strided_batched_full_rank = rocblas_ctrtri_strided_batched_orig(handle,uplo,diag,n,c_loc(A),lda,stride_a,c_loc(invA),ldinvA,stride_invA,batch_count)
    end function

    function rocblas_ctrtri_strided_batched_rank_0(handle,uplo,diag,n,A,lda,stride_a,invA,ldinvA,stride_invA,batch_count)
      use iso_c_binding
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocblas_ctrtri_strided_batched_rank_0
      type(c_ptr),value :: handle
      integer(kind(rocblas_fill_upper)),value :: uplo
      integer(kind(rocblas_diagonal_non_unit)),value :: diag
      integer(c_int),value :: n
      complex(c_float_complex),target :: A
      integer(c_int),value :: lda
      integer(c_int64_t),value :: stride_a
      complex(c_float_complex),target :: invA
      integer(c_int),value :: ldinvA
      integer(c_int64_t),value :: stride_invA
      integer(c_int),value :: batch_count
      !
      rocblas_ctrtri_strided_batched_rank_0 = rocblas_ctrtri_strided_batched_orig(handle,uplo,diag,n,c_loc(A),lda,stride_a,c_loc(invA),ldinvA,stride_invA,batch_count)
    end function

    function rocblas_ctrtri_strided_batched_rank_1(handle,uplo,diag,n,A,lda,stride_a,invA,ldinvA,stride_invA,batch_count)
      use iso_c_binding
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocblas_ctrtri_strided_batched_rank_1
      type(c_ptr),value :: handle
      integer(kind(rocblas_fill_upper)),value :: uplo
      integer(kind(rocblas_diagonal_non_unit)),value :: diag
      integer(c_int),value :: n
      complex(c_float_complex),target,dimension(:) :: A
      integer(c_int),value :: lda
      integer(c_int64_t),value :: stride_a
      complex(c_float_complex),target,dimension(:) :: invA
      integer(c_int),value :: ldinvA
      integer(c_int64_t),value :: stride_invA
      integer(c_int),value :: batch_count
      !
      rocblas_ctrtri_strided_batched_rank_1 = rocblas_ctrtri_strided_batched_orig(handle,uplo,diag,n,c_loc(A),lda,stride_a,c_loc(invA),ldinvA,stride_invA,batch_count)
    end function

    function rocblas_ztrtri_strided_batched_full_rank(handle,uplo,diag,n,A,lda,stride_a,invA,ldinvA,stride_invA,batch_count)
      use iso_c_binding
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocblas_ztrtri_strided_batched_full_rank
      type(c_ptr),value :: handle
      integer(kind(rocblas_fill_upper)),value :: uplo
      integer(kind(rocblas_diagonal_non_unit)),value :: diag
      integer(c_int),value :: n
      complex(c_double_complex),target,dimension(:,:) :: A
      integer(c_int),value :: lda
      integer(c_int64_t),value :: stride_a
      complex(c_double_complex),target,dimension(:,:) :: invA
      integer(c_int),value :: ldinvA
      integer(c_int64_t),value :: stride_invA
      integer(c_int),value :: batch_count
      !
      rocblas_ztrtri_strided_batched_full_rank = rocblas_ztrtri_strided_batched_orig(handle,uplo,diag,n,c_loc(A),lda,stride_a,c_loc(invA),ldinvA,stride_invA,batch_count)
    end function

    function rocblas_ztrtri_strided_batched_rank_0(handle,uplo,diag,n,A,lda,stride_a,invA,ldinvA,stride_invA,batch_count)
      use iso_c_binding
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocblas_ztrtri_strided_batched_rank_0
      type(c_ptr),value :: handle
      integer(kind(rocblas_fill_upper)),value :: uplo
      integer(kind(rocblas_diagonal_non_unit)),value :: diag
      integer(c_int),value :: n
      complex(c_double_complex),target :: A
      integer(c_int),value :: lda
      integer(c_int64_t),value :: stride_a
      complex(c_double_complex),target :: invA
      integer(c_int),value :: ldinvA
      integer(c_int64_t),value :: stride_invA
      integer(c_int),value :: batch_count
      !
      rocblas_ztrtri_strided_batched_rank_0 = rocblas_ztrtri_strided_batched_orig(handle,uplo,diag,n,c_loc(A),lda,stride_a,c_loc(invA),ldinvA,stride_invA,batch_count)
    end function

    function rocblas_ztrtri_strided_batched_rank_1(handle,uplo,diag,n,A,lda,stride_a,invA,ldinvA,stride_invA,batch_count)
      use iso_c_binding
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocblas_ztrtri_strided_batched_rank_1
      type(c_ptr),value :: handle
      integer(kind(rocblas_fill_upper)),value :: uplo
      integer(kind(rocblas_diagonal_non_unit)),value :: diag
      integer(c_int),value :: n
      complex(c_double_complex),target,dimension(:) :: A
      integer(c_int),value :: lda
      integer(c_int64_t),value :: stride_a
      complex(c_double_complex),target,dimension(:) :: invA
      integer(c_int),value :: ldinvA
      integer(c_int64_t),value :: stride_invA
      integer(c_int),value :: batch_count
      !
      rocblas_ztrtri_strided_batched_rank_1 = rocblas_ztrtri_strided_batched_orig(handle,uplo,diag,n,c_loc(A),lda,stride_a,c_loc(invA),ldinvA,stride_invA,batch_count)
    end function

    function rocblas_strsm_full_rank(handle,side,uplo,transA,diag,m,n,alpha,A,lda,B,ldb)
      use iso_c_binding
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocblas_strsm_full_rank
      type(c_ptr),value :: handle
      integer(kind(rocblas_side_left)),value :: side
      integer(kind(rocblas_fill_upper)),value :: uplo
      integer(kind(rocblas_operation_none)),value :: transA
      integer(kind(rocblas_diagonal_non_unit)),value :: diag
      integer(c_int),value :: m
      integer(c_int),value :: n
      real(c_float) :: alpha
      real(c_float),target,dimension(:,:) :: A
      integer(c_int),value :: lda
      real(c_float),target,dimension(:,:) :: B
      integer(c_int),value :: ldb
      !
      rocblas_strsm_full_rank = rocblas_strsm_orig(handle,side,uplo,transA,diag,m,n,alpha,c_loc(A),lda,c_loc(B),ldb)
    end function

    function rocblas_strsm_rank_0(handle,side,uplo,transA,diag,m,n,alpha,A,lda,B,ldb)
      use iso_c_binding
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocblas_strsm_rank_0
      type(c_ptr),value :: handle
      integer(kind(rocblas_side_left)),value :: side
      integer(kind(rocblas_fill_upper)),value :: uplo
      integer(kind(rocblas_operation_none)),value :: transA
      integer(kind(rocblas_diagonal_non_unit)),value :: diag
      integer(c_int),value :: m
      integer(c_int),value :: n
      real(c_float) :: alpha
      real(c_float),target :: A
      integer(c_int),value :: lda
      real(c_float),target :: B
      integer(c_int),value :: ldb
      !
      rocblas_strsm_rank_0 = rocblas_strsm_orig(handle,side,uplo,transA,diag,m,n,alpha,c_loc(A),lda,c_loc(B),ldb)
    end function

    function rocblas_strsm_rank_1(handle,side,uplo,transA,diag,m,n,alpha,A,lda,B,ldb)
      use iso_c_binding
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocblas_strsm_rank_1
      type(c_ptr),value :: handle
      integer(kind(rocblas_side_left)),value :: side
      integer(kind(rocblas_fill_upper)),value :: uplo
      integer(kind(rocblas_operation_none)),value :: transA
      integer(kind(rocblas_diagonal_non_unit)),value :: diag
      integer(c_int),value :: m
      integer(c_int),value :: n
      real(c_float) :: alpha
      real(c_float),target,dimension(:) :: A
      integer(c_int),value :: lda
      real(c_float),target,dimension(:) :: B
      integer(c_int),value :: ldb
      !
      rocblas_strsm_rank_1 = rocblas_strsm_orig(handle,side,uplo,transA,diag,m,n,alpha,c_loc(A),lda,c_loc(B),ldb)
    end function

    function rocblas_dtrsm_full_rank(handle,side,uplo,transA,diag,m,n,alpha,A,lda,B,ldb)
      use iso_c_binding
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocblas_dtrsm_full_rank
      type(c_ptr),value :: handle
      integer(kind(rocblas_side_left)),value :: side
      integer(kind(rocblas_fill_upper)),value :: uplo
      integer(kind(rocblas_operation_none)),value :: transA
      integer(kind(rocblas_diagonal_non_unit)),value :: diag
      integer(c_int),value :: m
      integer(c_int),value :: n
      real(c_double) :: alpha
      real(c_double),target,dimension(:,:) :: A
      integer(c_int),value :: lda
      real(c_double),target,dimension(:,:) :: B
      integer(c_int),value :: ldb
      !
      rocblas_dtrsm_full_rank = rocblas_dtrsm_orig(handle,side,uplo,transA,diag,m,n,alpha,c_loc(A),lda,c_loc(B),ldb)
    end function

    function rocblas_dtrsm_rank_0(handle,side,uplo,transA,diag,m,n,alpha,A,lda,B,ldb)
      use iso_c_binding
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocblas_dtrsm_rank_0
      type(c_ptr),value :: handle
      integer(kind(rocblas_side_left)),value :: side
      integer(kind(rocblas_fill_upper)),value :: uplo
      integer(kind(rocblas_operation_none)),value :: transA
      integer(kind(rocblas_diagonal_non_unit)),value :: diag
      integer(c_int),value :: m
      integer(c_int),value :: n
      real(c_double) :: alpha
      real(c_double),target :: A
      integer(c_int),value :: lda
      real(c_double),target :: B
      integer(c_int),value :: ldb
      !
      rocblas_dtrsm_rank_0 = rocblas_dtrsm_orig(handle,side,uplo,transA,diag,m,n,alpha,c_loc(A),lda,c_loc(B),ldb)
    end function

    function rocblas_dtrsm_rank_1(handle,side,uplo,transA,diag,m,n,alpha,A,lda,B,ldb)
      use iso_c_binding
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocblas_dtrsm_rank_1
      type(c_ptr),value :: handle
      integer(kind(rocblas_side_left)),value :: side
      integer(kind(rocblas_fill_upper)),value :: uplo
      integer(kind(rocblas_operation_none)),value :: transA
      integer(kind(rocblas_diagonal_non_unit)),value :: diag
      integer(c_int),value :: m
      integer(c_int),value :: n
      real(c_double) :: alpha
      real(c_double),target,dimension(:) :: A
      integer(c_int),value :: lda
      real(c_double),target,dimension(:) :: B
      integer(c_int),value :: ldb
      !
      rocblas_dtrsm_rank_1 = rocblas_dtrsm_orig(handle,side,uplo,transA,diag,m,n,alpha,c_loc(A),lda,c_loc(B),ldb)
    end function

    function rocblas_ctrsm_full_rank(handle,side,uplo,transA,diag,m,n,alpha,A,lda,B,ldb)
      use iso_c_binding
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocblas_ctrsm_full_rank
      type(c_ptr),value :: handle
      integer(kind(rocblas_side_left)),value :: side
      integer(kind(rocblas_fill_upper)),value :: uplo
      integer(kind(rocblas_operation_none)),value :: transA
      integer(kind(rocblas_diagonal_non_unit)),value :: diag
      integer(c_int),value :: m
      integer(c_int),value :: n
      complex(c_float_complex) :: alpha
      complex(c_float_complex),target,dimension(:,:) :: A
      integer(c_int),value :: lda
      complex(c_float_complex),target,dimension(:,:) :: B
      integer(c_int),value :: ldb
      !
      rocblas_ctrsm_full_rank = rocblas_ctrsm_orig(handle,side,uplo,transA,diag,m,n,alpha,c_loc(A),lda,c_loc(B),ldb)
    end function

    function rocblas_ctrsm_rank_0(handle,side,uplo,transA,diag,m,n,alpha,A,lda,B,ldb)
      use iso_c_binding
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocblas_ctrsm_rank_0
      type(c_ptr),value :: handle
      integer(kind(rocblas_side_left)),value :: side
      integer(kind(rocblas_fill_upper)),value :: uplo
      integer(kind(rocblas_operation_none)),value :: transA
      integer(kind(rocblas_diagonal_non_unit)),value :: diag
      integer(c_int),value :: m
      integer(c_int),value :: n
      complex(c_float_complex) :: alpha
      complex(c_float_complex),target :: A
      integer(c_int),value :: lda
      complex(c_float_complex),target :: B
      integer(c_int),value :: ldb
      !
      rocblas_ctrsm_rank_0 = rocblas_ctrsm_orig(handle,side,uplo,transA,diag,m,n,alpha,c_loc(A),lda,c_loc(B),ldb)
    end function

    function rocblas_ctrsm_rank_1(handle,side,uplo,transA,diag,m,n,alpha,A,lda,B,ldb)
      use iso_c_binding
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocblas_ctrsm_rank_1
      type(c_ptr),value :: handle
      integer(kind(rocblas_side_left)),value :: side
      integer(kind(rocblas_fill_upper)),value :: uplo
      integer(kind(rocblas_operation_none)),value :: transA
      integer(kind(rocblas_diagonal_non_unit)),value :: diag
      integer(c_int),value :: m
      integer(c_int),value :: n
      complex(c_float_complex) :: alpha
      complex(c_float_complex),target,dimension(:) :: A
      integer(c_int),value :: lda
      complex(c_float_complex),target,dimension(:) :: B
      integer(c_int),value :: ldb
      !
      rocblas_ctrsm_rank_1 = rocblas_ctrsm_orig(handle,side,uplo,transA,diag,m,n,alpha,c_loc(A),lda,c_loc(B),ldb)
    end function

    function rocblas_ztrsm_full_rank(handle,side,uplo,transA,diag,m,n,alpha,A,lda,B,ldb)
      use iso_c_binding
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocblas_ztrsm_full_rank
      type(c_ptr),value :: handle
      integer(kind(rocblas_side_left)),value :: side
      integer(kind(rocblas_fill_upper)),value :: uplo
      integer(kind(rocblas_operation_none)),value :: transA
      integer(kind(rocblas_diagonal_non_unit)),value :: diag
      integer(c_int),value :: m
      integer(c_int),value :: n
      complex(c_double_complex) :: alpha
      complex(c_double_complex),target,dimension(:,:) :: A
      integer(c_int),value :: lda
      complex(c_double_complex),target,dimension(:,:) :: B
      integer(c_int),value :: ldb
      !
      rocblas_ztrsm_full_rank = rocblas_ztrsm_orig(handle,side,uplo,transA,diag,m,n,alpha,c_loc(A),lda,c_loc(B),ldb)
    end function

    function rocblas_ztrsm_rank_0(handle,side,uplo,transA,diag,m,n,alpha,A,lda,B,ldb)
      use iso_c_binding
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocblas_ztrsm_rank_0
      type(c_ptr),value :: handle
      integer(kind(rocblas_side_left)),value :: side
      integer(kind(rocblas_fill_upper)),value :: uplo
      integer(kind(rocblas_operation_none)),value :: transA
      integer(kind(rocblas_diagonal_non_unit)),value :: diag
      integer(c_int),value :: m
      integer(c_int),value :: n
      complex(c_double_complex) :: alpha
      complex(c_double_complex),target :: A
      integer(c_int),value :: lda
      complex(c_double_complex),target :: B
      integer(c_int),value :: ldb
      !
      rocblas_ztrsm_rank_0 = rocblas_ztrsm_orig(handle,side,uplo,transA,diag,m,n,alpha,c_loc(A),lda,c_loc(B),ldb)
    end function

    function rocblas_ztrsm_rank_1(handle,side,uplo,transA,diag,m,n,alpha,A,lda,B,ldb)
      use iso_c_binding
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocblas_ztrsm_rank_1
      type(c_ptr),value :: handle
      integer(kind(rocblas_side_left)),value :: side
      integer(kind(rocblas_fill_upper)),value :: uplo
      integer(kind(rocblas_operation_none)),value :: transA
      integer(kind(rocblas_diagonal_non_unit)),value :: diag
      integer(c_int),value :: m
      integer(c_int),value :: n
      complex(c_double_complex) :: alpha
      complex(c_double_complex),target,dimension(:) :: A
      integer(c_int),value :: lda
      complex(c_double_complex),target,dimension(:) :: B
      integer(c_int),value :: ldb
      !
      rocblas_ztrsm_rank_1 = rocblas_ztrsm_orig(handle,side,uplo,transA,diag,m,n,alpha,c_loc(A),lda,c_loc(B),ldb)
    end function

    function rocblas_strsm_batched_full_rank(handle,side,uplo,transA,diag,m,n,alpha,A,lda,B,ldb,batch_count)
      use iso_c_binding
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocblas_strsm_batched_full_rank
      type(c_ptr),value :: handle
      integer(kind(rocblas_side_left)),value :: side
      integer(kind(rocblas_fill_upper)),value :: uplo
      integer(kind(rocblas_operation_none)),value :: transA
      integer(kind(rocblas_diagonal_non_unit)),value :: diag
      integer(c_int),value :: m
      integer(c_int),value :: n
      real(c_float) :: alpha
      real(c_float),target,dimension(:,:,:) :: A
      integer(c_int),value :: lda
      real(c_float),target,dimension(:,:,:) :: B
      integer(c_int),value :: ldb
      integer(c_int),value :: batch_count
      !
      rocblas_strsm_batched_full_rank = rocblas_strsm_batched_orig(handle,side,uplo,transA,diag,m,n,alpha,c_loc(A),lda,c_loc(B),ldb,batch_count)
    end function

    function rocblas_strsm_batched_rank_0(handle,side,uplo,transA,diag,m,n,alpha,A,lda,B,ldb,batch_count)
      use iso_c_binding
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocblas_strsm_batched_rank_0
      type(c_ptr),value :: handle
      integer(kind(rocblas_side_left)),value :: side
      integer(kind(rocblas_fill_upper)),value :: uplo
      integer(kind(rocblas_operation_none)),value :: transA
      integer(kind(rocblas_diagonal_non_unit)),value :: diag
      integer(c_int),value :: m
      integer(c_int),value :: n
      real(c_float) :: alpha
      real(c_float),target :: A
      integer(c_int),value :: lda
      real(c_float),target :: B
      integer(c_int),value :: ldb
      integer(c_int),value :: batch_count
      !
      rocblas_strsm_batched_rank_0 = rocblas_strsm_batched_orig(handle,side,uplo,transA,diag,m,n,alpha,c_loc(A),lda,c_loc(B),ldb,batch_count)
    end function

    function rocblas_strsm_batched_rank_1(handle,side,uplo,transA,diag,m,n,alpha,A,lda,B,ldb,batch_count)
      use iso_c_binding
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocblas_strsm_batched_rank_1
      type(c_ptr),value :: handle
      integer(kind(rocblas_side_left)),value :: side
      integer(kind(rocblas_fill_upper)),value :: uplo
      integer(kind(rocblas_operation_none)),value :: transA
      integer(kind(rocblas_diagonal_non_unit)),value :: diag
      integer(c_int),value :: m
      integer(c_int),value :: n
      real(c_float) :: alpha
      real(c_float),target,dimension(:) :: A
      integer(c_int),value :: lda
      real(c_float),target,dimension(:) :: B
      integer(c_int),value :: ldb
      integer(c_int),value :: batch_count
      !
      rocblas_strsm_batched_rank_1 = rocblas_strsm_batched_orig(handle,side,uplo,transA,diag,m,n,alpha,c_loc(A),lda,c_loc(B),ldb,batch_count)
    end function

    function rocblas_dtrsm_batched_full_rank(handle,side,uplo,transA,diag,m,n,alpha,A,lda,B,ldb,batch_count)
      use iso_c_binding
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocblas_dtrsm_batched_full_rank
      type(c_ptr),value :: handle
      integer(kind(rocblas_side_left)),value :: side
      integer(kind(rocblas_fill_upper)),value :: uplo
      integer(kind(rocblas_operation_none)),value :: transA
      integer(kind(rocblas_diagonal_non_unit)),value :: diag
      integer(c_int),value :: m
      integer(c_int),value :: n
      real(c_double) :: alpha
      real(c_double),target,dimension(:,:,:) :: A
      integer(c_int),value :: lda
      real(c_double),target,dimension(:,:,:) :: B
      integer(c_int),value :: ldb
      integer(c_int),value :: batch_count
      !
      rocblas_dtrsm_batched_full_rank = rocblas_dtrsm_batched_orig(handle,side,uplo,transA,diag,m,n,alpha,c_loc(A),lda,c_loc(B),ldb,batch_count)
    end function

    function rocblas_dtrsm_batched_rank_0(handle,side,uplo,transA,diag,m,n,alpha,A,lda,B,ldb,batch_count)
      use iso_c_binding
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocblas_dtrsm_batched_rank_0
      type(c_ptr),value :: handle
      integer(kind(rocblas_side_left)),value :: side
      integer(kind(rocblas_fill_upper)),value :: uplo
      integer(kind(rocblas_operation_none)),value :: transA
      integer(kind(rocblas_diagonal_non_unit)),value :: diag
      integer(c_int),value :: m
      integer(c_int),value :: n
      real(c_double) :: alpha
      real(c_double),target :: A
      integer(c_int),value :: lda
      real(c_double),target :: B
      integer(c_int),value :: ldb
      integer(c_int),value :: batch_count
      !
      rocblas_dtrsm_batched_rank_0 = rocblas_dtrsm_batched_orig(handle,side,uplo,transA,diag,m,n,alpha,c_loc(A),lda,c_loc(B),ldb,batch_count)
    end function

    function rocblas_dtrsm_batched_rank_1(handle,side,uplo,transA,diag,m,n,alpha,A,lda,B,ldb,batch_count)
      use iso_c_binding
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocblas_dtrsm_batched_rank_1
      type(c_ptr),value :: handle
      integer(kind(rocblas_side_left)),value :: side
      integer(kind(rocblas_fill_upper)),value :: uplo
      integer(kind(rocblas_operation_none)),value :: transA
      integer(kind(rocblas_diagonal_non_unit)),value :: diag
      integer(c_int),value :: m
      integer(c_int),value :: n
      real(c_double) :: alpha
      real(c_double),target,dimension(:) :: A
      integer(c_int),value :: lda
      real(c_double),target,dimension(:) :: B
      integer(c_int),value :: ldb
      integer(c_int),value :: batch_count
      !
      rocblas_dtrsm_batched_rank_1 = rocblas_dtrsm_batched_orig(handle,side,uplo,transA,diag,m,n,alpha,c_loc(A),lda,c_loc(B),ldb,batch_count)
    end function

    function rocblas_ctrsm_batched_full_rank(handle,side,uplo,transA,diag,m,n,alpha,A,lda,B,ldb,batch_count)
      use iso_c_binding
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocblas_ctrsm_batched_full_rank
      type(c_ptr),value :: handle
      integer(kind(rocblas_side_left)),value :: side
      integer(kind(rocblas_fill_upper)),value :: uplo
      integer(kind(rocblas_operation_none)),value :: transA
      integer(kind(rocblas_diagonal_non_unit)),value :: diag
      integer(c_int),value :: m
      integer(c_int),value :: n
      complex(c_float_complex) :: alpha
      complex(c_float_complex),target,dimension(:,:,:) :: A
      integer(c_int),value :: lda
      complex(c_float_complex),target,dimension(:,:,:) :: B
      integer(c_int),value :: ldb
      integer(c_int),value :: batch_count
      !
      rocblas_ctrsm_batched_full_rank = rocblas_ctrsm_batched_orig(handle,side,uplo,transA,diag,m,n,alpha,c_loc(A),lda,c_loc(B),ldb,batch_count)
    end function

    function rocblas_ctrsm_batched_rank_0(handle,side,uplo,transA,diag,m,n,alpha,A,lda,B,ldb,batch_count)
      use iso_c_binding
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocblas_ctrsm_batched_rank_0
      type(c_ptr),value :: handle
      integer(kind(rocblas_side_left)),value :: side
      integer(kind(rocblas_fill_upper)),value :: uplo
      integer(kind(rocblas_operation_none)),value :: transA
      integer(kind(rocblas_diagonal_non_unit)),value :: diag
      integer(c_int),value :: m
      integer(c_int),value :: n
      complex(c_float_complex) :: alpha
      complex(c_float_complex),target :: A
      integer(c_int),value :: lda
      complex(c_float_complex),target :: B
      integer(c_int),value :: ldb
      integer(c_int),value :: batch_count
      !
      rocblas_ctrsm_batched_rank_0 = rocblas_ctrsm_batched_orig(handle,side,uplo,transA,diag,m,n,alpha,c_loc(A),lda,c_loc(B),ldb,batch_count)
    end function

    function rocblas_ctrsm_batched_rank_1(handle,side,uplo,transA,diag,m,n,alpha,A,lda,B,ldb,batch_count)
      use iso_c_binding
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocblas_ctrsm_batched_rank_1
      type(c_ptr),value :: handle
      integer(kind(rocblas_side_left)),value :: side
      integer(kind(rocblas_fill_upper)),value :: uplo
      integer(kind(rocblas_operation_none)),value :: transA
      integer(kind(rocblas_diagonal_non_unit)),value :: diag
      integer(c_int),value :: m
      integer(c_int),value :: n
      complex(c_float_complex) :: alpha
      complex(c_float_complex),target,dimension(:) :: A
      integer(c_int),value :: lda
      complex(c_float_complex),target,dimension(:) :: B
      integer(c_int),value :: ldb
      integer(c_int),value :: batch_count
      !
      rocblas_ctrsm_batched_rank_1 = rocblas_ctrsm_batched_orig(handle,side,uplo,transA,diag,m,n,alpha,c_loc(A),lda,c_loc(B),ldb,batch_count)
    end function

    function rocblas_ztrsm_batched_full_rank(handle,side,uplo,transA,diag,m,n,alpha,A,lda,B,ldb,batch_count)
      use iso_c_binding
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocblas_ztrsm_batched_full_rank
      type(c_ptr),value :: handle
      integer(kind(rocblas_side_left)),value :: side
      integer(kind(rocblas_fill_upper)),value :: uplo
      integer(kind(rocblas_operation_none)),value :: transA
      integer(kind(rocblas_diagonal_non_unit)),value :: diag
      integer(c_int),value :: m
      integer(c_int),value :: n
      complex(c_double_complex) :: alpha
      complex(c_double_complex),target,dimension(:,:,:) :: A
      integer(c_int),value :: lda
      complex(c_double_complex),target,dimension(:,:,:) :: B
      integer(c_int),value :: ldb
      integer(c_int),value :: batch_count
      !
      rocblas_ztrsm_batched_full_rank = rocblas_ztrsm_batched_orig(handle,side,uplo,transA,diag,m,n,alpha,c_loc(A),lda,c_loc(B),ldb,batch_count)
    end function

    function rocblas_ztrsm_batched_rank_0(handle,side,uplo,transA,diag,m,n,alpha,A,lda,B,ldb,batch_count)
      use iso_c_binding
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocblas_ztrsm_batched_rank_0
      type(c_ptr),value :: handle
      integer(kind(rocblas_side_left)),value :: side
      integer(kind(rocblas_fill_upper)),value :: uplo
      integer(kind(rocblas_operation_none)),value :: transA
      integer(kind(rocblas_diagonal_non_unit)),value :: diag
      integer(c_int),value :: m
      integer(c_int),value :: n
      complex(c_double_complex) :: alpha
      complex(c_double_complex),target :: A
      integer(c_int),value :: lda
      complex(c_double_complex),target :: B
      integer(c_int),value :: ldb
      integer(c_int),value :: batch_count
      !
      rocblas_ztrsm_batched_rank_0 = rocblas_ztrsm_batched_orig(handle,side,uplo,transA,diag,m,n,alpha,c_loc(A),lda,c_loc(B),ldb,batch_count)
    end function

    function rocblas_ztrsm_batched_rank_1(handle,side,uplo,transA,diag,m,n,alpha,A,lda,B,ldb,batch_count)
      use iso_c_binding
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocblas_ztrsm_batched_rank_1
      type(c_ptr),value :: handle
      integer(kind(rocblas_side_left)),value :: side
      integer(kind(rocblas_fill_upper)),value :: uplo
      integer(kind(rocblas_operation_none)),value :: transA
      integer(kind(rocblas_diagonal_non_unit)),value :: diag
      integer(c_int),value :: m
      integer(c_int),value :: n
      complex(c_double_complex) :: alpha
      complex(c_double_complex),target,dimension(:) :: A
      integer(c_int),value :: lda
      complex(c_double_complex),target,dimension(:) :: B
      integer(c_int),value :: ldb
      integer(c_int),value :: batch_count
      !
      rocblas_ztrsm_batched_rank_1 = rocblas_ztrsm_batched_orig(handle,side,uplo,transA,diag,m,n,alpha,c_loc(A),lda,c_loc(B),ldb,batch_count)
    end function

    function rocblas_strsm_strided_batched_full_rank(handle,side,uplo,transA,diag,m,n,alpha,A,lda,stride_a,B,ldb,stride_b,batch_count)
      use iso_c_binding
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocblas_strsm_strided_batched_full_rank
      type(c_ptr),value :: handle
      integer(kind(rocblas_side_left)),value :: side
      integer(kind(rocblas_fill_upper)),value :: uplo
      integer(kind(rocblas_operation_none)),value :: transA
      integer(kind(rocblas_diagonal_non_unit)),value :: diag
      integer(c_int),value :: m
      integer(c_int),value :: n
      real(c_float) :: alpha
      real(c_float),target,dimension(:,:) :: A
      integer(c_int),value :: lda
      integer(c_int64_t),value :: stride_a
      real(c_float),target,dimension(:,:) :: B
      integer(c_int),value :: ldb
      integer(c_int64_t),value :: stride_b
      integer(c_int),value :: batch_count
      !
      rocblas_strsm_strided_batched_full_rank = rocblas_strsm_strided_batched_orig(handle,side,uplo,transA,diag,m,n,alpha,c_loc(A),lda,stride_a,c_loc(B),ldb,stride_b,batch_count)
    end function

    function rocblas_strsm_strided_batched_rank_0(handle,side,uplo,transA,diag,m,n,alpha,A,lda,stride_a,B,ldb,stride_b,batch_count)
      use iso_c_binding
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocblas_strsm_strided_batched_rank_0
      type(c_ptr),value :: handle
      integer(kind(rocblas_side_left)),value :: side
      integer(kind(rocblas_fill_upper)),value :: uplo
      integer(kind(rocblas_operation_none)),value :: transA
      integer(kind(rocblas_diagonal_non_unit)),value :: diag
      integer(c_int),value :: m
      integer(c_int),value :: n
      real(c_float) :: alpha
      real(c_float),target :: A
      integer(c_int),value :: lda
      integer(c_int64_t),value :: stride_a
      real(c_float),target :: B
      integer(c_int),value :: ldb
      integer(c_int64_t),value :: stride_b
      integer(c_int),value :: batch_count
      !
      rocblas_strsm_strided_batched_rank_0 = rocblas_strsm_strided_batched_orig(handle,side,uplo,transA,diag,m,n,alpha,c_loc(A),lda,stride_a,c_loc(B),ldb,stride_b,batch_count)
    end function

    function rocblas_strsm_strided_batched_rank_1(handle,side,uplo,transA,diag,m,n,alpha,A,lda,stride_a,B,ldb,stride_b,batch_count)
      use iso_c_binding
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocblas_strsm_strided_batched_rank_1
      type(c_ptr),value :: handle
      integer(kind(rocblas_side_left)),value :: side
      integer(kind(rocblas_fill_upper)),value :: uplo
      integer(kind(rocblas_operation_none)),value :: transA
      integer(kind(rocblas_diagonal_non_unit)),value :: diag
      integer(c_int),value :: m
      integer(c_int),value :: n
      real(c_float) :: alpha
      real(c_float),target,dimension(:) :: A
      integer(c_int),value :: lda
      integer(c_int64_t),value :: stride_a
      real(c_float),target,dimension(:) :: B
      integer(c_int),value :: ldb
      integer(c_int64_t),value :: stride_b
      integer(c_int),value :: batch_count
      !
      rocblas_strsm_strided_batched_rank_1 = rocblas_strsm_strided_batched_orig(handle,side,uplo,transA,diag,m,n,alpha,c_loc(A),lda,stride_a,c_loc(B),ldb,stride_b,batch_count)
    end function

    function rocblas_dtrsm_strided_batched_full_rank(handle,side,uplo,transA,diag,m,n,alpha,A,lda,stride_a,B,ldb,stride_b,batch_count)
      use iso_c_binding
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocblas_dtrsm_strided_batched_full_rank
      type(c_ptr),value :: handle
      integer(kind(rocblas_side_left)),value :: side
      integer(kind(rocblas_fill_upper)),value :: uplo
      integer(kind(rocblas_operation_none)),value :: transA
      integer(kind(rocblas_diagonal_non_unit)),value :: diag
      integer(c_int),value :: m
      integer(c_int),value :: n
      real(c_double) :: alpha
      real(c_double),target,dimension(:,:) :: A
      integer(c_int),value :: lda
      integer(c_int64_t),value :: stride_a
      real(c_double),target,dimension(:,:) :: B
      integer(c_int),value :: ldb
      integer(c_int64_t),value :: stride_b
      integer(c_int),value :: batch_count
      !
      rocblas_dtrsm_strided_batched_full_rank = rocblas_dtrsm_strided_batched_orig(handle,side,uplo,transA,diag,m,n,alpha,c_loc(A),lda,stride_a,c_loc(B),ldb,stride_b,batch_count)
    end function

    function rocblas_dtrsm_strided_batched_rank_0(handle,side,uplo,transA,diag,m,n,alpha,A,lda,stride_a,B,ldb,stride_b,batch_count)
      use iso_c_binding
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocblas_dtrsm_strided_batched_rank_0
      type(c_ptr),value :: handle
      integer(kind(rocblas_side_left)),value :: side
      integer(kind(rocblas_fill_upper)),value :: uplo
      integer(kind(rocblas_operation_none)),value :: transA
      integer(kind(rocblas_diagonal_non_unit)),value :: diag
      integer(c_int),value :: m
      integer(c_int),value :: n
      real(c_double) :: alpha
      real(c_double),target :: A
      integer(c_int),value :: lda
      integer(c_int64_t),value :: stride_a
      real(c_double),target :: B
      integer(c_int),value :: ldb
      integer(c_int64_t),value :: stride_b
      integer(c_int),value :: batch_count
      !
      rocblas_dtrsm_strided_batched_rank_0 = rocblas_dtrsm_strided_batched_orig(handle,side,uplo,transA,diag,m,n,alpha,c_loc(A),lda,stride_a,c_loc(B),ldb,stride_b,batch_count)
    end function

    function rocblas_dtrsm_strided_batched_rank_1(handle,side,uplo,transA,diag,m,n,alpha,A,lda,stride_a,B,ldb,stride_b,batch_count)
      use iso_c_binding
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocblas_dtrsm_strided_batched_rank_1
      type(c_ptr),value :: handle
      integer(kind(rocblas_side_left)),value :: side
      integer(kind(rocblas_fill_upper)),value :: uplo
      integer(kind(rocblas_operation_none)),value :: transA
      integer(kind(rocblas_diagonal_non_unit)),value :: diag
      integer(c_int),value :: m
      integer(c_int),value :: n
      real(c_double) :: alpha
      real(c_double),target,dimension(:) :: A
      integer(c_int),value :: lda
      integer(c_int64_t),value :: stride_a
      real(c_double),target,dimension(:) :: B
      integer(c_int),value :: ldb
      integer(c_int64_t),value :: stride_b
      integer(c_int),value :: batch_count
      !
      rocblas_dtrsm_strided_batched_rank_1 = rocblas_dtrsm_strided_batched_orig(handle,side,uplo,transA,diag,m,n,alpha,c_loc(A),lda,stride_a,c_loc(B),ldb,stride_b,batch_count)
    end function

    function rocblas_ctrsm_strided_batched_full_rank(handle,side,uplo,transA,diag,m,n,alpha,A,lda,stride_a,B,ldb,stride_b,batch_count)
      use iso_c_binding
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocblas_ctrsm_strided_batched_full_rank
      type(c_ptr),value :: handle
      integer(kind(rocblas_side_left)),value :: side
      integer(kind(rocblas_fill_upper)),value :: uplo
      integer(kind(rocblas_operation_none)),value :: transA
      integer(kind(rocblas_diagonal_non_unit)),value :: diag
      integer(c_int),value :: m
      integer(c_int),value :: n
      complex(c_float_complex) :: alpha
      complex(c_float_complex),target,dimension(:,:) :: A
      integer(c_int),value :: lda
      integer(c_int64_t),value :: stride_a
      complex(c_float_complex),target,dimension(:,:) :: B
      integer(c_int),value :: ldb
      integer(c_int64_t),value :: stride_b
      integer(c_int),value :: batch_count
      !
      rocblas_ctrsm_strided_batched_full_rank = rocblas_ctrsm_strided_batched_orig(handle,side,uplo,transA,diag,m,n,alpha,c_loc(A),lda,stride_a,c_loc(B),ldb,stride_b,batch_count)
    end function

    function rocblas_ctrsm_strided_batched_rank_0(handle,side,uplo,transA,diag,m,n,alpha,A,lda,stride_a,B,ldb,stride_b,batch_count)
      use iso_c_binding
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocblas_ctrsm_strided_batched_rank_0
      type(c_ptr),value :: handle
      integer(kind(rocblas_side_left)),value :: side
      integer(kind(rocblas_fill_upper)),value :: uplo
      integer(kind(rocblas_operation_none)),value :: transA
      integer(kind(rocblas_diagonal_non_unit)),value :: diag
      integer(c_int),value :: m
      integer(c_int),value :: n
      complex(c_float_complex) :: alpha
      complex(c_float_complex),target :: A
      integer(c_int),value :: lda
      integer(c_int64_t),value :: stride_a
      complex(c_float_complex),target :: B
      integer(c_int),value :: ldb
      integer(c_int64_t),value :: stride_b
      integer(c_int),value :: batch_count
      !
      rocblas_ctrsm_strided_batched_rank_0 = rocblas_ctrsm_strided_batched_orig(handle,side,uplo,transA,diag,m,n,alpha,c_loc(A),lda,stride_a,c_loc(B),ldb,stride_b,batch_count)
    end function

    function rocblas_ctrsm_strided_batched_rank_1(handle,side,uplo,transA,diag,m,n,alpha,A,lda,stride_a,B,ldb,stride_b,batch_count)
      use iso_c_binding
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocblas_ctrsm_strided_batched_rank_1
      type(c_ptr),value :: handle
      integer(kind(rocblas_side_left)),value :: side
      integer(kind(rocblas_fill_upper)),value :: uplo
      integer(kind(rocblas_operation_none)),value :: transA
      integer(kind(rocblas_diagonal_non_unit)),value :: diag
      integer(c_int),value :: m
      integer(c_int),value :: n
      complex(c_float_complex) :: alpha
      complex(c_float_complex),target,dimension(:) :: A
      integer(c_int),value :: lda
      integer(c_int64_t),value :: stride_a
      complex(c_float_complex),target,dimension(:) :: B
      integer(c_int),value :: ldb
      integer(c_int64_t),value :: stride_b
      integer(c_int),value :: batch_count
      !
      rocblas_ctrsm_strided_batched_rank_1 = rocblas_ctrsm_strided_batched_orig(handle,side,uplo,transA,diag,m,n,alpha,c_loc(A),lda,stride_a,c_loc(B),ldb,stride_b,batch_count)
    end function

    function rocblas_ztrsm_strided_batched_full_rank(handle,side,uplo,transA,diag,m,n,alpha,A,lda,stride_a,B,ldb,stride_b,batch_count)
      use iso_c_binding
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocblas_ztrsm_strided_batched_full_rank
      type(c_ptr),value :: handle
      integer(kind(rocblas_side_left)),value :: side
      integer(kind(rocblas_fill_upper)),value :: uplo
      integer(kind(rocblas_operation_none)),value :: transA
      integer(kind(rocblas_diagonal_non_unit)),value :: diag
      integer(c_int),value :: m
      integer(c_int),value :: n
      complex(c_double_complex) :: alpha
      complex(c_double_complex),target,dimension(:,:) :: A
      integer(c_int),value :: lda
      integer(c_int64_t),value :: stride_a
      complex(c_double_complex),target,dimension(:,:) :: B
      integer(c_int),value :: ldb
      integer(c_int64_t),value :: stride_b
      integer(c_int),value :: batch_count
      !
      rocblas_ztrsm_strided_batched_full_rank = rocblas_ztrsm_strided_batched_orig(handle,side,uplo,transA,diag,m,n,alpha,c_loc(A),lda,stride_a,c_loc(B),ldb,stride_b,batch_count)
    end function

    function rocblas_ztrsm_strided_batched_rank_0(handle,side,uplo,transA,diag,m,n,alpha,A,lda,stride_a,B,ldb,stride_b,batch_count)
      use iso_c_binding
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocblas_ztrsm_strided_batched_rank_0
      type(c_ptr),value :: handle
      integer(kind(rocblas_side_left)),value :: side
      integer(kind(rocblas_fill_upper)),value :: uplo
      integer(kind(rocblas_operation_none)),value :: transA
      integer(kind(rocblas_diagonal_non_unit)),value :: diag
      integer(c_int),value :: m
      integer(c_int),value :: n
      complex(c_double_complex) :: alpha
      complex(c_double_complex),target :: A
      integer(c_int),value :: lda
      integer(c_int64_t),value :: stride_a
      complex(c_double_complex),target :: B
      integer(c_int),value :: ldb
      integer(c_int64_t),value :: stride_b
      integer(c_int),value :: batch_count
      !
      rocblas_ztrsm_strided_batched_rank_0 = rocblas_ztrsm_strided_batched_orig(handle,side,uplo,transA,diag,m,n,alpha,c_loc(A),lda,stride_a,c_loc(B),ldb,stride_b,batch_count)
    end function

    function rocblas_ztrsm_strided_batched_rank_1(handle,side,uplo,transA,diag,m,n,alpha,A,lda,stride_a,B,ldb,stride_b,batch_count)
      use iso_c_binding
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocblas_ztrsm_strided_batched_rank_1
      type(c_ptr),value :: handle
      integer(kind(rocblas_side_left)),value :: side
      integer(kind(rocblas_fill_upper)),value :: uplo
      integer(kind(rocblas_operation_none)),value :: transA
      integer(kind(rocblas_diagonal_non_unit)),value :: diag
      integer(c_int),value :: m
      integer(c_int),value :: n
      complex(c_double_complex) :: alpha
      complex(c_double_complex),target,dimension(:) :: A
      integer(c_int),value :: lda
      integer(c_int64_t),value :: stride_a
      complex(c_double_complex),target,dimension(:) :: B
      integer(c_int),value :: ldb
      integer(c_int64_t),value :: stride_b
      integer(c_int),value :: batch_count
      !
      rocblas_ztrsm_strided_batched_rank_1 = rocblas_ztrsm_strided_batched_orig(handle,side,uplo,transA,diag,m,n,alpha,c_loc(A),lda,stride_a,c_loc(B),ldb,stride_b,batch_count)
    end function

    function rocblas_sgemm_full_rank(handle,transA,transB,m,n,k,alpha,A,lda,B,ldb,beta,C,ldc)
      use iso_c_binding
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocblas_sgemm_full_rank
      type(c_ptr),value :: handle
      integer(kind(rocblas_operation_none)),value :: transA
      integer(kind(rocblas_operation_none)),value :: transB
      integer(c_int),value :: m
      integer(c_int),value :: n
      integer(c_int),value :: k
      real(c_float) :: alpha
      real(c_float),target,dimension(:,:) :: A
      integer(c_int),value :: lda
      real(c_float),target,dimension(:,:) :: B
      integer(c_int),value :: ldb
      real(c_float) :: beta
      real(c_float),target,dimension(:,:) :: C
      integer(c_int),value :: ldc
      !
      rocblas_sgemm_full_rank = rocblas_sgemm_orig(handle,transA,transB,m,n,k,alpha,c_loc(A),lda,c_loc(B),ldb,beta,c_loc(C),ldc)
    end function

    function rocblas_sgemm_rank_0(handle,transA,transB,m,n,k,alpha,A,lda,B,ldb,beta,C,ldc)
      use iso_c_binding
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocblas_sgemm_rank_0
      type(c_ptr),value :: handle
      integer(kind(rocblas_operation_none)),value :: transA
      integer(kind(rocblas_operation_none)),value :: transB
      integer(c_int),value :: m
      integer(c_int),value :: n
      integer(c_int),value :: k
      real(c_float) :: alpha
      real(c_float),target :: A
      integer(c_int),value :: lda
      real(c_float),target :: B
      integer(c_int),value :: ldb
      real(c_float) :: beta
      real(c_float),target :: C
      integer(c_int),value :: ldc
      !
      rocblas_sgemm_rank_0 = rocblas_sgemm_orig(handle,transA,transB,m,n,k,alpha,c_loc(A),lda,c_loc(B),ldb,beta,c_loc(C),ldc)
    end function

    function rocblas_sgemm_rank_1(handle,transA,transB,m,n,k,alpha,A,lda,B,ldb,beta,C,ldc)
      use iso_c_binding
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocblas_sgemm_rank_1
      type(c_ptr),value :: handle
      integer(kind(rocblas_operation_none)),value :: transA
      integer(kind(rocblas_operation_none)),value :: transB
      integer(c_int),value :: m
      integer(c_int),value :: n
      integer(c_int),value :: k
      real(c_float) :: alpha
      real(c_float),target,dimension(:) :: A
      integer(c_int),value :: lda
      real(c_float),target,dimension(:) :: B
      integer(c_int),value :: ldb
      real(c_float) :: beta
      real(c_float),target,dimension(:) :: C
      integer(c_int),value :: ldc
      !
      rocblas_sgemm_rank_1 = rocblas_sgemm_orig(handle,transA,transB,m,n,k,alpha,c_loc(A),lda,c_loc(B),ldb,beta,c_loc(C),ldc)
    end function

    function rocblas_dgemm_full_rank(handle,transA,transB,m,n,k,alpha,A,lda,B,ldb,beta,C,ldc)
      use iso_c_binding
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocblas_dgemm_full_rank
      type(c_ptr),value :: handle
      integer(kind(rocblas_operation_none)),value :: transA
      integer(kind(rocblas_operation_none)),value :: transB
      integer(c_int),value :: m
      integer(c_int),value :: n
      integer(c_int),value :: k
      real(c_double) :: alpha
      real(c_double),target,dimension(:,:) :: A
      integer(c_int),value :: lda
      real(c_double),target,dimension(:,:) :: B
      integer(c_int),value :: ldb
      real(c_double) :: beta
      real(c_double),target,dimension(:,:) :: C
      integer(c_int),value :: ldc
      !
      rocblas_dgemm_full_rank = rocblas_dgemm_orig(handle,transA,transB,m,n,k,alpha,c_loc(A),lda,c_loc(B),ldb,beta,c_loc(C),ldc)
    end function

    function rocblas_dgemm_rank_0(handle,transA,transB,m,n,k,alpha,A,lda,B,ldb,beta,C,ldc)
      use iso_c_binding
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocblas_dgemm_rank_0
      type(c_ptr),value :: handle
      integer(kind(rocblas_operation_none)),value :: transA
      integer(kind(rocblas_operation_none)),value :: transB
      integer(c_int),value :: m
      integer(c_int),value :: n
      integer(c_int),value :: k
      real(c_double) :: alpha
      real(c_double),target :: A
      integer(c_int),value :: lda
      real(c_double),target :: B
      integer(c_int),value :: ldb
      real(c_double) :: beta
      real(c_double),target :: C
      integer(c_int),value :: ldc
      !
      rocblas_dgemm_rank_0 = rocblas_dgemm_orig(handle,transA,transB,m,n,k,alpha,c_loc(A),lda,c_loc(B),ldb,beta,c_loc(C),ldc)
    end function

    function rocblas_dgemm_rank_1(handle,transA,transB,m,n,k,alpha,A,lda,B,ldb,beta,C,ldc)
      use iso_c_binding
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocblas_dgemm_rank_1
      type(c_ptr),value :: handle
      integer(kind(rocblas_operation_none)),value :: transA
      integer(kind(rocblas_operation_none)),value :: transB
      integer(c_int),value :: m
      integer(c_int),value :: n
      integer(c_int),value :: k
      real(c_double) :: alpha
      real(c_double),target,dimension(:) :: A
      integer(c_int),value :: lda
      real(c_double),target,dimension(:) :: B
      integer(c_int),value :: ldb
      real(c_double) :: beta
      real(c_double),target,dimension(:) :: C
      integer(c_int),value :: ldc
      !
      rocblas_dgemm_rank_1 = rocblas_dgemm_orig(handle,transA,transB,m,n,k,alpha,c_loc(A),lda,c_loc(B),ldb,beta,c_loc(C),ldc)
    end function

    function rocblas_cgemm_full_rank(handle,transA,transB,m,n,k,alpha,A,lda,B,ldb,beta,C,ldc)
      use iso_c_binding
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocblas_cgemm_full_rank
      type(c_ptr),value :: handle
      integer(kind(rocblas_operation_none)),value :: transA
      integer(kind(rocblas_operation_none)),value :: transB
      integer(c_int),value :: m
      integer(c_int),value :: n
      integer(c_int),value :: k
      complex(c_float_complex) :: alpha
      complex(c_float_complex),target,dimension(:,:) :: A
      integer(c_int),value :: lda
      complex(c_float_complex),target,dimension(:,:) :: B
      integer(c_int),value :: ldb
      complex(c_float_complex) :: beta
      complex(c_float_complex),target,dimension(:,:) :: C
      integer(c_int),value :: ldc
      !
      rocblas_cgemm_full_rank = rocblas_cgemm_orig(handle,transA,transB,m,n,k,alpha,c_loc(A),lda,c_loc(B),ldb,beta,c_loc(C),ldc)
    end function

    function rocblas_cgemm_rank_0(handle,transA,transB,m,n,k,alpha,A,lda,B,ldb,beta,C,ldc)
      use iso_c_binding
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocblas_cgemm_rank_0
      type(c_ptr),value :: handle
      integer(kind(rocblas_operation_none)),value :: transA
      integer(kind(rocblas_operation_none)),value :: transB
      integer(c_int),value :: m
      integer(c_int),value :: n
      integer(c_int),value :: k
      complex(c_float_complex) :: alpha
      complex(c_float_complex),target :: A
      integer(c_int),value :: lda
      complex(c_float_complex),target :: B
      integer(c_int),value :: ldb
      complex(c_float_complex) :: beta
      complex(c_float_complex),target :: C
      integer(c_int),value :: ldc
      !
      rocblas_cgemm_rank_0 = rocblas_cgemm_orig(handle,transA,transB,m,n,k,alpha,c_loc(A),lda,c_loc(B),ldb,beta,c_loc(C),ldc)
    end function

    function rocblas_cgemm_rank_1(handle,transA,transB,m,n,k,alpha,A,lda,B,ldb,beta,C,ldc)
      use iso_c_binding
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocblas_cgemm_rank_1
      type(c_ptr),value :: handle
      integer(kind(rocblas_operation_none)),value :: transA
      integer(kind(rocblas_operation_none)),value :: transB
      integer(c_int),value :: m
      integer(c_int),value :: n
      integer(c_int),value :: k
      complex(c_float_complex) :: alpha
      complex(c_float_complex),target,dimension(:) :: A
      integer(c_int),value :: lda
      complex(c_float_complex),target,dimension(:) :: B
      integer(c_int),value :: ldb
      complex(c_float_complex) :: beta
      complex(c_float_complex),target,dimension(:) :: C
      integer(c_int),value :: ldc
      !
      rocblas_cgemm_rank_1 = rocblas_cgemm_orig(handle,transA,transB,m,n,k,alpha,c_loc(A),lda,c_loc(B),ldb,beta,c_loc(C),ldc)
    end function

    function rocblas_zgemm_full_rank(handle,transA,transB,m,n,k,alpha,A,lda,B,ldb,beta,C,ldc)
      use iso_c_binding
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocblas_zgemm_full_rank
      type(c_ptr),value :: handle
      integer(kind(rocblas_operation_none)),value :: transA
      integer(kind(rocblas_operation_none)),value :: transB
      integer(c_int),value :: m
      integer(c_int),value :: n
      integer(c_int),value :: k
      complex(c_double_complex) :: alpha
      complex(c_double_complex),target,dimension(:,:) :: A
      integer(c_int),value :: lda
      complex(c_double_complex),target,dimension(:,:) :: B
      integer(c_int),value :: ldb
      complex(c_double_complex) :: beta
      complex(c_double_complex),target,dimension(:,:) :: C
      integer(c_int),value :: ldc
      !
      rocblas_zgemm_full_rank = rocblas_zgemm_orig(handle,transA,transB,m,n,k,alpha,c_loc(A),lda,c_loc(B),ldb,beta,c_loc(C),ldc)
    end function

    function rocblas_zgemm_rank_0(handle,transA,transB,m,n,k,alpha,A,lda,B,ldb,beta,C,ldc)
      use iso_c_binding
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocblas_zgemm_rank_0
      type(c_ptr),value :: handle
      integer(kind(rocblas_operation_none)),value :: transA
      integer(kind(rocblas_operation_none)),value :: transB
      integer(c_int),value :: m
      integer(c_int),value :: n
      integer(c_int),value :: k
      complex(c_double_complex) :: alpha
      complex(c_double_complex),target :: A
      integer(c_int),value :: lda
      complex(c_double_complex),target :: B
      integer(c_int),value :: ldb
      complex(c_double_complex) :: beta
      complex(c_double_complex),target :: C
      integer(c_int),value :: ldc
      !
      rocblas_zgemm_rank_0 = rocblas_zgemm_orig(handle,transA,transB,m,n,k,alpha,c_loc(A),lda,c_loc(B),ldb,beta,c_loc(C),ldc)
    end function

    function rocblas_zgemm_rank_1(handle,transA,transB,m,n,k,alpha,A,lda,B,ldb,beta,C,ldc)
      use iso_c_binding
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocblas_zgemm_rank_1
      type(c_ptr),value :: handle
      integer(kind(rocblas_operation_none)),value :: transA
      integer(kind(rocblas_operation_none)),value :: transB
      integer(c_int),value :: m
      integer(c_int),value :: n
      integer(c_int),value :: k
      complex(c_double_complex) :: alpha
      complex(c_double_complex),target,dimension(:) :: A
      integer(c_int),value :: lda
      complex(c_double_complex),target,dimension(:) :: B
      integer(c_int),value :: ldb
      complex(c_double_complex) :: beta
      complex(c_double_complex),target,dimension(:) :: C
      integer(c_int),value :: ldc
      !
      rocblas_zgemm_rank_1 = rocblas_zgemm_orig(handle,transA,transB,m,n,k,alpha,c_loc(A),lda,c_loc(B),ldb,beta,c_loc(C),ldc)
    end function

    function rocblas_sgemm_batched_full_rank(handle,transA,transB,m,n,k,alpha,A,lda,B,ldb,beta,C,ldc,batch_count)
      use iso_c_binding
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocblas_sgemm_batched_full_rank
      type(c_ptr),value :: handle
      integer(kind(rocblas_operation_none)),value :: transA
      integer(kind(rocblas_operation_none)),value :: transB
      integer(c_int),value :: m
      integer(c_int),value :: n
      integer(c_int),value :: k
      real(c_float) :: alpha
      real(c_float),target,dimension(:,:,:) :: A
      integer(c_int),value :: lda
      real(c_float),target,dimension(:,:,:) :: B
      integer(c_int),value :: ldb
      real(c_float) :: beta
      real(c_float),target,dimension(:,:,:) :: C
      integer(c_int),value :: ldc
      integer(c_int),value :: batch_count
      !
      rocblas_sgemm_batched_full_rank = rocblas_sgemm_batched_orig(handle,transA,transB,m,n,k,alpha,c_loc(A),lda,c_loc(B),ldb,beta,c_loc(C),ldc,batch_count)
    end function

    function rocblas_sgemm_batched_rank_0(handle,transA,transB,m,n,k,alpha,A,lda,B,ldb,beta,C,ldc,batch_count)
      use iso_c_binding
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocblas_sgemm_batched_rank_0
      type(c_ptr),value :: handle
      integer(kind(rocblas_operation_none)),value :: transA
      integer(kind(rocblas_operation_none)),value :: transB
      integer(c_int),value :: m
      integer(c_int),value :: n
      integer(c_int),value :: k
      real(c_float) :: alpha
      real(c_float),target :: A
      integer(c_int),value :: lda
      real(c_float),target :: B
      integer(c_int),value :: ldb
      real(c_float) :: beta
      real(c_float),target :: C
      integer(c_int),value :: ldc
      integer(c_int),value :: batch_count
      !
      rocblas_sgemm_batched_rank_0 = rocblas_sgemm_batched_orig(handle,transA,transB,m,n,k,alpha,c_loc(A),lda,c_loc(B),ldb,beta,c_loc(C),ldc,batch_count)
    end function

    function rocblas_sgemm_batched_rank_1(handle,transA,transB,m,n,k,alpha,A,lda,B,ldb,beta,C,ldc,batch_count)
      use iso_c_binding
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocblas_sgemm_batched_rank_1
      type(c_ptr),value :: handle
      integer(kind(rocblas_operation_none)),value :: transA
      integer(kind(rocblas_operation_none)),value :: transB
      integer(c_int),value :: m
      integer(c_int),value :: n
      integer(c_int),value :: k
      real(c_float) :: alpha
      real(c_float),target,dimension(:) :: A
      integer(c_int),value :: lda
      real(c_float),target,dimension(:) :: B
      integer(c_int),value :: ldb
      real(c_float) :: beta
      real(c_float),target,dimension(:) :: C
      integer(c_int),value :: ldc
      integer(c_int),value :: batch_count
      !
      rocblas_sgemm_batched_rank_1 = rocblas_sgemm_batched_orig(handle,transA,transB,m,n,k,alpha,c_loc(A),lda,c_loc(B),ldb,beta,c_loc(C),ldc,batch_count)
    end function

    function rocblas_dgemm_batched_full_rank(handle,transA,transB,m,n,k,alpha,A,lda,B,ldb,beta,C,ldc,batch_count)
      use iso_c_binding
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocblas_dgemm_batched_full_rank
      type(c_ptr),value :: handle
      integer(kind(rocblas_operation_none)),value :: transA
      integer(kind(rocblas_operation_none)),value :: transB
      integer(c_int),value :: m
      integer(c_int),value :: n
      integer(c_int),value :: k
      real(c_double) :: alpha
      real(c_double),target,dimension(:,:,:) :: A
      integer(c_int),value :: lda
      real(c_double),target,dimension(:,:,:) :: B
      integer(c_int),value :: ldb
      real(c_double) :: beta
      real(c_double),target,dimension(:,:,:) :: C
      integer(c_int),value :: ldc
      integer(c_int),value :: batch_count
      !
      rocblas_dgemm_batched_full_rank = rocblas_dgemm_batched_orig(handle,transA,transB,m,n,k,alpha,c_loc(A),lda,c_loc(B),ldb,beta,c_loc(C),ldc,batch_count)
    end function

    function rocblas_dgemm_batched_rank_0(handle,transA,transB,m,n,k,alpha,A,lda,B,ldb,beta,C,ldc,batch_count)
      use iso_c_binding
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocblas_dgemm_batched_rank_0
      type(c_ptr),value :: handle
      integer(kind(rocblas_operation_none)),value :: transA
      integer(kind(rocblas_operation_none)),value :: transB
      integer(c_int),value :: m
      integer(c_int),value :: n
      integer(c_int),value :: k
      real(c_double) :: alpha
      real(c_double),target :: A
      integer(c_int),value :: lda
      real(c_double),target :: B
      integer(c_int),value :: ldb
      real(c_double) :: beta
      real(c_double),target :: C
      integer(c_int),value :: ldc
      integer(c_int),value :: batch_count
      !
      rocblas_dgemm_batched_rank_0 = rocblas_dgemm_batched_orig(handle,transA,transB,m,n,k,alpha,c_loc(A),lda,c_loc(B),ldb,beta,c_loc(C),ldc,batch_count)
    end function

    function rocblas_dgemm_batched_rank_1(handle,transA,transB,m,n,k,alpha,A,lda,B,ldb,beta,C,ldc,batch_count)
      use iso_c_binding
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocblas_dgemm_batched_rank_1
      type(c_ptr),value :: handle
      integer(kind(rocblas_operation_none)),value :: transA
      integer(kind(rocblas_operation_none)),value :: transB
      integer(c_int),value :: m
      integer(c_int),value :: n
      integer(c_int),value :: k
      real(c_double) :: alpha
      real(c_double),target,dimension(:) :: A
      integer(c_int),value :: lda
      real(c_double),target,dimension(:) :: B
      integer(c_int),value :: ldb
      real(c_double) :: beta
      real(c_double),target,dimension(:) :: C
      integer(c_int),value :: ldc
      integer(c_int),value :: batch_count
      !
      rocblas_dgemm_batched_rank_1 = rocblas_dgemm_batched_orig(handle,transA,transB,m,n,k,alpha,c_loc(A),lda,c_loc(B),ldb,beta,c_loc(C),ldc,batch_count)
    end function

    function rocblas_cgemm_batched_full_rank(handle,transA,transB,m,n,k,alpha,A,lda,B,ldb,beta,C,ldc,batch_count)
      use iso_c_binding
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocblas_cgemm_batched_full_rank
      type(c_ptr),value :: handle
      integer(kind(rocblas_operation_none)),value :: transA
      integer(kind(rocblas_operation_none)),value :: transB
      integer(c_int),value :: m
      integer(c_int),value :: n
      integer(c_int),value :: k
      complex(c_float_complex) :: alpha
      complex(c_float_complex),target,dimension(:,:,:) :: A
      integer(c_int),value :: lda
      complex(c_float_complex),target,dimension(:,:,:) :: B
      integer(c_int),value :: ldb
      complex(c_float_complex) :: beta
      complex(c_float_complex),target,dimension(:,:,:) :: C
      integer(c_int),value :: ldc
      integer(c_int),value :: batch_count
      !
      rocblas_cgemm_batched_full_rank = rocblas_cgemm_batched_orig(handle,transA,transB,m,n,k,alpha,c_loc(A),lda,c_loc(B),ldb,beta,c_loc(C),ldc,batch_count)
    end function

    function rocblas_cgemm_batched_rank_0(handle,transA,transB,m,n,k,alpha,A,lda,B,ldb,beta,C,ldc,batch_count)
      use iso_c_binding
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocblas_cgemm_batched_rank_0
      type(c_ptr),value :: handle
      integer(kind(rocblas_operation_none)),value :: transA
      integer(kind(rocblas_operation_none)),value :: transB
      integer(c_int),value :: m
      integer(c_int),value :: n
      integer(c_int),value :: k
      complex(c_float_complex) :: alpha
      complex(c_float_complex),target :: A
      integer(c_int),value :: lda
      complex(c_float_complex),target :: B
      integer(c_int),value :: ldb
      complex(c_float_complex) :: beta
      complex(c_float_complex),target :: C
      integer(c_int),value :: ldc
      integer(c_int),value :: batch_count
      !
      rocblas_cgemm_batched_rank_0 = rocblas_cgemm_batched_orig(handle,transA,transB,m,n,k,alpha,c_loc(A),lda,c_loc(B),ldb,beta,c_loc(C),ldc,batch_count)
    end function

    function rocblas_cgemm_batched_rank_1(handle,transA,transB,m,n,k,alpha,A,lda,B,ldb,beta,C,ldc,batch_count)
      use iso_c_binding
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocblas_cgemm_batched_rank_1
      type(c_ptr),value :: handle
      integer(kind(rocblas_operation_none)),value :: transA
      integer(kind(rocblas_operation_none)),value :: transB
      integer(c_int),value :: m
      integer(c_int),value :: n
      integer(c_int),value :: k
      complex(c_float_complex) :: alpha
      complex(c_float_complex),target,dimension(:) :: A
      integer(c_int),value :: lda
      complex(c_float_complex),target,dimension(:) :: B
      integer(c_int),value :: ldb
      complex(c_float_complex) :: beta
      complex(c_float_complex),target,dimension(:) :: C
      integer(c_int),value :: ldc
      integer(c_int),value :: batch_count
      !
      rocblas_cgemm_batched_rank_1 = rocblas_cgemm_batched_orig(handle,transA,transB,m,n,k,alpha,c_loc(A),lda,c_loc(B),ldb,beta,c_loc(C),ldc,batch_count)
    end function

    function rocblas_zgemm_batched_full_rank(handle,transa,transb,m,n,k,alpha,A,lda,B,ldb,beta,C,ldc,batch_count)
      use iso_c_binding
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocblas_zgemm_batched_full_rank
      type(c_ptr),value :: handle
      integer(kind(rocblas_operation_none)),value :: transa
      integer(kind(rocblas_operation_none)),value :: transb
      integer(c_int),value :: m
      integer(c_int),value :: n
      integer(c_int),value :: k
      complex(c_double_complex) :: alpha
      complex(c_double_complex),target,dimension(:,:,:) :: A
      integer(c_int),value :: lda
      complex(c_double_complex),target,dimension(:,:,:) :: B
      integer(c_int),value :: ldb
      complex(c_double_complex) :: beta
      complex(c_double_complex),target,dimension(:,:,:) :: C
      integer(c_int),value :: ldc
      integer(c_int),value :: batch_count
      !
      rocblas_zgemm_batched_full_rank = rocblas_zgemm_batched_orig(handle,transa,transb,m,n,k,alpha,c_loc(A),lda,c_loc(B),ldb,beta,c_loc(C),ldc,batch_count)
    end function

    function rocblas_zgemm_batched_rank_0(handle,transa,transb,m,n,k,alpha,A,lda,B,ldb,beta,C,ldc,batch_count)
      use iso_c_binding
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocblas_zgemm_batched_rank_0
      type(c_ptr),value :: handle
      integer(kind(rocblas_operation_none)),value :: transa
      integer(kind(rocblas_operation_none)),value :: transb
      integer(c_int),value :: m
      integer(c_int),value :: n
      integer(c_int),value :: k
      complex(c_double_complex) :: alpha
      complex(c_double_complex),target :: A
      integer(c_int),value :: lda
      complex(c_double_complex),target :: B
      integer(c_int),value :: ldb
      complex(c_double_complex) :: beta
      complex(c_double_complex),target :: C
      integer(c_int),value :: ldc
      integer(c_int),value :: batch_count
      !
      rocblas_zgemm_batched_rank_0 = rocblas_zgemm_batched_orig(handle,transa,transb,m,n,k,alpha,c_loc(A),lda,c_loc(B),ldb,beta,c_loc(C),ldc,batch_count)
    end function

    function rocblas_zgemm_batched_rank_1(handle,transa,transb,m,n,k,alpha,A,lda,B,ldb,beta,C,ldc,batch_count)
      use iso_c_binding
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocblas_zgemm_batched_rank_1
      type(c_ptr),value :: handle
      integer(kind(rocblas_operation_none)),value :: transa
      integer(kind(rocblas_operation_none)),value :: transb
      integer(c_int),value :: m
      integer(c_int),value :: n
      integer(c_int),value :: k
      complex(c_double_complex) :: alpha
      complex(c_double_complex),target,dimension(:) :: A
      integer(c_int),value :: lda
      complex(c_double_complex),target,dimension(:) :: B
      integer(c_int),value :: ldb
      complex(c_double_complex) :: beta
      complex(c_double_complex),target,dimension(:) :: C
      integer(c_int),value :: ldc
      integer(c_int),value :: batch_count
      !
      rocblas_zgemm_batched_rank_1 = rocblas_zgemm_batched_orig(handle,transa,transb,m,n,k,alpha,c_loc(A),lda,c_loc(B),ldb,beta,c_loc(C),ldc,batch_count)
    end function

    function rocblas_sgemm_strided_batched_full_rank(handle,transA,transB,m,n,k,alpha,A,lda,stride_a,B,ldb,stride_b,beta,C,ldc,stride_c,batch_count)
      use iso_c_binding
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocblas_sgemm_strided_batched_full_rank
      type(c_ptr),value :: handle
      integer(kind(rocblas_operation_none)),value :: transA
      integer(kind(rocblas_operation_none)),value :: transB
      integer(c_int),value :: m
      integer(c_int),value :: n
      integer(c_int),value :: k
      real(c_float) :: alpha
      real(c_float),target,dimension(:,:) :: A
      integer(c_int),value :: lda
      integer(c_int64_t),value :: stride_a
      real(c_float),target,dimension(:,:) :: B
      integer(c_int),value :: ldb
      integer(c_int64_t),value :: stride_b
      real(c_float) :: beta
      real(c_float),target,dimension(:,:) :: C
      integer(c_int),value :: ldc
      integer(c_int64_t),value :: stride_c
      integer(c_int),value :: batch_count
      !
      rocblas_sgemm_strided_batched_full_rank = rocblas_sgemm_strided_batched_orig(handle,transA,transB,m,n,k,alpha,c_loc(A),lda,stride_a,c_loc(B),ldb,stride_b,beta,c_loc(C),ldc,stride_c,batch_count)
    end function

    function rocblas_sgemm_strided_batched_rank_0(handle,transA,transB,m,n,k,alpha,A,lda,stride_a,B,ldb,stride_b,beta,C,ldc,stride_c,batch_count)
      use iso_c_binding
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocblas_sgemm_strided_batched_rank_0
      type(c_ptr),value :: handle
      integer(kind(rocblas_operation_none)),value :: transA
      integer(kind(rocblas_operation_none)),value :: transB
      integer(c_int),value :: m
      integer(c_int),value :: n
      integer(c_int),value :: k
      real(c_float) :: alpha
      real(c_float),target :: A
      integer(c_int),value :: lda
      integer(c_int64_t),value :: stride_a
      real(c_float),target :: B
      integer(c_int),value :: ldb
      integer(c_int64_t),value :: stride_b
      real(c_float) :: beta
      real(c_float),target :: C
      integer(c_int),value :: ldc
      integer(c_int64_t),value :: stride_c
      integer(c_int),value :: batch_count
      !
      rocblas_sgemm_strided_batched_rank_0 = rocblas_sgemm_strided_batched_orig(handle,transA,transB,m,n,k,alpha,c_loc(A),lda,stride_a,c_loc(B),ldb,stride_b,beta,c_loc(C),ldc,stride_c,batch_count)
    end function

    function rocblas_sgemm_strided_batched_rank_1(handle,transA,transB,m,n,k,alpha,A,lda,stride_a,B,ldb,stride_b,beta,C,ldc,stride_c,batch_count)
      use iso_c_binding
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocblas_sgemm_strided_batched_rank_1
      type(c_ptr),value :: handle
      integer(kind(rocblas_operation_none)),value :: transA
      integer(kind(rocblas_operation_none)),value :: transB
      integer(c_int),value :: m
      integer(c_int),value :: n
      integer(c_int),value :: k
      real(c_float) :: alpha
      real(c_float),target,dimension(:) :: A
      integer(c_int),value :: lda
      integer(c_int64_t),value :: stride_a
      real(c_float),target,dimension(:) :: B
      integer(c_int),value :: ldb
      integer(c_int64_t),value :: stride_b
      real(c_float) :: beta
      real(c_float),target,dimension(:) :: C
      integer(c_int),value :: ldc
      integer(c_int64_t),value :: stride_c
      integer(c_int),value :: batch_count
      !
      rocblas_sgemm_strided_batched_rank_1 = rocblas_sgemm_strided_batched_orig(handle,transA,transB,m,n,k,alpha,c_loc(A),lda,stride_a,c_loc(B),ldb,stride_b,beta,c_loc(C),ldc,stride_c,batch_count)
    end function

    function rocblas_dgemm_strided_batched_full_rank(handle,transA,transB,m,n,k,alpha,A,lda,stride_a,B,ldb,stride_b,beta,C,ldc,stride_c,batch_count)
      use iso_c_binding
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocblas_dgemm_strided_batched_full_rank
      type(c_ptr),value :: handle
      integer(kind(rocblas_operation_none)),value :: transA
      integer(kind(rocblas_operation_none)),value :: transB
      integer(c_int),value :: m
      integer(c_int),value :: n
      integer(c_int),value :: k
      real(c_double) :: alpha
      real(c_double),target,dimension(:,:) :: A
      integer(c_int),value :: lda
      integer(c_int64_t),value :: stride_a
      real(c_double),target,dimension(:,:) :: B
      integer(c_int),value :: ldb
      integer(c_int64_t),value :: stride_b
      real(c_double) :: beta
      real(c_double),target,dimension(:,:) :: C
      integer(c_int),value :: ldc
      integer(c_int64_t),value :: stride_c
      integer(c_int),value :: batch_count
      !
      rocblas_dgemm_strided_batched_full_rank = rocblas_dgemm_strided_batched_orig(handle,transA,transB,m,n,k,alpha,c_loc(A),lda,stride_a,c_loc(B),ldb,stride_b,beta,c_loc(C),ldc,stride_c,batch_count)
    end function

    function rocblas_dgemm_strided_batched_rank_0(handle,transA,transB,m,n,k,alpha,A,lda,stride_a,B,ldb,stride_b,beta,C,ldc,stride_c,batch_count)
      use iso_c_binding
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocblas_dgemm_strided_batched_rank_0
      type(c_ptr),value :: handle
      integer(kind(rocblas_operation_none)),value :: transA
      integer(kind(rocblas_operation_none)),value :: transB
      integer(c_int),value :: m
      integer(c_int),value :: n
      integer(c_int),value :: k
      real(c_double) :: alpha
      real(c_double),target :: A
      integer(c_int),value :: lda
      integer(c_int64_t),value :: stride_a
      real(c_double),target :: B
      integer(c_int),value :: ldb
      integer(c_int64_t),value :: stride_b
      real(c_double) :: beta
      real(c_double),target :: C
      integer(c_int),value :: ldc
      integer(c_int64_t),value :: stride_c
      integer(c_int),value :: batch_count
      !
      rocblas_dgemm_strided_batched_rank_0 = rocblas_dgemm_strided_batched_orig(handle,transA,transB,m,n,k,alpha,c_loc(A),lda,stride_a,c_loc(B),ldb,stride_b,beta,c_loc(C),ldc,stride_c,batch_count)
    end function

    function rocblas_dgemm_strided_batched_rank_1(handle,transA,transB,m,n,k,alpha,A,lda,stride_a,B,ldb,stride_b,beta,C,ldc,stride_c,batch_count)
      use iso_c_binding
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocblas_dgemm_strided_batched_rank_1
      type(c_ptr),value :: handle
      integer(kind(rocblas_operation_none)),value :: transA
      integer(kind(rocblas_operation_none)),value :: transB
      integer(c_int),value :: m
      integer(c_int),value :: n
      integer(c_int),value :: k
      real(c_double) :: alpha
      real(c_double),target,dimension(:) :: A
      integer(c_int),value :: lda
      integer(c_int64_t),value :: stride_a
      real(c_double),target,dimension(:) :: B
      integer(c_int),value :: ldb
      integer(c_int64_t),value :: stride_b
      real(c_double) :: beta
      real(c_double),target,dimension(:) :: C
      integer(c_int),value :: ldc
      integer(c_int64_t),value :: stride_c
      integer(c_int),value :: batch_count
      !
      rocblas_dgemm_strided_batched_rank_1 = rocblas_dgemm_strided_batched_orig(handle,transA,transB,m,n,k,alpha,c_loc(A),lda,stride_a,c_loc(B),ldb,stride_b,beta,c_loc(C),ldc,stride_c,batch_count)
    end function

    function rocblas_sgemm_kernel_name_full_rank(handle,transA,transB,m,n,k,alpha,A,lda,stride_a,B,ldb,stride_b,beta,C,ldc,stride_c,batch_count)
      use iso_c_binding
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocblas_sgemm_kernel_name_full_rank
      type(c_ptr),value :: handle
      integer(kind(rocblas_operation_none)),value :: transA
      integer(kind(rocblas_operation_none)),value :: transB
      integer(c_int),value :: m
      integer(c_int),value :: n
      integer(c_int),value :: k
      real(c_float) :: alpha
      real(c_float),target,dimension(:,:) :: A
      integer(c_int),value :: lda
      integer(c_int64_t),value :: stride_a
      real(c_float),target,dimension(:,:) :: B
      integer(c_int),value :: ldb
      integer(c_int64_t),value :: stride_b
      real(c_float) :: beta
      real(c_float),target,dimension(:,:) :: C
      integer(c_int),value :: ldc
      integer(c_int64_t),value :: stride_c
      integer(c_int),value :: batch_count
      !
      rocblas_sgemm_kernel_name_full_rank = rocblas_sgemm_kernel_name_orig(handle,transA,transB,m,n,k,alpha,c_loc(A),lda,stride_a,c_loc(B),ldb,stride_b,beta,c_loc(C),ldc,stride_c,batch_count)
    end function

    function rocblas_sgemm_kernel_name_rank_0(handle,transA,transB,m,n,k,alpha,A,lda,stride_a,B,ldb,stride_b,beta,C,ldc,stride_c,batch_count)
      use iso_c_binding
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocblas_sgemm_kernel_name_rank_0
      type(c_ptr),value :: handle
      integer(kind(rocblas_operation_none)),value :: transA
      integer(kind(rocblas_operation_none)),value :: transB
      integer(c_int),value :: m
      integer(c_int),value :: n
      integer(c_int),value :: k
      real(c_float) :: alpha
      real(c_float),target :: A
      integer(c_int),value :: lda
      integer(c_int64_t),value :: stride_a
      real(c_float),target :: B
      integer(c_int),value :: ldb
      integer(c_int64_t),value :: stride_b
      real(c_float) :: beta
      real(c_float),target :: C
      integer(c_int),value :: ldc
      integer(c_int64_t),value :: stride_c
      integer(c_int),value :: batch_count
      !
      rocblas_sgemm_kernel_name_rank_0 = rocblas_sgemm_kernel_name_orig(handle,transA,transB,m,n,k,alpha,c_loc(A),lda,stride_a,c_loc(B),ldb,stride_b,beta,c_loc(C),ldc,stride_c,batch_count)
    end function

    function rocblas_sgemm_kernel_name_rank_1(handle,transA,transB,m,n,k,alpha,A,lda,stride_a,B,ldb,stride_b,beta,C,ldc,stride_c,batch_count)
      use iso_c_binding
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocblas_sgemm_kernel_name_rank_1
      type(c_ptr),value :: handle
      integer(kind(rocblas_operation_none)),value :: transA
      integer(kind(rocblas_operation_none)),value :: transB
      integer(c_int),value :: m
      integer(c_int),value :: n
      integer(c_int),value :: k
      real(c_float) :: alpha
      real(c_float),target,dimension(:) :: A
      integer(c_int),value :: lda
      integer(c_int64_t),value :: stride_a
      real(c_float),target,dimension(:) :: B
      integer(c_int),value :: ldb
      integer(c_int64_t),value :: stride_b
      real(c_float) :: beta
      real(c_float),target,dimension(:) :: C
      integer(c_int),value :: ldc
      integer(c_int64_t),value :: stride_c
      integer(c_int),value :: batch_count
      !
      rocblas_sgemm_kernel_name_rank_1 = rocblas_sgemm_kernel_name_orig(handle,transA,transB,m,n,k,alpha,c_loc(A),lda,stride_a,c_loc(B),ldb,stride_b,beta,c_loc(C),ldc,stride_c,batch_count)
    end function

    function rocblas_dgemm_kernel_name_full_rank(handle,transA,transB,m,n,k,alpha,A,lda,stride_a,B,ldb,stride_b,beta,C,ldc,stride_c,batch_count)
      use iso_c_binding
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocblas_dgemm_kernel_name_full_rank
      type(c_ptr),value :: handle
      integer(kind(rocblas_operation_none)),value :: transA
      integer(kind(rocblas_operation_none)),value :: transB
      integer(c_int),value :: m
      integer(c_int),value :: n
      integer(c_int),value :: k
      real(c_double) :: alpha
      real(c_double),target,dimension(:,:) :: A
      integer(c_int),value :: lda
      integer(c_int64_t),value :: stride_a
      real(c_double),target,dimension(:,:) :: B
      integer(c_int),value :: ldb
      integer(c_int64_t),value :: stride_b
      real(c_double) :: beta
      real(c_double),target,dimension(:,:) :: C
      integer(c_int),value :: ldc
      integer(c_int64_t),value :: stride_c
      integer(c_int),value :: batch_count
      !
      rocblas_dgemm_kernel_name_full_rank = rocblas_dgemm_kernel_name_orig(handle,transA,transB,m,n,k,alpha,c_loc(A),lda,stride_a,c_loc(B),ldb,stride_b,beta,c_loc(C),ldc,stride_c,batch_count)
    end function

    function rocblas_dgemm_kernel_name_rank_0(handle,transA,transB,m,n,k,alpha,A,lda,stride_a,B,ldb,stride_b,beta,C,ldc,stride_c,batch_count)
      use iso_c_binding
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocblas_dgemm_kernel_name_rank_0
      type(c_ptr),value :: handle
      integer(kind(rocblas_operation_none)),value :: transA
      integer(kind(rocblas_operation_none)),value :: transB
      integer(c_int),value :: m
      integer(c_int),value :: n
      integer(c_int),value :: k
      real(c_double) :: alpha
      real(c_double),target :: A
      integer(c_int),value :: lda
      integer(c_int64_t),value :: stride_a
      real(c_double),target :: B
      integer(c_int),value :: ldb
      integer(c_int64_t),value :: stride_b
      real(c_double) :: beta
      real(c_double),target :: C
      integer(c_int),value :: ldc
      integer(c_int64_t),value :: stride_c
      integer(c_int),value :: batch_count
      !
      rocblas_dgemm_kernel_name_rank_0 = rocblas_dgemm_kernel_name_orig(handle,transA,transB,m,n,k,alpha,c_loc(A),lda,stride_a,c_loc(B),ldb,stride_b,beta,c_loc(C),ldc,stride_c,batch_count)
    end function

    function rocblas_dgemm_kernel_name_rank_1(handle,transA,transB,m,n,k,alpha,A,lda,stride_a,B,ldb,stride_b,beta,C,ldc,stride_c,batch_count)
      use iso_c_binding
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocblas_dgemm_kernel_name_rank_1
      type(c_ptr),value :: handle
      integer(kind(rocblas_operation_none)),value :: transA
      integer(kind(rocblas_operation_none)),value :: transB
      integer(c_int),value :: m
      integer(c_int),value :: n
      integer(c_int),value :: k
      real(c_double) :: alpha
      real(c_double),target,dimension(:) :: A
      integer(c_int),value :: lda
      integer(c_int64_t),value :: stride_a
      real(c_double),target,dimension(:) :: B
      integer(c_int),value :: ldb
      integer(c_int64_t),value :: stride_b
      real(c_double) :: beta
      real(c_double),target,dimension(:) :: C
      integer(c_int),value :: ldc
      integer(c_int64_t),value :: stride_c
      integer(c_int),value :: batch_count
      !
      rocblas_dgemm_kernel_name_rank_1 = rocblas_dgemm_kernel_name_orig(handle,transA,transB,m,n,k,alpha,c_loc(A),lda,stride_a,c_loc(B),ldb,stride_b,beta,c_loc(C),ldc,stride_c,batch_count)
    end function

    function rocblas_cgemm_strided_batched_full_rank(handle,transa,transb,m,n,k,alpha,A,lda,stride_a,B,ldb,stride_b,beta,C,ldc,stride_c,batch_count)
      use iso_c_binding
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocblas_cgemm_strided_batched_full_rank
      type(c_ptr),value :: handle
      integer(kind(rocblas_operation_none)),value :: transa
      integer(kind(rocblas_operation_none)),value :: transb
      integer(c_int),value :: m
      integer(c_int),value :: n
      integer(c_int),value :: k
      complex(c_float_complex) :: alpha
      complex(c_float_complex),target,dimension(:,:) :: A
      integer(c_int),value :: lda
      integer(c_int64_t),value :: stride_a
      complex(c_float_complex),target,dimension(:,:) :: B
      integer(c_int),value :: ldb
      integer(c_int64_t),value :: stride_b
      complex(c_float_complex) :: beta
      complex(c_float_complex),target,dimension(:,:) :: C
      integer(c_int),value :: ldc
      integer(c_int64_t),value :: stride_c
      integer(c_int),value :: batch_count
      !
      rocblas_cgemm_strided_batched_full_rank = rocblas_cgemm_strided_batched_orig(handle,transa,transb,m,n,k,alpha,c_loc(A),lda,stride_a,c_loc(B),ldb,stride_b,beta,c_loc(C),ldc,stride_c,batch_count)
    end function

    function rocblas_cgemm_strided_batched_rank_0(handle,transa,transb,m,n,k,alpha,A,lda,stride_a,B,ldb,stride_b,beta,C,ldc,stride_c,batch_count)
      use iso_c_binding
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocblas_cgemm_strided_batched_rank_0
      type(c_ptr),value :: handle
      integer(kind(rocblas_operation_none)),value :: transa
      integer(kind(rocblas_operation_none)),value :: transb
      integer(c_int),value :: m
      integer(c_int),value :: n
      integer(c_int),value :: k
      complex(c_float_complex) :: alpha
      complex(c_float_complex),target :: A
      integer(c_int),value :: lda
      integer(c_int64_t),value :: stride_a
      complex(c_float_complex),target :: B
      integer(c_int),value :: ldb
      integer(c_int64_t),value :: stride_b
      complex(c_float_complex) :: beta
      complex(c_float_complex),target :: C
      integer(c_int),value :: ldc
      integer(c_int64_t),value :: stride_c
      integer(c_int),value :: batch_count
      !
      rocblas_cgemm_strided_batched_rank_0 = rocblas_cgemm_strided_batched_orig(handle,transa,transb,m,n,k,alpha,c_loc(A),lda,stride_a,c_loc(B),ldb,stride_b,beta,c_loc(C),ldc,stride_c,batch_count)
    end function

    function rocblas_cgemm_strided_batched_rank_1(handle,transa,transb,m,n,k,alpha,A,lda,stride_a,B,ldb,stride_b,beta,C,ldc,stride_c,batch_count)
      use iso_c_binding
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocblas_cgemm_strided_batched_rank_1
      type(c_ptr),value :: handle
      integer(kind(rocblas_operation_none)),value :: transa
      integer(kind(rocblas_operation_none)),value :: transb
      integer(c_int),value :: m
      integer(c_int),value :: n
      integer(c_int),value :: k
      complex(c_float_complex) :: alpha
      complex(c_float_complex),target,dimension(:) :: A
      integer(c_int),value :: lda
      integer(c_int64_t),value :: stride_a
      complex(c_float_complex),target,dimension(:) :: B
      integer(c_int),value :: ldb
      integer(c_int64_t),value :: stride_b
      complex(c_float_complex) :: beta
      complex(c_float_complex),target,dimension(:) :: C
      integer(c_int),value :: ldc
      integer(c_int64_t),value :: stride_c
      integer(c_int),value :: batch_count
      !
      rocblas_cgemm_strided_batched_rank_1 = rocblas_cgemm_strided_batched_orig(handle,transa,transb,m,n,k,alpha,c_loc(A),lda,stride_a,c_loc(B),ldb,stride_b,beta,c_loc(C),ldc,stride_c,batch_count)
    end function

    function rocblas_zgemm_strided_batched_full_rank(handle,transa,transb,m,n,k,alpha,A,lda,stride_a,B,ldb,stride_b,beta,C,ldc,stride_c,batch_count)
      use iso_c_binding
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocblas_zgemm_strided_batched_full_rank
      type(c_ptr),value :: handle
      integer(kind(rocblas_operation_none)),value :: transa
      integer(kind(rocblas_operation_none)),value :: transb
      integer(c_int),value :: m
      integer(c_int),value :: n
      integer(c_int),value :: k
      complex(c_double_complex) :: alpha
      complex(c_double_complex),target,dimension(:,:) :: A
      integer(c_int),value :: lda
      integer(c_int64_t),value :: stride_a
      complex(c_double_complex),target,dimension(:,:) :: B
      integer(c_int),value :: ldb
      integer(c_int64_t),value :: stride_b
      complex(c_double_complex) :: beta
      complex(c_double_complex),target,dimension(:,:) :: C
      integer(c_int),value :: ldc
      integer(c_int64_t),value :: stride_c
      integer(c_int),value :: batch_count
      !
      rocblas_zgemm_strided_batched_full_rank = rocblas_zgemm_strided_batched_orig(handle,transa,transb,m,n,k,alpha,c_loc(A),lda,stride_a,c_loc(B),ldb,stride_b,beta,c_loc(C),ldc,stride_c,batch_count)
    end function

    function rocblas_zgemm_strided_batched_rank_0(handle,transa,transb,m,n,k,alpha,A,lda,stride_a,B,ldb,stride_b,beta,C,ldc,stride_c,batch_count)
      use iso_c_binding
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocblas_zgemm_strided_batched_rank_0
      type(c_ptr),value :: handle
      integer(kind(rocblas_operation_none)),value :: transa
      integer(kind(rocblas_operation_none)),value :: transb
      integer(c_int),value :: m
      integer(c_int),value :: n
      integer(c_int),value :: k
      complex(c_double_complex) :: alpha
      complex(c_double_complex),target :: A
      integer(c_int),value :: lda
      integer(c_int64_t),value :: stride_a
      complex(c_double_complex),target :: B
      integer(c_int),value :: ldb
      integer(c_int64_t),value :: stride_b
      complex(c_double_complex) :: beta
      complex(c_double_complex),target :: C
      integer(c_int),value :: ldc
      integer(c_int64_t),value :: stride_c
      integer(c_int),value :: batch_count
      !
      rocblas_zgemm_strided_batched_rank_0 = rocblas_zgemm_strided_batched_orig(handle,transa,transb,m,n,k,alpha,c_loc(A),lda,stride_a,c_loc(B),ldb,stride_b,beta,c_loc(C),ldc,stride_c,batch_count)
    end function

    function rocblas_zgemm_strided_batched_rank_1(handle,transa,transb,m,n,k,alpha,A,lda,stride_a,B,ldb,stride_b,beta,C,ldc,stride_c,batch_count)
      use iso_c_binding
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocblas_zgemm_strided_batched_rank_1
      type(c_ptr),value :: handle
      integer(kind(rocblas_operation_none)),value :: transa
      integer(kind(rocblas_operation_none)),value :: transb
      integer(c_int),value :: m
      integer(c_int),value :: n
      integer(c_int),value :: k
      complex(c_double_complex) :: alpha
      complex(c_double_complex),target,dimension(:) :: A
      integer(c_int),value :: lda
      integer(c_int64_t),value :: stride_a
      complex(c_double_complex),target,dimension(:) :: B
      integer(c_int),value :: ldb
      integer(c_int64_t),value :: stride_b
      complex(c_double_complex) :: beta
      complex(c_double_complex),target,dimension(:) :: C
      integer(c_int),value :: ldc
      integer(c_int64_t),value :: stride_c
      integer(c_int),value :: batch_count
      !
      rocblas_zgemm_strided_batched_rank_1 = rocblas_zgemm_strided_batched_orig(handle,transa,transb,m,n,k,alpha,c_loc(A),lda,stride_a,c_loc(B),ldb,stride_b,beta,c_loc(C),ldc,stride_c,batch_count)
    end function

    function rocblas_sdgmm_full_rank(handle,side,m,n,A,lda,x,incx,C,ldc)
      use iso_c_binding
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocblas_sdgmm_full_rank
      type(c_ptr),value :: handle
      integer(kind(rocblas_side_left)),value :: side
      integer(c_int),value :: m
      integer(c_int),value :: n
      real(c_float),target,dimension(:,:) :: A
      integer(c_int),value :: lda
      real(c_float),target,dimension(:) :: x
      integer(c_int),value :: incx
      real(c_float),target,dimension(:,:) :: C
      integer(c_int),value :: ldc
      !
      rocblas_sdgmm_full_rank = rocblas_sdgmm_orig(handle,side,m,n,c_loc(A),lda,c_loc(x),incx,c_loc(C),ldc)
    end function

    function rocblas_sdgmm_rank_0(handle,side,m,n,A,lda,x,incx,C,ldc)
      use iso_c_binding
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocblas_sdgmm_rank_0
      type(c_ptr),value :: handle
      integer(kind(rocblas_side_left)),value :: side
      integer(c_int),value :: m
      integer(c_int),value :: n
      real(c_float),target :: A
      integer(c_int),value :: lda
      real(c_float),target :: x
      integer(c_int),value :: incx
      real(c_float),target :: C
      integer(c_int),value :: ldc
      !
      rocblas_sdgmm_rank_0 = rocblas_sdgmm_orig(handle,side,m,n,c_loc(A),lda,c_loc(x),incx,c_loc(C),ldc)
    end function

    function rocblas_sdgmm_rank_1(handle,side,m,n,A,lda,x,incx,C,ldc)
      use iso_c_binding
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocblas_sdgmm_rank_1
      type(c_ptr),value :: handle
      integer(kind(rocblas_side_left)),value :: side
      integer(c_int),value :: m
      integer(c_int),value :: n
      real(c_float),target,dimension(:) :: A
      integer(c_int),value :: lda
      real(c_float),target,dimension(:) :: x
      integer(c_int),value :: incx
      real(c_float),target,dimension(:) :: C
      integer(c_int),value :: ldc
      !
      rocblas_sdgmm_rank_1 = rocblas_sdgmm_orig(handle,side,m,n,c_loc(A),lda,c_loc(x),incx,c_loc(C),ldc)
    end function

    function rocblas_ddgmm_full_rank(handle,side,m,n,A,lda,x,incx,C,ldc)
      use iso_c_binding
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocblas_ddgmm_full_rank
      type(c_ptr),value :: handle
      integer(kind(rocblas_side_left)),value :: side
      integer(c_int),value :: m
      integer(c_int),value :: n
      real(c_double),target,dimension(:,:) :: A
      integer(c_int),value :: lda
      real(c_double),target,dimension(:) :: x
      integer(c_int),value :: incx
      real(c_double),target,dimension(:,:) :: C
      integer(c_int),value :: ldc
      !
      rocblas_ddgmm_full_rank = rocblas_ddgmm_orig(handle,side,m,n,c_loc(A),lda,c_loc(x),incx,c_loc(C),ldc)
    end function

    function rocblas_ddgmm_rank_0(handle,side,m,n,A,lda,x,incx,C,ldc)
      use iso_c_binding
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocblas_ddgmm_rank_0
      type(c_ptr),value :: handle
      integer(kind(rocblas_side_left)),value :: side
      integer(c_int),value :: m
      integer(c_int),value :: n
      real(c_double),target :: A
      integer(c_int),value :: lda
      real(c_double),target :: x
      integer(c_int),value :: incx
      real(c_double),target :: C
      integer(c_int),value :: ldc
      !
      rocblas_ddgmm_rank_0 = rocblas_ddgmm_orig(handle,side,m,n,c_loc(A),lda,c_loc(x),incx,c_loc(C),ldc)
    end function

    function rocblas_ddgmm_rank_1(handle,side,m,n,A,lda,x,incx,C,ldc)
      use iso_c_binding
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocblas_ddgmm_rank_1
      type(c_ptr),value :: handle
      integer(kind(rocblas_side_left)),value :: side
      integer(c_int),value :: m
      integer(c_int),value :: n
      real(c_double),target,dimension(:) :: A
      integer(c_int),value :: lda
      real(c_double),target,dimension(:) :: x
      integer(c_int),value :: incx
      real(c_double),target,dimension(:) :: C
      integer(c_int),value :: ldc
      !
      rocblas_ddgmm_rank_1 = rocblas_ddgmm_orig(handle,side,m,n,c_loc(A),lda,c_loc(x),incx,c_loc(C),ldc)
    end function

    function rocblas_cdgmm_full_rank(handle,side,m,n,A,lda,x,incx,C,ldc)
      use iso_c_binding
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocblas_cdgmm_full_rank
      type(c_ptr),value :: handle
      integer(kind(rocblas_side_left)),value :: side
      integer(c_int),value :: m
      integer(c_int),value :: n
      complex(c_float_complex),target,dimension(:,:) :: A
      integer(c_int),value :: lda
      complex(c_float_complex),target,dimension(:) :: x
      integer(c_int),value :: incx
      complex(c_float_complex),target,dimension(:,:) :: C
      integer(c_int),value :: ldc
      !
      rocblas_cdgmm_full_rank = rocblas_cdgmm_orig(handle,side,m,n,c_loc(A),lda,c_loc(x),incx,c_loc(C),ldc)
    end function

    function rocblas_cdgmm_rank_0(handle,side,m,n,A,lda,x,incx,C,ldc)
      use iso_c_binding
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocblas_cdgmm_rank_0
      type(c_ptr),value :: handle
      integer(kind(rocblas_side_left)),value :: side
      integer(c_int),value :: m
      integer(c_int),value :: n
      complex(c_float_complex),target :: A
      integer(c_int),value :: lda
      complex(c_float_complex),target :: x
      integer(c_int),value :: incx
      complex(c_float_complex),target :: C
      integer(c_int),value :: ldc
      !
      rocblas_cdgmm_rank_0 = rocblas_cdgmm_orig(handle,side,m,n,c_loc(A),lda,c_loc(x),incx,c_loc(C),ldc)
    end function

    function rocblas_cdgmm_rank_1(handle,side,m,n,A,lda,x,incx,C,ldc)
      use iso_c_binding
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocblas_cdgmm_rank_1
      type(c_ptr),value :: handle
      integer(kind(rocblas_side_left)),value :: side
      integer(c_int),value :: m
      integer(c_int),value :: n
      complex(c_float_complex),target,dimension(:) :: A
      integer(c_int),value :: lda
      complex(c_float_complex),target,dimension(:) :: x
      integer(c_int),value :: incx
      complex(c_float_complex),target,dimension(:) :: C
      integer(c_int),value :: ldc
      !
      rocblas_cdgmm_rank_1 = rocblas_cdgmm_orig(handle,side,m,n,c_loc(A),lda,c_loc(x),incx,c_loc(C),ldc)
    end function

    function rocblas_zdgmm_full_rank(handle,side,m,n,A,lda,x,incx,C,ldc)
      use iso_c_binding
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocblas_zdgmm_full_rank
      type(c_ptr),value :: handle
      integer(kind(rocblas_side_left)),value :: side
      integer(c_int),value :: m
      integer(c_int),value :: n
      complex(c_double_complex),target,dimension(:,:) :: A
      integer(c_int),value :: lda
      complex(c_double_complex),target,dimension(:) :: x
      integer(c_int),value :: incx
      complex(c_double_complex),target,dimension(:,:) :: C
      integer(c_int),value :: ldc
      !
      rocblas_zdgmm_full_rank = rocblas_zdgmm_orig(handle,side,m,n,c_loc(A),lda,c_loc(x),incx,c_loc(C),ldc)
    end function

    function rocblas_zdgmm_rank_0(handle,side,m,n,A,lda,x,incx,C,ldc)
      use iso_c_binding
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocblas_zdgmm_rank_0
      type(c_ptr),value :: handle
      integer(kind(rocblas_side_left)),value :: side
      integer(c_int),value :: m
      integer(c_int),value :: n
      complex(c_double_complex),target :: A
      integer(c_int),value :: lda
      complex(c_double_complex),target :: x
      integer(c_int),value :: incx
      complex(c_double_complex),target :: C
      integer(c_int),value :: ldc
      !
      rocblas_zdgmm_rank_0 = rocblas_zdgmm_orig(handle,side,m,n,c_loc(A),lda,c_loc(x),incx,c_loc(C),ldc)
    end function

    function rocblas_zdgmm_rank_1(handle,side,m,n,A,lda,x,incx,C,ldc)
      use iso_c_binding
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocblas_zdgmm_rank_1
      type(c_ptr),value :: handle
      integer(kind(rocblas_side_left)),value :: side
      integer(c_int),value :: m
      integer(c_int),value :: n
      complex(c_double_complex),target,dimension(:) :: A
      integer(c_int),value :: lda
      complex(c_double_complex),target,dimension(:) :: x
      integer(c_int),value :: incx
      complex(c_double_complex),target,dimension(:) :: C
      integer(c_int),value :: ldc
      !
      rocblas_zdgmm_rank_1 = rocblas_zdgmm_orig(handle,side,m,n,c_loc(A),lda,c_loc(x),incx,c_loc(C),ldc)
    end function

    function rocblas_sdgmm_batched_full_rank(handle,side,m,n,A,lda,x,incx,C,ldc,batch_count)
      use iso_c_binding
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocblas_sdgmm_batched_full_rank
      type(c_ptr),value :: handle
      integer(kind(rocblas_side_left)),value :: side
      integer(c_int),value :: m
      integer(c_int),value :: n
      real(c_float),target,dimension(:,:,:) :: A
      integer(c_int),value :: lda
      real(c_float),target,dimension(:,:) :: x
      integer(c_int),value :: incx
      real(c_float),target,dimension(:,:,:) :: C
      integer(c_int),value :: ldc
      integer(c_int),value :: batch_count
      !
      rocblas_sdgmm_batched_full_rank = rocblas_sdgmm_batched_orig(handle,side,m,n,c_loc(A),lda,c_loc(x),incx,c_loc(C),ldc,batch_count)
    end function

    function rocblas_sdgmm_batched_rank_0(handle,side,m,n,A,lda,x,incx,C,ldc,batch_count)
      use iso_c_binding
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocblas_sdgmm_batched_rank_0
      type(c_ptr),value :: handle
      integer(kind(rocblas_side_left)),value :: side
      integer(c_int),value :: m
      integer(c_int),value :: n
      real(c_float),target :: A
      integer(c_int),value :: lda
      real(c_float),target :: x
      integer(c_int),value :: incx
      real(c_float),target :: C
      integer(c_int),value :: ldc
      integer(c_int),value :: batch_count
      !
      rocblas_sdgmm_batched_rank_0 = rocblas_sdgmm_batched_orig(handle,side,m,n,c_loc(A),lda,c_loc(x),incx,c_loc(C),ldc,batch_count)
    end function

    function rocblas_sdgmm_batched_rank_1(handle,side,m,n,A,lda,x,incx,C,ldc,batch_count)
      use iso_c_binding
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocblas_sdgmm_batched_rank_1
      type(c_ptr),value :: handle
      integer(kind(rocblas_side_left)),value :: side
      integer(c_int),value :: m
      integer(c_int),value :: n
      real(c_float),target,dimension(:) :: A
      integer(c_int),value :: lda
      real(c_float),target,dimension(:) :: x
      integer(c_int),value :: incx
      real(c_float),target,dimension(:) :: C
      integer(c_int),value :: ldc
      integer(c_int),value :: batch_count
      !
      rocblas_sdgmm_batched_rank_1 = rocblas_sdgmm_batched_orig(handle,side,m,n,c_loc(A),lda,c_loc(x),incx,c_loc(C),ldc,batch_count)
    end function

    function rocblas_ddgmm_batched_full_rank(handle,side,m,n,A,lda,x,incx,C,ldc,batch_count)
      use iso_c_binding
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocblas_ddgmm_batched_full_rank
      type(c_ptr),value :: handle
      integer(kind(rocblas_side_left)),value :: side
      integer(c_int),value :: m
      integer(c_int),value :: n
      real(c_double),target,dimension(:,:,:) :: A
      integer(c_int),value :: lda
      real(c_double),target,dimension(:,:) :: x
      integer(c_int),value :: incx
      real(c_double),target,dimension(:,:,:) :: C
      integer(c_int),value :: ldc
      integer(c_int),value :: batch_count
      !
      rocblas_ddgmm_batched_full_rank = rocblas_ddgmm_batched_orig(handle,side,m,n,c_loc(A),lda,c_loc(x),incx,c_loc(C),ldc,batch_count)
    end function

    function rocblas_ddgmm_batched_rank_0(handle,side,m,n,A,lda,x,incx,C,ldc,batch_count)
      use iso_c_binding
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocblas_ddgmm_batched_rank_0
      type(c_ptr),value :: handle
      integer(kind(rocblas_side_left)),value :: side
      integer(c_int),value :: m
      integer(c_int),value :: n
      real(c_double),target :: A
      integer(c_int),value :: lda
      real(c_double),target :: x
      integer(c_int),value :: incx
      real(c_double),target :: C
      integer(c_int),value :: ldc
      integer(c_int),value :: batch_count
      !
      rocblas_ddgmm_batched_rank_0 = rocblas_ddgmm_batched_orig(handle,side,m,n,c_loc(A),lda,c_loc(x),incx,c_loc(C),ldc,batch_count)
    end function

    function rocblas_ddgmm_batched_rank_1(handle,side,m,n,A,lda,x,incx,C,ldc,batch_count)
      use iso_c_binding
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocblas_ddgmm_batched_rank_1
      type(c_ptr),value :: handle
      integer(kind(rocblas_side_left)),value :: side
      integer(c_int),value :: m
      integer(c_int),value :: n
      real(c_double),target,dimension(:) :: A
      integer(c_int),value :: lda
      real(c_double),target,dimension(:) :: x
      integer(c_int),value :: incx
      real(c_double),target,dimension(:) :: C
      integer(c_int),value :: ldc
      integer(c_int),value :: batch_count
      !
      rocblas_ddgmm_batched_rank_1 = rocblas_ddgmm_batched_orig(handle,side,m,n,c_loc(A),lda,c_loc(x),incx,c_loc(C),ldc,batch_count)
    end function

    function rocblas_cdgmm_batched_full_rank(handle,side,m,n,A,lda,x,incx,C,ldc,batch_count)
      use iso_c_binding
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocblas_cdgmm_batched_full_rank
      type(c_ptr),value :: handle
      integer(kind(rocblas_side_left)),value :: side
      integer(c_int),value :: m
      integer(c_int),value :: n
      complex(c_float_complex),target,dimension(:,:,:) :: A
      integer(c_int),value :: lda
      complex(c_float_complex),target,dimension(:,:) :: x
      integer(c_int),value :: incx
      complex(c_float_complex),target,dimension(:,:,:) :: C
      integer(c_int),value :: ldc
      integer(c_int),value :: batch_count
      !
      rocblas_cdgmm_batched_full_rank = rocblas_cdgmm_batched_orig(handle,side,m,n,c_loc(A),lda,c_loc(x),incx,c_loc(C),ldc,batch_count)
    end function

    function rocblas_cdgmm_batched_rank_0(handle,side,m,n,A,lda,x,incx,C,ldc,batch_count)
      use iso_c_binding
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocblas_cdgmm_batched_rank_0
      type(c_ptr),value :: handle
      integer(kind(rocblas_side_left)),value :: side
      integer(c_int),value :: m
      integer(c_int),value :: n
      complex(c_float_complex),target :: A
      integer(c_int),value :: lda
      complex(c_float_complex),target :: x
      integer(c_int),value :: incx
      complex(c_float_complex),target :: C
      integer(c_int),value :: ldc
      integer(c_int),value :: batch_count
      !
      rocblas_cdgmm_batched_rank_0 = rocblas_cdgmm_batched_orig(handle,side,m,n,c_loc(A),lda,c_loc(x),incx,c_loc(C),ldc,batch_count)
    end function

    function rocblas_cdgmm_batched_rank_1(handle,side,m,n,A,lda,x,incx,C,ldc,batch_count)
      use iso_c_binding
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocblas_cdgmm_batched_rank_1
      type(c_ptr),value :: handle
      integer(kind(rocblas_side_left)),value :: side
      integer(c_int),value :: m
      integer(c_int),value :: n
      complex(c_float_complex),target,dimension(:) :: A
      integer(c_int),value :: lda
      complex(c_float_complex),target,dimension(:) :: x
      integer(c_int),value :: incx
      complex(c_float_complex),target,dimension(:) :: C
      integer(c_int),value :: ldc
      integer(c_int),value :: batch_count
      !
      rocblas_cdgmm_batched_rank_1 = rocblas_cdgmm_batched_orig(handle,side,m,n,c_loc(A),lda,c_loc(x),incx,c_loc(C),ldc,batch_count)
    end function

    function rocblas_zdgmm_batched_full_rank(handle,side,m,n,A,lda,x,incx,C,ldc,batch_count)
      use iso_c_binding
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocblas_zdgmm_batched_full_rank
      type(c_ptr),value :: handle
      integer(kind(rocblas_side_left)),value :: side
      integer(c_int),value :: m
      integer(c_int),value :: n
      complex(c_double_complex),target,dimension(:,:,:) :: A
      integer(c_int),value :: lda
      complex(c_double_complex),target,dimension(:,:) :: x
      integer(c_int),value :: incx
      complex(c_double_complex),target,dimension(:,:,:) :: C
      integer(c_int),value :: ldc
      integer(c_int),value :: batch_count
      !
      rocblas_zdgmm_batched_full_rank = rocblas_zdgmm_batched_orig(handle,side,m,n,c_loc(A),lda,c_loc(x),incx,c_loc(C),ldc,batch_count)
    end function

    function rocblas_zdgmm_batched_rank_0(handle,side,m,n,A,lda,x,incx,C,ldc,batch_count)
      use iso_c_binding
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocblas_zdgmm_batched_rank_0
      type(c_ptr),value :: handle
      integer(kind(rocblas_side_left)),value :: side
      integer(c_int),value :: m
      integer(c_int),value :: n
      complex(c_double_complex),target :: A
      integer(c_int),value :: lda
      complex(c_double_complex),target :: x
      integer(c_int),value :: incx
      complex(c_double_complex),target :: C
      integer(c_int),value :: ldc
      integer(c_int),value :: batch_count
      !
      rocblas_zdgmm_batched_rank_0 = rocblas_zdgmm_batched_orig(handle,side,m,n,c_loc(A),lda,c_loc(x),incx,c_loc(C),ldc,batch_count)
    end function

    function rocblas_zdgmm_batched_rank_1(handle,side,m,n,A,lda,x,incx,C,ldc,batch_count)
      use iso_c_binding
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocblas_zdgmm_batched_rank_1
      type(c_ptr),value :: handle
      integer(kind(rocblas_side_left)),value :: side
      integer(c_int),value :: m
      integer(c_int),value :: n
      complex(c_double_complex),target,dimension(:) :: A
      integer(c_int),value :: lda
      complex(c_double_complex),target,dimension(:) :: x
      integer(c_int),value :: incx
      complex(c_double_complex),target,dimension(:) :: C
      integer(c_int),value :: ldc
      integer(c_int),value :: batch_count
      !
      rocblas_zdgmm_batched_rank_1 = rocblas_zdgmm_batched_orig(handle,side,m,n,c_loc(A),lda,c_loc(x),incx,c_loc(C),ldc,batch_count)
    end function

    function rocblas_sdgmm_strided_batched_full_rank(handle,side,m,n,A,lda,stride_a,x,incx,stride_x,C,ldc,stride_c,batch_count)
      use iso_c_binding
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocblas_sdgmm_strided_batched_full_rank
      type(c_ptr),value :: handle
      integer(kind(rocblas_side_left)),value :: side
      integer(c_int),value :: m
      integer(c_int),value :: n
      real(c_float),target,dimension(:,:) :: A
      integer(c_int),value :: lda
      integer(c_int64_t),value :: stride_a
      real(c_float),target,dimension(:) :: x
      integer(c_int),value :: incx
      integer(c_int64_t),value :: stride_x
      real(c_float),target,dimension(:,:) :: C
      integer(c_int),value :: ldc
      integer(c_int64_t),value :: stride_c
      integer(c_int),value :: batch_count
      !
      rocblas_sdgmm_strided_batched_full_rank = rocblas_sdgmm_strided_batched_orig(handle,side,m,n,c_loc(A),lda,stride_a,c_loc(x),incx,stride_x,c_loc(C),ldc,stride_c,batch_count)
    end function

    function rocblas_sdgmm_strided_batched_rank_0(handle,side,m,n,A,lda,stride_a,x,incx,stride_x,C,ldc,stride_c,batch_count)
      use iso_c_binding
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocblas_sdgmm_strided_batched_rank_0
      type(c_ptr),value :: handle
      integer(kind(rocblas_side_left)),value :: side
      integer(c_int),value :: m
      integer(c_int),value :: n
      real(c_float),target :: A
      integer(c_int),value :: lda
      integer(c_int64_t),value :: stride_a
      real(c_float),target :: x
      integer(c_int),value :: incx
      integer(c_int64_t),value :: stride_x
      real(c_float),target :: C
      integer(c_int),value :: ldc
      integer(c_int64_t),value :: stride_c
      integer(c_int),value :: batch_count
      !
      rocblas_sdgmm_strided_batched_rank_0 = rocblas_sdgmm_strided_batched_orig(handle,side,m,n,c_loc(A),lda,stride_a,c_loc(x),incx,stride_x,c_loc(C),ldc,stride_c,batch_count)
    end function

    function rocblas_sdgmm_strided_batched_rank_1(handle,side,m,n,A,lda,stride_a,x,incx,stride_x,C,ldc,stride_c,batch_count)
      use iso_c_binding
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocblas_sdgmm_strided_batched_rank_1
      type(c_ptr),value :: handle
      integer(kind(rocblas_side_left)),value :: side
      integer(c_int),value :: m
      integer(c_int),value :: n
      real(c_float),target,dimension(:) :: A
      integer(c_int),value :: lda
      integer(c_int64_t),value :: stride_a
      real(c_float),target,dimension(:) :: x
      integer(c_int),value :: incx
      integer(c_int64_t),value :: stride_x
      real(c_float),target,dimension(:) :: C
      integer(c_int),value :: ldc
      integer(c_int64_t),value :: stride_c
      integer(c_int),value :: batch_count
      !
      rocblas_sdgmm_strided_batched_rank_1 = rocblas_sdgmm_strided_batched_orig(handle,side,m,n,c_loc(A),lda,stride_a,c_loc(x),incx,stride_x,c_loc(C),ldc,stride_c,batch_count)
    end function

    function rocblas_ddgmm_strided_batched_full_rank(handle,side,m,n,A,lda,stride_a,x,incx,stride_x,C,ldc,stride_c,batch_count)
      use iso_c_binding
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocblas_ddgmm_strided_batched_full_rank
      type(c_ptr),value :: handle
      integer(kind(rocblas_side_left)),value :: side
      integer(c_int),value :: m
      integer(c_int),value :: n
      real(c_double),target,dimension(:,:) :: A
      integer(c_int),value :: lda
      integer(c_int64_t),value :: stride_a
      real(c_double),target,dimension(:) :: x
      integer(c_int),value :: incx
      integer(c_int64_t),value :: stride_x
      real(c_double),target,dimension(:,:) :: C
      integer(c_int),value :: ldc
      integer(c_int64_t),value :: stride_c
      integer(c_int),value :: batch_count
      !
      rocblas_ddgmm_strided_batched_full_rank = rocblas_ddgmm_strided_batched_orig(handle,side,m,n,c_loc(A),lda,stride_a,c_loc(x),incx,stride_x,c_loc(C),ldc,stride_c,batch_count)
    end function

    function rocblas_ddgmm_strided_batched_rank_0(handle,side,m,n,A,lda,stride_a,x,incx,stride_x,C,ldc,stride_c,batch_count)
      use iso_c_binding
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocblas_ddgmm_strided_batched_rank_0
      type(c_ptr),value :: handle
      integer(kind(rocblas_side_left)),value :: side
      integer(c_int),value :: m
      integer(c_int),value :: n
      real(c_double),target :: A
      integer(c_int),value :: lda
      integer(c_int64_t),value :: stride_a
      real(c_double),target :: x
      integer(c_int),value :: incx
      integer(c_int64_t),value :: stride_x
      real(c_double),target :: C
      integer(c_int),value :: ldc
      integer(c_int64_t),value :: stride_c
      integer(c_int),value :: batch_count
      !
      rocblas_ddgmm_strided_batched_rank_0 = rocblas_ddgmm_strided_batched_orig(handle,side,m,n,c_loc(A),lda,stride_a,c_loc(x),incx,stride_x,c_loc(C),ldc,stride_c,batch_count)
    end function

    function rocblas_ddgmm_strided_batched_rank_1(handle,side,m,n,A,lda,stride_a,x,incx,stride_x,C,ldc,stride_c,batch_count)
      use iso_c_binding
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocblas_ddgmm_strided_batched_rank_1
      type(c_ptr),value :: handle
      integer(kind(rocblas_side_left)),value :: side
      integer(c_int),value :: m
      integer(c_int),value :: n
      real(c_double),target,dimension(:) :: A
      integer(c_int),value :: lda
      integer(c_int64_t),value :: stride_a
      real(c_double),target,dimension(:) :: x
      integer(c_int),value :: incx
      integer(c_int64_t),value :: stride_x
      real(c_double),target,dimension(:) :: C
      integer(c_int),value :: ldc
      integer(c_int64_t),value :: stride_c
      integer(c_int),value :: batch_count
      !
      rocblas_ddgmm_strided_batched_rank_1 = rocblas_ddgmm_strided_batched_orig(handle,side,m,n,c_loc(A),lda,stride_a,c_loc(x),incx,stride_x,c_loc(C),ldc,stride_c,batch_count)
    end function

    function rocblas_cdgmm_strided_batched_full_rank(handle,side,m,n,A,lda,stride_a,x,incx,stride_x,C,ldc,stride_c,batch_count)
      use iso_c_binding
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocblas_cdgmm_strided_batched_full_rank
      type(c_ptr),value :: handle
      integer(kind(rocblas_side_left)),value :: side
      integer(c_int),value :: m
      integer(c_int),value :: n
      complex(c_float_complex),target,dimension(:,:) :: A
      integer(c_int),value :: lda
      integer(c_int64_t),value :: stride_a
      complex(c_float_complex),target,dimension(:) :: x
      integer(c_int),value :: incx
      integer(c_int64_t),value :: stride_x
      complex(c_float_complex),target,dimension(:,:) :: C
      integer(c_int),value :: ldc
      integer(c_int64_t),value :: stride_c
      integer(c_int),value :: batch_count
      !
      rocblas_cdgmm_strided_batched_full_rank = rocblas_cdgmm_strided_batched_orig(handle,side,m,n,c_loc(A),lda,stride_a,c_loc(x),incx,stride_x,c_loc(C),ldc,stride_c,batch_count)
    end function

    function rocblas_cdgmm_strided_batched_rank_0(handle,side,m,n,A,lda,stride_a,x,incx,stride_x,C,ldc,stride_c,batch_count)
      use iso_c_binding
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocblas_cdgmm_strided_batched_rank_0
      type(c_ptr),value :: handle
      integer(kind(rocblas_side_left)),value :: side
      integer(c_int),value :: m
      integer(c_int),value :: n
      complex(c_float_complex),target :: A
      integer(c_int),value :: lda
      integer(c_int64_t),value :: stride_a
      complex(c_float_complex),target :: x
      integer(c_int),value :: incx
      integer(c_int64_t),value :: stride_x
      complex(c_float_complex),target :: C
      integer(c_int),value :: ldc
      integer(c_int64_t),value :: stride_c
      integer(c_int),value :: batch_count
      !
      rocblas_cdgmm_strided_batched_rank_0 = rocblas_cdgmm_strided_batched_orig(handle,side,m,n,c_loc(A),lda,stride_a,c_loc(x),incx,stride_x,c_loc(C),ldc,stride_c,batch_count)
    end function

    function rocblas_cdgmm_strided_batched_rank_1(handle,side,m,n,A,lda,stride_a,x,incx,stride_x,C,ldc,stride_c,batch_count)
      use iso_c_binding
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocblas_cdgmm_strided_batched_rank_1
      type(c_ptr),value :: handle
      integer(kind(rocblas_side_left)),value :: side
      integer(c_int),value :: m
      integer(c_int),value :: n
      complex(c_float_complex),target,dimension(:) :: A
      integer(c_int),value :: lda
      integer(c_int64_t),value :: stride_a
      complex(c_float_complex),target,dimension(:) :: x
      integer(c_int),value :: incx
      integer(c_int64_t),value :: stride_x
      complex(c_float_complex),target,dimension(:) :: C
      integer(c_int),value :: ldc
      integer(c_int64_t),value :: stride_c
      integer(c_int),value :: batch_count
      !
      rocblas_cdgmm_strided_batched_rank_1 = rocblas_cdgmm_strided_batched_orig(handle,side,m,n,c_loc(A),lda,stride_a,c_loc(x),incx,stride_x,c_loc(C),ldc,stride_c,batch_count)
    end function

    function rocblas_zdgmm_strided_batched_full_rank(handle,side,m,n,A,lda,stride_a,x,incx,stride_x,C,ldc,stride_c,batch_count)
      use iso_c_binding
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocblas_zdgmm_strided_batched_full_rank
      type(c_ptr),value :: handle
      integer(kind(rocblas_side_left)),value :: side
      integer(c_int),value :: m
      integer(c_int),value :: n
      complex(c_double_complex),target,dimension(:,:) :: A
      integer(c_int),value :: lda
      integer(c_int64_t),value :: stride_a
      complex(c_double_complex),target,dimension(:) :: x
      integer(c_int),value :: incx
      integer(c_int64_t),value :: stride_x
      complex(c_double_complex),target,dimension(:,:) :: C
      integer(c_int),value :: ldc
      integer(c_int64_t),value :: stride_c
      integer(c_int),value :: batch_count
      !
      rocblas_zdgmm_strided_batched_full_rank = rocblas_zdgmm_strided_batched_orig(handle,side,m,n,c_loc(A),lda,stride_a,c_loc(x),incx,stride_x,c_loc(C),ldc,stride_c,batch_count)
    end function

    function rocblas_zdgmm_strided_batched_rank_0(handle,side,m,n,A,lda,stride_a,x,incx,stride_x,C,ldc,stride_c,batch_count)
      use iso_c_binding
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocblas_zdgmm_strided_batched_rank_0
      type(c_ptr),value :: handle
      integer(kind(rocblas_side_left)),value :: side
      integer(c_int),value :: m
      integer(c_int),value :: n
      complex(c_double_complex),target :: A
      integer(c_int),value :: lda
      integer(c_int64_t),value :: stride_a
      complex(c_double_complex),target :: x
      integer(c_int),value :: incx
      integer(c_int64_t),value :: stride_x
      complex(c_double_complex),target :: C
      integer(c_int),value :: ldc
      integer(c_int64_t),value :: stride_c
      integer(c_int),value :: batch_count
      !
      rocblas_zdgmm_strided_batched_rank_0 = rocblas_zdgmm_strided_batched_orig(handle,side,m,n,c_loc(A),lda,stride_a,c_loc(x),incx,stride_x,c_loc(C),ldc,stride_c,batch_count)
    end function

    function rocblas_zdgmm_strided_batched_rank_1(handle,side,m,n,A,lda,stride_a,x,incx,stride_x,C,ldc,stride_c,batch_count)
      use iso_c_binding
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocblas_zdgmm_strided_batched_rank_1
      type(c_ptr),value :: handle
      integer(kind(rocblas_side_left)),value :: side
      integer(c_int),value :: m
      integer(c_int),value :: n
      complex(c_double_complex),target,dimension(:) :: A
      integer(c_int),value :: lda
      integer(c_int64_t),value :: stride_a
      complex(c_double_complex),target,dimension(:) :: x
      integer(c_int),value :: incx
      integer(c_int64_t),value :: stride_x
      complex(c_double_complex),target,dimension(:) :: C
      integer(c_int),value :: ldc
      integer(c_int64_t),value :: stride_c
      integer(c_int),value :: batch_count
      !
      rocblas_zdgmm_strided_batched_rank_1 = rocblas_zdgmm_strided_batched_orig(handle,side,m,n,c_loc(A),lda,stride_a,c_loc(x),incx,stride_x,c_loc(C),ldc,stride_c,batch_count)
    end function

    function rocblas_sgeam_full_rank(handle,transA,transB,m,n,alpha,A,lda,beta,B,ldb,C,ldc)
      use iso_c_binding
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocblas_sgeam_full_rank
      type(c_ptr),value :: handle
      integer(kind(rocblas_operation_none)),value :: transA
      integer(kind(rocblas_operation_none)),value :: transB
      integer(c_int),value :: m
      integer(c_int),value :: n
      real(c_float) :: alpha
      real(c_float),target,dimension(:,:) :: A
      integer(c_int),value :: lda
      real(c_float) :: beta
      real(c_float),target,dimension(:,:) :: B
      integer(c_int),value :: ldb
      real(c_float),target,dimension(:,:) :: C
      integer(c_int),value :: ldc
      !
      rocblas_sgeam_full_rank = rocblas_sgeam_orig(handle,transA,transB,m,n,alpha,c_loc(A),lda,beta,c_loc(B),ldb,c_loc(C),ldc)
    end function

    function rocblas_sgeam_rank_0(handle,transA,transB,m,n,alpha,A,lda,beta,B,ldb,C,ldc)
      use iso_c_binding
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocblas_sgeam_rank_0
      type(c_ptr),value :: handle
      integer(kind(rocblas_operation_none)),value :: transA
      integer(kind(rocblas_operation_none)),value :: transB
      integer(c_int),value :: m
      integer(c_int),value :: n
      real(c_float) :: alpha
      real(c_float),target :: A
      integer(c_int),value :: lda
      real(c_float) :: beta
      real(c_float),target :: B
      integer(c_int),value :: ldb
      real(c_float),target :: C
      integer(c_int),value :: ldc
      !
      rocblas_sgeam_rank_0 = rocblas_sgeam_orig(handle,transA,transB,m,n,alpha,c_loc(A),lda,beta,c_loc(B),ldb,c_loc(C),ldc)
    end function

    function rocblas_sgeam_rank_1(handle,transA,transB,m,n,alpha,A,lda,beta,B,ldb,C,ldc)
      use iso_c_binding
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocblas_sgeam_rank_1
      type(c_ptr),value :: handle
      integer(kind(rocblas_operation_none)),value :: transA
      integer(kind(rocblas_operation_none)),value :: transB
      integer(c_int),value :: m
      integer(c_int),value :: n
      real(c_float) :: alpha
      real(c_float),target,dimension(:) :: A
      integer(c_int),value :: lda
      real(c_float) :: beta
      real(c_float),target,dimension(:) :: B
      integer(c_int),value :: ldb
      real(c_float),target,dimension(:) :: C
      integer(c_int),value :: ldc
      !
      rocblas_sgeam_rank_1 = rocblas_sgeam_orig(handle,transA,transB,m,n,alpha,c_loc(A),lda,beta,c_loc(B),ldb,c_loc(C),ldc)
    end function

    function rocblas_dgeam_full_rank(handle,transA,transB,m,n,alpha,A,lda,beta,B,ldb,C,ldc)
      use iso_c_binding
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocblas_dgeam_full_rank
      type(c_ptr),value :: handle
      integer(kind(rocblas_operation_none)),value :: transA
      integer(kind(rocblas_operation_none)),value :: transB
      integer(c_int),value :: m
      integer(c_int),value :: n
      real(c_double) :: alpha
      real(c_double),target,dimension(:,:) :: A
      integer(c_int),value :: lda
      real(c_double) :: beta
      real(c_double),target,dimension(:,:) :: B
      integer(c_int),value :: ldb
      real(c_double),target,dimension(:,:) :: C
      integer(c_int),value :: ldc
      !
      rocblas_dgeam_full_rank = rocblas_dgeam_orig(handle,transA,transB,m,n,alpha,c_loc(A),lda,beta,c_loc(B),ldb,c_loc(C),ldc)
    end function

    function rocblas_dgeam_rank_0(handle,transA,transB,m,n,alpha,A,lda,beta,B,ldb,C,ldc)
      use iso_c_binding
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocblas_dgeam_rank_0
      type(c_ptr),value :: handle
      integer(kind(rocblas_operation_none)),value :: transA
      integer(kind(rocblas_operation_none)),value :: transB
      integer(c_int),value :: m
      integer(c_int),value :: n
      real(c_double) :: alpha
      real(c_double),target :: A
      integer(c_int),value :: lda
      real(c_double) :: beta
      real(c_double),target :: B
      integer(c_int),value :: ldb
      real(c_double),target :: C
      integer(c_int),value :: ldc
      !
      rocblas_dgeam_rank_0 = rocblas_dgeam_orig(handle,transA,transB,m,n,alpha,c_loc(A),lda,beta,c_loc(B),ldb,c_loc(C),ldc)
    end function

    function rocblas_dgeam_rank_1(handle,transA,transB,m,n,alpha,A,lda,beta,B,ldb,C,ldc)
      use iso_c_binding
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocblas_dgeam_rank_1
      type(c_ptr),value :: handle
      integer(kind(rocblas_operation_none)),value :: transA
      integer(kind(rocblas_operation_none)),value :: transB
      integer(c_int),value :: m
      integer(c_int),value :: n
      real(c_double) :: alpha
      real(c_double),target,dimension(:) :: A
      integer(c_int),value :: lda
      real(c_double) :: beta
      real(c_double),target,dimension(:) :: B
      integer(c_int),value :: ldb
      real(c_double),target,dimension(:) :: C
      integer(c_int),value :: ldc
      !
      rocblas_dgeam_rank_1 = rocblas_dgeam_orig(handle,transA,transB,m,n,alpha,c_loc(A),lda,beta,c_loc(B),ldb,c_loc(C),ldc)
    end function

    function rocblas_cgeam_full_rank(handle,transA,transB,m,n,alpha,A,lda,beta,B,ldb,C,ldc)
      use iso_c_binding
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocblas_cgeam_full_rank
      type(c_ptr),value :: handle
      integer(kind(rocblas_operation_none)),value :: transA
      integer(kind(rocblas_operation_none)),value :: transB
      integer(c_int),value :: m
      integer(c_int),value :: n
      complex(c_float_complex) :: alpha
      complex(c_float_complex),target,dimension(:,:) :: A
      integer(c_int),value :: lda
      complex(c_float_complex) :: beta
      complex(c_float_complex),target,dimension(:,:) :: B
      integer(c_int),value :: ldb
      complex(c_float_complex),target,dimension(:,:) :: C
      integer(c_int),value :: ldc
      !
      rocblas_cgeam_full_rank = rocblas_cgeam_orig(handle,transA,transB,m,n,alpha,c_loc(A),lda,beta,c_loc(B),ldb,c_loc(C),ldc)
    end function

    function rocblas_cgeam_rank_0(handle,transA,transB,m,n,alpha,A,lda,beta,B,ldb,C,ldc)
      use iso_c_binding
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocblas_cgeam_rank_0
      type(c_ptr),value :: handle
      integer(kind(rocblas_operation_none)),value :: transA
      integer(kind(rocblas_operation_none)),value :: transB
      integer(c_int),value :: m
      integer(c_int),value :: n
      complex(c_float_complex) :: alpha
      complex(c_float_complex),target :: A
      integer(c_int),value :: lda
      complex(c_float_complex) :: beta
      complex(c_float_complex),target :: B
      integer(c_int),value :: ldb
      complex(c_float_complex),target :: C
      integer(c_int),value :: ldc
      !
      rocblas_cgeam_rank_0 = rocblas_cgeam_orig(handle,transA,transB,m,n,alpha,c_loc(A),lda,beta,c_loc(B),ldb,c_loc(C),ldc)
    end function

    function rocblas_cgeam_rank_1(handle,transA,transB,m,n,alpha,A,lda,beta,B,ldb,C,ldc)
      use iso_c_binding
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocblas_cgeam_rank_1
      type(c_ptr),value :: handle
      integer(kind(rocblas_operation_none)),value :: transA
      integer(kind(rocblas_operation_none)),value :: transB
      integer(c_int),value :: m
      integer(c_int),value :: n
      complex(c_float_complex) :: alpha
      complex(c_float_complex),target,dimension(:) :: A
      integer(c_int),value :: lda
      complex(c_float_complex) :: beta
      complex(c_float_complex),target,dimension(:) :: B
      integer(c_int),value :: ldb
      complex(c_float_complex),target,dimension(:) :: C
      integer(c_int),value :: ldc
      !
      rocblas_cgeam_rank_1 = rocblas_cgeam_orig(handle,transA,transB,m,n,alpha,c_loc(A),lda,beta,c_loc(B),ldb,c_loc(C),ldc)
    end function

    function rocblas_zgeam_full_rank(handle,transA,transB,m,n,alpha,A,lda,beta,B,ldb,C,ldc)
      use iso_c_binding
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocblas_zgeam_full_rank
      type(c_ptr),value :: handle
      integer(kind(rocblas_operation_none)),value :: transA
      integer(kind(rocblas_operation_none)),value :: transB
      integer(c_int),value :: m
      integer(c_int),value :: n
      complex(c_double_complex) :: alpha
      complex(c_double_complex),target,dimension(:,:) :: A
      integer(c_int),value :: lda
      complex(c_double_complex) :: beta
      complex(c_double_complex),target,dimension(:,:) :: B
      integer(c_int),value :: ldb
      complex(c_double_complex),target,dimension(:,:) :: C
      integer(c_int),value :: ldc
      !
      rocblas_zgeam_full_rank = rocblas_zgeam_orig(handle,transA,transB,m,n,alpha,c_loc(A),lda,beta,c_loc(B),ldb,c_loc(C),ldc)
    end function

    function rocblas_zgeam_rank_0(handle,transA,transB,m,n,alpha,A,lda,beta,B,ldb,C,ldc)
      use iso_c_binding
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocblas_zgeam_rank_0
      type(c_ptr),value :: handle
      integer(kind(rocblas_operation_none)),value :: transA
      integer(kind(rocblas_operation_none)),value :: transB
      integer(c_int),value :: m
      integer(c_int),value :: n
      complex(c_double_complex) :: alpha
      complex(c_double_complex),target :: A
      integer(c_int),value :: lda
      complex(c_double_complex) :: beta
      complex(c_double_complex),target :: B
      integer(c_int),value :: ldb
      complex(c_double_complex),target :: C
      integer(c_int),value :: ldc
      !
      rocblas_zgeam_rank_0 = rocblas_zgeam_orig(handle,transA,transB,m,n,alpha,c_loc(A),lda,beta,c_loc(B),ldb,c_loc(C),ldc)
    end function

    function rocblas_zgeam_rank_1(handle,transA,transB,m,n,alpha,A,lda,beta,B,ldb,C,ldc)
      use iso_c_binding
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocblas_zgeam_rank_1
      type(c_ptr),value :: handle
      integer(kind(rocblas_operation_none)),value :: transA
      integer(kind(rocblas_operation_none)),value :: transB
      integer(c_int),value :: m
      integer(c_int),value :: n
      complex(c_double_complex) :: alpha
      complex(c_double_complex),target,dimension(:) :: A
      integer(c_int),value :: lda
      complex(c_double_complex) :: beta
      complex(c_double_complex),target,dimension(:) :: B
      integer(c_int),value :: ldb
      complex(c_double_complex),target,dimension(:) :: C
      integer(c_int),value :: ldc
      !
      rocblas_zgeam_rank_1 = rocblas_zgeam_orig(handle,transA,transB,m,n,alpha,c_loc(A),lda,beta,c_loc(B),ldb,c_loc(C),ldc)
    end function

    function rocblas_sgeam_batched_full_rank(handle,transA,transB,m,n,alpha,A,lda,beta,B,ldb,C,ldc,batch_count)
      use iso_c_binding
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocblas_sgeam_batched_full_rank
      type(c_ptr),value :: handle
      integer(kind(rocblas_operation_none)),value :: transA
      integer(kind(rocblas_operation_none)),value :: transB
      integer(c_int),value :: m
      integer(c_int),value :: n
      real(c_float) :: alpha
      real(c_float),target,dimension(:,:,:) :: A
      integer(c_int),value :: lda
      real(c_float) :: beta
      real(c_float),target,dimension(:,:,:) :: B
      integer(c_int),value :: ldb
      real(c_float),target,dimension(:,:,:) :: C
      integer(c_int),value :: ldc
      integer(c_int),value :: batch_count
      !
      rocblas_sgeam_batched_full_rank = rocblas_sgeam_batched_orig(handle,transA,transB,m,n,alpha,c_loc(A),lda,beta,c_loc(B),ldb,c_loc(C),ldc,batch_count)
    end function

    function rocblas_sgeam_batched_rank_0(handle,transA,transB,m,n,alpha,A,lda,beta,B,ldb,C,ldc,batch_count)
      use iso_c_binding
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocblas_sgeam_batched_rank_0
      type(c_ptr),value :: handle
      integer(kind(rocblas_operation_none)),value :: transA
      integer(kind(rocblas_operation_none)),value :: transB
      integer(c_int),value :: m
      integer(c_int),value :: n
      real(c_float) :: alpha
      real(c_float),target :: A
      integer(c_int),value :: lda
      real(c_float) :: beta
      real(c_float),target :: B
      integer(c_int),value :: ldb
      real(c_float),target :: C
      integer(c_int),value :: ldc
      integer(c_int),value :: batch_count
      !
      rocblas_sgeam_batched_rank_0 = rocblas_sgeam_batched_orig(handle,transA,transB,m,n,alpha,c_loc(A),lda,beta,c_loc(B),ldb,c_loc(C),ldc,batch_count)
    end function

    function rocblas_sgeam_batched_rank_1(handle,transA,transB,m,n,alpha,A,lda,beta,B,ldb,C,ldc,batch_count)
      use iso_c_binding
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocblas_sgeam_batched_rank_1
      type(c_ptr),value :: handle
      integer(kind(rocblas_operation_none)),value :: transA
      integer(kind(rocblas_operation_none)),value :: transB
      integer(c_int),value :: m
      integer(c_int),value :: n
      real(c_float) :: alpha
      real(c_float),target,dimension(:) :: A
      integer(c_int),value :: lda
      real(c_float) :: beta
      real(c_float),target,dimension(:) :: B
      integer(c_int),value :: ldb
      real(c_float),target,dimension(:) :: C
      integer(c_int),value :: ldc
      integer(c_int),value :: batch_count
      !
      rocblas_sgeam_batched_rank_1 = rocblas_sgeam_batched_orig(handle,transA,transB,m,n,alpha,c_loc(A),lda,beta,c_loc(B),ldb,c_loc(C),ldc,batch_count)
    end function

    function rocblas_dgeam_batched_full_rank(handle,transA,transB,m,n,alpha,A,lda,beta,B,ldb,C,ldc,batch_count)
      use iso_c_binding
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocblas_dgeam_batched_full_rank
      type(c_ptr),value :: handle
      integer(kind(rocblas_operation_none)),value :: transA
      integer(kind(rocblas_operation_none)),value :: transB
      integer(c_int),value :: m
      integer(c_int),value :: n
      real(c_double) :: alpha
      real(c_double),target,dimension(:,:,:) :: A
      integer(c_int),value :: lda
      real(c_double) :: beta
      real(c_double),target,dimension(:,:,:) :: B
      integer(c_int),value :: ldb
      real(c_double),target,dimension(:,:,:) :: C
      integer(c_int),value :: ldc
      integer(c_int),value :: batch_count
      !
      rocblas_dgeam_batched_full_rank = rocblas_dgeam_batched_orig(handle,transA,transB,m,n,alpha,c_loc(A),lda,beta,c_loc(B),ldb,c_loc(C),ldc,batch_count)
    end function

    function rocblas_dgeam_batched_rank_0(handle,transA,transB,m,n,alpha,A,lda,beta,B,ldb,C,ldc,batch_count)
      use iso_c_binding
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocblas_dgeam_batched_rank_0
      type(c_ptr),value :: handle
      integer(kind(rocblas_operation_none)),value :: transA
      integer(kind(rocblas_operation_none)),value :: transB
      integer(c_int),value :: m
      integer(c_int),value :: n
      real(c_double) :: alpha
      real(c_double),target :: A
      integer(c_int),value :: lda
      real(c_double) :: beta
      real(c_double),target :: B
      integer(c_int),value :: ldb
      real(c_double),target :: C
      integer(c_int),value :: ldc
      integer(c_int),value :: batch_count
      !
      rocblas_dgeam_batched_rank_0 = rocblas_dgeam_batched_orig(handle,transA,transB,m,n,alpha,c_loc(A),lda,beta,c_loc(B),ldb,c_loc(C),ldc,batch_count)
    end function

    function rocblas_dgeam_batched_rank_1(handle,transA,transB,m,n,alpha,A,lda,beta,B,ldb,C,ldc,batch_count)
      use iso_c_binding
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocblas_dgeam_batched_rank_1
      type(c_ptr),value :: handle
      integer(kind(rocblas_operation_none)),value :: transA
      integer(kind(rocblas_operation_none)),value :: transB
      integer(c_int),value :: m
      integer(c_int),value :: n
      real(c_double) :: alpha
      real(c_double),target,dimension(:) :: A
      integer(c_int),value :: lda
      real(c_double) :: beta
      real(c_double),target,dimension(:) :: B
      integer(c_int),value :: ldb
      real(c_double),target,dimension(:) :: C
      integer(c_int),value :: ldc
      integer(c_int),value :: batch_count
      !
      rocblas_dgeam_batched_rank_1 = rocblas_dgeam_batched_orig(handle,transA,transB,m,n,alpha,c_loc(A),lda,beta,c_loc(B),ldb,c_loc(C),ldc,batch_count)
    end function

    function rocblas_cgeam_batched_full_rank(handle,transA,transB,m,n,alpha,A,lda,beta,B,ldb,C,ldc,batch_count)
      use iso_c_binding
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocblas_cgeam_batched_full_rank
      type(c_ptr),value :: handle
      integer(kind(rocblas_operation_none)),value :: transA
      integer(kind(rocblas_operation_none)),value :: transB
      integer(c_int),value :: m
      integer(c_int),value :: n
      complex(c_float_complex) :: alpha
      complex(c_float_complex),target,dimension(:,:,:) :: A
      integer(c_int),value :: lda
      complex(c_float_complex) :: beta
      complex(c_float_complex),target,dimension(:,:,:) :: B
      integer(c_int),value :: ldb
      complex(c_float_complex),target,dimension(:,:,:) :: C
      integer(c_int),value :: ldc
      integer(c_int),value :: batch_count
      !
      rocblas_cgeam_batched_full_rank = rocblas_cgeam_batched_orig(handle,transA,transB,m,n,alpha,c_loc(A),lda,beta,c_loc(B),ldb,c_loc(C),ldc,batch_count)
    end function

    function rocblas_cgeam_batched_rank_0(handle,transA,transB,m,n,alpha,A,lda,beta,B,ldb,C,ldc,batch_count)
      use iso_c_binding
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocblas_cgeam_batched_rank_0
      type(c_ptr),value :: handle
      integer(kind(rocblas_operation_none)),value :: transA
      integer(kind(rocblas_operation_none)),value :: transB
      integer(c_int),value :: m
      integer(c_int),value :: n
      complex(c_float_complex) :: alpha
      complex(c_float_complex),target :: A
      integer(c_int),value :: lda
      complex(c_float_complex) :: beta
      complex(c_float_complex),target :: B
      integer(c_int),value :: ldb
      complex(c_float_complex),target :: C
      integer(c_int),value :: ldc
      integer(c_int),value :: batch_count
      !
      rocblas_cgeam_batched_rank_0 = rocblas_cgeam_batched_orig(handle,transA,transB,m,n,alpha,c_loc(A),lda,beta,c_loc(B),ldb,c_loc(C),ldc,batch_count)
    end function

    function rocblas_cgeam_batched_rank_1(handle,transA,transB,m,n,alpha,A,lda,beta,B,ldb,C,ldc,batch_count)
      use iso_c_binding
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocblas_cgeam_batched_rank_1
      type(c_ptr),value :: handle
      integer(kind(rocblas_operation_none)),value :: transA
      integer(kind(rocblas_operation_none)),value :: transB
      integer(c_int),value :: m
      integer(c_int),value :: n
      complex(c_float_complex) :: alpha
      complex(c_float_complex),target,dimension(:) :: A
      integer(c_int),value :: lda
      complex(c_float_complex) :: beta
      complex(c_float_complex),target,dimension(:) :: B
      integer(c_int),value :: ldb
      complex(c_float_complex),target,dimension(:) :: C
      integer(c_int),value :: ldc
      integer(c_int),value :: batch_count
      !
      rocblas_cgeam_batched_rank_1 = rocblas_cgeam_batched_orig(handle,transA,transB,m,n,alpha,c_loc(A),lda,beta,c_loc(B),ldb,c_loc(C),ldc,batch_count)
    end function

    function rocblas_zgeam_batched_full_rank(handle,transA,transB,m,n,alpha,A,lda,beta,B,ldb,C,ldc,batch_count)
      use iso_c_binding
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocblas_zgeam_batched_full_rank
      type(c_ptr),value :: handle
      integer(kind(rocblas_operation_none)),value :: transA
      integer(kind(rocblas_operation_none)),value :: transB
      integer(c_int),value :: m
      integer(c_int),value :: n
      complex(c_double_complex) :: alpha
      complex(c_double_complex),target,dimension(:,:,:) :: A
      integer(c_int),value :: lda
      complex(c_double_complex) :: beta
      complex(c_double_complex),target,dimension(:,:,:) :: B
      integer(c_int),value :: ldb
      complex(c_double_complex),target,dimension(:,:,:) :: C
      integer(c_int),value :: ldc
      integer(c_int),value :: batch_count
      !
      rocblas_zgeam_batched_full_rank = rocblas_zgeam_batched_orig(handle,transA,transB,m,n,alpha,c_loc(A),lda,beta,c_loc(B),ldb,c_loc(C),ldc,batch_count)
    end function

    function rocblas_zgeam_batched_rank_0(handle,transA,transB,m,n,alpha,A,lda,beta,B,ldb,C,ldc,batch_count)
      use iso_c_binding
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocblas_zgeam_batched_rank_0
      type(c_ptr),value :: handle
      integer(kind(rocblas_operation_none)),value :: transA
      integer(kind(rocblas_operation_none)),value :: transB
      integer(c_int),value :: m
      integer(c_int),value :: n
      complex(c_double_complex) :: alpha
      complex(c_double_complex),target :: A
      integer(c_int),value :: lda
      complex(c_double_complex) :: beta
      complex(c_double_complex),target :: B
      integer(c_int),value :: ldb
      complex(c_double_complex),target :: C
      integer(c_int),value :: ldc
      integer(c_int),value :: batch_count
      !
      rocblas_zgeam_batched_rank_0 = rocblas_zgeam_batched_orig(handle,transA,transB,m,n,alpha,c_loc(A),lda,beta,c_loc(B),ldb,c_loc(C),ldc,batch_count)
    end function

    function rocblas_zgeam_batched_rank_1(handle,transA,transB,m,n,alpha,A,lda,beta,B,ldb,C,ldc,batch_count)
      use iso_c_binding
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocblas_zgeam_batched_rank_1
      type(c_ptr),value :: handle
      integer(kind(rocblas_operation_none)),value :: transA
      integer(kind(rocblas_operation_none)),value :: transB
      integer(c_int),value :: m
      integer(c_int),value :: n
      complex(c_double_complex) :: alpha
      complex(c_double_complex),target,dimension(:) :: A
      integer(c_int),value :: lda
      complex(c_double_complex) :: beta
      complex(c_double_complex),target,dimension(:) :: B
      integer(c_int),value :: ldb
      complex(c_double_complex),target,dimension(:) :: C
      integer(c_int),value :: ldc
      integer(c_int),value :: batch_count
      !
      rocblas_zgeam_batched_rank_1 = rocblas_zgeam_batched_orig(handle,transA,transB,m,n,alpha,c_loc(A),lda,beta,c_loc(B),ldb,c_loc(C),ldc,batch_count)
    end function

    function rocblas_sgeam_strided_batched_full_rank(handle,transA,transB,m,n,alpha,A,lda,stride_a,beta,B,ldb,stride_b,C,ldc,stride_c,batch_count)
      use iso_c_binding
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocblas_sgeam_strided_batched_full_rank
      type(c_ptr),value :: handle
      integer(kind(rocblas_operation_none)),value :: transA
      integer(kind(rocblas_operation_none)),value :: transB
      integer(c_int),value :: m
      integer(c_int),value :: n
      real(c_float) :: alpha
      real(c_float),target,dimension(:,:) :: A
      integer(c_int),value :: lda
      integer(c_int64_t),value :: stride_a
      real(c_float) :: beta
      real(c_float),target,dimension(:,:) :: B
      integer(c_int),value :: ldb
      integer(c_int64_t),value :: stride_b
      real(c_float),target,dimension(:,:) :: C
      integer(c_int),value :: ldc
      integer(c_int64_t),value :: stride_c
      integer(c_int),value :: batch_count
      !
      rocblas_sgeam_strided_batched_full_rank = rocblas_sgeam_strided_batched_orig(handle,transA,transB,m,n,alpha,c_loc(A),lda,stride_a,beta,c_loc(B),ldb,stride_b,c_loc(C),ldc,stride_c,batch_count)
    end function

    function rocblas_sgeam_strided_batched_rank_0(handle,transA,transB,m,n,alpha,A,lda,stride_a,beta,B,ldb,stride_b,C,ldc,stride_c,batch_count)
      use iso_c_binding
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocblas_sgeam_strided_batched_rank_0
      type(c_ptr),value :: handle
      integer(kind(rocblas_operation_none)),value :: transA
      integer(kind(rocblas_operation_none)),value :: transB
      integer(c_int),value :: m
      integer(c_int),value :: n
      real(c_float) :: alpha
      real(c_float),target :: A
      integer(c_int),value :: lda
      integer(c_int64_t),value :: stride_a
      real(c_float) :: beta
      real(c_float),target :: B
      integer(c_int),value :: ldb
      integer(c_int64_t),value :: stride_b
      real(c_float),target :: C
      integer(c_int),value :: ldc
      integer(c_int64_t),value :: stride_c
      integer(c_int),value :: batch_count
      !
      rocblas_sgeam_strided_batched_rank_0 = rocblas_sgeam_strided_batched_orig(handle,transA,transB,m,n,alpha,c_loc(A),lda,stride_a,beta,c_loc(B),ldb,stride_b,c_loc(C),ldc,stride_c,batch_count)
    end function

    function rocblas_sgeam_strided_batched_rank_1(handle,transA,transB,m,n,alpha,A,lda,stride_a,beta,B,ldb,stride_b,C,ldc,stride_c,batch_count)
      use iso_c_binding
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocblas_sgeam_strided_batched_rank_1
      type(c_ptr),value :: handle
      integer(kind(rocblas_operation_none)),value :: transA
      integer(kind(rocblas_operation_none)),value :: transB
      integer(c_int),value :: m
      integer(c_int),value :: n
      real(c_float) :: alpha
      real(c_float),target,dimension(:) :: A
      integer(c_int),value :: lda
      integer(c_int64_t),value :: stride_a
      real(c_float) :: beta
      real(c_float),target,dimension(:) :: B
      integer(c_int),value :: ldb
      integer(c_int64_t),value :: stride_b
      real(c_float),target,dimension(:) :: C
      integer(c_int),value :: ldc
      integer(c_int64_t),value :: stride_c
      integer(c_int),value :: batch_count
      !
      rocblas_sgeam_strided_batched_rank_1 = rocblas_sgeam_strided_batched_orig(handle,transA,transB,m,n,alpha,c_loc(A),lda,stride_a,beta,c_loc(B),ldb,stride_b,c_loc(C),ldc,stride_c,batch_count)
    end function

    function rocblas_dgeam_strided_batched_full_rank(handle,transA,transB,m,n,alpha,A,lda,stride_a,beta,B,ldb,stride_b,C,ldc,stride_c,batch_count)
      use iso_c_binding
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocblas_dgeam_strided_batched_full_rank
      type(c_ptr),value :: handle
      integer(kind(rocblas_operation_none)),value :: transA
      integer(kind(rocblas_operation_none)),value :: transB
      integer(c_int),value :: m
      integer(c_int),value :: n
      real(c_double) :: alpha
      real(c_double),target,dimension(:,:) :: A
      integer(c_int),value :: lda
      integer(c_int64_t),value :: stride_a
      real(c_double) :: beta
      real(c_double),target,dimension(:,:) :: B
      integer(c_int),value :: ldb
      integer(c_int64_t),value :: stride_b
      real(c_double),target,dimension(:,:) :: C
      integer(c_int),value :: ldc
      integer(c_int64_t),value :: stride_c
      integer(c_int),value :: batch_count
      !
      rocblas_dgeam_strided_batched_full_rank = rocblas_dgeam_strided_batched_orig(handle,transA,transB,m,n,alpha,c_loc(A),lda,stride_a,beta,c_loc(B),ldb,stride_b,c_loc(C),ldc,stride_c,batch_count)
    end function

    function rocblas_dgeam_strided_batched_rank_0(handle,transA,transB,m,n,alpha,A,lda,stride_a,beta,B,ldb,stride_b,C,ldc,stride_c,batch_count)
      use iso_c_binding
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocblas_dgeam_strided_batched_rank_0
      type(c_ptr),value :: handle
      integer(kind(rocblas_operation_none)),value :: transA
      integer(kind(rocblas_operation_none)),value :: transB
      integer(c_int),value :: m
      integer(c_int),value :: n
      real(c_double) :: alpha
      real(c_double),target :: A
      integer(c_int),value :: lda
      integer(c_int64_t),value :: stride_a
      real(c_double) :: beta
      real(c_double),target :: B
      integer(c_int),value :: ldb
      integer(c_int64_t),value :: stride_b
      real(c_double),target :: C
      integer(c_int),value :: ldc
      integer(c_int64_t),value :: stride_c
      integer(c_int),value :: batch_count
      !
      rocblas_dgeam_strided_batched_rank_0 = rocblas_dgeam_strided_batched_orig(handle,transA,transB,m,n,alpha,c_loc(A),lda,stride_a,beta,c_loc(B),ldb,stride_b,c_loc(C),ldc,stride_c,batch_count)
    end function

    function rocblas_dgeam_strided_batched_rank_1(handle,transA,transB,m,n,alpha,A,lda,stride_a,beta,B,ldb,stride_b,C,ldc,stride_c,batch_count)
      use iso_c_binding
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocblas_dgeam_strided_batched_rank_1
      type(c_ptr),value :: handle
      integer(kind(rocblas_operation_none)),value :: transA
      integer(kind(rocblas_operation_none)),value :: transB
      integer(c_int),value :: m
      integer(c_int),value :: n
      real(c_double) :: alpha
      real(c_double),target,dimension(:) :: A
      integer(c_int),value :: lda
      integer(c_int64_t),value :: stride_a
      real(c_double) :: beta
      real(c_double),target,dimension(:) :: B
      integer(c_int),value :: ldb
      integer(c_int64_t),value :: stride_b
      real(c_double),target,dimension(:) :: C
      integer(c_int),value :: ldc
      integer(c_int64_t),value :: stride_c
      integer(c_int),value :: batch_count
      !
      rocblas_dgeam_strided_batched_rank_1 = rocblas_dgeam_strided_batched_orig(handle,transA,transB,m,n,alpha,c_loc(A),lda,stride_a,beta,c_loc(B),ldb,stride_b,c_loc(C),ldc,stride_c,batch_count)
    end function

    function rocblas_cgeam_strided_batched_full_rank(handle,transA,transB,m,n,alpha,A,lda,stride_a,beta,B,ldb,stride_b,C,ldc,stride_c,batch_count)
      use iso_c_binding
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocblas_cgeam_strided_batched_full_rank
      type(c_ptr),value :: handle
      integer(kind(rocblas_operation_none)),value :: transA
      integer(kind(rocblas_operation_none)),value :: transB
      integer(c_int),value :: m
      integer(c_int),value :: n
      complex(c_float_complex) :: alpha
      complex(c_float_complex),target,dimension(:,:) :: A
      integer(c_int),value :: lda
      integer(c_int64_t),value :: stride_a
      complex(c_float_complex) :: beta
      complex(c_float_complex),target,dimension(:,:) :: B
      integer(c_int),value :: ldb
      integer(c_int64_t),value :: stride_b
      complex(c_float_complex),target,dimension(:,:) :: C
      integer(c_int),value :: ldc
      integer(c_int64_t),value :: stride_c
      integer(c_int),value :: batch_count
      !
      rocblas_cgeam_strided_batched_full_rank = rocblas_cgeam_strided_batched_orig(handle,transA,transB,m,n,alpha,c_loc(A),lda,stride_a,beta,c_loc(B),ldb,stride_b,c_loc(C),ldc,stride_c,batch_count)
    end function

    function rocblas_cgeam_strided_batched_rank_0(handle,transA,transB,m,n,alpha,A,lda,stride_a,beta,B,ldb,stride_b,C,ldc,stride_c,batch_count)
      use iso_c_binding
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocblas_cgeam_strided_batched_rank_0
      type(c_ptr),value :: handle
      integer(kind(rocblas_operation_none)),value :: transA
      integer(kind(rocblas_operation_none)),value :: transB
      integer(c_int),value :: m
      integer(c_int),value :: n
      complex(c_float_complex) :: alpha
      complex(c_float_complex),target :: A
      integer(c_int),value :: lda
      integer(c_int64_t),value :: stride_a
      complex(c_float_complex) :: beta
      complex(c_float_complex),target :: B
      integer(c_int),value :: ldb
      integer(c_int64_t),value :: stride_b
      complex(c_float_complex),target :: C
      integer(c_int),value :: ldc
      integer(c_int64_t),value :: stride_c
      integer(c_int),value :: batch_count
      !
      rocblas_cgeam_strided_batched_rank_0 = rocblas_cgeam_strided_batched_orig(handle,transA,transB,m,n,alpha,c_loc(A),lda,stride_a,beta,c_loc(B),ldb,stride_b,c_loc(C),ldc,stride_c,batch_count)
    end function

    function rocblas_cgeam_strided_batched_rank_1(handle,transA,transB,m,n,alpha,A,lda,stride_a,beta,B,ldb,stride_b,C,ldc,stride_c,batch_count)
      use iso_c_binding
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocblas_cgeam_strided_batched_rank_1
      type(c_ptr),value :: handle
      integer(kind(rocblas_operation_none)),value :: transA
      integer(kind(rocblas_operation_none)),value :: transB
      integer(c_int),value :: m
      integer(c_int),value :: n
      complex(c_float_complex) :: alpha
      complex(c_float_complex),target,dimension(:) :: A
      integer(c_int),value :: lda
      integer(c_int64_t),value :: stride_a
      complex(c_float_complex) :: beta
      complex(c_float_complex),target,dimension(:) :: B
      integer(c_int),value :: ldb
      integer(c_int64_t),value :: stride_b
      complex(c_float_complex),target,dimension(:) :: C
      integer(c_int),value :: ldc
      integer(c_int64_t),value :: stride_c
      integer(c_int),value :: batch_count
      !
      rocblas_cgeam_strided_batched_rank_1 = rocblas_cgeam_strided_batched_orig(handle,transA,transB,m,n,alpha,c_loc(A),lda,stride_a,beta,c_loc(B),ldb,stride_b,c_loc(C),ldc,stride_c,batch_count)
    end function

    function rocblas_zgeam_strided_batched_full_rank(handle,transA,transB,m,n,alpha,A,lda,stride_a,beta,B,ldb,stride_b,C,ldc,stride_c,batch_count)
      use iso_c_binding
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocblas_zgeam_strided_batched_full_rank
      type(c_ptr),value :: handle
      integer(kind(rocblas_operation_none)),value :: transA
      integer(kind(rocblas_operation_none)),value :: transB
      integer(c_int),value :: m
      integer(c_int),value :: n
      complex(c_double_complex) :: alpha
      complex(c_double_complex),target,dimension(:,:) :: A
      integer(c_int),value :: lda
      integer(c_int64_t),value :: stride_a
      complex(c_double_complex) :: beta
      complex(c_double_complex),target,dimension(:,:) :: B
      integer(c_int),value :: ldb
      integer(c_int64_t),value :: stride_b
      complex(c_double_complex),target,dimension(:,:) :: C
      integer(c_int),value :: ldc
      integer(c_int64_t),value :: stride_c
      integer(c_int),value :: batch_count
      !
      rocblas_zgeam_strided_batched_full_rank = rocblas_zgeam_strided_batched_orig(handle,transA,transB,m,n,alpha,c_loc(A),lda,stride_a,beta,c_loc(B),ldb,stride_b,c_loc(C),ldc,stride_c,batch_count)
    end function

    function rocblas_zgeam_strided_batched_rank_0(handle,transA,transB,m,n,alpha,A,lda,stride_a,beta,B,ldb,stride_b,C,ldc,stride_c,batch_count)
      use iso_c_binding
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocblas_zgeam_strided_batched_rank_0
      type(c_ptr),value :: handle
      integer(kind(rocblas_operation_none)),value :: transA
      integer(kind(rocblas_operation_none)),value :: transB
      integer(c_int),value :: m
      integer(c_int),value :: n
      complex(c_double_complex) :: alpha
      complex(c_double_complex),target :: A
      integer(c_int),value :: lda
      integer(c_int64_t),value :: stride_a
      complex(c_double_complex) :: beta
      complex(c_double_complex),target :: B
      integer(c_int),value :: ldb
      integer(c_int64_t),value :: stride_b
      complex(c_double_complex),target :: C
      integer(c_int),value :: ldc
      integer(c_int64_t),value :: stride_c
      integer(c_int),value :: batch_count
      !
      rocblas_zgeam_strided_batched_rank_0 = rocblas_zgeam_strided_batched_orig(handle,transA,transB,m,n,alpha,c_loc(A),lda,stride_a,beta,c_loc(B),ldb,stride_b,c_loc(C),ldc,stride_c,batch_count)
    end function

    function rocblas_zgeam_strided_batched_rank_1(handle,transA,transB,m,n,alpha,A,lda,stride_a,beta,B,ldb,stride_b,C,ldc,stride_c,batch_count)
      use iso_c_binding
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocblas_zgeam_strided_batched_rank_1
      type(c_ptr),value :: handle
      integer(kind(rocblas_operation_none)),value :: transA
      integer(kind(rocblas_operation_none)),value :: transB
      integer(c_int),value :: m
      integer(c_int),value :: n
      complex(c_double_complex) :: alpha
      complex(c_double_complex),target,dimension(:) :: A
      integer(c_int),value :: lda
      integer(c_int64_t),value :: stride_a
      complex(c_double_complex) :: beta
      complex(c_double_complex),target,dimension(:) :: B
      integer(c_int),value :: ldb
      integer(c_int64_t),value :: stride_b
      complex(c_double_complex),target,dimension(:) :: C
      integer(c_int),value :: ldc
      integer(c_int64_t),value :: stride_c
      integer(c_int),value :: batch_count
      !
      rocblas_zgeam_strided_batched_rank_1 = rocblas_zgeam_strided_batched_orig(handle,transA,transB,m,n,alpha,c_loc(A),lda,stride_a,beta,c_loc(B),ldb,stride_b,c_loc(C),ldc,stride_c,batch_count)
    end function

  
#endif
end module hipfort_rocblas